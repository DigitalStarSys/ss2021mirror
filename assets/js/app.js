// --------------------------------------
// 
//    _  _ _/ .  _  _/ /_ _  _  _        
//   /_|/_ / /|//_  / / //_ /_// /_/     
//   https://activetheory.net    _/      
// 
// --------------------------------------
//   4/24/21 10:46a
// --------------------------------------

/**
 * Native polyfills and extensions for Hydra
 * @name Polyfill
 */

if (typeof(console) === 'undefined') {
    window.console = {};
    console.log = console.error = console.info = console.debug = console.warn = console.trace = function() {};
}

window.performance = (function() {
    if (window.performance && window.performance.now) return window.performance;
    else return Date;
})();

Date.now = Date.now || function() { return +new Date; };

if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = (function() {
        return window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            (function() {
                const start = Date.now();
                return function(callback) {
                    window.setTimeout(() => callback(Date.now() - start), 1000 / 60);
                }
            })();
    })();
}

/**
 * Temporary alias for Core. Gets overwritten when Timer instantiated.
 * @see Timer
 * @private
 */
window.defer = window.requestAnimationFrame;

/**
 * Extends clearTimeout to clear hydra timers as well as native setTimeouts
 * @name window.clearTimeout
 * @memberof Polyfill
 *
 * @function
 * @param {Number} ref
 * @example
 * let timer = _this.delayedCall(myFunc, 1000);
 * clearTimeout(timer);
 */
window.clearTimeout = (function() {
    const _clearTimeout = window.clearTimeout;
    return function(ref) {

        // If Timer exists, try and see if is a hydra timer ref otherwise run native
        if (window.Timer) return Timer.__clearTimeout(ref) || _clearTimeout(ref);
        return _clearTimeout(ref);
    }
})();

/**
 * Fires callback when framerate idles, else fire at max time. Alias of window.requestIdleCallback
 * @name window.onIdle
 * @memberof Polyfill
 *
 * @function
 * @param {Function} callback
 * @param {Number} max - Milliseconds
 * @example
 * onIdle(myFunc, 1000);
 */
window.requestIdleCallback = (function() {
    const _requestIdleCallback = window.requestIdleCallback;
    return function(callback, max) {
        if (_requestIdleCallback) {
            return _requestIdleCallback(callback, max ? {timeout: max} : null);
        }
        return defer(() => {
            callback({didTimeout: false});
        }, 0);
    }
})();

window.onIdle = window.requestIdleCallback;

if (typeof Float32Array == 'undefined') Float32Array = Array;

/**
 * @name Math.sign
 * @memberof Polyfill
 *
 * @function
 * @param  {Number} x
 * @return {Number} Returns 1.0 if above 0.0, or -1.0 if below
 */
Math.sign = function(x) {
    x = +x; // convert to a number
    if (x === 0 || isNaN(x)) return Number(x);
    return x > 0 ? 1 : -1;
};

/**
 * Returns rounded number, with decimal places equal to precision
 * @name Math.round
 * @memberof Polyfill
 *
 * @function
 * @param {Number} Value to be rounded
 * @param {Integer} [precision = 0] Number of decimal places to return. 0 for integers.
 * @returns {Number} Rounded number
 * @example
 * // Returns 3.14
 * Math.round(3.14854839, 2);
 */
Math._round = Math.round;
Math.round = function(value, precision = 0) {
    let p = Math.pow(10, precision);
    return Math._round(value * p) / p;
};

/**
 * Returns random number between min and max values inclusive, with decimal places equal to precision
 * @name Math.random
 * @memberof Polyfill
 *
 * @function
 * @param {Number} [min=0] Min possible returned value
 * @param {Number} [max=1] Max possible returned value - inclusive.
 * @param {Integer} [precision = 0] Number of decimal places to return. 0 for integers.
 * @returns {Number} Between min and max inclusive
 * @example
 * // Returns int between 3 and 5 inclusive
 * Math.random(3, 5, 0);
 */
Math._random = Math.random;
Math.rand = Math.random = function(min, max, precision = 0) {
    if (typeof min === 'undefined') return Math._random();
    if (min === max) return min;

    min = min || 0;
    max = max || 1;

    if (precision == 0) return Math.floor(Math._random() * ((max+1) - min) + min);
    return Math.round((min + Math._random() * (max - min)), precision);
};

/**
 * Converts radians into degrees
 * @name Math.degrees
 * @memberof Polyfill
 *
 * @function
 * @param {Number} radians
 * @returns {Number}
 */

Math.degrees = function(radians) {
    return radians * (180 / Math.PI);
};

/**
 * Converts degrees into radians
 * @name Math.radians
 * @memberof Polyfill
 *
 * @function
 * @param {Number} degrees
 * @returns {Number}
 */
Math.radians = function(degrees) {
    return degrees * (Math.PI / 180);
};

/**
 * Clamps value between min and max
 * @name Math.clamp
 * @memberof Polyfill
 *
 * @function
 * @param {Number} value
 * @param {Number} [min = 0]
 * @param {Number} [max = 1]
 * @returns {Number}
 */
Math.clamp = function(value, min = 0, max = 1) {
    return Math.min(Math.max(value, Math.min(min, max)), Math.max(min, max));
};

/**
 * Maps value from an old range onto a new range
 * @name Math.map
 * @memberof Polyfill
 *
 * @function
 * @param {Number} value
 * @param {Number} [oldMin = -1]
 * @param {Number} [oldMax = 1]
 * @param {Number} [newMin = 0]
 * @param {Number} [newMax = 1]
 * @param {Boolean} [isClamp = false]
 * @returns {Number}
 * @example
 * // Convert sine curve's -1.0 > 1.0 value to 0.0 > 1.0 range
 * let x = Math.map(Math.sin(time));
 * @example
 * // Shift range
 * let y = 80;
 * let x = Math.map(y, 0, 200, -10, 10);
 * console.log(x); // logs -2
 * @example
 * // Reverse direction and shift range
 * let y = 0.9;
 * let x = Math.map(y, 0, 1, 200, 100);
 * console.log(x); // logs 110
 */
Math.map = Math.range = function(value, oldMin = -1, oldMax = 1, newMin = 0, newMax = 1, isClamp) {
    const newValue = (((value - oldMin) * (newMax - newMin)) / (oldMax - oldMin)) + newMin;
    if (isClamp) return Math.clamp(newValue, Math.min(newMin, newMax), Math.max(newMin, newMax));
    return newValue;
};

/**
 * Return blend between two values based on alpha paramater
 * @name Math.mix
 * @memberof Polyfill
 *
 * @function
 * @param {Number} a
 * @param {Number} b
 * @param {Number} alpha - Range of 0.0 to 1.0. Value of 0.0 returns a, value of 1.0 returns b
 * @returns {Number}
 * @example
 * console.log(Math.mix(0, 10, 0.4)); // logs 4
 */
Math.mix = function(a, b, alpha) {
    return a * (1.0 - alpha) + b * alpha;
};

/**
 * Returns 0.0 if value less than edge, 1.0 if greater.
 * @name Math.step
 * @memberof Polyfill
 *
 * @function
 * @param {Number} edge
 * @param {Number} value
 * @returns {Number}
 */
Math.step = function(edge, value) {
    return (value < edge) ? 0 : 1;
};

/**
 * Returns 0.0 if value less than min, 1.0 if greater than max. Otherwise the return value is interpolated between 0.0 and 1.0 using Hermite polynomials.
 * @name Math.smoothstep
 * @memberof Polyfill
 *
 * @function
 * @param {Number} min
 * @param {Number} max
 * @param {Number} value
 * @returns {Number}
 */
Math.smoothStep = function(min, max, value) {
    const x = Math.max(0, Math.min(1, (value - min) / (max - min)));
    return x * x * (3 - 2 * x);
};

/**
 * Returns fraction part of value
 * @name Math.fract
 * @memberof Polyfill
 *
 * @function
 * @param {Number} value
 * @returns {Number}
 */
Math.fract = function(value) {
    return value - Math.floor(value);
};

/**
 * Returns time-based interpolated value
 * @name Math.lerp
 * @memberof Polyfill
 *
 * @function
 * @param {Number} target
 * @param {Number} value
 * @param {Number} alpha
 * @returns {Number}
 */
{
    const mainThread = !!window.document;
    Math.lerp = function (target, value, alpha, calcHz = true) {
        let hz = mainThread && calcHz ? Render.HZ_MULTIPLIER : 1;
        return value + ((target - value) * Math.clamp(alpha * hz, 0, 1));
    };
}

/**
 * Modulo limited to positive numbers
 * @name Math.mod
 * @memberof Polyfill
 *
 * @function
 * @param {Number} value
 * @param {Number} n
 * @returns {Number}
 */
Math.mod = function(value, n) {
    return ((value % n) + n) % n;
};

/**
 * Shuffles array
 * @name Array.prototype.shuffle
 * @memberof Polyfill
 *
 * @function
 * @returns {Array} shuffled
 */
Array.prototype.shuffle = function() {
    let i = this.length - 1;
    let temp, r;
    while (i > 0) {
        r = Math.random(0, i, 0);
        i -= 1;
        temp = this[i];
        this[i] = this[r];
        this[r] = temp;
    }
    return this;
};

Array.storeRandom = function(arr) {
    arr.randomStore = [];
};

/**
 * Returns random element. If range passed in, will not return same element again until function has been called enough times to surpass the value.
 * @name Array.prototype.random
 * @memberof Polyfill
 *
 * @function
 * @param {Integer} [range]
 * @returns {ArrayElement}
 * @example
 * let a = [1, 2, 3, 4];
 * for (let i = 0; i < 6; i++) console.log(a.random(4)); // logs 3, 1, 2, 4, 3, 1
 */
Array.prototype.random = function(range) {
    let value = Math.random(0, this.length - 1);
    if (arguments.length && !this.randomStore) Array.storeRandom(this);
    if (!this.randomStore) return this[value];
    if (range > this.length - 1) range = this.length;
    if (range > 1) {
        while (!!~this.randomStore.indexOf(value)) if ((value += 1) > this.length - 1) value = 0;
        this.randomStore.push(value);
        if (this.randomStore.length >= range) this.randomStore.shift();
    }
    return this[value];
};

/**
 * Finds and removes element value from array
 * @name Array.prototype.remove
 * @memberof Polyfill
 *
 * @function
 * @param {ArrayElement} element - Element to remove
 * @returns {Array} Array containing removed element
 * @example
 * let a = ['cat', 'dog'];
 * a.remove('cat');
 * console.log(a); // logs ['dog']
 */
Array.prototype.remove = function(element) {
    if (!this.indexOf) return;
    const index = this.indexOf(element);
    if (!!~index) return this.splice(index, 1);
};

/**
 * Returns last element
 * @name Array.prototype.last
 * @memberof Polyfill
 *
 * @function
 * @returns {ArrayElement}
 */
Array.prototype.last = function() {
    return this[this.length - 1]
};

window.Promise = window.Promise || {};

if (!Array.prototype.flat) {
    Object.defineProperty(Array.prototype, 'flat', {
        configurable: true,
        value: function flat () {
            var depth = isNaN(arguments[0]) ? 1 : Number(arguments[0]);

            return depth ? Array.prototype.reduce.call(this, function (acc, cur) {
                if (Array.isArray(cur)) {
                    acc.push.apply(acc, flat.call(cur, depth - 1));
                } else {
                    acc.push(cur);
                }

                return acc;
            }, []) : Array.prototype.slice.call(this);
        },
        writable: true
    });
}

/**
 * Returns new Promise object
 * @name Promise.create
 * @memberof Polyfill
 *
 * @function
 * @returns {Promise}
 * @example
 * function waitOneSecond() {
 *     let p = Promise.create();
 *     _this.delayedCall(p.resolve, 1000);
 *     return p
 * }
 * waitOneSecond().then(() => console.log('happy days'));
 */
Promise.create = function() {
    const promise = new Promise((resolve, reject) => {
        this.temp_resolve = resolve;
        this.temp_reject = reject;
    });
    promise.resolve = this.temp_resolve;
    promise.reject = this.temp_reject;
    delete this.temp_resolve;
    delete this.temp_reject;
    return promise;
};

Promise.catchAll = function(array) {
    let promises = [];
    array.forEach(promise => {
        let p = Promise.create();
        promises.push(p);
        promise.then(d => p.resolve(d)).catch(e => p.reject(e));
    });

    return Promise.all(promises);
};

Promise.timeout = function(promise, timeout) {
    if (Array.isArray(promise)) {
        promise = Promise.all(promise);
    }
    return Promise.race([promise, Timer.delayedCall(timeout)]);
};

/**
 * Check if string contains phrase
 * @name String.prototype.includes
 * @memberof Polyfill
 *
 * @function
 * @param {String|String[]} str - Either a string or array of strings to check for
 * @returns {boolean}
 * @example
 * let userName = 'roger moore';
 * console.log(userName.includes(['steve', 'andrew', 'roger']); // logs true
 */
String.prototype.includes = function(str) {
    if (!Array.isArray(str)) return !!~this.indexOf(str);
    for (let i = str.length - 1; i >= 0; i--) {
        if (!!~this.indexOf(str[i])) return true;
    }
    return false;
};

String.prototype.equals = function(str) {
    let compare = String(this);
    if (!Array.isArray(str)) return str === compare;
    for (let i = str.length - 1; i >= 0; i--) {
        if (str[i] === compare) return true;
    }
    return false;
};

String.prototype.strpos = function(str) {
    console.warn('strpos deprecated: use .includes()');
    return this.includes(str);
};


/**
 * Returns clipped string. Doesn't alter original string.
 * @name String.prototype.clip
 * @memberof Polyfill
 *
 * @function
 * @param {Number} num - character length to clip to
 * @param {String} [end] - add string to end, such as elipsis '...'
 * @returns {string} - clipped string
 */
String.prototype.clip = function(num, end = '') {
    return this.length > num ? this.slice(0, Math.max( 0, num - end.length )).trim() + end : this.slice();
};

/**
 * Returns string with uppercase first letter. Doesn't alter original string.
 * @name String.prototype.capitalize
 * @memberof Polyfill
 *
 * @function
 * @returns {string}
 */
String.prototype.capitalize = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
};

/**
 * Replaces all occurrences within a string
 * @name String.prototype.replaceAll
 * @memberof Polyfill
 *
 * @function
 * @param {String} find - sub string to be replaced
 * @param {String} replace - sub string that replaces all occurrences
 * @returns {string}
 */
String.prototype.replaceAll = function(find, replace) {
    return this.split(find).join(replace);
};

String.prototype.replaceAt = function(index, replacement) {
    return this.substr(0, index) + replacement + this.substr(index + replacement.length);
};

/**
 * fetch API polyfill
 * @private
 */
if (!window.fetch || (!window.AURA && location.protocol.includes('file'))) window.fetch = function(url, options) {
    options = options || {};
    const promise = Promise.create();
    const request = new XMLHttpRequest();

    request.open(options.method || 'get', url);
    if (url.includes('.ktx')) request.responseType = 'arraybuffer';

    for (let i in options.headers) {
        request.setRequestHeader(i, options.headers[i]);
    }

    // request.withCredentials = options.credentials == 'include';

    request.onload = () => {
        promise.resolve(response());
    };

    request.onerror = promise.reject;

    request.send(options.body);

    function response() {
        let keys = [],
            all = [],
            headers = {},
            header;

        request.getAllResponseHeaders().replace(/^(.*?):\s*([\s\S]*?)$/gm, (m, key, value) => {
            keys.push(key = key.toLowerCase());
            all.push([key, value]);
            header = headers[key];
            headers[key] = header ? `${header},${value}` : value;
        });

        return {
            ok: (request.status/200|0) == 1,		// 200-399
            status: request.status,
            statusText: request.statusText,
            url: request.responseURL,
            clone: response,

            text: () => Promise.resolve(request.responseText),
            json: () => Promise.resolve(request.responseText).then(JSON.parse),
            xml: () => Promise.resolve(request.responseXML),
            blob: () => Promise.resolve(new Blob([request.response])),
            arrayBuffer: () => Promise.resolve(request.response),

            headers: {
                keys: () => keys,
                entries: () => all,
                get: n => headers[n.toLowerCase()],
                has: n => n.toLowerCase() in headers
            }
        };
    }
    return promise;
};

/**
 * Send http GET request. Wrapper around native fetch api. Automatically parses json.
 * @name window.get
 * @memberof Polyfill
 *
 * @function
 * @param {String} url
 * @param {Object} options
 * @returns {Promise}
 * @example
 * get('assets/geometry/curves.json).then(d => console.log(d));
 */
window.get = function(url, options = {credentials: 'same-origin'}) {
    let promise = Promise.create();
    options.method = 'GET';

    fetch(url, options).then(handleResponse).catch(promise.reject);

    function handleResponse(e) {
        if (!e.ok) return promise.reject(e);
        e.text().then(text => {
            if (text.charAt(0).includes(['[', '{'])) {

                // Try to parse json, else return text
                try {
                    promise.resolve(JSON.parse(text));
                } catch (err) {
                    promise.resolve(text);
                }
            } else {
                promise.resolve(text);
            }
        });
    }

    return promise;
};

/**
 * Send http POST request. Wrapper around native fetch api.
 * @name window.post
 * @memberof Polyfill
 *
 * @function
 * @param {String} url
 * @param {Object} body
 * @param {Object} [options]
 * @returns {Promise}
 */
window.post = function(url, body = {}, options = {}) {
    let promise = Promise.create();
    options.method = 'POST';
    if (body) options.body = typeof body === 'object' || Array.isArray(body) ? JSON.stringify(body) : body;
    if (!options.headers) options.headers = {'content-type': 'application/json'};

    fetch(url, options).then(handleResponse).catch(promise.reject);

    function handleResponse(e) {
        if (!e.ok) return promise.reject(e);
        e.text().then(text => {
            if (text.charAt(0).includes(['[', '{'])) {

                // Try to parse json, else return text
                try {
                    promise.resolve(JSON.parse(text));
                } catch (err) {
                    promise.resolve(text);
                }
            } else {
                promise.resolve(text);
            }
        });
    }

    return promise;
};

/**
 * Send http PUT request. Wrapper around native fetch api.
 * @name window.put
 * @memberof Polyfill
 *
 * @function
 * @param {String} url
 * @param {Object} body
 * @param {Object} [options]
 * @returns {Promise}
 */
window.put = function(url, body, options = {}) {
    let promise = Promise.create();
    options.method = 'PUT';
    if (body) options.body = typeof body === 'object' || Array.isArray(body) ? JSON.stringify(body) : body;

    fetch(url, options).then(handleResponse).catch(promise.reject);

    function handleResponse(e) {
        if (!e.ok) return promise.reject(e);
        e.text().then(text => {
            if (text.charAt(0).includes(['[', '{'])) {

                // Try to parse json, else return text
                try {
                    promise.resolve(JSON.parse(text));
                } catch (err) {
                    promise.resolve(text);
                }
            } else {
                promise.resolve(text);
            }
        });
    }

    return promise;
};
/**
 * Class creation and stucture.
 * @name Core
 */

/**
 * Class constructor
 * @name Class
 * @memberof Core
 *
 * @function
 * @param {Function} _class - main class function
 * @param {String|Function} [_type] - class type ('static' or 'singleton') or static function
 * @param {Function} [_static] - static function if type is passed through, useful for 'singleton' type
 * @example
 *
 * // Instance
 * Class(function Name() {
 *     //...
 * });
 *
 * new Name(); // or
 * _this.initClass(Name);
 * @example
 * // Static
 * Class(function Name() {
 *     //...
 * }, 'static');
 *
 * console.log(Name);
 * @example
 * // Singleton
 * Class(function Name() {
 *     //...
 * }, 'singleton');
 *
 * Name.instance();
 * @example
 * // Instance with Static function
 * Class(function Name() {
 *     //...
 * }, function() {
 *     // Static
 *     Name.EVENT_NAME = 'event_name';
 * });
 * @example
 * // Singleton with Static function
 * Class(function Name() {
 *     //...
 * }, 'singleton', function() {
 *     // Static
 * });

 */
window.Class = function(_class, _type, _static) {
    const _this = this || window;

    // Function.name ie12+ only
    const _name = _class.name || _class.toString().match(/function ?([^\(]+)/)[1];

    // Polymorphic if no type passed
    if (typeof _type === 'function') {
        _static = _type;
        _type = null;
    }

    _type = (_type || '').toLowerCase();

    // Instanced Class
    if (!_type) {
        _this[_name] = _class;

        // Initiate static function if passed through
        _static && _static();
    } else {

        // Static Class
        if (_type == 'static') {
            _this[_name] = new _class();

        // Singleton Class
        } else if (_type == 'singleton') {
            _this[_name] = _class;

            (function() {
                let _instance;

                _this[_name].instance = function(a, b, c) {
                    if (!_instance) _instance = new _class(a, b, c);
                    return _instance;
                };
            })();

            // Initiate static function if passed through
            _static && _static();
        }
    }

    // Giving namespace classes reference to namespace
    if (this && this !== window) this[_name]._namespace = this.__namespace;
};

/**
 * Inherit class
 * @name Inherit
 * @memberof Core
 *
 * @function
 * @param {Object} child
 * @param {Function} parent
 * @param {Array} [params]
 * @example
 * Class(function Parent() {
 *     this.method = function() {
 *         console.log(`I'm a Parent`);
 *     };
 * });
 *
 * Class(function Child() {
 *     Inherit(this, Parent);
 *
 *     // Call parent method
 *     this.method();
 *     // Logs 'I'm a Parent'
 *
 *     // Overwrite method
 *     this.method = function() {
 *         console.log(`I'm a Child`);
 *
 *         // Call overwritten method with _ prefix
 *         this._method();
 *     };
 * });
 *
 * let child = new Child();
 *
 * // Need to defer to wait for method overwrite
 * defer(child.method);
 * // Logs 'I'm a Child', 'I'm a Parent'
 */
window.Inherit = function(child, parent) {
    const args = [].slice.call(arguments, 2);
    parent.apply(child, args);

    // Store methods for super calls
    const save = {};
    for (let method in child) {
        save[method] = child[method];
    }

    // defer to wait for child to create of overwrite methods
    defer(() => {
        for (let method in child) {
            if (save[method] && child[method] !== save[method]) {
                if (method == 'destroy' && (child.destroy && !child.__element)) throw 'Do not override destroy directly, use onDestroy :: ' + child.constructor.toString();
                child['_' + method] = save[method];
            }
        }
    });
};

/**
 * Create class namespace for hydra
 * @name Namespace
 * @memberof Core
 *
 * @function
 * @param {Object|String} obj
 * @example
 * // Example using object
 * Class(function Baby() {
 *     Namespace(this);
 * }, 'static');
 *
 * Baby.Class(function Powder() {});
 *
 * new Baby.Powder();
 * @example
 * // Example using string
 * Class(function Baby() {
 *     Namespace('Talcum');
 * }, 'static');
 *
 * Talcum.Class(function Powder() {});
 *
 * new Talcum.Powder();
 */
window.Namespace = function(obj) {
    if (typeof obj === 'string') {
        if (!window[obj]) window[obj] = {Class, __namespace: obj};
    } else {
        obj.Class = Class;
        obj.__namespace = obj.constructor.name || obj.constructor.toString().match(/function ([^\(]+)/)[1];
    }
};

/**
 * Object to attach global properties
 * @name window.Global
 * @memberof Core
 *
 * @example
 * Global.PLAYGROUND = true;
 */
window.Global = {};

/**
 * Boolean for if Hydra is running on a thread
 * @name window.THREAD
 * @memberof Core
 */
window.THREAD = false;

/**
 * Hydra namespace. Fires ready callbacks and kicks off Main class once loaded.
 * @name Hydra
 */

Class(function Hydra() {
    const _this = this;
    const _readyPromise = Promise.create();
    var _base;

    var _callbacks = [];

    this.HASH = window.location.hash.slice(1);
    this.LOCAL = !window._BUILT_ && (location.hostname.indexOf('local') > -1 || location.hostname.split('.')[0] == '10' || location.hostname.split('.')[0] == '192') && location.port == '';

    (function () {
        initLoad();
    })();

    function initLoad() {
        if (!document || !window) return setTimeout(initLoad, 1);
        if (window._NODE_) return setTimeout(loaded, 1);

        if (window._AURA_) {
            if (!window.Main) return setTimeout(initLoad, 1);
            else return setTimeout(loaded, 1);
        }

        window.addEventListener('load', loaded, false);
    }

    function loaded() {
        window.removeEventListener('load', loaded, false);

        _this.LOCAL = (!window._BUILT_ || location.pathname.toLowerCase().includes('platform')) && (location.hostname.indexOf('local') > -1 || location.hostname.split('.')[0] == '10' || location.hostname.split('.')[0] == '192') && location.port == '';

        _callbacks.forEach(cb => cb());
        _callbacks = null;

        _readyPromise.resolve();

        // Initiate app
        if (window.Main) {
            _readyPromise.then(() => Hydra.Main = new window.Main());
        }
    }

    /**
     * Trigger page load callback
     * @memberof Hydra
     * @private
     */
    this.__triggerReady = function () {
        loaded();
    };

    /**
     * Attachment for ready event
     * @name Hydra.ready
     * @memberof Hydra
     *
     * @function
     * @param {Function} [callback] Function to trigger upon page load
     * @returns {Promise} - Returns promise if no callback passed in
     * @example
     * // either
     * Hydra.ready(init);
     * // or
     * Hydra.ready().then(init);
     * function init() {}
     */
    this.ready = function (callback) {
        if (!callback) return _readyPromise;
        if (_callbacks) _callbacks.push(callback);
        else callback();
    };

    this.absolutePath = function (path) {
        if (window.AURA) return path;
        let base = _base;
        if (base === undefined) {
            try {
                if (document.getElementsByTagName('base').length > 0) {
                    var a = document.createElement('a');
                    a.href = document.getElementsByTagName('base')[0].href;
                    base = a.pathname;
                    _base = base;
                }
            } catch (e) {
                _base = null;
            }
        }
        let pathname = base || location.pathname;
        if (pathname.includes('/index.html')) pathname = pathname.replace('/index.html', '');
        let port = Number(location.port) > 1000 ? `:${location.port}` : '';
        return path.includes('http') ? path : (location.protocol.length ? location.protocol + '//' : '') + (location.hostname + port + pathname + '/' + path).replace('//', '/');
    }

}, 'Static');

/**
 * Hydra tool-belt
 * @name Utils
 */

Class(function Utils() {

    var _queries = {};

    /**
     * Parse URL queries
     * @name this.query
     * @memberof Utils
     *
     * @function
     * @param {String} key
     * @returns {string}
     * @example
     * // url is myProject/HTML?dev=1
     * console.log(Utls.query('dev')); // logs '1'
     * @example
     * // url is myProject/HTML?dev=0
     * console.log(Utls.query('dev')); // logs false
     * // Also logs false for ?dev=false or ?dev=
     */
    this.query = function(key, value) {
        if (!!value) _queries[key] = value;

        if (_queries[key] !== undefined) return _queries[key];

        const str = decodeURIComponent(window.location.search.replace(new RegExp('^(?:.*[&\\?]' + encodeURIComponent(key).replace(/[\.\+\*]/g, '\\$&') + '(?:\\=([^&]*))?)?.*$', 'i'), '$1'));
        if (str == '0') {
            _queries[key] = 0;
            return 0;
        }

        if (!str.length || str == 'false') {
            _queries[key] = location.search.includes(key);
            return _queries[key];
        }

        _queries[key] = str;
        return str;
    };

    /**
     * @name this.addQuery
     * @memberof Utils
     *
     * @function
     * @param query
     * @param value
   */
    this.addQuery = function ( query, value ) {
        if ( _queries[ query ] === value ) return _queries[ query ];
        this.removeQuery(query);
        window.history.replaceState({}, document.title, `${location.pathname}${this.addParam( location.search, query, value )}`);
        return _queries[ query ] = value;
    }

    /**
     * @name this.removeQuery
     * @memberof Utils
     *
     * @function
     * @param query
    */
    this.removeQuery = function ( query ) {
        window.history.replaceState({}, document.title, `${location.pathname}${this.removeParam( location.search, query )}`);
        return delete _queries[ query ];
    }

    /**
     * @name this.addParam
     * @memberof Utils
     *
     * @function
     * @param url
     * @param param
     * @param value
   */
    this.addParam = function (url, param, value) {
        let u = url.split('?');
        let addedParam = encodeURIComponent(param)+'='+value;
        let pars = u[1] ? u[1].split(/[&;]/g) : [];
        pars.push(addedParam);
        url = u[0] + (pars.length > 0 ? '?' + pars.join('&') : '');
        return url;
    }

    /**
     * @name this.removeParam
     * @memberof Utils
     *
     * @function
     * @param url, param
     */
    this.removeParam = function(url, param) {
        let u = url.split('?');
        if (u.length >= 2) {
            let prefix = encodeURIComponent(param)+'=';
            let pars = u[1].split(/[&;]/g);
            for (let i = pars.length; i-- > 0;) {
                if (pars[i].lastIndexOf(prefix, 0) !== -1) pars.splice(i, 1);
            }
            url = u[0] + (pars.length > 0 ? '?' + pars.join('&') : '');
            return url;
        } else {
            return url;
        }
    }

    // Object utils

    /**
     * Get class constructor name
     * @name this.getConstructorName
     * @memberof Utils
     *
     * @function
     * @param {Object} obj
     * @returns {String}
     */
    this.getConstructorName = function(obj) {
        if (!obj) return obj;
        if (typeof obj === 'function') return obj.toString().match(/function ([^\(]+)/)[1];
        return obj.constructor.name || obj.constructor.toString().match(/function ([^\(]+)/)[1];
    };

    /**
     * Nullify object's properties
     * @name this.nullObject
     * @memberof Utils
     *
     * @function
     * @param {Object} object
     * @returns {null}
     */
    this.nullObject = function(object) {
        if (object && ( object.destroy || object.div)) {
            for (var key in object) {
                if (typeof object[key] !== 'undefined') object[key] = null;
            }
        }
        return null;
    };

    /**
     * Clone object
     * @name this.cloneObject
     * @memberof Utils
     *
     * @function
     * @param {Object} obj
     * @returns {Object}
     */
    this.cloneObject = function(obj) {
        return JSON.parse(JSON.stringify(obj));
    };

    /**
     * Return one of two parameters randomly
     * @name this.headsTails
     * @memberof Utils
     *
     * @function
     * @param {Number} n0
     * @param {Number} n1
     * @returns {Object}
     */
    this.headsTails = function(n0, n1) {
        return Math.random(0, 1) ? n1 : n0;
    };

    /**
     * Merge objects. Takes all arguments and merges them into one object.
     * @name this.mergeObject
     * @memberof Utils
     *
     * @function
     * @param {Object} Object - Any number of object paramaters
     * @returns {Object}
     */
    this.mergeObject = function() {
        var obj = {};
        for (var i = 0; i < arguments.length; i++) {
            var o = arguments[i];
            for (var key in o) {
                obj[key] = o[key];
            }
        }

        return obj;
    };

    // Mathematical utils

    /**
     * Returns unique timestamp
     * @name this.timestamp
     * @memberof Utils
     *
     * @function
     * @returns {string}
     */
    this.timestamp = this.uuid = function() {
        return Date.now() + 'xx-4xx-yxx-xxx'.replace(/[xy]/g, function(c) {
            let r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    };

    /**
     * Returns random Hex color value
     * @name this.randomColor
     * @memberof Utils
     *
     * @function
     * @returns {string} - Hex color value
     */
    this.randomColor = function() {
        var color = '#' + Math.floor(Math.random() * 16777215).toString(16);
        if (color.length < 7) color = this.randomColor();
        return color;
    };

    /**
     * Turn number into comma-delimited string
     * @name this.numberWithCommas
     * @memberof Utils
     *
     * @function
     * @param {Number} num
     * @returns {String} - String of value with comma delimiters
     */
    this.numberWithCommas = function(num) {
        return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    };

    /**
     * Pads number with 0s to match digits amount
     * @name this.padInt
     * @memberof Utils
     *
     * @function
     * @param {Number} num - Number value to convert to pad
     * @param {Integer} [digits] - Number of digits to match
     * @param {Boolean} [isLimit] limit to digit amount of 9s
     * @returns {string} - Padded value
     */
    this.padInt = function(num, digits, isLimit) {
        if (isLimit) num = Math.min(num, Math.pow(10, digits) - 1);
        let str = Math.floor(num).toString();
        return Math.pow(10, Math.max(0, digits - str.length)).toString().slice(1) + str;
    };

    /**
     * Copies string to clipboard on interaction
     * @name this.copyToClipboard
     * @memberof Utils
     *
     * @function
     * @param {string} string to copy to clipboard
     * @returns {Boolean} - Success
     */
    this.copyToClipboard = function(string) {
        try {
            var el = document.createElement( 'textarea' );
            var range = document.createRange();
            el.contentEditable = true;
            el.readOnly = true;
            el.value = string;
            document.body.appendChild( el );
            el.select();
            range.selectNodeContents( el );
            var s = window.getSelection();
            s.removeAllRanges();
            s.addRange(range);
            el.setSelectionRange(0, string.length);
            document.execCommand('copy');
            document.body.removeChild( el );
            return true;
        } catch ( e ) {
            return false;
        }
    };

    /**
     * Formats an array of strings into a single string list
     * @name this.stringList
     * @memberof Utils
     *
     * @function
     * @param {Array} Array of strings to join and format
     * @param {Integer} Max number of items to list before shortening - optional
     * @param {Object} Additional formatting options - optional
     * @returns {String} - Formatted string
     */
    this.stringList = function ( items = [], limit = 0, options = {} ) {
        if ( items.length === 0 ) return '';

        let output = '';
        let printed = 0;

        if ( typeof limit === 'object' ) {
            options = limit;
            limit = 0;
        }

        options.oxford = options.oxford === true ? true : false;
        options.more = options.more === false ? false : options.more ? options.more : 'more';
        options.and = options.and ? options.and : '&';
        options.comma = options.comma ? options.comma : ',';

        if ( !isNaN(options.limit)) limit = options.limit;
        if ( limit === 0 ) limit = items.length;

        do {
            let item = items.shift();
            output = `${output}${item}${options.comma} `;
            printed++;
        } while ( items.length > 1 && printed + 1 < limit );

        output = output.trim();
        output = output.slice(0,output.length-1);

        if ( items.length === 1 ) {
            output = `${output}${options.oxford && printed > 1 ? options.comma : ''} ${options.and} ${items.shift()}`;
        } else if ( items.length > 1 && options.more ) {
            let more = `${items.length} ${options.more}`;
            output = `${output}${options.oxford && printed > 1 ? options.comma : ''} ${options.and} ${more}`;
        }

        return output;
    }

    /**
     * @name this.debounce
     * @memberof Utils
     *
     * @function
     * @param callback
     * @param time
    */
    this.debounce = function (callback, time = 100) {
        clearTimeout(callback.__interval);
        callback.__interval = Timer.create(callback, time);
    }

}, 'Static');
/**
 * Single global requestAnimationFrame render loop to which all other classes attach their callbacks to be triggered every frame
 * @name Render
 */

Class(function Render() {
    const _this = this;

    const _render = [];
    const _drawFrame = [];
    const _multipliers = [];

    var _last = performance.now();
    var _skipLimit = 200;
    var _localTSL = 0;
    var _elapsed = 0;
    var _capLast = 0;
    var _sampleRefreshRate = [];
    var _firstSample = false;
    var rAF = requestAnimationFrame;
    var _refreshScale = 1;

   /**
    * @name timeScaleUniform
    * @memberof Render
    * @property
    */
    this.timeScaleUniform = {value: 1, type: 'f', ignoreUIL: true};
   /**
    * @name REFRESH_TABLE
    * @memberof Render
    * @property
    */
    this.REFRESH_TABLE = [30, 60, 72, 90, 100, 120, 144, 240];
   /**
    * @name REFRESH_RATE
    * @memberof Render
    * @property
    */
    this.REFRESH_RATE = 60;
   /**
    * @name HZ_MULTIPLIER
    * @memberof Render
    * @property
    */
    this.HZ_MULTIPLIER = 1;

   /**
    * @name capFPS
    * @memberof Render
    * @property
    */
    this.capFPS = null;

    //*** Constructor
    (function() {
        if (THREAD) return;
        rAF(render);
        setInterval(_ => _sampleRefreshRate = [], 3000);
    })();

    function render(tsl) {
        if (_this.capFPS > 0) {
            let delta = tsl - _capLast;
            _capLast = tsl;
            _elapsed += delta;
            if (_elapsed < 1000 / _this.capFPS) return rAF(render);
            _this.REFRESH_RATE = _this.capFPS;
            _this.HZ_MULTIPLIER = (60/_this.REFRESH_RATE) * _refreshScale;
            _elapsed = 0;
        }

        _this.timeScaleUniform.value = 1;
        if (_multipliers.length) {
            for (let i = 0; i < _multipliers.length; i++) {
                let obj = _multipliers[i];
                _this.timeScaleUniform.value *= obj.value;
            }
        }

        _this.DT = tsl - _last;
        _last = tsl;

        let delta = _this.DT * _this.timeScaleUniform.value;
        delta = Math.min(_skipLimit, delta);

        if (_this.startFrame) _this.startFrame(tsl, delta);

        if (_sampleRefreshRate && !_this.capFPS) {
            let fps = 1000 / _this.DT;
            _sampleRefreshRate.push(fps);
            if (_sampleRefreshRate.length > 30) {
                _sampleRefreshRate.sort((a, b) => a - b);
                let rate = _sampleRefreshRate[Math.round(_sampleRefreshRate.length / 2)];
                rate = _this.REFRESH_TABLE.reduce((prev, curr) => (Math.abs(curr - rate) < Math.abs(prev - rate) ? curr : prev));
                _this.REFRESH_RATE = _firstSample ? Math.max(_this.REFRESH_RATE, rate) : rate;
                _this.HZ_MULTIPLIER = (60/_this.REFRESH_RATE) * _refreshScale;
                _sampleRefreshRate = null;
                _firstSample = true;
            }
        }

        _this.TIME = tsl;
        _this.DELTA = delta;

        _localTSL += delta;

        for (let i = _render.length - 1; i >= 0; i--) {
            var callback = _render[i];
            if (!callback) {
                _render.remove(callback);
                continue;
            }
            if (callback.fps) {
                if (tsl - callback.last < 1000 / callback.fps) continue;
                callback(++callback.frame);
                callback.last = tsl;
                continue;
            }
            callback(tsl, delta);
        }

        for (let i = _drawFrame.length-1; i > -1; i--) {
            _drawFrame[i](tsl, delta);
        }

        if (_this.drawFrame) _this.drawFrame(tsl, delta); //Deprecated
        if (_this.endFrame) _this.endFrame(tsl, delta); //Deprecated

        if (!THREAD && !_this.isPaused) rAF(render);
    }

    /**
     * @name Render.now
     * @memberof Render
     *
     * @function
    */
    this.now = function() {
        return _localTSL;
    }

    /**
     * @name Render.setRefreshScale
     * @memberof Render
     *
     * @function
     * @param scale
    */
    this.setRefreshScale = function(scale) {
        _refreshScale = scale;
        _sampleRefreshRate = [];
    }

    /**
     * Add callback to render queue
     * @name Render.start
     * @memberof Render
     *
     * @function
     * @param {Function} callback - Function to call
     * @param {Integer} [fps] - Optional frames per second callback rate limit
     * @example
     * // Warp time using multiplier
     * Render.start(loop);
     * let _timewarp = 0;
     * function loop(t, delta) {
     *     console.log(_timewarp += delta * 0.001);
     * }
     * @example
     * // Limits callback rate to 5
     * Render.start(tick, 5);
     *
     * // Frame count is passed to callback instead of time information
     * function tick(frame) {
     *     console.log(frame);
     * }
     */
    this.start = function(callback, fps) {
        if (fps) {
            callback.fps = fps;
            callback.last = -Infinity;
            callback.frame = -1;
        }

        // unshift as render queue works back-to-front
        if (!~_render.indexOf(callback)) _render.unshift(callback);
    };

    /**
     * Remove callback from render queue
     * @name Render.stop
     * @memberof Render
     *
     * @function
     * @param {Function} callback
     */
    this.stop = function(callback) {
        _render.remove(callback);
    };

    /**
     * Force render - for use in threads
     * @name Render.tick
     * @memberof Render
     *
     * @function
     */
    this.tick = function() {
        if (!THREAD) return;
        this.TIME = performance.now();
        render(this.TIME);
    };

    /**
     * Distributed worker constuctor
     * @name Render.Worker
     * @memberof Render

     * @constructor
     * @param {Function} _callback
     * @param {Number} [_budget = 4]
     * @example
     * const worker = _this.initClass(Render.Worker, compute, 1);
     * function compute() {console.log(Math.sqrt(Math.map(Math.sin(performance.now()))))};
     * _this.delayedCall(worker.stop, 1000)
     *
     */
    this.Worker = function(_callback, _budget = 4) {
        Inherit(this, Component);
        let _scope = this;
        let _elapsed = 0;
        this.startRender(loop);
        function loop() {
            if (_scope.dead) return;
            while (_elapsed < _budget) {
                if (_scope.dead || _scope.paused) return;
                const start = performance.now();
                _callback && _callback();
                _elapsed += performance.now() - start;
            }
            _elapsed = 0;
        }

    /**
     * @name Render.stop
     * @memberof Render
     *
     * @function
    */
        this.stop = function() {
            this.dead = true;
            this.stopRender(loop);
            //defer(_ => _scope.destroy());
        }

    /**
     * @name Render.pause
     * @memberof Render
     *
     * @function
    */
        this.pause = function() {
            this.paused = true;
            this.stopRender(loop);
        }

    /**
     * @name Render.resume
     * @memberof Render
     *
     * @function
    */
        this.resume = function() {
            this.paused = false;
            this.startRender(loop);
        }

    /**
     * @name Render.setCallback
     * @memberof Render
     *
     * @function
     * @param cb
    */
        this.setCallback = function(cb) {
            _callback = cb;
        }
    };

    /**
     * Pause global render loop
     * @name Render.pause
     * @memberof Render
     *
     * @function
     */
    this.pause = function() {
        _this.isPaused = true;
    };

    /**
     * Resume global render loop
     * @name Render.resume
     * @memberof Render
     *
     * @function
     */
    this.resume = function() {
        if (!_this.isPaused) return;
        _this.isPaused = false;
        rAF(render);
    };

    /**
     * Use an alternative requestAnimationFrame function (for VR)
     * @name Render.useRAF
     * @param {Function} _callback
     * @memberof Render
     *
     * @function
     */
    this.useRAF = function(raf) {
        _firstSample = null;
        _last = performance.now();
        rAF = raf;
        rAF(render);
    }

    /**
     * @name Render.onDrawFrame
     * @memberof Render
     *
     * @function
     * @param cb
    */
    this.onDrawFrame = function(cb) {
        _drawFrame.push(cb);
    }

    /**
     * @name Render.setTimeScale
     * @memberof Render
     *
     * @function
     * @param v
    */
    this.setTimeScale = function(v) {
        _this.timeScaleUniform.value = v;
    }

    /**
     * @name Render.getTimeScale
     * @memberof Render
     *
     * @function
    */
    this.getTimeScale = function() {
        return _this.timeScaleUniform.value;
    }

    /**
     * @name Render.createTimeMultiplier
     * @memberof Render
     *
     * @function
    */
    /**
     * @name Render.createTimeMultiplier
     * @memberof Render
     *
     * @function
    */
    this.createTimeMultiplier = function() {
        let obj = {value: 1};
        _multipliers.push(obj);
        return obj;
    }

    /**
     * @name Render.destroyTimeMultiplier
     * @memberof Render
     *
     * @function
     * @param obj
    */
    this.destroyTimeMultiplier = function(obj) {
        _multipliers.remove(obj);
    }

    /**
     * @name Render.tweenTimeScale
     * @memberof Render
     *
     * @function
     * @param value
     * @param time
     * @param ease
     * @param delay
    */
    this.tweenTimeScale = function(value, time, ease, delay) {
        return tween(_this.timeScaleUniform, {value}, time, ease, delay, null, null, true);
    }

}, 'Static');

/**
 * Timer class that uses hydra Render loop, which has much less overhead than native setTimeout
 * @name Timer
 */

Class(function Timer() {
    const _this = this;
    const _callbacks = [];
    const _discard = [];
    const _deferA = [];
    const _deferB = [];
    var _defer = _deferA;

    (function() {
        Render.start(loop);
    })();


    function loop(t, delta) {
        for (let i = _discard.length - 1; i >= 0; i--) {
            let obj = _discard[i];
            obj.callback = null;
            _callbacks.remove(obj);
        }
        if (_discard.length) _discard.length = 0;

        for (let i = _callbacks.length - 1; i >= 0; i--) {
            let obj = _callbacks[i];
            if (!obj) {
                _callbacks.remove(obj);
                continue;
            }

            if (obj.scaledTime) {
                obj.current += delta;
            } else {
                obj.current += Render.DT;
            }

            if (obj.current >= obj.time) {
                obj.callback && obj.callback();
                _discard.push(obj);
            }
        }

        for (let i = _defer.length-1; i > -1; i--) {
            _defer[i]();
        }
        _defer.length = 0;
        _defer = _defer == _deferA ? _deferB : _deferA;
    }

    function find(ref) {
        for (let i = _callbacks.length - 1; i > -1; i--) if (_callbacks[i].ref == ref) return _callbacks[i];
    }

    //*** Event handlers

    //*** Public methods

    /**
     *
     * @private
     *
     * @param ref
     * @returns {boolean}
     */
    this.__clearTimeout = function(ref) {
        const obj = find(ref);
        if (!obj) return false;
        obj.callback = null;
        _callbacks.remove(obj);
        return true;
    };

    /**
     * Create timer
     * @name Timer.create
     * @memberof Timer
     *
     * @function
     * @param {Function} callback
     * @param {Number} time
     * @returns {Number} Returns timer reference for use with window.clearTimeout
     */
    this.create = function(callback, time, scaledTime) {
        if (window._NODE_) return setTimeout(callback, time);
        const obj = {
            time: Math.max(1, time || 1),
            current: 0,
            ref: Utils.timestamp(),
            callback,
            scaledTime
        };
        _callbacks.unshift(obj);
        return obj.ref;
    };

    /**
     * @name Timer.delayedCall
     * @memberof Timer
     *
     * @function
     * @param time
    */
    this.delayedCall = function(time) {
        let promise = Promise.create();
        _this.create(promise.resolve, time);
        return promise;
    }

    /**
     * Defer callback until next frame
     * @name window.defer
     * @memberof Timer
     *
     * @function
     * @param {Function} callback
     */
    window.defer = this.defer = function(callback) {
        let promise;
        if (!callback) {
            promise = Promise.create();
            callback = promise.resolve;
        }

        let array = _defer == _deferA ? _deferB : _deferA;
        array.unshift(callback);
        return promise;
    };

}, 'static');
/**
 * Events class
 * @name Events
 */

Class(function Events() {
    const _this = this;
    this.events = {};

    const _e = {};
    const _linked = [];
    let _emitter;

    /**
     * Add event listener
     * @name this.events.sub
     * @memberof Events
     *
     * @function
     * @param {Object} [obj] - Optional local object to listen upon, prevents event from going global
     * @param {String} evt - Event string
     * @param {Function} callback - Callback function
     * @returns {Function} callback - Returns callback to be immediately triggered
     * @example
     * // Global event listener
     * _this.events.sub(Events.RESIZE, resize);
     * function resize(e) {};
     * @example
     * // Local event listener
     * _this.events.sub(_someClass, Events.COMPLETE, loaded);
     * function loaded(e) {};
     * @example
     * // Custom event
     * MyClass.READY = 'my_class_ready';
     * _this.events.sub(MyClass.READY, ready);
     * function ready(e) {};
     */
    this.events.sub = function(obj, evt, callback) {
        if (typeof obj !== 'object') {
            callback = evt;
            evt = obj;
            obj = null;
        }

        if (!obj) {
            Events.emitter._addEvent(evt, !!callback.resolve ? callback.resolve : callback, this);
            return callback;
        }

        let emitter = obj.events.emitter();
        emitter._addEvent(evt, !!callback.resolve ? callback.resolve : callback, this);
        emitter._saveLink(this);
        _linked.push(emitter);

        return callback;
    };

    this.events.wait = async function(obj, evt) {
        const promise = Promise.create();
        const args = [obj, evt, (e) => {
            _this.events.unsub(...args);
            promise.resolve(e);
        }];
        if (typeof obj !== 'object') {
            args.splice(1, 1);
        }
        _this.events.sub(...args);
        return promise;
    };

    /**
     * Remove event listener
     * @name this.events.unsub
     * @memberof Events
     *
     * @function
     * @param {Object} [obj] - Optional local object
     * @param {String} evt - Event string
     * @param {Function} callback - Callback function
     * @example
     * // Global event listener
     * _this.events.unsub(Events.RESIZE, resize);
     * @example
     * // Local event listener
     * _this.events.unsub(_someClass, Events.COMPLETE, loaded);
     */
    this.events.unsub = function(obj, evt, callback) {
        if (typeof obj !== 'object') {
            callback = evt;
            evt = obj;
            obj = null;
        }

        if (!obj) return Events.emitter._removeEvent(evt, !!callback.resolve ? callback.resolve : callback);
        obj.events.emitter()._removeEvent(evt, !!callback.resolve ? callback.resolve : callback);
    };

    /**
     * Fire event
     * @name this.events.fire
     * @memberof Events
     *
     * @function
     * @param {String} evt - Event string
     * @param {Object} [obj] - Optional passed data
     * @param {Boolean} [isLocalOnly] - If true, prevents event from going global if no-one is listening locally
     * @example
     * // Passing data with event
     * const data = {};
     * _this.events.fire(Events.COMPLETE, {data});
     * _this.events.sub(Events.COMPLETE, e => console.log(e.data);
     * @example
     * // Custom event
     * MyClass.READY = 'my_class_ready';
     * _this.events.fire(MyClass.READY);
     */
    this.events.fire = function(evt, obj, isLocalOnly) {
        obj = obj || _e;
        obj.target = this;
        Events.emitter._check(evt);
        if (_emitter && _emitter._fireEvent(evt, obj)) return;
        if (isLocalOnly) return;
        Events.emitter._fireEvent(evt, obj);
    };

    /**
     * Bubble up local event - subscribes locally and re-emits immediately
     * @name this.events.bubble
     * @memberof Events
     *
     * @function
     * @param {Object} obj - Local object
     * @param {String} evt - Event string
     * @example
     * _this.events.bubble(_someClass, Events.COMPLETE);
     */
    this.events.bubble = function(obj, evt) {
        _this.events.sub(obj, evt, e => _this.events.fire(evt, e));
    };

    /**
     * Destroys all events and notifies listeners to remove reference
     * @private
     * @name this.events.destroy
     * @memberof Events
     *
     * @function
     * @returns {null}
     */
    this.events.destroy = function() {
        Events.emitter._destroyEvents(this);
        if (_linked) _linked.forEach(emitter => emitter._destroyEvents(this));
        if (_emitter && _emitter.links) _emitter.links.forEach(obj => obj.events && obj.events._unlink(_emitter));
        return null;
    };

    /**
     * Gets and creates local emitter if necessary
     * @private
     * @name this.events.emitter
     * @memberof Events
     *
     * @function
     * @returns {Emitter}
     */
    this.events.emitter = function() {
        if (!_emitter) _emitter = Events.emitter.createLocalEmitter();
        return _emitter;
    };

    /**
     * Unlink reference of local emitter upon its destruction
     * @private
     * @name this.events._unlink
     * @memberof Events
     *
     * @function
     * @param {Emitter} emitter
     */
    this.events._unlink = function(emitter) {
        _linked.remove(emitter);
    };
}, () => {

    /**
     * Global emitter
     * @private
     * @name Events.emitter
     * @memberof Events
     */
    Events.emitter = new Emitter();
    Events.broadcast = Events.emitter._fireEvent;

    Events.VISIBILITY = 'hydra_visibility';
    Events.HASH_UPDATE = 'hydra_hash_update';
    Events.COMPLETE = 'hydra_complete';
    Events.PROGRESS = 'hydra_progress';
    Events.UPDATE = 'hydra_update';
    Events.LOADED = 'hydra_loaded';
    Events.END = 'hydra_end';
    Events.FAIL = 'hydra_fail';
    Events.SELECT = 'hydra_select';
    Events.ERROR = 'hydra_error';
    Events.READY = 'hydra_ready';
    Events.RESIZE = 'hydra_resize';
    Events.CLICK = 'hydra_click';
    Events.HOVER = 'hydra_hover';
    Events.MESSAGE = 'hydra_message';
    Events.ORIENTATION = 'orientation';
    Events.BACKGROUND = 'background';
    Events.BACK = 'hydra_back';
    Events.PREVIOUS = 'hydra_previous';
    Events.NEXT = 'hydra_next';
    Events.RELOAD = 'hydra_reload';
    Events.UNLOAD = 'hydra_unload';
    Events.FULLSCREEN = 'hydra_fullscreen';

    const _e = {};

    function Emitter() {
        const prototype = Emitter.prototype;
        this.events = [];

        if (typeof prototype._check !== 'undefined') return;
        prototype._check = function(evt) {
            if (typeof evt == 'undefined') throw 'Undefined event';
        };

        prototype._addEvent = function(evt, callback, object) {
            this._check(evt);
            this.events.push({evt, object, callback});
        };

        prototype._removeEvent = function(eventString, callback) {
            this._check(eventString);

            for (let i = this.events.length - 1; i >= 0; i--) {
                if (this.events[i].evt === eventString && this.events[i].callback === callback) {
                    this._markForDeletion(i);
                }
            }
        };

        prototype._sweepEvents = function() {
            for (let i = 0; i < this.events.length; i++) {
                if (this.events[i].markedForDeletion) {
                    delete this.events[i].markedForDeletion;
                    this.events.splice(i, 1);
                    --i;
                }
            }
        }

        prototype._markForDeletion = function(i) {
            this.events[i].markedForDeletion = true;
            if (this._sweepScheduled) return;
            this._sweepScheduled = true;
            defer(() => {
                this._sweepScheduled = false;
                this._sweepEvents();
            });
        }

        prototype._fireEvent = function(eventString, obj) {
            if (this._check) this._check(eventString);
            obj = obj || _e;
            let called = false;
            for (let i = 0; i < this.events.length; i++) {
                let evt = this.events[i];
                if (evt.evt == eventString && !evt.markedForDeletion) {
                    evt.callback(obj);
                    called = true;
                }
            }
            return called;
        };

        prototype._destroyEvents = function(object) {
            for (var i = this.events.length - 1; i >= 0; i--) {
                if (this.events[i].object === object) {
                    this._markForDeletion(i);
                }
            }
        };

        prototype._saveLink = function(obj) {
            if (!this.links) this.links = [];
            if (!~this.links.indexOf(obj)) this.links.push(obj);
        };

        prototype.createLocalEmitter = function() {
            return new Emitter();
        };
    }

    // Global Events
    Hydra.ready(() => {

        /**
         * Visibility event handler
         * @private
         */
        (function() {
            let _lastTime = performance.now();
            let _last;

            Timer.create(addVisibilityHandler, 250);

            function addVisibilityHandler() {
                let hidden, eventName;
                [
                    ['msHidden', 'msvisibilitychange'],
                    ['webkitHidden', 'webkitvisibilitychange'],
                    ['hidden', 'visibilitychange']
                ].forEach(d => {
                    if (typeof document[d[0]] !== 'undefined') {
                        hidden = d[0];
                        eventName = d[1];
                    }
                });

                if (!eventName) {
                    const root = Device.browser == 'ie' ? document : window;
                    root.onfocus = onfocus;
                    root.onblur = onblur;
                    return;
                }

                document.addEventListener(eventName, () => {
                    const time = performance.now();
                    if (time - _lastTime > 10) {
                        if (document[hidden] === false) onfocus();
                        else onblur();
                    }
                    _lastTime = time;
                });
            }

            function onfocus() {
                Render.blurTime = -1;
                if (_last != 'focus') Events.emitter._fireEvent(Events.VISIBILITY, {type: 'focus'});
                _last = 'focus';
            }

            function onblur() {
                Render.blurTime = Date.now();
                if (_last != 'blur') Events.emitter._fireEvent(Events.VISIBILITY, {type: 'blur'});
                _last = 'blur';
            }

            window.onbeforeunload = _ => {
                Events.emitter._fireEvent(Events.UNLOAD);
                return null;
            };
        })();

        window.Stage = window.Stage || {};
        let box;
        if (Device.system.browser == 'social' && Device.system.os == 'ios') {
            box = document.createElement('div');
            box.style.position = 'fixed';
            box.style.top = box.style.left = box.style.right = box.style.bottom = '0px';
            box.style.zIndex = '-1';
            box.style.opacity = '0';
            box.style.pointerEvents = 'none';
            document.body.appendChild(box);
        }
        updateStage();

        let iosResize = Device.system.os === 'ios';
        let html = iosResize ? document.querySelector('html') : false;
        let delay = iosResize ? 500 : 16;
        let timer;

        function handleResize() {
            clearTimeout(timer);
            timer = setTimeout(_ => {
                updateStage();
                if ( html && Math.min( window.screen.width, window.screen.height ) !== Stage.height && !Mobile.isAllowNativeScroll ) {
                    html.scrollTop = -1;
                }
                Events.emitter._fireEvent(Events.RESIZE);
            }, delay);
        }

        window.addEventListener('resize', handleResize);

        window.onorientationchange = window.onresize;

        if (Device.system.browser == 'social' && (Stage.height >= screen.height || Stage.width >= screen.width)) {
            setTimeout(updateStage, 1000);
        }

        // Call initially
        defer(window.onresize);

        function updateStage() {
            if (box) {
                let bbox = box.getBoundingClientRect();
                Stage.width = bbox.width || window.innerWidth || document.body.clientWidth || document.documentElement.offsetWidth;
                Stage.height = bbox.height || window.innerHeight || document.body.clientHeight || document.documentElement.offsetHeight;

                document.body.parentElement.scrollTop = document.body.scrollTop = 0;
                document.documentElement.style.width = document.body.style.width = `${Stage.width}px`;
                document.documentElement.style.height = document.body.style.height = `${Stage.height}px`;
                Events.emitter._fireEvent(Events.RESIZE);
            } else {
                Stage.width = window.innerWidth || document.body.clientWidth || document.documentElement.offsetWidth;
                Stage.height = window.innerHeight || document.body.clientHeight || document.documentElement.offsetHeight;
            }
        }
    });
});
/**
 * Read-only class with device-specific information and exactly what's supported.
 * Information split into: system, mobile, media, graphics, style, tween.
 * @name Device
 */

Class(function Device() {
    var _this = this;

    /**
     * Stores user agent as string
     * @name Device.agent
     * @memberof Device
     */
    this.agent = navigator.userAgent.toLowerCase();

    /**
     * Checks user agent against match query
     * @name Device.detect
     * @memberof Device
     *
     * @function
     * @param {String|String[]} match - Either string or array of strings to test against
     * @returns {Boolean}
     */
    this.detect = function(match) {
        return this.agent.includes(match)
    };

    /**
     * Boolean
     * @name Device.touchCapable
     * @memberof Device
     */
    this.touchCapable = !!navigator.maxTouchPoints;

    /**
     * Alias of window.devicePixelRatio
     * @name Device.pixelRatio
     * @memberof Device
     */
    this.pixelRatio = window.devicePixelRatio;

    //==================================================================================//
    //===// System //===================================================================//

    this.system = {};

    /**
     * Boolean. True if devicePixelRatio greater that 1.0
     * @name Device.system.retina
     * @memberof Device
     */
    this.system.retina = window.devicePixelRatio > 1;

    /**
     * Boolean
     * @name Device.system.webworker
     * @memberof Device
     */
    this.system.webworker = typeof window.Worker !== 'undefined';


    /**
     * Boolean
     * @name Device.system.geolocation
     * @memberof Device
     */
    if (!window._NODE_) this.system.geolocation = typeof navigator.geolocation !== 'undefined';

    /**
     * Boolean
     * @name Device.system.pushstate
     * @memberof Device
     */
    if (!window._NODE_) this.system.pushstate = typeof window.history.pushState !== 'undefined';

    /**
     * Boolean
     * @name Device.system.webcam
     * @memberof Device
     */
    this.system.webcam = !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.mediaDevices);

    /**
     * String of user's navigator language
     * @name Device.system.language
     * @memberof Device
     */
    this.system.language = window.navigator.userLanguage || window.navigator.language;

    /**
     * Boolean
     * @name Device.system.webaudio
     * @memberof Device
     */
    this.system.webaudio = typeof window.AudioContext !== 'undefined';

    /**
     * Boolean
     * @name Device.system.xr
     * @memberof Device
     */
    this.system.xr = {};
    this.system.detectXR = async function() {
        if (window.AURA) {
            _this.system.xr.vr = true;
            _this.system.xr.ar = true;
            return;
        }

        if (!navigator.xr) {
            _this.system.xr.vr = false;
            _this.system.xr.ar = false;
            return;
        }

        [_this.system.xr.vr, _this.system.xr.ar] = await Promise.all([
            navigator.xr.isSessionSupported('immersive-vr'),
            navigator.xr.isSessionSupported('immersive-ar')
        ]);

        if (_this.system.os == 'android') {
            if (!_this.detect('oculus')) {
                _this.system.xr.vr = false;
            }
        }
    };

    /**
     * Boolean
     * @name Device.system.localStorage
     * @memberof Device
     */
    try {
        this.system.localStorage = typeof window.localStorage !== 'undefined';
    } catch (e) {
        this.system.localStorage = false;
    }

    /**
     * Boolean
     * @name Device.system.fullscreen
     * @memberof Device
     */
    this.system.fullscreen = document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;

    /**
     * String of operating system. Returns 'ios', 'android', 'blackberry', 'mac', 'windows', 'linux' or 'unknown'.
     * @name Device.system.os
     * @memberof Device
     */
    this.system.os = (function() {
        if (_this.detect(['ipad', 'iphone', 'ios']) || (_this.detect('mac') && _this.touchCapable && Math.max(screen.width, screen.height) < 1370)) return 'ios';
        if (_this.detect(['android', 'kindle'])) return 'android';
        if (_this.detect(['blackberry'])) return 'blackberry';
        if (_this.detect(['mac os'])) return 'mac';
        if (_this.detect(['windows', 'iemobile'])) return 'windows';
        if (_this.detect(['linux'])) return 'linux';
        return 'unknown';
    })();

    /**
     * Mobile os version. Currently only applicable to mobile OS.
     * @name Device.system.version
     * @memberof Device
     */
    this.system.version = (function() {
        try {
            if (_this.system.os == 'ios') {
                if (_this.agent.includes('intel mac')) {
                    let num = _this.agent.split('version/')[1].split(' ')[0];
                    let split = num.split('.');
                    return Number(split[0] + '.' + split[1]);
                } else {
                    var num = _this.agent.split('os ')[1].split('_');
                    var main = num[0];
                    var sub = num[1].split(' ')[0];
                    return Number(main + '.' + sub);
                }
            }
            if (_this.system.os == 'android') {
                var version = _this.agent.split('android ')[1].split(';')[0];
                if (version.length > 3) version = version.slice(0, -2);
                if (version.charAt(version.length-1) == '.') version = version.slice(0, -1);
                return Number(version);
            }
            if (_this.system.os == 'windows') {
                if (_this.agent.includes('rv:11')) return 11;
                return Number(_this.agent.split('windows phone ')[1].split(';')[0]);
            }
        } catch(e) {}
        return -1;
    })();

    /**
     * String of browser. Returns, 'social, 'chrome', 'safari', 'firefox', 'ie', 'browser' (android), or 'unknown'.
     * @name Device.system.browser
     * @memberof Device
     */
    this.system.browser = (function() {
        if (_this.system.os == 'ios') {
            if (_this.detect(['twitter', 'fbios', 'instagram'])) return 'social';
            if (_this.detect(['crios'])) return 'chrome';
            if (_this.detect(['safari'])) return 'safari';
            return 'unknown';
        }
        if (_this.system.os == 'android') {
            if (_this.detect(['twitter', 'fb', 'facebook', 'instagram'])) return 'social';
            if (_this.detect(['chrome'])) return 'chrome';
            if (_this.detect(['firefox'])) return 'firefox';
            return 'browser';
        }
        if (_this.detect(['msie'])) return 'ie';
        if (_this.detect(['trident']) && _this.detect(['rv:'])) return 'ie';
        if (_this.detect(['windows']) && _this.detect(['edge'])) return 'ie';
        if (_this.detect(['chrome'])) return 'chrome';
        if (_this.detect(['safari'])) return 'safari';
        if (_this.detect(['firefox'])) return 'firefox';

        // TODO: test windows phone and see what it returns
        //if (_this.os == 'Windows') return 'ie';
        return 'unknown';
    })();

    /**
     * Number value of browser version
     * @name Device.browser.browserVersion
     * @memberof Device
     */
    this.system.browserVersion = (function() {
        try {
            if (_this.system.browser == 'chrome') return Number(_this.agent.split('chrome/')[1].split('.')[0]);
            if (_this.system.browser == 'firefox') return Number(_this.agent.split('firefox/')[1].split('.')[0]);
            if (_this.system.browser == 'safari') return Number(_this.agent.split('version/')[1].split('.')[0].split('.')[0]);
            if (_this.system.browser == 'ie') {
                if (_this.detect(['msie'])) return Number(_this.agent.split('msie ')[1].split('.')[0]);
                if (_this.detect(['rv:'])) return Number(_this.agent.split('rv:')[1].split('.')[0]);
                return Number(_this.agent.split('edge/')[1].split('.')[0]);
            }
        } catch(e) {
            return -1;
        }
    })();

    //==================================================================================//
    //===// Mobile //===================================================================//

    /**
     * Object that only exists if device is mobile or tablet
     * @name Device.mobile
     * @memberof Device
     */
    this.mobile = !window._NODE_ && (!!(('ontouchstart' in window) || ('onpointerdown' in window)) && _this.system.os.includes(['ios', 'android', 'magicleap'])) ? {} : false;
    if (_this.detect('quest')) this.mobile = true;
    if (this.mobile && this.detect(['windows']) && !this.detect(['touch'])) this.mobile = false;
    if (this.mobile) {

        /**
         * Boolean
         * @name Device.mobile.tablet
         * @memberof Device
         */
        this.mobile.tablet = Math.max(window.screen ? screen.width : window.innerWidth, window.screen ? screen.height : window.innerHeight) > 1000;

        /**
         * Boolean
         * @name Device.mobile.phone
         * @memberof Device
         */
        this.mobile.phone = !this.mobile.tablet;

        /**
         * Boolean
         * @name Device.mobile.pwa
         * @memberof Device
         */
        this.mobile.pwa = (function() {
            if (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) return true;
            if (window.navigator.standalone) return true;
            return false;
        })();

        /**
         * Boolean. Only available after Hydra is ready
         * @name Device.mobile.native
         * @memberof Device
         */
        Hydra.ready(() => {
            _this.mobile.native = (function() {
                if (Mobile.NativeCore && Mobile.NativeCore.active) return true;
                if (window._AURA_) return true;
                return false;
            })();
        });
    }

    //=================================================================================//
    //===// Media //===================================================================//

    this.media = {};

    /**
     * String for preferred audio format ('ogg' or 'mp3'), else false if unsupported
     * @name Device.media.audio
     * @memberof Device
     */
    this.media.audio = (function() {
        if (!!document.createElement('audio').canPlayType) {
            return _this.detect(['firefox', 'opera']) ? 'ogg' : 'mp3';
        } else {
            return false;
        }
    })();

    /**
     * String for preferred video format ('webm', 'mp4' or 'ogv'), else false if unsupported
     * @name Device.media.video
     * @memberof Device
     */
    this.media.video = (function() {
        var vid = document.createElement('video');
        if (!!vid.canPlayType) {
            if (vid.canPlayType('video/webm;')) return 'webm';
            return 'mp4';
        } else {
            return false;
        }
    })();

    /**
     * Boolean
     * @name Device.media.webrtc
     * @memberof Device
     */
    this.media.webrtc = !!(window.webkitRTCPeerConnection || window.mozRTCPeerConnection || window.msRTCPeerConnection || window.oRTCPeerConnection || window.RTCPeerConnection);

    //====================================================================================//
    //===// Graphics //===================================================================//

    this.graphics = {};

    /**
     * Object with WebGL-related information. False if WebGL unsupported.
     * @name Device.graphics.webgl
     * @memberof Device
     * @example
     * Device.graphics.webgl.renderer
     * Device.graphics.webgl.version
     * Device.graphics.webgl.glsl
     * Device.graphics.webgl.extensions
     * Device.graphics.webgl.gpu
     * Device.graphics.webgl.extensions
     */
    this.graphics.webgl = (function() {

        let DISABLED = false;

        Object.defineProperty(_this.graphics, 'webgl', {
           get: () => {
               if (DISABLED) return false;

               if (_this.graphics._webglContext) return _this.graphics._webglContext;

               try {
                   const names = ['webgl2', 'webgl', 'experimental-webgl'];
                   const canvas = document.createElement('canvas');
                   let gl;
                   for (let i = 0; i < names.length; i++) {
                       gl = canvas.getContext(names[i]);
                       if (gl) break;
                   }

                   let info = gl.getExtension('WEBGL_debug_renderer_info');
                   let output = {};
                   if (info) {
                       let gpu = info.UNMASKED_RENDERER_WEBGL;
                       output.gpu = gl.getParameter(gpu).toLowerCase();
                   } else {
                       output.gpu = 'unknown';
                   }

                   output.renderer = gl.getParameter(gl.RENDERER).toLowerCase();
                   output.version = gl.getParameter(gl.VERSION).toLowerCase();
                   output.glsl = gl.getParameter(gl.SHADING_LANGUAGE_VERSION).toLowerCase();
                   output.extensions = gl.getSupportedExtensions();
                   output.webgl2 = output.version.includes(['webgl 2', 'webgl2']);
                   output.canvas = canvas;
                   output.context = gl;

                   output.detect = function(matches) {
                       if (output.gpu && output.gpu.toLowerCase().includes(matches)) return true;
                       if (output.version && output.version.toLowerCase().includes(matches)) return true;

                       for (let i = 0; i < output.extensions.length; i++) {
                           if (output.extensions[i].toLowerCase().includes(matches)) return true;
                       }
                       return false;
                   };

                   if (!output.webgl2 && !output.detect('instance') && !window.AURA) DISABLED = true;

                   _this.graphics._webglContext = output;
                   return output;
               } catch(e) {
                   return false;
               }
           },

            set: v => {
               if (v === false) DISABLED = true;
            }
        });
    })();

    this.graphics.metal = (function() {
        if (!window.Metal) return false;
        let output = {};
        output.gpu = Metal.device.getName().toLowerCase();
        output.detect = function(matches) {
            return output.gpu.includes(matches);
        };
        return output;
    })();

    /**
     * Abstraction of Device.graphics.webgl to handle different rendering backends
     *
     * @name Device.graphics.gpu
     * @memberof Device
     */
    this.graphics.gpu = (function() {
        if (!_this.graphics.webgl && !_this.graphics.metal) return false;
        let output = {};
        ['metal', 'webgl'].forEach(name => {
            if (!!_this.graphics[name] && !output.identifier) {
                output.detect = _this.graphics[name].detect;
                output.identifier = _this.graphics[name].gpu;
            }
        });
        return output;
    })();

    /**
     * Boolean
     * @name Device.graphics.canvas
     * @memberof Device
     */
    this.graphics.canvas = (function() {
        var canvas = document.createElement('canvas');
        return canvas.getContext ? true : false;
    })();

    //==================================================================================//
    //===// Styles //===================================================================//

    const checkForStyle = (function() {
        let _tagDiv;
        return function (prop) {
            _tagDiv = _tagDiv || document.createElement('div');
            const vendors = ['Khtml', 'ms', 'O', 'Moz', 'Webkit']
            if (prop in _tagDiv.style) return true;
            prop = prop.replace(/^[a-z]/, val => {return val.toUpperCase()});
            for (let i = vendors.length - 1; i >= 0; i--) if (vendors[i] + prop in _tagDiv.style) return true;
            return false;
        }
    })();

    this.styles = {};

    /**
     * Boolean
     * @name Device.styles.filter
     * @memberof Device
     */
    this.styles.filter = checkForStyle('filter');

    /**
     * Boolean
     * @name Device.styles.blendMode
     * @memberof Device
     */
    this.styles.blendMode = checkForStyle('mix-blend-mode');

    //=================================================================================//
    //===// Tween //===================================================================//

    this.tween = {};

    /**
     * Boolean
     * @name Device.tween.transition
     * @memberof Device
     */
    this.tween.transition = checkForStyle('transition');

    /**
     * Boolean
     * @name Device.tween.css2d
     * @memberof Device
     */
    this.tween.css2d = checkForStyle('transform');

    /**
     * Boolean
     * @name Device.tween.css3d
     * @memberof Device
     */
    this.tween.css3d = checkForStyle('perspective');

    //==================================================================================//
    //===// Social //===================================================================//

    /**
     * Boolean
     * @name Device.social
     * @memberof Device
     */
    this.social = (function() {
        if (_this.agent.includes('instagram')) return 'instagram';
        if (_this.agent.includes('fban')) return 'facebook';
        if (_this.agent.includes('fbav')) return 'facebook';
        if (_this.agent.includes('fbios')) return 'facebook';
        if (_this.agent.includes('twitter')) return 'twitter';
        if (document.referrer && document.referrer.includes('//t.co/')) return 'twitter';
        return false;
    })();
}, 'Static');
/**
 * Class structure tool-belt that cleans up after itself upon class destruction.
 * @name Component
 */

Class(function Component() {
    Inherit(this, Events);
    const _this = this;
    const _setters = {};
    const _flags = {};
    const _timers = [];
    const _loops = [];
    var _onDestroy;

    this.classes = {};

    function defineSetter(_this, prop) {
        _setters[prop] = {};
        Object.defineProperty(_this, prop, {
            set: function(v) {
                if (_setters[prop] && _setters[prop].s) _setters[prop].s.call(_this, v);
                v = null;
            },

            get: function() {
                if (_setters[prop] && _setters[prop].g) return _setters[prop].g.apply(_this);
            }
        });
    }

    /**
     * @name this.findParent
     * @memberof Component
     *
     * @function
     * @param type
    */
    this.findParent = function(type) {
        let p = _this.parent;
        while (p) {
            if (!p._cachedName) p._cachedName = Utils.getConstructorName(p);
            if (p._cachedName == type) return p;
            p = p.parent;
        }
    }

    /**
     * Define setter for class property
     * @name this.set
     * @memberof Component
     *
     * @function
     * @param {String} prop
     * @param {Function} callback
     */
    this.set = function(prop, callback) {
        if (!_setters[prop]) defineSetter(this, prop);
        _setters[prop].s = callback;
    };

    /**
     * Define getter for class property
     * @name this.get
     * @memberof Component
     *
     * @function
     * @param {String} prop
     * @param {Function} callback
     */
    this.get = function(prop, callback) {
        if (!_setters[prop]) defineSetter(this, prop);
        _setters[prop].g = callback;
    };

    /**
     * Returns true if the current playground is set to this class
     * @name this.set
     * @memberof Component
     *
     * @function
     */
    this.isPlayground = function(name) {
        return Global.PLAYGROUND && Global.PLAYGROUND == (name || Utils.getConstructorName(_this));
    };


    /**
     * Helper to initialise class and keep reference for automatic cleanup upon class destruction
     * @name this.initClass
     * @memberof Component
     *
     * @function
     * @param {Function} clss - class to initialise
     * @param {*} arguments - All additional arguments passed to class constructor
     * @returns {Object} - Instanced child class
     * @example
     * Class(function BigButton(_color) {
     *     console.log(`${this.parent} made me ${_color}); //logs [parent object] made me red
     * });
     * const bigButton _this.initClass(BigButton, 'red');
     */
    this.initClass = function(clss) {
        if (!clss) throw `unable to locate class`;

        const args = [].slice.call(arguments, 1);
        const child = Object.create(clss.prototype);
        child.parent = this;
        clss.apply(child, args);

        // Store reference if child is type Component
        if (child.destroy) {
            const id = Utils.timestamp();
            this.classes[id] = child;
            this.classes[id].__id = id;
        }

        // Automatically attach HydraObject elements
        if (child.element) {
            const last = arguments[arguments.length - 1];
            if (Array.isArray(last) && last.length == 1 && last[0] instanceof HydraObject) last[0].add(child.element);
            else if (this.element && last !== null) this.element.add(child.element);
        }

        // Automatically attach 3D groups
        if (child.group) {
            const last = arguments[arguments.length - 1];
            if (this.group && last !== null) this.group.add(child.group);
        }

        return child;
    };

    /**
     * Create timer callback with automatic cleanup upon class destruction
     * @name this.delayedCall
     * @memberof Component
     *
     * @function
     * @param {Function} callback
     * @param {Number} time
     * @param {*} [args] - any number of arguments can be passed to callback
     */
    this.delayedCall = function(callback, time, scaledTime) {
        const timer = Timer.create(() => {
            if (!_this || !_this.destroy) return;
            callback && callback();
        }, time, scaledTime);

        _timers.push(timer);

        // Limit in case dev using a very large amount of timers, so not to local reference
        if (_timers.length > 50) _timers.shift();

        return timer;
    };

    /**
     * Clear all timers linked to this class
     * @name this.clearTimers
     * @memberof Component
     *
     * @function
     */
    this.clearTimers = function() {
        for (let i = _timers.length - 1; i >= 0; i--) clearTimeout(_timers[i]);
        _timers.length = 0;
    };

    /**
     * Start render loop. Stored for automatic cleanup upon class destruction
     * @name this.startRender
     * @memberof Component
     *
     * @function
     * @param {Function} callback
     * @param {Number} [fps] Limit loop rate to number of frames per second. eg Value of 1 will trigger callback once per second
     */
    this.startRender = function(callback, fps, obj) {
        if (typeof fps !== 'number') {
            obj = fps;
            fps = undefined;
        }

        for (let i = 0; i < _loops.length; i++) {
            if (_loops[i].callback == callback) return;
        }

        let flagInvisible = _ => {
            if (!_this._invisible) {
                _this._invisible = true;
                _this.onInvisible && _this.onInvisible();
            }
        };

        let loop = (a, b, c, d) => {
            if (!_this.startRender) return false;

            let p = _this;
            while (p) {
                if (p.visible === false) return flagInvisible();
                if (p.group && p.group.visible === false) return flagInvisible();
                p = p.parent;
            }

            if (_this._invisible !== false) {
                _this._invisible = false;
                _this.onVisible && _this.onVisible();
            }

            callback(a, b, c, d);
            return true;
        };
        _loops.push({callback, loop});

        if (obj) {
            RenderManager.schedule(loop, obj);
        } else {
            Render.start(loop, fps);
        }
    };

    /**
     * Link up to the resize event
     * @name this.resize
     * @memberof Component
     *
     * @function
     * @param {Function} callback
     */
    this.onResize = function(callback) {
        callback();
        this.events.sub(Events.RESIZE, callback);
    }

    /**
     * Stop and clear render loop linked to callback
     * @name this.stopRender
     * @memberof Component
     *
     * @function
     * @param {Function} callback
     */
    this.stopRender = function(callback, obj) {
        for (let i = 0; i < _loops.length; i++) {
            if (_loops[i].callback == callback) {

                let loop = _loops[i].loop;

                if (obj) {
                    RenderManager.unschedule(loop, obj);
                }

                Render.stop(loop);
                _loops.splice(i, 1);
            }
        }
    };

    /**
     * Clear all render loops linked to this class
     * @name this.clearRenders
     * @memberof Component
     *
     * @function
     */
    this.clearRenders = function() {
        for (let i = 0; i < _loops.length; i++) {
            Render.stop(_loops[i].loop);
        }

        _loops.length = 0;
    };

    /**
     * Get callback when object key exists. Uses internal render loop so automatically cleaned up.
     * @name this.wait
     * @memberof Component
     *
     * @function
     * @param {Object} object
     * @param {String} key
     * @param {Function} [callback] - Optional callback
     * @example
     * // Using promise syntax
     * this.wait(this, 'loaded').then(() => console.log('LOADED'));
     * @example
     * // Using callback
     * this.wait(this, 'loaded', () => console.log('LOADED'));
     */
    this.wait = function(object, key, callback) {
        const promise = Promise.create();

        if (typeof object === 'string') {
            callback = key;
            key = object;
            object = _this;
        }

        if (typeof object === 'number' && !key) {
            _this.delayedCall(promise.resolve, object);
            return promise;
        }

        // To catch old format of first param being callback
        if (typeof object == 'function' && typeof callback !== 'function') {
            let _object = object;
            object = key;
            key = callback;
            callback = _object;
        }

        callback = callback || promise.resolve;

        if (!!object[key] || !!_this.flag(key)) {
            callback();
        } else {
            Render.start(test);

            function test() {
                if (!object || !_this.flag) return Render.stop(test);
                if (!!object[key] || !!_this.flag(key)) {
                    callback();
                    Render.stop(test);
                }
            }
        }

        return promise;
    };

    /**
     * Set or get boolean
     * @name this.flag
     * @memberof Component
     *
     * @function
     * @param {String} name
     * @param {Boolean} [value] if no value passed in, current value returned
     * @param {Number} [time] - Optional delay before toggling the value to the opposite of its current value
     * @returns {*} Returns with current value if no value passed in
     */
    this.flag = function(name, value, time) {
        if (typeof value !== 'undefined') {
            _flags[name] = value;

            if (time) {
                clearTimeout(_flags[name+'_timer']);
                _flags[name+'_timer'] = this.delayedCall(() => {
                    _flags[name] = !_flags[name];
                }, time);
            }
        } else {
            return _flags[name];
        }
    };

    /**
     * Destroy class and all of its attachments: events, timers, render loops, children.
     * @name this.destroy
     * @memberof Component
     *
     * @function
     */
    this.destroy = function() {
        if (this.removeDispatch) this.removeDispatch();
        if (this.onDestroy) this.onDestroy();
        if (this.fxDestroy) this.fxDestroy();
        if (_onDestroy) _onDestroy.forEach(cb => cb());

        for (let id in this.classes) {
            var clss = this.classes[id];
            if (clss && clss.destroy) clss.destroy();
        }
        this.classes = null;

        this.clearRenders && this.clearRenders();
        this.clearTimers && this.clearTimers();
        if (this.element && window.GLUI && this.element instanceof GLUIObject) this.element.remove();

        if (this.events) this.events = this.events.destroy();
        if (this.parent && this.parent.__destroyChild) this.parent.__destroyChild(this.__id);

        return Utils.nullObject(this);
    };

    this._bindOnDestroy = function(cb) {
        if (!_onDestroy) _onDestroy = [];
        _onDestroy.push(cb);
    }

    this.__destroyChild = function(name) {
        delete this.classes[name];
    };

});
/**
 * Class structure tool-belt that helps with loading and storing data.
 * @name Model
 */

Class(function Model() {
    Inherit(this, Component);
    Namespace(this);

    const _this = this;
    const _storage = {};
    let _data = 0;
    let _triggered = 0;

    /**
     * @name this.push
     * @memberof Model
     *
     * @function
     * @param {String} name
     * @param {*} val
     */
    this.push = function(name, val) {
        _storage[name] = val;
    };

    /**
     * @name this.pull
     * @memberof Model
     *
     * @function
     * @param {String} name
     * @returns {*}
     */
    this.pull = function(name) {
        return _storage[name];
    };

    /**
     * @name this.promiseData
     * @memberof Model
     *
     * @function
     * @param {Number} [num = 1]
     */
    this.waitForData = this.promiseData = function(num = 1) {
        _data += num;
    };

    /**
     * @name this.resolveData
     * @memberof Model
     *
     * @function
     */
    this.fulfillData = this.resolveData = function() {
        _triggered++;
        if (_triggered == _data) {
            _this.dataReady = true;
        }
    };

    /**
     * @name this.ready
     * @memberof Model
     *
     * @function
     * @param {Function} [callback]
     * @returns {Promise}
     */
    this.ready = function(callback) {
        let promise = Promise.create();
        if (callback) promise.then(callback);
        _this.wait(_this, 'dataReady').then(promise.resolve);
        return promise;
    };

    /**
     * Calls init() on object member is exists, and then on self once completed.
     * @name this.initWithData
     * @memberof Model
     *
     * @function
     * @param {Object} data
     */
    this.initWithData = function(data) {
        _this.STATIC_DATA = data;

        for (var key in _this) {
            var model = _this[key];
            var init = false;

            for (var i in data) {
                if (i.toLowerCase().replace(/-/g, "") == key.toLowerCase()) {
                    init = true;
                    if (model.init) model.init(data[i]);
                }
            }

            if (!init && model.init) model.init();
        }

        _this.init && _this.init(data);
    };

    /**
     * Loads url with salt, then calls initWithData on object received
     * @name this.loadData
     * @memberof Model
     *
     * @function
     * @param {String} url
     * @param {Function} [callback]
     * @returns {Promise}
     */
    this.loadData = function(url, callback) {
        let promise = Promise.create();
        if (!callback) callback = promise.resolve;

        var _this = this;
        get(url + '?' + Utils.timestamp()).then( d => {
            defer(() => {
                _this.initWithData(d);
                callback(d);
            });
        });

        return promise;
    };

});

/**
 * @name Modules
 */

Class(function Modules() {
    const _modules = {};
    const _constructors = {};

    //*** Constructor
    (function () {
        defer(exec);
    })();

    function exec() {
        for (let m in _modules) {
            for (let key in _modules[m]) {
                let module = _modules[m][key];
                if (module._ready) continue;
                module._ready = true;
                if (module.exec) module.exec();
            }
        }
    }

    function requireModule(root, path) {
        let module = _modules[root];
        if (!module) throw `Module ${root} not found`;
        module = module[path];

        if (!module._ready) {
            module._ready = true;
            if (module.exec) module.exec();
        }

        return module;
    }

    //*** Public methods

    /**
     * @name window.Module
     * @memberof Modules
     *
     * @function
     * @param {Constructor} module
     */
    this.Module = function(module) {
        let m = new module();

        let name = module.toString().slice(0, 100).match(/function ([^\(]+)/);

        if (name) {
            m._ready = true;
            name = name[1];
            _modules[name] = {index: m};
            _constructors[name] = module;
        } else {
            if (!_modules[m.module]) _modules[m.module] = {};
            _modules[m.module][m.path] = m;
        }
    };

    /**
     * @name window.require
     * @memberof Modules
     *
     * @function
     * @param {String} path
     * @returns {*}
     */
    this.require = function(path) {
        let root;
        if (!path.includes('/')) {
            root = path;
            path = 'index';
        } else {
            root = path.split('/')[0];
            path = path.replace(root+'/', '');
        }

        return requireModule(root, path).exports;
    };

    this.getConstructor = function(name) {
        return _constructors[name];
    }

    window.Module = this.Module;

    if (!window._NODE_) {
        window.requireNative = window.require;
        window.require = this.require;
    }
}, 'Static');
/**
 * @name LinkedList
 *
 * @constructor
 */

Class(function LinkedList() {
    var prototype = LinkedList.prototype;

    /**
     * @name length
     * @memberof LinkedList
     */
    this.length = 0;
    this.first = null;
    this.last = null;
    this.current = null;
    this.prev = null;

    if (typeof prototype.push !== 'undefined') return;

    /**
     * @name push
     * @memberof LinkedList
     *
     * @function
     * @param {*} obj
     */
    prototype.push = function(obj) {
        if (!this.first) {
            this.first = obj;
            this.last = obj;
            obj.__prev = obj;
            obj.__next = obj;
        } else {
            obj.__next = this.first;
            obj.__prev = this.last;
            this.last.__next = obj;
            this.last = obj;
        }

        this.length++;
    };

    /**
     * @name remove
     * @memberof LinkedList
     *
     * @function
     * @param {*} obj
     */
    prototype.remove = function(obj) {
        if (!obj || !obj.__next) return;

        if (this.length <= 1) {
            this.empty();
        } else {
            if (obj == this.first) {
                this.first = obj.__next;
                this.last.__next = this.first;
                this.first.__prev = this.last;
            } else if (obj == this.last) {
                this.last = obj.__prev;
                this.last.__next = this.first;
                this.first.__prev = this.last;
            } else {
                obj.__prev.__next = obj.__next;
                obj.__next.__prev = obj.__prev;
            }

            this.length--;
        }

        obj.__prev = null;
        obj.__next = null;
    };

    /**
     * @name empty
     * @memberof LinkedList
     *
     * @function
     */
    prototype.empty = function() {
        this.first = null;
        this.last = null;
        this.current = null;
        this.prev = null;
        this.length = 0;
    };

    /**
     * @name start
     * @memberof LinkedList
     *
     * @function
     * @return {*}
     */
    prototype.start = function() {
        this.current = this.first;
        this.prev = this.current;
        return this.current;
    };

    /**
     * @name next
     * @memberof LinkedList
     *
     * @function
     * @return {*}
     */
    prototype.next = function() {
        if (!this.current) return;
        this.current = this.current.__next;
        if (this.length == 1 || this.prev.__next == this.first) return;
        this.prev = this.current;
        return this.current;
    };

    /**
     * @name destroy
     * @memberof LinkedList
     *
     * @function
     * @returns {Null}
     */
    prototype.destroy = function() {
        Utils.nullObject(this);
        return null;
    };

});
/**
 * @name ObjectPool
 *
 * @constructor
 * @param {Constructor} [_type]
 * @param {Number} [_number = 10] - Only applied if _type argument exists
 */

Class(function ObjectPool(_type, _number = 10) {
    var _pool = [];

    /**
     * Pool array
     * @name array
     * @memberof ObjectPool
     */
    this.array = _pool;

    //*** Constructor
    (function() {
        if (_type) for (var i = 0; i < _number; i++) _pool.push(new _type());
    })();

    //*** Public Methods

    /**
     * Retrieve next object from pool
     * @name get
     * @memberof ObjectPool
     *
     * @function
     * @returns {ArrayElement|null}
     */
    this.get = function() {
        return _pool.shift() || (_type ? new _type() : null);
    };

    /**
     * Empties pool array
     * @name empty
     * @memberof ObjectPool
     *
     * @function
     */
    this.empty = function() {
        _pool.length = 0;
    };

    /**
     * Place object into pool
     * @name put
     * @memberof ObjectPool
     *
     * @function
     * @param {Object} obj
     */
    this.put = function(obj) {
        if (obj) _pool.push(obj);
    };

    /**
     * Insert array elements into pool
     * @name insert
     * @memberof ObjectPool
     *
     * @function
     * @param {Array} array
     */
    this.insert = function(array) {
        if (typeof array.push === 'undefined') array = [array];
        for (var i = 0; i < array.length; i++) _pool.push(array[i]);
    };

    /**
     * Retrieve pool length
     * @name length
     * @memberof ObjectPool
     *
     * @function
     * @returns {Number}
     */
    this.length = function() {
        return _pool.length;
    };

    /**
     * Randomize pool
     * @memberof ObjectPool
     *
     * @function
     */
    this.randomize = function() {
        let array = _pool;
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    /**
     * Calls destroy method on all members if exists, then removes reference.
     * @name destroy
     * @memberof ObjectPool
     *
     * @function
     * @returns {null}
     */
    this.destroy = function() {
        for (let i = _pool.length - 1; i >= 0; i--) if (_pool[i].destroy) _pool[i].destroy();
        return _pool = null;
    };
});
/**
 * @name Gate
 *
 * @constructor
 */


Class(function Gate() {
    var _this = this;

    var _list = [];
    var _map = {};

    //*** Event handlers

    //*** Public methods
    /**
     * @name this.create
     * @memberof Gate
     *
     * @function
     * @param name
    */
    this.create = function(name) {
        let promise = Promise.create();
        if (name) _map[name] = promise;
        else _list.push(promise);
    }

    /**
     * @name this.open
     * @memberof Gate
     *
     * @function
     * @param name
    */
    this.open = function(name) {
        if (name) {
            if (!_map[name]) _map[name] = Promise.create();
            _map[name].resolve();
        }

        let promise = _list.shift();
        if (promise) promise.resolve();
    }

    /**
     * @name this.wait
     * @memberof Gate
     *
     * @function
     * @param name
    */
    this.wait = function(name) {
        if (!_list.length && !name) return Promise.resolve();

        if (name) {
            if (!_map[name]) _map[name] = Promise.create();
            return _map[name];
        }

        return _list[_list.length-1] || Promise.resolve();
    }
}, 'static');
/**
 * @name Assets
 */

Class(function Assets() {
    const _this = this;
    const _fetchCors = {mode: 'cors'};

    this.__loaded = [];

    /**
     * Flip bitmap images when decoding.
     * @name Assets.FLIPY
     * @memberof Assets
     * @example
     * Assets.FLIPY = false // do not flip when decoding
     */
    this.FLIPY = true;

    /**
     * Path for Content Distribution Network (eg. Amazon bucket)
     * @name Assets.CDN
     * @memberof Assets
     * @example
     * Assets.CDN = '//amazonbucket.com/project/';
     */
    this.CDN = '';

    /**
     * Cross Origin string to apply to images
     * @name Assets.CORS
     * @memberof Assets
     * @example
     * Assets.CORS = '';
     */
    this.CORS = 'anonymous';

    /**
     * Storage for all images loaded for easy access
     * @name Assets.IMAGES
     * @memberof Assets
     */
    this.IMAGES = {};

    /**
     * Storage for all videos loaded for easy access
     * @name Assets.VIDEOS
     * @memberof Assets
     */
    this.VIDEOS = {};

    /**
     * Storage for all audios loaded for easy access
     * @name Assets.AUDIOS
     * @memberof Assets
     */
    this.AUDIOS = {};

    /**
     * Storage for all sdf font files loaded for easy access
     * @name Assets.SDF
     * @memberof Assets
     */
    this.SDF = {};

    /**
     * Storage for all JSON files loaded for easy access. Always clones object when retrieved.
     * @name Assets.JSON
     * @memberof Assets
     */
    this.JSON = {
        push: function(prop, value) {
            this[prop] = value;
            Object.defineProperty(this, prop, {
                get: () => {return JSON.parse(JSON.stringify(value))},
            });
        }
    };

    Object.defineProperty(this.JSON, 'push', {
        enumerable: false,
        writable: true
    });

    /**
     * Storage for all SVG files loaded for easy access
     * @name Assets.SVG
     * @memberof Assets
     */
    this.SVG = {};

    /**
     * Returns pixel-ratio-appropriate version if exists
     * @private
     * @param path
     * @returns {String}
     */
    function parseResolution(path) {
        if (!window.ASSETS || !ASSETS.RES) return path;
        var res = ASSETS.RES[path];
        var ratio = Math.min(Device.pixelRatio, 3);
        if (!res) return path;
        if (!res['x' + ratio]) return path;
        var split = path.split('/');
        var file = split[split.length-1];
        split = file.split('.');
        return path.replace(file, split[0] + '-' + ratio + 'x.' + split[1]);
    }

    /**
     * Array extension for manipulating list of assets
     * @private
     * @param {Array} arr
     * @returns {AssetList}
     * @constructor
     */
    function AssetList(arr) {
        arr.__proto__ = AssetList.prototype;
        return arr;
    }
    AssetList.prototype = new Array;

    /**
     * Filter asset list to only include those matching the arguments
     * @param {String|String[]} items
     */
    AssetList.prototype.filter = function(items) {
        for (let i = this.length - 1; i >= 0; i--) if (!this[i].includes(items)) this.splice(i, 1);
        return this;
    };

    /**
     * Filter asset list to exclude those matching the arguments
     * @param {String|String[]} items
     */
    AssetList.prototype.exclude = function(items) {
        for (let i = this.length - 1; i >= 0; i--) if (this[i].includes(items)) this.splice(i, 1);
        return this;
    };

    AssetList.prototype.prepend = function(prefix) {
        for (let i = this.length - 1; i >= 0; i--) this[i] = prefix + this[i];
        return this;
    };

    AssetList.prototype.append = function(suffix) {
        for (let i = this.length - 1; i >= 0; i--) this[i] = this[i] + suffix;
        return this;
    };

    /**
     * Get compiled list of assets
     * @name Assets.list
     * @memberof Assets
     *
     * @function
     * @returns {AssetList}
     * @example
     * const assets = Assets.list();
     * assets.filter(['images', 'geometry']);
     * assets.exclude('mobile');
     * assets.append('?' + Utils.timestamp());
     * const loader = _this.initClass(AssetLoader, assets);
     */
    this.list = function() {
        if (!window.ASSETS) console.warn(`ASSETS list not available`);
        return new AssetList(window.ASSETS.slice(0) || []);
    };

    /**
     * Wrap path in CDN and get correct resolution file
     * @name Assets.getPath
     * @memberof Assets
     *
     * @function
     * @param {String} path
     * @returns {String}
     */

    this.BASE_PATH = '';

    this.getPath = function(path) {

        if (path.includes('~')) return _this.BASE_PATH + path.replace('~', '');

        // If static url, return untouched
        if (path.includes('//')) return path;

        // Check if should offer different DPR version
        path = parseResolution(path);

        if (_this.dictionary) {
            for (let pathKey in _this.dictionary) {
                if (_this.dictionary[pathKey].includes(path.split('?')[0])) return pathKey + path;
            }
        }

        // Wrap in CDN
        if (this.CDN && !~path.indexOf(this.CDN)) path = this.CDN + path;

        return path;
    };

    this.registerPath = function(path, assets) {
        if (!_this.dictionary) _this.dictionary = {};
        _this.dictionary[path] = assets;
    };

    /**
     * Load image, adding CDN and CORS state and optionally storing in memory
     * @name Assets.loadImage
     * @memberof Assets
     *
     * @function
     * @param {String} path - path of asset
     * @param {Boolean} [isStore] - True if to store in memory under Assets.IMAGES
     * @returns {Image}
     * @example
     * Assets.loadImage('assets/images/cube.jpg', true);
     * console.log(Assets.IMAGES['assets/images/cube.jpg']);
     */
    this.loadImage = function(path, isStore) {
        var img = new Image();
        img.crossOrigin = this.CORS;
        img.src = _this.getPath(path);

        img.loadPromise = function() {
            let promise = Promise.create();
            img.onload = promise.resolve;
            return promise;
        };

        if (isStore) this.IMAGES[path] = img;

        return img;
    };

    /**
     * Load and decode an image off the main thread
     * @name Assets.decodeImage
     * @memberof Assets
     *
     * @function
     * @param {String} path - path of asset
     * @param {Boolean} [flipY=Assets.FLIPY] - overwrite global flipY option
     * @returns {Promise}
     * @example
     * Assets.decodeImage('assets/images/cube.jpg').then(imgBmp => {});
     */
    this.decodeImage = function(path, params, promise) {
        if ( !promise ) promise = Promise.create();
        let img = _this.loadImage(path);
        img.onload = () => promise.resolve(img);
        img.onerror = () => _this.decodeImage('assets/images/_scenelayout/uv.jpg', params, promise);
        return promise;
    };

}, 'static');
/**
 * @name AssetLoader
 * @example
 * const assets = Assets.list()l
 * const loader = new AssetLoader(assets);
 * _this.events.sub(loader, Events.COMPLETE, complete);
 */

Class(function AssetLoader(_assets, _callback, ASSETS = Assets) {
    Inherit(this, Events);
    const _this = this;

    let _total = _assets.length;
    let _loaded = 0;
    let _lastFiredPercent = 0;

    (function() {
        if (!Array.isArray(_assets)) throw `AssetLoader requires array of assets to load`;
        _assets = _assets.slice(0).reverse();

        init();
    })();

    function init() {
        if (!_assets.length) return complete();
        for (let i = 0; i < AssetLoader.SPLIT; i++) {
            if (_assets.length) loadAsset();
        }
    }

    function loadAsset() {
        let path = _assets.splice(_assets.length - 1, 1)[0];

        const name = path.split('assets/').last().split('.')[0];
        const ext = path.split('.').last().split('?')[0].toLowerCase();

        let timeout = Timer.create(timedOut, AssetLoader.TIMEOUT, path);

        // Check if asset previously loaded
        if (!Assets.preventCache && !!~Assets.__loaded.indexOf(path)) return loaded();

        // If image, don't use fetch api
        if (ext.includes(['jpg', 'jpeg', 'png', 'gif'])) {
            let image = ASSETS.loadImage(path);
            if (image.complete) return loaded();
            image.onload = loaded;
            image.onerror = loaded;
            return;
        }

        // If video, do manual request and create blob
        if (ext.includes(['mp4', 'webm'])) {
            fetch(path).then(async response => {
                let blob = await response.blob();
                Assets.VIDEOS[name] = URL.createObjectURL(blob);
                loaded();
            }).catch(e => {
                console.warn(e);
                loaded();
            });
            return;
        }

        // If audio, do manual request and create blob
        if (ext.includes(['mp3'])) {
            fetch(path).then(async response => {
                let blob = await response.blob();
                Assets.AUDIOS[name] = URL.createObjectURL(blob);
                loaded();
            }).catch(e => {
                console.warn(e);
                loaded();
            });
            return;
        }

        get(Assets.getPath(path), Assets.HEADERS).then(data => {
            Assets.__loaded.push(path);
            if (ext == 'json') ASSETS.JSON.push(name, data);
            if (ext == 'svg') ASSETS.SVG[name] = data;
            if (ext == 'fnt') ASSETS.SDF[name.split('/')[1]] = data;
            if (ext == 'js') window.eval(data);
            if (ext.includes(['fs', 'vs', 'glsl']) && window.Shaders) Shaders.parse(data, path);
            loaded();
        }).catch(e => {
            console.warn(e);
            loaded();
        });

        function loaded() {
            if (timeout) clearTimeout(timeout);
            increment();
            if (_assets.length) loadAsset();
        }
    }

    function increment() {
        let percent = Math.max(_lastFiredPercent, Math.min(1, ++_loaded / _total));
        _this.events.fire(Events.PROGRESS, {percent});
        _lastFiredPercent = percent;

        // Defer to get out of promise error catching
        if (_loaded >= _total) defer(complete);
    }

    function complete() {
        if (_this.completed) return;
        _this.completed = true;

        // Defer again to allow any code waiting for loaded libs to run first
        defer(() => {
            _callback && _callback();
            _this.events.fire(Events.COMPLETE);
        });
    }

    function timedOut(path) {
        console.warn('Asset timed out', path);
    }

    this.loadModules = function() {
        if (!window._BUILT_) return;
        this.add(1);
        let module = window._ES5_ ? 'es5-modules' : 'modules';
        let s = document.createElement('script');
        s.src = 'assets/js/'+module+'.js?' + window._CACHE_;
        s.async = true;
        document.head.appendChild(s);
        return AssetLoader.waitForLib('_MODULES_').then(_ => _this.trigger(1));
    }

    /**
     * Increment total tasks for loader. Will need to manually trigger same amount for loader to complete.
     * @name add
     * @memberof AssetLoader
     *
     * @function
     * @param {Number} num
     * @example
     * const loader = new AssetLoader(assets);
     * loader.add(1);
     * _this.delayedCall(loader.trigger, 1000, 1);
     */
    this.add = function(num) {
        _total += num || 1;
    };

    /**
     * Increment number of loaded tasks.
     * @name trigger
     * @memberof AssetLoader
     *
     * @function
     * @param {Number} num
     */
    this.trigger = function(num) {
        for (let i = 0; i < (num || 1); i++) increment();
    };

}, () => {

    /**
     * Define number of batches to split up AssetLoader. Loader waits until each batch completes before starting next.
     * @name AssetLoader.SPLIT
     * @memberof AssetLoader
     */
    AssetLoader.SPLIT = 2;

    /**
     * Define length of asset timeout
     * @name AssetLoader.TIMEOUT
     * @memberof AssetLoader
     */
    AssetLoader.TIMEOUT = 5000;

    /**
     * Util to wrap AssetLoader in a promise and load all files.
     * @name AssetLoader.loadAllAssets
     * @memberof AssetLoader
     *
     * @function
     * @param {Function} callback
     * @returns {Promise}
     */
    AssetLoader.loadAllAssets = function(callback) {
        let promise = Promise.create();
        if (!callback) callback = promise.resolve;

        promise.loader = new AssetLoader(Assets.list(), () => {
            if (callback) callback();
            if (promise.loader && promise.loader.destroy) promise.loader = promise.loader.destroy();
        });

        return promise;
    };

    /**
     * Util to wrap AssetLoader in a promise and load a list of files.
     * @name AssetLoader.loadAssets
     * @memberof AssetLoader
     *
     * @function
     * @param {Array} list
     * @param {Function} callback
     * @returns {Promise}
     */
    AssetLoader.loadAssets = function(list, callback) {
        let promise = Promise.create();
        if (!callback) callback = promise.resolve;

        promise.loader = new AssetLoader(list, () => {
            if (callback) callback();
            if (promise.loader && promise.loader.destroy) promise.loader = promise.loader.destroy();
        });

        return promise;
    };

    /**
     * Wait for global variable to be available
     * @name AssetLoader.waitForLib
     * @memberof AssetLoader
     *
     * @function
     * @param {String} name
     * @param {Function} [callback]
     * @returns {Promise}
     */
    AssetLoader.waitForLib = function(name, callback) {
        let promise = Promise.create();
        if (!callback) callback = promise.resolve;

        Render.start(check);
        function check() {
            if (window[name]) {
                Render.stop(check);
                callback && callback();
            }
        }

        return promise;
    };

    AssetLoader.waitForModules = function() {
        return AssetLoader.waitForLib(window._BUILT_ ? '_MODULES_' : 'zUtils3D');
    }
});
/**
 * @name Stage
 */

Hydra.ready(function() {
    //*** Set global shortcut to window, document, and body.

    /**
     * A HydraObject wrapper of the window object
     * @name window.__window
     * @memberof Stage
     */
    window.__window = $(window);

    /**
     * A HydraObject wrapper of the window object
     * @name window.__document
     * @memberof Stage
     */
    window.__document = $(document);

    /**
     * A HydraObject wrapper of the document.body element
     * @name window.__body
     * @memberof Stage
     */
    window.__body = $(document.getElementsByTagName('body')[0]);

    /**
     * A HydraObject wrapper of the main #Stage div element. Size of application to be retrieved from this object via Stage.width and Stage.height.
     * @name window.Stage
     * @memberof Stage
     */
    window.Stage = !!window.Stage && !!window.Stage.style ? $(window.Stage) : __body.create('#Stage');

    Stage.size('100%');
    Stage.__useFragment = true;
    Stage.width = window.innerWidth || document.body.clientWidth || document.documentElement.offsetWidth;
    Stage.height = window.innerHeight || document.body.clientHeight || document.documentElement.offsetHeight;
});
/**
 * @name HydraCSS
 */

Class(function HydraCSS() {
    var _this = this;
    var _obj, _style, _needsUpdate;

    //*** Constructor
    Hydra.ready(function() {
        _style = '';
        _obj = document.createElement('style');
        _obj.type = 'text/css';
        document.getElementsByTagName('head')[0].appendChild(_obj);
    });

    function objToCSS(key) {
        var match = key.match(/[A-Z]/);
        var camelIndex = match ? match.index : null;
        if (camelIndex) {
            var start = key.slice(0, camelIndex);
            var end = key.slice(camelIndex);
            key = start+'-'+end.toLowerCase();
        }
        return key;
    }

    function cssToObj(key) {
        var match = key.match(/\-/);
        var camelIndex = match ? match.index : null;
        if (camelIndex) {
            var start = key.slice(0, camelIndex);
            var end = key.slice(camelIndex).slice(1);
            var letter = end.charAt(0);
            end = end.slice(1);
            end = letter.toUpperCase() + end;
            key = start + end;
        }
        return key;
    }

    function setHTML() {
        _obj.innerHTML = _style;
        _needsUpdate = false;
    }

    this._read = function() {
        return _style;
    };

    this._write = function(css) {
        _style = css;
        if (!_needsUpdate) {
            _needsUpdate = true;
            defer(setHTML);
        }
    };

    /**
     * @name HydraCSS.style
     * @memberof HydraCSS
     *
     * @function
     * @param {String} selector
     * @param {Object} obj
     */
    this.style = function(selector, obj) {
        var s = selector + ' {';
        for (var key in obj) {
            var prop = objToCSS(key);
            var val = obj[key];
            if (typeof val !== 'string' && key != 'opacity') val += 'px';
            s += prop+':'+val+'!important;';
        }
        s += '}';
        _this._write(_style + s);
    };

    /**
     * @name HydraCSS.get
     * @memberof HydraCSS
     *
     * @function
     * @param {String} selector
     * @param {String} prop
     * @returns {*}
     */
    this.get = function(selector, prop) {
        var values = new Object();
        var string = _obj.innerHTML.split(selector+' {');
        for (var i = 0; i < string.length; i++) {
            var str = string[i];
            if (!str.length) continue;
            var split = str.split('!important;');
            for (var j in split) {
                if (split[j].includes(':')) {
                    var fsplit = split[j].split(':');
                    if (fsplit[1].slice(-2) == 'px') {
                        fsplit[1] = Number(fsplit[1].slice(0, -2));
                    }
                    values[cssToObj(fsplit[0])] = fsplit[1];
                }
            }
        }

        if (!prop) return values;
        else return values[prop];
    };

    /**
     * @name HydraCSS.textSize
     * @memberof HydraCSS
     *
     * @function
     * @param {HydraObject} $obj
     * @returns {Object} Object with width and height properties
     */
	this.textSize = function($obj) {
	    var $clone = $obj.clone();
	    $clone.css({position: 'relative', cssFloat: 'left', styleFloat: 'left', marginTop: -99999, width: '', height: ''});
	    __body.addChild($clone);

	    var width = $clone.div.offsetWidth;
	    var height = $clone.div.offsetHeight;

	    $clone.remove();
	    return {width: width, height: height};
	};

    /**
     * @name HydraCSS.prefix
     * @memberof HydraCSS
     *
     * @function
     * @param {String} style
     * @returns {String}
     */
	this.prefix = function(style) {
        return _this.styles.vendor == '' ? style.charAt(0).toLowerCase() + style.slice(1) : _this.styles.vendor + style;
    };

    this._toCSS = objToCSS;

}, 'Static');
/**
 * @name HydraObject
 *
 * @constructor
 */

Class(function HydraObject(_selector, _type, _exists, _useFragment) {

	this._children = new LinkedList();
	this.__useFragment = _useFragment;
	this._initSelector(_selector, _type, _exists);

}, () => {
	var prototype = HydraObject.prototype;

	// Constructor function
	prototype._initSelector = function(_selector, _type, _exists) {
		if (_selector && typeof _selector !== 'string') {
			this.div = _selector;
		} else {
			var first = _selector ? _selector.charAt(0) : null;
			var name = _selector ? _selector.slice(1) : null;

			if (first != '.' && first != '#') {
				name = _selector;
				first = '.';
			}

			if (!_exists) {
				this._type = _type || 'div';
				if (this._type == 'svg') {
					this.div = document.createElementNS('http://www.w3.org/2000/svg', this._type);
					this.div.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
				} else {
					this.div = document.createElement(this._type);
					if (first) {
						if (first == '#') this.div.id = name;
						else this.div.className = name;
					}
				}
			} else {
				if (first != '#') throw 'Hydra Selectors Require #ID';
				this.div = document.getElementById(name);
			}
		}

		this.div.hydraObject = this;
	};

	/**
	 * @name this.add
	 * @memberof HydraObject
	 *
	 * @function
     * @params {HydraObject} child
     * @returns {Self}
     */
	prototype.add = function(child) {
		var div = this.div;

        var _this = this;
		var createFrag = function() {
			if (_this.__useFragment) {
				if (!_this._fragment) {
					_this._fragment = document.createDocumentFragment();

					defer(function () {
						if (!_this._fragment || !_this.div) return _this._fragment = null;
						_this.div.appendChild(_this._fragment);
						_this._fragment = null;
					})
				}
				div = _this._fragment;
			}
		};

        if (child.element && child.element instanceof HydraObject) {
            createFrag();
            div.appendChild(child.element.div);
            this._children.push(child.element);
            child.element._parent = this;
            child.element.div.parentNode = this.div;
        } else if (child.div) {
			createFrag();
			div.appendChild(child.div);
			this._children.push(child);
			child._parent = this;
			child.div.parentNode = this.div;
		} else if (child.nodeName) {
			createFrag();
			div.appendChild(child);
			child.parentNode = this.div;
		}

		return this;
	};

    /**
     * @name this.clone
	 * @memberof HydraObject
	 *
	 * @function
     * @returns {HydraObject}
     */
	prototype.clone = function() {
		return $(this.div.cloneNode(true));
	};

    /**
     * @name this.create
	 * @memberof HydraObject
	 *
	 * @function
     * @param {String} name
     * @param {String} [type='div']
     * @returns {HydraObject}
     */
	prototype.create = function(name, type) {
		var $obj = $(name, type);
		this.add($obj);
		return $obj;
	};

    /**
     * @name this.empty
	 * @memberof HydraObject
	 *
	 * @function
     * @returns {Self}
     */
	prototype.empty = function() {
		var child = this._children.start();
		while (child) {
			if (child && child.remove) child.remove();
			child = this._children.next();
		}

		this.div.innerHTML = '';
		return this;
	};

    /**
     * @name this.parent
	 * @memberof HydraObject
	 *
	 * @function
     * @returns {HydraObject}
     */
	prototype.parent = function() {
		return this._parent;
	};

    /**
     * @name this.children
	 * @memberof HydraObject
	 *
	 * @function
     * @returns {DocumentNode[]}
     */
	prototype.children = function(isHydraChildren = false) {
		let children = this.div.children ? this.div.children : this.div.childNodes;

		if (isHydraChildren) {
			children = [];

			var child = this._children.start();

			while (child) {
				if (child) {
					children.push(child);
					child = this._children.next();
				}
			}
		}

		return children;
	};

    /**
     * @name this.removeChild
	 * @memberof HydraObject
	 *
	 * @function
     * @param {HydraObject} object
     * @param {Boolean} [keep]
     * @returns {HydraObject}
     */
	prototype.removeChild = function(object, keep) {
		try {object.div.parentNode.removeChild(object.div)} catch(e) {};
		if (!keep) this._children.remove(object);
	};

    /**
	 * Removes self from parent
	 * @memberof HydraObject
	 *
	 * @function
     * @name this.remove
     */
	prototype.remove = function(param) {
		if (param) console.warn('HydraObject.remove removes ITSELF from its parent. use removeChild instead');

		this.removed = true;

		var parent = this._parent;
		if (!!(parent && !parent.removed && parent.removeChild)) parent.removeChild(this, true);

		var child = this._children.start();
		while (child) {
			if (child && child.remove) child.remove();
			child = this._children.next();
		}
		this._children.destroy();

		this.div.hydraObject = null;
		Utils.nullObject(this);
	};

	prototype.destroy = function() {
		this.remove();
	}

    /**
     * @name window.$
	 * @memberof HydraObject
	 *
	 * @function
     * @param {String} selector - dom element class name
     * @param {String} [type='div']
     * @param {Boolean} [exists] - will search document tree if true, else creates new dom element
     * @returns {HydraObject}
     */
	window.$ = function(selector, type, exists) {
		return new HydraObject(selector, type, exists);
	};

    /**
     * @name window.$.fn
	 * @memberof HydraObject
	 *
     * @param {String} name
     * @param {String} [type='div']
     * @returns {HydraObject}
     */
	$.fn = HydraObject.prototype;
});

/**
 * @name Extensions
 */

/*
* TODO: write documentation comments
* */

(function() {

    /**
     * @name $.fn.text
     * @memberof Extensions
     *
     * @function
     * @param {String} text
     * @returns {Self}
     */
    $.fn.text = function(text) {
        if (typeof text !== 'undefined') {
            if (this.__cacheText != text) this.div.textContent = text;
            this.__cacheText = text;
            return this;
        } else {
            return this.div.textContent;
        }
    };

    /**
     * @name $.fn.html
     * @memberof Extensions
     *
     * @function
     * @param {String} text
     * @param {Boolean} [force]
     * @returns {Self}
     */
    $.fn.html = function(text, force) {
        if (text && !text.includes('<') && !force) return this.text(text);

        if (typeof text !== 'undefined') {
            this.div.innerHTML = text;
            return this;
        } else {
            return this.div.innerHTML;
        }
    };

    /**
     * @name $.fn.hide
     * @memberof Extensions
     *
     * @function
     * @returns {Self}
     */
    $.fn.hide = function() {
        this.div.style.display = 'none';
        return this;
    };

    /**
     * @name $.fn.show
     * @memberof Extensions
     *
     * @function
     * @returns {Self}
     */
    $.fn.show = function() {
        this.div.style.display = '';
        return this;
    };

    /**
     * @name $.fn.visible
     * @memberof Extensions
     *
     * @function
     * @returns {Self}
     */
    $.fn.visible = function() {
        this.div.style.visibility = 'visible';
        return this;
    };

    /**
     * @name $.fn.invisible
     * @memberof Extensions
     *
     * @function
     * @returns {Self}
     */
    $.fn.invisible = function() {
        this.div.style.visibility = 'hidden';
        return this;
    };

    /**
     * @name $.fn.setZ
     * @memberof Extensions
     *
     * @function
     * @param {Integer} z
     * @returns {Self}
     */
    $.fn.setZ = function(z) {
        this.div.style.zIndex = z;
        return this;
    };

    /**
     * @name $.fn.clearAlpha
     * @memberof Extensions
     *
     * @function
     * @returns {Self}
     */
    $.fn.clearAlpha = function() {
        this.div.style.opacity = '';
        return this;
    };

    /**
     * @name $.fn.size
     * @memberof Extensions
     *
     * @function
     * @param {Number|String} w
     * @param {Number|String} h
     * @param {Boolean} [noScale] - Set true to prevent bacground size being set
     * @returns {Self}
     */
    $.fn.size = function(w, h, noScale) {
        if (typeof w === 'string') {
            if (typeof h === 'undefined') h = '100%';
            else if (typeof h !== 'string') h = h+'px';
            this.div.style.width = w;
            this.div.style.height = h;
        } else {
            this.div.style.width = w+'px';
            this.div.style.height = h+'px';
            if (!noScale) this.div.style.backgroundSize = w+'px '+h+'px';
        }

        this.width = w;
        this.height = h;

        return this;
    };

    /**
     * @name $.fn.mouseEnabled
     * @memberof Extensions
     *
     * @function
     * @param {Boolean} bool
     * @returns {Self}
     */
    $.fn.mouseEnabled = function(bool) {
        this.div.style.pointerEvents = bool ? 'auto' : 'none';
        return this;
    };

    /**
     * @name $.fn.fontStyle
     * @memberof Extensions
     *
     * @function
     * @param {String} [family]
     * @param {String} [size]
     * @param {String} [color]
     * @param {String} [style]
     * @returns {Self}
     */
    $.fn.fontStyle = function(family, size, color, style) {
        var font = {};
        if (family) font.fontFamily = family;
        if (size) font.fontSize = size;
        if (color) font.color = color;
        if (style) font.fontStyle = style;
        this.css(font);
        return this;
    };

    /**
     * @name $.fn.font
     * @memberof Extensions
     *
     * @function
     * @param {String} [font]
     * @returns {Self}
     */
    $.fn.font = function(font) {
        this.css('font', font);
        return this;
    }

    /**
     * @name $.fn.bg
     * @memberof Extensions
     *
     * @function
     * @param {String} src
     * @param {Number|String} x
     * @param {Number|String} y
     * @param {Boolean} repeat
     * @returns {Self}
     */
    $.fn.bg = function(src, x, y, repeat) {
        if (!src) return this;

        if (src.includes('.')) src = Assets.getPath(src);

        if (!src.includes('.')) this.div.style.backgroundColor = src;
        else this.div.style.backgroundImage = 'url('+src+')';

        if (typeof x !== 'undefined') {
            x = typeof x == 'number' ? x+'px' : x;
            y = typeof y == 'number' ? y+'px' : y;
            this.div.style.backgroundPosition = x+' '+y;
        }

        if (repeat) {
            this.div.style.backgroundSize = '';
            this.div.style.backgroundRepeat = repeat;
        }

        if (x == 'cover' || x == 'contain') {
            this.div.style.backgroundSize = x;
            this.div.style.backgroundPosition = typeof y != 'undefined' ? y +' ' +repeat : 'center';
        }

        return this;
    };

    /**
     * @name $.fn.center
     * @memberof Extensions
     *
     * @function
     * @param {Boolean} [x]
     * @param {Boolean} [y]
     * @param {Boolean} [noPos]
     * @returns {Self}
     */
    $.fn.center = function(x, y, noPos) {
        var css = {};
        if (typeof x === 'undefined') {
            css.left = '50%';
            css.top = '50%';
            css.marginLeft = -this.width/2;
            css.marginTop = -this.height/2;
        } else {
            if (x) {
                css.left = '50%';
                css.marginLeft = -this.width/2;
            }
            if (y) {
                css.top = '50%';
                css.marginTop = -this.height/2;
            }
        }

        if (noPos) {
            delete css.left;
            delete css.top;
        }

        this.css(css);
        return this;
    };

    /**
     * @name $.fn.max
     * @memberof Extensions
     *
     * @function
     * @param {Number} [width]
     * @param {Number} [height]
     * @returns {Self}
     */
    $.fn.max = function(width, height) {
        let w, h;
        if (typeof width !== 'undefined') {
            w = typeof width == 'number' ? width+'px' : width;
            this.div.style.maxWidth = w;
        }

        if (typeof height !== 'undefined') {
            h = typeof height == 'number' ? height+'px' : height;
            this.div.style.maxHeight = h;
        } else {
            h = w;
            this.div.style.maxHeight = h;
        }

        return this;
    }

    /**
     * @name $.fn.min
     * @memberof Extensions
     *
     * @function
     * @param {Number} [width]
     * @param {Number} [height]
     * @returns {Self}
     */
    $.fn.min = function(width, height) {
        let w, h;
        if (typeof width !== 'undefined') {
            w = typeof width == 'number' ? width+'px' : width;
            this.div.style.minWidth = w;
        }

        if (typeof height !== 'undefined') {
            h = typeof height == 'number' ? height+'px' : height;
            this.div.style.minHeight = h;
        } else {
            h = w;
            this.div.style.minHeight = h;
        }

        return this;
    }

    /**
     * @name $.fn.flex
     * @memberof Extensions
     *
     * @function
     * @param {Boolean} [inline]
     * @returns {Self}
     */
      $.fn.flex = function(inline) {
        // if parent is not flex, set a default flex on it
        // if (!this.parent) return;
        // let parentEl = this.parent();
        // parentEl.div.style['display'] = 'flex';
        this.div.style.display = inline ? 'inline-flex' : 'flex';
        this.div.style.justifyContent = 'center';
        this.div.style.alignItems = 'center';

        this.div.classList.add('relative-children');

        return this;
    };

    /**
     * @name $.fn.order
     * @memberof Extensions
     *
     * @function
     * @param {Object} [options]
     * @returns {Self}
     */
    $.fn.order = function(opts={}) {
        let s = this.div.style;

        if (opts.flexWrap === 'none') opts.flexWrap = 'nowrap';

        if (opts.direction) s.flexDirection = opts.direction;
        if (opts.wrap) s.flexWrap = opts.wrap;
        if (opts.order) s.order = opts.order;

        return this;
    }

    /**
     * @name $.fn.align
     * @memberof Extensions
     *
     * @function
     * @param {Object} [options]
     * @returns {Self}
     */
    $.fn.align = function(opts={}) {
        let s = this.div.style;

        function flex(str, contentMode = false) {
            if (str === 'start') return 'flex-start';
            if (str === 'end') return 'flex-end';
            if (str === 'between') return contentMode ? 'space-between' : 'flex-between';
            if (str === 'around') return contentMode ? 'space-around' : 'flex-around';
            if (str === 'none') return 'nowrap';
            return str;
        }

        if (opts.justify) s.justifyContent = flex(opts.justify);
        if (opts.items) s.alignItems = flex(opts.items);
        if (opts.self) s.alignSelf = flex(opts.self);
        if (opts.content) s.alignContent = flex(opts.content, true);

        return this;
    }

    /**
     * @name $.fn.flexibility
     * @memberof Extensions
     *
     * @function
     * @param {Object} [options]
     * @returns {Self}
     */
    $.fn.flexibility = function(opts={}) {
        let s = this.div.style;

        if (opts.grow !== 'undefined') s.flexGrow = opts.grow;
        if (opts.shrink !== 'undefined') s.flexGrow = opts.shrink;

        if (typeof opts.basis !== 'undefined') {
            s.flexBasis = typeof opts.basis == 'number' ? opts.basis+'px' : opts.basis;
        }

        return this;
    }

    /**
     * @name $.fn.mask
     * @memberof Extensions
     *
     * @function
     * @param {String} arg
     * @returns {Self}
     */
    $.fn.mask = function(arg) {
        let maskPrefix = HydraCSS.styles.vendor === 'Moz' ? 'mask' : HydraCSS.prefix('Mask');
        this.div.style[maskPrefix] = (arg.includes('.') ? 'url('+arg+')' : arg) + ' no-repeat';
        this.div.style[maskPrefix+'Size'] = 'contain';
        return this;
    };

    /**
     * @name $.fn.blendMode
     * @memberof Extensions
     *
     * @function
     * @param {String} mode
     * @param {Boolean} [bg]
     * @returns {Self}
     */
    $.fn.blendMode = function(mode, bg) {
        if (bg) {
            this.div.style['background-blend-mode'] = mode;
        } else {
            this.div.style['mix-blend-mode'] = mode;
        }

        return this;
    };

    /**
     * @name $.fn.css
     * @memberof Extensions
     *
     * @function
     * @param {Object|String} obj
     * @param {*} [value]
     * @returns {Self}
     */
    $.fn.css = function(obj, value) {
        if (typeof value == 'boolean') {
            value = null;
        }

        if (typeof obj !== 'object') {
            if (!value) {
                var style = this.div.style[obj];
                if (typeof style !== 'number') {
                    if (!style) return false;
                    if (style.includes('px')) style = Number(style.slice(0, -2));
                    if (obj == 'opacity') style = !isNaN(Number(this.div.style.opacity)) ? Number(this.div.style.opacity) : 1;
                }
                if (!style) style = 0;
                return style;
            } else {
                this.div.style[obj] = value;
                return this;
            }
        }

        TweenManager._clearCSSTween(this);

        for (var type in obj) {
            var val = obj[type];
            if (!(typeof val === 'string' || typeof val === 'number')) continue;
            if (typeof val !== 'string' && type != 'opacity' && type != 'zIndex') val += 'px';
            if (type == 'position' && val == 'sticky' && Device.system.browser == 'safari') val = '-webkit-sticky';
            this.div.style[type] = val;
        }

        return this;
    };

    /**
     * @name $.fn.transform
     * @memberof Extensions
     *
     * @function
     * @param {Object} props
     * @returns {Self}
     */
    $.fn.transform = function(props) {
        TweenManager._clearCSSTween(this);

        if (Device.tween.css2d) {
            if (!props) {
                props = this;
            } else {
                for (var key in props) {
                    if (typeof props[key] === 'number' || typeof props[key] === 'string') this[key] = props[key];
                }
            }

            var transformString =TweenManager._parseTransform(props);

            if (this.__transformCache != transformString) {
                this.div.style[HydraCSS.styles.vendorTransform] = transformString;
                this.__transformCache = transformString;
            }
        }

        return this;
    };

    /**
     * @name $.fn.willChange
     * @memberof Extensions
     *
     * @function
     * @param {Boolean} [props]
     */
    $.fn.willChange = function(props) {
        if (typeof props === 'boolean') {
            if (props === true) this._willChangeLock = true;
            else this._willChangeLock = false;
        } else {
            if (this._willChangeLock) return;
        }

        var string = typeof props === 'string';
        if ((!this._willChange || string) && typeof props !== 'null') {
            this._willChange = true;
            this.div.style['will-change'] = string ? props : HydraCSS.transformProperty+', opacity';
        } else {
            this._willChange = false;
            this.div.style['will-change'] = '';
        }
    };

    /**
     * @name $.fn.backfaceVisibility
     * @memberof Extensions
     *
     * @function
     * @param {Boolean} visible
     */
    $.fn.backfaceVisibility = function(visible) {
        if (visible) this.div.style[HydraCSS.prefix('BackfaceVisibility')] = 'visible';
        else this.div.style[HydraCSS.prefix('BackfaceVisibility')] = 'hidden';
    };

    /**
     * @name $.fn.enable3D
     * @memberof Extensions
     *
     * @function
     * @param {Number} perspective
     * @param {Number|String} x
     * @param {Number|String} y
     * @returns {Self}
     */
    $.fn.enable3D = function(perspective, x, y) {
        if (!Device.tween.css3d) return this;
        this.div.style[HydraCSS.prefix('TransformStyle')] = 'preserve-3d';
        if (perspective) this.div.style[HydraCSS.prefix('Perspective')] = perspective + 'px';
        if (typeof x !== 'undefined') {
            x = typeof x === 'number' ? x + 'px' : x;
            y = typeof y === 'number' ? y + 'px' : y;
            this.div.style[HydraCSS.prefix('PerspectiveOrigin')] = x+' '+y;
        }
        return this;
    };

    /**
     * @name $.fn.disable3D
     * @memberof Extensions
     *
     * @function
     * @returns {Self}
     */
    $.fn.disable3D = function() {
        this.div.style[HydraCSS.prefix('TransformStyle')] = '';
        this.div.style[HydraCSS.prefix('Perspective')] = '';
        return this;
    };

    /**
     * @name $.fn.transformPoint
     * @memberof Extensions
     *
     * @function
     * @param {Number|String} x
     * @param {Number|String} y
     * @param {Number|String} z
     * @returns {Self}
     */
    $.fn.transformPoint = function(x, y, z) {
        var origin = '';
        if (typeof x !== 'undefined') origin += (typeof x === 'number' ? x+'px ' : x+' ');
        if (typeof y !== 'undefined') origin += (typeof y === 'number' ? y+'px ' : y+' ');
        if (typeof z !== 'undefined') origin += (typeof z === 'number' ? z+'px' : z);
        this.div.style[HydraCSS.prefix('TransformOrigin')] = origin;
        return this;
    };

    /**
     * @name $.fn.tween
     * @memberof Extensions
     *
     * @function
     * @param {Object} props
     * @param {Number} time
     * @param {String} ease
     * @param {Number} [delay]
     * @param {Function} [callback]
     * @param {Boolean} [manual]
     * @returns {*}
     */
    $.fn.tween = function(props, time, ease, delay, callback, manual) {
        if (typeof delay === 'boolean') {
            manual = delay;
            delay = 0;
            callback = null;
        } else if (typeof delay === 'function') {
            callback = delay;
            delay = 0;
        }
        if (typeof callback === 'boolean') {
            manual = callback;
            callback = null;
        }
        if (!delay) delay = 0;

        var usePromise = null;
        if (callback && callback instanceof Promise) {
            usePromise = callback;
            callback = callback.resolve;
        }

        var tween = TweenManager._detectTween(this, props, time, ease, delay, callback, manual);
        return usePromise || tween;
    };

    /**
     * @name $.fn.clearTransform
     * @memberof Extensions
     *
     * @function
     * @returns {Self}
     */
    $.fn.clearTransform = function() {
        if (typeof this.x === 'number') this.x = 0;
        if (typeof this.y === 'number') this.y = 0;
        if (typeof this.z === 'number') this.z = 0;
        if (typeof this.scale === 'number') this.scale = 1;
        if (typeof this.scaleX === 'number')this.scaleX = 1;
        if (typeof this.scaleY === 'number') this.scaleY = 1;
        if (typeof this.rotation === 'number') this.rotation = 0;
        if (typeof this.rotationX === 'number') this.rotationX = 0;
        if (typeof this.rotationY === 'number') this.rotationY = 0;
        if (typeof this.rotationZ === 'number') this.rotationZ = 0;
        if (typeof this.skewX === 'number') this.skewX = 0;
        if (typeof this.skewY === 'number') this.skewY = 0;
        this.div.style[HydraCSS.styles.vendorTransform] = '';
        return this;
    };

    /**
     * @name $.fn.clearTween
     * @memberof Extensions
     *
     * @function
     * @returns {Self}
     */
    $.fn.clearTween = function() {
        if (this._cssTween) this._cssTween.stop();
        if (this._mathTween) this._mathTween.stop();
        return this;
    };

    $.fn.stopTween = function() {
        console.warn('.stopTween deprecated. use .clearTween instead');
        return this.clearTween();
    };

    /**
     * @name $.fn.keypress
     * @memberof Extensions
     *
     * @function
     * @param {Function} callback
     */
    $.fn.keypress = function(callback) {
        this.div.onkeypress = function(e) {
            e = e || window.event;
            e.code = e.keyCode ? e.keyCode : e.charCode;
            if (callback) callback(e);
        };
    };

    /**
     * @name $.fn.keydown
     * @memberof Extensions
     *
     * @function
     * @param {Function} callback
     */
    $.fn.keydown = function(callback) {
        this.div.onkeydown = function(e) {
            e = e || window.event;
            e.code = e.keyCode;
            if (callback) callback(e);
        };
    };

    /**
     * @name $.fn.keyup
     * @memberof Extensions
     *
     * @function
     * @param {Function} callback
     */
    $.fn.keyup = function(callback) {
        this.div.onkeyup = function(e) {
            e = e || window.event;
            e.code = e.keyCode;
            if (callback) callback(e);
        }
    };

    /**
     * @name $.fn.attr
     * @memberof Extensions
     *
     * @function
     * @param {String} attr
     * @param {String|Boolean} value
     * @returns {Self}
     */
    $.fn.attr = function(attr, value) {
        if (typeof attr !== 'string') return this;
        if (value === undefined) return this.div.getAttribute(attr);

        if (value === false || value === null) this.div.removeAttribute(attr);
        else this.div.setAttribute(attr, value);

        return this;
    };

    /**
     * @name $.fn.val
     * @memberof Extensions
     *
     * @function
     * @param {String} [value] - sets if value exists, else returns value
     * @returns {Number|Self}
     */
    $.fn.val = function(value) {
        if (typeof value === 'undefined') {
            return this.div.value;
        } else {
            this.div.value = value;
        }

        return this;
    };

    /**
     * @name $.fn.change
     * @memberof Extensions
     *
     * @function
     * @param {Function} callback
     */
    $.fn.change = function(callback) {
        var _this = this;
        this.div.onchange = function() {
            callback({object: _this, value: _this.div.value || ''});
        };
    };

    /**
     * @name $.fn.svgSymbol
     * @memberof Extensions
     *
     * @function
     * @param {String} id
     * @param {String} width
     * @param {String} height
     */
    $.fn.svgSymbol = function(id, width, height) {
        var config = SVG.getSymbolConfig(id);
        var svgHTML = '<svg viewBox="0 0 '+config.width+' '+config.height+'" width="'+width+'" height="'+height+'">'+
            '<use xlink:href="#'+config.id+'" x="0" y="0" />'+
            '</svg>';
        this.html(svgHTML, true);
    };

    /**
     * @name $.fn.svg
     * @memberof Extensions
     *
     * @function
     * @param {String} url
     */
    $.fn.svg = async function(url) {
        let promise = Promise.create();
        fetch(url).then(async res => {
            let svgHTML = await res.text();
            this.html(svgHTML, true);
            promise.resolve();
        });

        return promise;
    };

    /**
     * @name $.fn.overflowScroll
     * @memberof Extensions
     *
     * @function
     * @param {Object} [dir] object with x and y boolean properties
     */
    $.fn.overflowScroll = function(dir) {
        var x = !!dir.x;
        var y = !!dir.y;

        var overflow = {};
        if ((!x && !y) || (x && y)) overflow.overflow = 'auto';
        if (!x && y) {
            overflow.overflowY = 'auto';
            overflow.overflowX = 'hidden';
        }
        if (x && !y) {
            overflow.overflowX = 'auto';
            overflow.overflowY = 'hidden';
        }

        if (Device.mobile) {
            overflow['-webkit-overflow-scrolling'] = 'touch';
            Mobile._addOverflowScroll(this);
        }

        this.css(overflow);
    };

    /**
     * @name $.fn.removeOverflowScroll
     * @memberof Extensions
     *
     * @function
     */
    $.fn.removeOverflowScroll = function() {
        this.css({overflow: 'hidden', overflowX: '', overflowY: '', '-webkit-overflow-scrolling': ''});
        if (Device.mobile) Mobile._removeOverflowScroll(this);
    };

    /**
     * @name $.fn.accessible
     * @memberof Extensions
     *
     * @function
     * @param {String} [type]
     * @param {Number} [tabIndex]
     * @returns {Self}
     */
    $.fn.accessible = function(type = 'label', tabIndex = -1) {
        if (tabIndex > -1) this.attr('tabindex', tabIndex);
        switch (type) {
            case 'label':
                this.attr('aria-label', this.div.textContent);
                break;

            case 'hidden':
                this.attr('aria-hidden', true);
                break;
        }
    };

    /**
     * @name $.fn.tabIndex
     * @memberof Extensions
     *
     * @function
     * @param {Number} [tabIndex]
     * @returns {Self}
     */
    $.fn.tabIndex = function(tabIndex) {
        this.attr('tabindex', tabIndex);
        return this;
    };

    /**
     * @name $.fn.createObserver
     * @memberof Extensions
     *
     * @function
     * @param {Callback} [options]
     * @returns {Self}
     */
    $.fn.createObserver = function(callback, options = {}) {
        const handle = array => {
            array.forEach(entry => {
                entry.object = entry.target.hydraObject;
            });
            callback(array);
        };
        this._observer = new IntersectionObserver(handle, Utils.mergeObject(options, {root: this.div}));
        return this;
    }

    /**
     * @name $.fn.observe
     * @memberof Extensions
     *
     * @function
     * @param {HydraObject}
     * @returns {Self}
     */
    $.fn.observe = function(obj) {
        this._observer?.observe(obj.div);
        return this;
    }

    /**
     * @name $.fn.unobserve
     * @memberof Extensions
     *
     * @function
     * @param {HydraObject}
     * @returns {Self}
     */
    $.fn.unobserve = function(obj) {
        this._observer?.unobserve(obj.div);
        return this;
    }

    /**
     * @name $.fn.cursor
     * @memberof Extensions
     *
     * @function
     * @param {String} [type]
     * @param {Object} [lock]
     * @returns {Self}
     */
    $.fn.cursor = function(cursor, lock) {
        if (lock) {
            if (!this.cursorLock) this.cursorLock = new Map();

            if (cursor == 'auto') {
                this.cursorLock.delete(lock);
            } else {
                this.cursorLock.set(lock, cursor);
            }
        }

        if (this.cursorLock && cursor == 'auto') {
            this.cursorLock.forEach(v => {
                cursor = v; //todo maybe add priority if necessary
            });
        }

        this.css('cursor', cursor);
        return this;
    };

    /**
     * @name $.fn.classList
     * @memberof Extensions
     *
     * @function
     * @returns {classList}
     */
    $.fn.classList = function() {
        return this.div.classList;
    }
})();

/**
 * @name Input
 */

/*
* TODO: rewrite using bind instead of addEventListener directly
* */

(function() {
    var windowsPointer = !!window.MSGesture;

    var translateEvent = function(evt) {
        if (windowsPointer) {
            switch (evt) {
                case 'touchstart': return 'pointerdown'; break;
                case 'touchmove': return 'MSGestureChange'; break;
                case 'touchend': return 'pointerup'; break;
            }
        }
        return evt;
    };

    var convertTouchEvent = function(e) {
        var touchEvent = {};
        touchEvent.x = 0;
        touchEvent.y = 0;

        if (e.windowsPointer) return e;

        if (!e) return touchEvent;
        if (e.touches || e.changedTouches) {
            if (e.touches.length) {
                touchEvent.x = e.touches[0].clientX;
                touchEvent.y = e.touches[0].clientY;
            } else {
                touchEvent.x = e.changedTouches[0].clientX;
                touchEvent.y = e.changedTouches[0].clientY;
            }
        } else {
            touchEvent.x = e.clientX;
            touchEvent.y = e.clientY;
        }

        // If mobile forced into other orientation - transform touch coordinates to match
        if (Mobile.ScreenLock && Mobile.ScreenLock.isActive && Mobile.orientationSet && Mobile.orientation !== Mobile.orientationSet) {
            if (window.orientation == 90 || window.orientation === 0) {
                var x = touchEvent.y;
                touchEvent.y = touchEvent.x;
                touchEvent.x = Stage.width - x;
            }

            if (window.orientation == -90 || window.orientation === 180) {
                var y = touchEvent.x;
                touchEvent.x = touchEvent.y;
                touchEvent.y = Stage.height - y;
            }
        }

        return touchEvent;
    };

    /**
     * @name this.click
     * @memberof Input
     *
     * @function
     * @param {Function} callback
     * @returns {Self}
     */
    $.fn.click = function(callback) {
        var _this = this;
        function click(e) {
            if (!_this.div) return false;
            if (Mouse._preventClicks) return false;
            e.object = _this.div.className == 'hit' ? _this.parent() : _this;
            e.action = 'click';

            if (callback) callback(e);

            if (Mouse.autoPreventClicks) Mouse.preventClicks();
        }

        this.div.addEventListener(translateEvent('click'), click, true);
        this.div.style.cursor = 'pointer';

        return this;
    };

    /**
     * @name this.hover
     * @memberof Input
     *
     * @function
     * @param {Function} callback
     * @returns {Self}
     */
    $.fn.hover = function(callback) {
        var _this = this;
        var _over = false;
        var _time;

        function hover(e) {
            if (!_this.div) return false;
            var time = performance.now();
            var original = e.toElement || e.relatedTarget;

            if (_time && (time - _time) < 5) {
                _time = time;
                return false;
            }

            _time = time;

            e.object = _this.div.className == 'hit' ? _this.parent() : _this;

            switch (e.type) {
                case 'mouseout': e.action = 'out'; break;
                case 'mouseleave': e.action = 'out'; break;
                default: e.action = 'over'; break;
            }

            if (_over) {
                if (Mouse._preventClicks) return false;
                if (e.action == 'over') return false;
                if (e.action == 'out') {
                    if (isAChild(_this.div, original)) return false;
                }
                _over = false;
            } else {
                if (e.action == 'out') return false;
                _over = true;
            }

            if (callback) callback(e);
        }

        function isAChild(div, object) {
            var len = div.children.length-1;
            for (var i = len; i > -1; i--) {
                if (object == div.children[i]) return true;
            }

            for (i = len; i > -1; i--) {
                if (isAChild(div.children[i], object)) return true;
            }
        }

        this.div.addEventListener(translateEvent('mouseover'), hover, true);
        this.div.addEventListener(translateEvent('mouseout'), hover, true);

        return this;
    };

    /**
     * @name this.press
     * @memberof Input
     *
     * @function
     * @param {Function} callback
     * @returns {Self}
     */
    $.fn.press = function(callback) {
        var _this = this;

        function press(e) {
            if (!_this.div) return false;
            e.object = _this.div.className == 'hit' ? _this.parent() : _this;

            switch (e.type) {
                case 'mousedown': e.action = 'down'; break;
                default: e.action = 'up'; break;
            }

            if (callback) callback(e);
        }

        this.div.addEventListener(translateEvent('mousedown'), press, true);
        this.div.addEventListener(translateEvent('mouseup'), press, true);

        return this;
    };

    /**
     * @name this.bind
     * @memberof Input
     *
     * @function
     * @param {String} evt
     * @param {Function} callback
     * @returns {Self}
     */
    $.fn.bind = function(evt, callback) {
        this._events = this._events || {};

        if (windowsPointer && this == __window) {
            return Stage.bind(evt, callback);
        }

        if (evt == 'touchstart') {
            if (!Device.mobile) {
                if (Device.touchCapable) this.bind('mousedown', callback);
                else evt = 'mousedown';
            }
        } else if (evt == 'touchmove') {
            if (!Device.mobile) {
                if (Device.touchCapable) this.bind('mousemove', callback);
                else evt = 'mousemove';
            }

            if (windowsPointer && !this.div.msGesture) {
                this.div.msGesture = new MSGesture();
                this.div.msGesture.target = this.div;
            }
        } else if (evt == 'touchend') {
            if (!Device.mobile) {
                if (Device.touchCapable) this.bind('mouseup', callback);
                else evt = 'mouseup';
            }
        }

        this._events['bind_'+evt] = this._events['bind_'+evt] || [];
        var _events = this._events['bind_'+evt];
        var e = {};
        var target = this.div;
        e.callback = callback;
        e.target = this.div;
        _events.push(e);

        function touchEvent(e) {
            if (windowsPointer && target.msGesture && evt == 'touchstart') {
                target.msGesture.addPointer(e.pointerId);
            }

            if (!Device.mobile && evt == 'touchstart') e.preventDefault();

            var touch = convertTouchEvent(e);
            if (windowsPointer) {
                var windowsEvt = e;
                e = {};
                e.x = Number(windowsEvt.clientX);
                e.y = Number(windowsEvt.clientY);
                e.target = windowsEvt.target;
                e.currentTarget = windowsEvt.currentTarget;
                e.path = [];
                var node = e.target;
                while (node) {
                    e.path.push(node);
                    node = node.parentElement || null;
                }
                e.windowsPointer = true;
            } else {
                e.x = touch.x;
                e.y = touch.y;
            }

            for (var i = 0; i < _events.length; i++) {
                var ev = _events[i];
                if (ev.target == e.currentTarget) {
                    ev.callback(e);
                }
            }
        }

        if (!this._events['fn_'+evt]) {
            this._events['fn_'+evt] = touchEvent;
            this.div.addEventListener(translateEvent(evt), touchEvent, { capture: true, passive: false });
        }
        return this;
    };

    /**
     * @name this.unbind
     * @memberof Input
     *
     * @function
     * @param {String} evt
     * @param {Function} callback
     * @returns {*}
     */
    $.fn.unbind = function(evt, callback) {
        this._events = this._events || {};

        if (windowsPointer && this == __window) {
            return Stage.unbind(evt, callback);
        }

        if (evt == 'touchstart') {
            if (!Device.mobile) {
                if (Device.touchCapable) this.unbind('mousedown', callback);
                else evt = 'mousedown';
            }
        } else if (evt == 'touchmove') {
            if (!Device.mobile) {
                if (Device.touchCapable) this.unbind('mousemove', callback);
                else evt = 'mousemove';
            }
        } else if (evt == 'touchend') {
            if (!Device.mobile) {
                if (Device.touchCapable) this.unbind('mouseup', callback);
                else evt = 'mouseup';
            }
        }

        var _events = this._events['bind_'+evt];
        if (!_events) return this;

        for (var i = 0; i < _events.length; i++) {
            var ev = _events[i];
            if (ev.callback == callback) _events.splice(i, 1);
        }

        if (this._events['fn_'+evt] && !_events.length) {
            this.div.removeEventListener(translateEvent(evt), this._events['fn_'+evt], Device.mobile ? {passive: true} : true);
            this._events['fn_'+evt] = null;
        }

        return this;
    };

    /**
     * @name this.interact
     * @memberof Input
     *
     * All parameters may be omitted and instead specified inside an options
     * object passed as the last parameter.
     *
     * Some additional options may only be passed in the options object:
     *   - `role`: pass 'button' to use the button interaction convention of
     *     firing the clickCallback on spacebar as well as the enter key.
     *
     * @function
     * @param {Function} overCallback
     * @param {Function} clickCallback
     * @param {String} seoLink path for SEO link href, turns hit into anchor tag
     * @param {String} seoText text for achor tag if seoLink is provided
     * @param {String | Number} zIndex specify zIndex or default to 99999 (pass 'auto' for browser default 0)
     * @param {Object} options optional object containing further parameters
     */
    $.fn.interact = function(overCallback, clickCallback, seoLink, seoText, zIndex, options) {
        if (!this.hit) {
            if (typeof arguments[arguments.length - 1] === 'object') {
                options = arguments[arguments.length - 1];
                [overCallback, clickCallback, seoLink, seoText, zIndex] = Array.prototype.slice.call(arguments, 0, -1);
                if (options.overCallback) overCallback = options.overCallback;
                if (options.clickCallback) clickCallback = options.clickCallback;
                if (options.seoLink) seoLink = options.seoLink;
                if (options.seoText) seoText = options.seoText;
                if (options.zIndex) zIndex = options.zIndex;
            }
            if (!options) options = {};
            this.hit = $('.hit', seoLink ? 'a' : undefined);
            this.hit.css({width: '100%', height: '100%', zIndex: zIndex || 99999, top: 0, left: 0, position: 'absolute'});
            this.add(this.hit);
            var _this = this;

            if (seoLink) {
                this.hit.attr('href', seoLink === '#' ? seoLink : Hydra.absolutePath(seoLink));
                this.hit.text(seoText || this.div.textContent);
                this.hit.css({fontSize: 0});
                this.hit.accessible();
                if (typeof overCallback === 'function') {
                    this.hit.div.onfocus = _ => overCallback({action: 'over', object: this});
                    this.hit.div.onblur = _ => overCallback({action: 'out', object: this});
                }
                this.hit.div.onclick = e => {
                    e.preventDefault();
                    e.object = _this;
                    e.action = 'click';
                    clicked(e);
                };
            }
            if (options.role) {
                this.hit.attr('role', options.role);
                if (options.role === 'button') {
                    this.hit.div.onkeydown = e => {
                        switch (e.key) {
                            case ' ':
                            case 'Spacebar':
                                e.stopPropagation();
                                e.object = _this;
                                e.action = 'click';
                                clicked(e);
                                break;
                        }
                    }
                }
            }
        }

        let time = Render.TIME;
        function clicked(e) {
            if (clickCallback && Render.TIME - time > 250) clickCallback(e);
            time = Render.TIME;
        }

        if (!Device.mobile) this.hit.hover(overCallback).click(clicked);
        else this.hit.touchClick(overCallback, clicked).click(clicked);
    };

    $.fn.clearInteract = function() {
        if (this.hit) this.hit = this.hit.destroy();
    };

    $.fn.disableInteract = function() {
        if (this.hit) this.hit.css({ pointerEvents: 'none' });
    };

    $.fn.enableInteract = function() {
        if (this.hit) this.hit.css({ pointerEvents: 'auto' });
    };

    /**
     * @name this.touchSwipe
     * @memberof Input
     *
     * @function
     * @param {Function} callback
     * @param {Number} [distance = 75]
     * @returns {Self}
     */
    $.fn.touchSwipe = function(callback, distance) {
        if (!window.addEventListener) return this;

        var _this = this;
        var _distance = distance || 75;
        var _startX, _startY;
        var _moving = false;
        var _move = {};

        if (Device.mobile) {
            this.div.addEventListener(translateEvent('touchstart'), touchStart, {passive: true});
            this.div.addEventListener(translateEvent('touchend'), touchEnd, {passive: true});
            this.div.addEventListener(translateEvent('touchcancel'), touchEnd, {passive: true});
        }

        function touchStart(e) {
            var touch = convertTouchEvent(e);
            if (!_this.div) return false;
            if (e.touches.length == 1) {
                _startX = touch.x;
                _startY = touch.y;
                _moving = true;
                _this.div.addEventListener(translateEvent('touchmove'), touchMove, {passive: true});
            }
        }

        function touchMove(e) {
            if (!_this.div) return false;
            if (_moving) {
                var touch = convertTouchEvent(e);
                var dx = _startX - touch.x;
                var dy = _startY - touch.y;

                _move.direction = null;
                _move.moving = null;
                _move.x = null;
                _move.y = null;
                _move.evt = e;

                if (Math.abs(dx) >= _distance) {
                    touchEnd();
                    if (dx > 0) {
                        _move.direction = 'left';
                    } else {
                        _move.direction = 'right';
                    }
                } else if (Math.abs(dy) >= _distance) {
                    touchEnd();
                    if (dy > 0) {
                        _move.direction = 'up';
                    } else {
                        _move.direction = 'down';
                    }
                } else {
                    _move.moving = true;
                    _move.x = dx;
                    _move.y = dy;
                }

                if (callback) callback(_move, e);
            }
        }

        function touchEnd(e) {
            if (!_this.div) return false;
            _startX = _startY = _moving = false;
            _this.div.removeEventListener(translateEvent('touchmove'), touchMove);
        }

        return this;
    };

    /**
     * @name this.touchClick
     * @memberof Input
     *
     * @function
     * @param {Function} hover
     * @param {Function} click
     * @returns {Self}
     */
    $.fn.touchClick = function(hover, click) {
        if (!window.addEventListener) return this;
        var _this = this;
        var _time, _move;
        var _start = {};
        var _touch = {};

        if (Device.mobile) {
            this.div.addEventListener(translateEvent('touchstart'), touchStart, {passive: true});
            this.div.addEventListener(translateEvent('touchend'), touchEnd, {passive: true});
        }

        function findDistance(p1, p2) {
            var dx = p2.x - p1.x;
            var dy = p2.y - p1.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function setTouch(e) {
            var touch = convertTouchEvent(e);
            e.touchX = touch.x;
            e.touchY = touch.y;

            _start.x = e.touchX;
            _start.y = e.touchY;
        }

        function touchStart(e) {
            if (!_this.div) return false;
            _time = performance.now();
            e.action = 'over';
            e.object = _this.div.className == 'hit' ? _this.parent() : _this;
            setTouch(e);
            if (hover && !_move) hover(e);
        }

        function touchEnd(e) {
            if (!_this.div) return false;
            var time = performance.now();
            var clicked = false;

            _touch = convertTouchEvent(e);
            _move = findDistance(_start, _touch) > 25;

            e.object = _this.div.className == 'hit' ? _this.parent() : _this;
            setTouch(e);

            if (_time && time - _time < 750) {
                if (Mouse._preventClicks) return false;
                if (click && !_move) {
                    clicked = true;
                    e.action = 'click';
                    if (click && !_move) click(e);

                    if (Mouse.autoPreventClicks) Mouse.preventClicks();
                }
            }

            if (hover) {
                e.action = 'out';
                if (!Mouse._preventFire) hover(e);
            }

            _move = false;
        }

        return this;
    };
})();

/**
 * @name Element
 */

Class(function Element(type = 'div') {
	Inherit(this, Component);
	var name = Utils.getConstructorName(this);

	this.__element = true;

    /**
     * Hydra object
     * @name this.element
     * @memberof Element
     */
	this.element = $('.'+name, type);
	this.element.__useFragment = true;

    /**
     * @name Element.destroy
     * @memberof Element
     *
     * @function
    */
    this.destroy = function() {
        if (this.element && this.element.remove) this.element = this.element.remove();
        this._destroy && this._destroy();
    };

    /**
     * @name Element.querySelector
     * @memberof Element
     *
     * @function
     * @param selector
    */
    this.querySelector = async function(selector) {
        await defer();

        if (!Array.isArray(selector)) {
            return $(this.element.div.querySelector(selector));
        } else {
            let values = [];
            selector.forEach(s => {
                values.push($(this.element.div.querySelector(s)));
            });
            return values;
        }
    }

    /**
     * @name Element.querySelectorAll
     * @memberof Element
     *
     * @function
     * @param selector
    */
    this.querySelectorAll = async function(selector) {
        await defer();

        let list = this.element.div.querySelectorAll(selector);
        let values = [];
        for (let i = 0; i < list.length; i++) values.push($(list[i]));
        return values;
    }

});
/**
 * @name CSSConfig
 */

(function() {
	Hydra.ready(() => {
		TweenManager.Transforms = [
			'scale',
			'scaleX',
			'scaleY',
			'x',
			'y',
			'z',
			'rotation',
			'rotationX',
			'rotationY',
			'rotationZ',
			'skewX',
			'skewY',
			'perspective',
		];

		TweenManager.CubicEases = [
			{name: 'easeOutCubic', curve: 'cubic-bezier(0.215, 0.610, 0.355, 1.000)'},
			{name: 'easeOutQuad', curve: 'cubic-bezier(0.250, 0.460, 0.450, 0.940)'},
			{name: 'easeOutQuart', curve: 'cubic-bezier(0.165, 0.840, 0.440, 1.000)'},
			{name: 'easeOutQuint', curve: 'cubic-bezier(0.230, 1.000, 0.320, 1.000)'},
			{name: 'easeOutSine', curve: 'cubic-bezier(0.390, 0.575, 0.565, 1.000)'},
			{name: 'easeOutExpo', curve: 'cubic-bezier(0.190, 1.000, 0.220, 1.000)'},
			{name: 'easeOutCirc', curve: 'cubic-bezier(0.075, 0.820, 0.165, 1.000)'},
			{name: 'easeOutBack', curve: 'cubic-bezier(0.175, 0.885, 0.320, 1.275)'},

			{name: 'easeInCubic', curve: 'cubic-bezier(0.550, 0.055, 0.675, 0.190)'},
			{name: 'easeInQuad', curve: 'cubic-bezier(0.550, 0.085, 0.680, 0.530)'},
			{name: 'easeInQuart', curve: 'cubic-bezier(0.895, 0.030, 0.685, 0.220)'},
			{name: 'easeInQuint', curve: 'cubic-bezier(0.755, 0.050, 0.855, 0.060)'},
			{name: 'easeInSine', curve: 'cubic-bezier(0.470, 0.000, 0.745, 0.715)'},
			{name: 'easeInCirc', curve: 'cubic-bezier(0.600, 0.040, 0.980, 0.335)'},
			{name: 'easeInBack', curve: 'cubic-bezier(0.600, -0.280, 0.735, 0.045)'},

			{name: 'easeInOutCubic', curve: 'cubic-bezier(0.645, 0.045, 0.355, 1.000)'},
			{name: 'easeInOutQuad', curve: 'cubic-bezier(0.455, 0.030, 0.515, 0.955)'},
			{name: 'easeInOutQuart', curve: 'cubic-bezier(0.770, 0.000, 0.175, 1.000)'},
			{name: 'easeInOutQuint', curve: 'cubic-bezier(0.860, 0.000, 0.070, 1.000)'},
			{name: 'easeInOutSine', curve: 'cubic-bezier(0.445, 0.050, 0.550, 0.950)'},
			{name: 'easeInOutExpo', curve: 'cubic-bezier(1.000, 0.000, 0.000, 1.000)'},
			{name: 'easeInOutCirc', curve: 'cubic-bezier(0.785, 0.135, 0.150, 0.860)'},
			{name: 'easeInOutBack', curve: 'cubic-bezier(0.680, -0.550, 0.265, 1.550)'},

			{name: 'easeInOut', curve: 'cubic-bezier(.42,0,.58,1)'},
			{name: 'linear', curve: 'linear'}
		];

		TweenManager.useCSSTrans = function (props, ease, object) {
			if (props.math) return false;
			if (typeof ease === 'string' && (ease.includes(['Elastic', 'Bounce']))) return false;
			if (object.multiTween || TweenManager._inspectEase(ease).path) return false;
			if (!Device.tween.transition) return false;
			return true;
		}

		TweenManager._detectTween = function(object, props, time, ease, delay, callback) {
			if (!TweenManager.useCSSTrans(props, ease, object)) {
				return new FrameTween(object, props, time, ease, delay, callback);
			} else {
				return new CSSTransition(object, props, time, ease, delay, callback);
			}
		}

		TweenManager._parseTransform = function(props) {
			var unitRequiresCSSTween = [ '%', 'vw', 'vh', 'em' ];
			var transforms = '';
			var translate = '';

			if (props.perspective > 0) transforms += 'perspective('+props.perspective+'px)';

			if (typeof props.x !== 'undefined' || typeof props.y !== 'undefined' || typeof props.z !== 'undefined') {
				var x = (props.x || 0);
				var y = (props.y || 0);
				var z = (props.z || 0);
				var xUnit = (typeof props.x === 'string' && (props.x.includes( unitRequiresCSSTween ))) ? '' : 'px';
				var yUnit = (typeof props.y === 'string' && (props.y.includes( unitRequiresCSSTween ))) ? '' : 'px';
                translate += x + xUnit + ', ';
                translate += y + yUnit;
				if (Device.tween.css3d) {
					translate += ', ' + z + 'px';
					transforms += 'translate3d('+translate+')';
				} else {
					transforms += 'translate('+translate+')';
				}
			}

			if (typeof props.scale !== 'undefined') {
				transforms += 'scale('+props.scale+')';
			} else {
				if (typeof props.scaleX !== 'undefined') transforms += 'scaleX('+props.scaleX+')';
				if (typeof props.scaleY !== 'undefined') transforms += 'scaleY('+props.scaleY+')';
			}

			if (typeof props.rotation !== 'undefined') transforms += 'rotate('+props.rotation+'deg)';
			if (typeof props.rotationX !== 'undefined') transforms += 'rotateX('+props.rotationX+'deg)';
			if (typeof props.rotationY !== 'undefined') transforms += 'rotateY('+props.rotationY+'deg)';
			if (typeof props.rotationZ !== 'undefined') transforms += 'rotateZ('+props.rotationZ+'deg)';
			if (typeof props.skewX !== 'undefined') transforms += 'skewX('+props.skewX+'deg)';
			if (typeof props.skewY !== 'undefined') transforms += 'skewY('+props.skewY+'deg)';

			return transforms;
		}

		TweenManager._clearCSSTween = function(obj) {
			if (obj && !obj._cssTween && obj.div._transition && !obj.persistTween) {
				obj.div.style[HydraCSS.styles.vendorTransition] = '';
				obj.div._transition = false;
				obj._cssTween = null;
			}
		}

		TweenManager._isTransform = function(key) {
			var index = TweenManager.Transforms.indexOf(key);
			return index > -1;
		}

		TweenManager._getAllTransforms = function(object) {
			var obj = {};
			for (var i = TweenManager.Transforms.length-1; i > -1; i--) {
				var tf = TweenManager.Transforms[i];
				var val = object[tf];
				if (val !== 0 && (typeof val === 'number' || typeof val === 'string')) {
					obj[tf] = val;
				}
			}
			return obj;
		}

        const prefix = (function() {
            let pre = '';
            let dom = '';

            try {
                var styles = window.getComputedStyle(document.documentElement, '');
                pre = (Array.prototype.slice
                        .call(styles)
                        .join('')
                        .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])
                )[1];
                dom = ('WebKit|Moz|MS|O').match(new RegExp('(' + pre + ')', 'i'))[1];

                return {
                    unprefixed: Device.system.browser == 'ie' && !Device.detect('msie 9'),
                    dom: dom,
                    lowercase: pre,
                    css: '-' + pre + '-',
                    js: (Device.system.browser == 'ie' ? pre[0] : pre[0].toUpperCase()) + pre.substr(1)
                };
            } catch(e) {
                return {unprefixed: true, dom: '', lowercase: '', css: '', js: ''};
            }
        })();

		HydraCSS.styles = {};

		/**
		 * String of vender prefix for js-applied styles. eg, for webkitTransform vs -webkit-transform.
		 * @name HydraCSS.styles.vendor
		 * @memberof CSSConfig
		 */
		HydraCSS.styles.vendor = prefix.unprefixed ? '' : prefix.js;

		/**
		 * String of transition vender prefix for js-applied styles.
		 * @name HydraCSS.styles.vendorTransition
		 * @memberof CSSConfig
		 */
		HydraCSS.styles.vendorTransition = HydraCSS.styles.vendor.length ? HydraCSS.styles.vendor + 'Transition' : 'transition';

		/**
		 * String of transform vender prefix for js-applied styles.
		 * @name HydraCSS.styles.vendorTransform
		 * @memberof CSSConfig
		 */
		HydraCSS.styles.vendorTransform = HydraCSS.styles.vendor.length ? HydraCSS.styles.vendor + 'Transform' : 'transform';

		//*** Transforms
		/**
		 * String of css prefix. eg. '-webkit-', '-moz-' etc.
		 * @name HydraCSS.vendor
		 * @memberof CSSConfig
		 */
		HydraCSS.vendor = prefix.css;

		/**
		 * String of css transform prefix. eg. '-webkit-transform', '-moz-transform' etc.
		 * @name HydraCSS.transformProperty
		 * @memberof CSSConfig
		 */
		HydraCSS.transformProperty = (function() {
		    switch (prefix.lowercase) {
		        case 'moz': return '-moz-transform'; break;
		        case 'webkit': return '-webkit-transform'; break;
		        case 'o': return '-o-transform'; break;
		        case 'ms': return '-ms-transform'; break;
		        default: return 'transform'; break;
		    }
		})();

		HydraCSS.tween = {};

		/**
		 * @name HydraCSS.tween.complete
		 * @memberof CSSConfig
		 */
		HydraCSS.tween.complete = (function() {
		    if (prefix.unprefixed) return 'transitionend';
		    return prefix.lowercase + 'TransitionEnd';
		})();

	});
})();
/**
 * @name CSSTransition
 */

Class(function CSSTransition(_object, _props, _time, _ease, _delay, _callback) {
    const _this = this;
    let _transformProps, _transitionProps;

    this.playing = true;

    //*** Constructor
    (function() {
        // if (_this.overrideValues) {
        //     let values = _this.overrideValues(_this, _object, _props, _time, _ease, _delay);
        //     if (values) {
        //         _props = values.props || _props;
        //         _time = values.time || _time;
        //         _ease = values.ease || _ease;
        //         _delay = values.delay || _delay;
        //     }
        // }

        if (typeof _time !== 'number') throw 'CSSTween Requires object, props, time, ease';
        initProperties();
        initCSSTween();
    })();

    function killed() {
        return !_this || _this.kill || !_object || !_object.div;
    }

    function initProperties() {
        var transform = TweenManager._getAllTransforms(_object);
        var properties = [];

        for (var key in _props) {
            if (TweenManager._isTransform(key)) {
                transform.use = true;
                transform[key] = _props[key];
                delete _props[key];
            } else {
                if (typeof _props[key] === 'number' || key.includes(['-', 'color'])) properties.push(key);
            }
        }

        if (transform.use) {
            properties.push(HydraCSS.transformProperty);
            delete transform.use;
        }

        _transformProps = transform;
        _transitionProps = properties;
    }

    async function initCSSTween(values) {
        if (killed()) return;
        if (_object._cssTween) _object._cssTween.kill = true;
        _object._cssTween = _this;
        _object.div._transition = true;

        var strings = buildStrings(_time, _ease, _delay);

        _object.willChange(strings.props);

        var time = values ? values.time : _time;
        var delay = values ? values.delay : _delay;
        var props = values ? values.props : _props;
        var transformProps = values ? values.transform : _transformProps;
        var singleFrame = 1000 / Render.REFRESH_RATE;

        _this.time = _time;
        _this.delay = _delay;

        await Timer.delayedCall(3 * singleFrame);
        if (killed()) return;
        _object.div.style[HydraCSS.styles.vendorTransition] = strings.transition;
        _this.playing = true;

        if (Device.system.browser == 'safari') {
            if (Device.system.browserVersion < 11) await Timer.delayedCall(singleFrame);
            if (killed()) return;
            _object.css(props);
            _object.transform(transformProps);
        } else {
            _object.css(props);
            _object.transform(transformProps);
        }

        Timer.create(function() {
            if (killed()) return;
            clearCSSTween();
            if (_callback) _callback();
            if (_this.completePromise) _this.completePromise.resolve();
        }, time + delay);
    }

    function buildStrings(time, ease, delay) {
        var props = '';
        var str = '';
        var len = _transitionProps.length;
        for (var i = 0; i < len; i++) {
            var transitionProp = _transitionProps[i];
            props += (props.length ? ', ' : '') + transitionProp;
            str += (str.length ? ', ' : '') + transitionProp + ' ' + time+'ms ' + TweenManager._getEase(ease) + ' ' + delay+'ms';
        }

        return {props: props, transition: str};
    }

    function clearCSSTween() {
        if (killed()) return;
        _this.playing = false;
        _object._cssTween = null;
        _object.willChange(null);
        _object = _props = null;
        Utils.nullObject(this);
    }

    //*** Event handlers
    function tweenComplete() {
        if (!_callback && _this.playing) clearCSSTween();
    }

    //*** Public methods
    /**
     * @name this.stop
     * @memberof CSSTransition
     *
     * @function
     */
    this.stop = function() {
        if (!this.playing) return;
        this.kill = true;
        this.playing = false;
        _object.div.style[HydraCSS.styles.vendorTransition] = '';
        _object.div._transition = false;
        _object.willChange(null);
        _object._cssTween = null;
        Utils.nullObject(this);
    };


    /**
     * @name this.stop
     * @memberof CSSTransition
     *
     * @function
     * @param {Function} callback
     */
    this.onComplete = function(callback) {
        _callback = callback;
        return this;
    };

    /**
     * @name this.promise
     * @memberof CSSTransition
     *
     * @function
     * @param {Function}
     */
    this.promise = function() {
        _this.completePromise = Promise.create();
        return _this.completePromise;
    };
});
/**
 * @name FrameTween
 */

Class(function FrameTween(_object, _props, _time, _ease, _delay, _callback, _manual) {
    var _this = this;
    var _endValues, _transformEnd, _transformStart, _startValues;
    var _isTransform, _isCSS, _transformProps;
    var _cssTween, _transformTween, _update;

    this.playing = true;

    _this.object = _object;
    _this.props = _props;
    _this.time = _time;
    _this.ease = _ease;
    _this.delay = _delay;

    //*** Constructor
    defer(function() {
        if (_this.overrideValues) {
            let values = _this.overrideValues(_this, _object, _props, _time, _ease, _delay);
            if (values) {
                _this.props = _props = values.props || _props;
                _this.time = _time = values.time || _time;
                _this.ease = _ease = values.ease || _ease;
                _this.delay = _delay = values.delay || _delay;
            }
        }

        if (typeof _ease === 'object') _ease = 'easeOutCubic';
        if (_object && _props) {
            _this.object = _object;
            if (typeof _time !== 'number') throw 'FrameTween Requires object, props, time, ease';
            initValues();
            startTween();
        }
    });

    function killed() {
        return _this.kill || !_object || !_object.div || !_object.css;
    }

    function initValues() {
        if (_props.math) delete _props.math;
        if (Device.tween.transition && _object.div && _object.div._transition) {
            _object.div.style[HydraCSS.styles.vendorTransition] = '';
            _object.div._transition = false;
        }

        _this.time = _time;
        _this.delay = _delay;

        _endValues = {};
        _transformEnd = {};
        _transformStart = {};
        _startValues = {};

        if (!_object.multiTween) {
            if (typeof _props.x === 'undefined') _props.x = _object.x;
            if (typeof _props.y === 'undefined') _props.y = _object.y;
            if (typeof _props.z === 'undefined') _props.z = _object.z;
        }

        for (var key in _props) {
            if (key.includes(['damping', 'spring'])) {
                _endValues[key] = _props[key];
                _transformEnd[key] = _props[key];
                continue;
            }
            if (TweenManager._isTransform(key)) {
                _isTransform = true;
                _transformStart[key] = _object[key] || (key == 'scale' ? 1 : 0);
                _transformEnd[key] = _props[key];
            } else {
                _isCSS = true;
                var v = _props[key];
                if (typeof v === 'string') {
                    _object.div.style[key] = v;
                } else if (typeof v === 'number') {
                    _startValues[key] = _object.css ? Number(_object.css(key)) : 0;
                    _endValues[key] = v;
                }
            }
        }
    }

    function startTween() {
        if (_object._cssTween && !_manual && !_object.multiTween) _object._cssTween.kill = true;

        _this.time = _time;
        _this.delay = _delay;

        if (_object.multiTween) {
            if (!_object._cssTweens) _object._cssTweens = [];
            _object._cssTweens.push(_this);
        }

        _object._cssTween = _this;
        _this.playing = true;
        _props = copy(_startValues);
        _transformProps = copy(_transformStart);

        if (_isCSS) _cssTween = tween(_props, _endValues, _time, _ease, _delay, null, _manual).onUpdate(update).onComplete(tweenComplete);
        if (_isTransform) _transformTween = tween(_transformProps, _transformEnd, _time, _ease, _delay, null, _manual).onComplete(!_isCSS ? tweenComplete : null).onUpdate(!_isCSS ? update : null);
    }

    function copy(obj) {
        let newObj = {};
        for (let key in obj) {
            if (typeof obj[key] === 'number') newObj[key] = obj[key];
        }
        return newObj;
    }

    function clear() {
        if (_object._cssTweens) {
            _object._cssTweens.remove(_this);
        }

        _this.playing = false;
        _object._cssTween = null;
        _object = _props = null;
    }

    //*** Event handlers
    function update() {
        if (killed()) return;
        if (_isCSS) _object.css(_props);
        if (_isTransform) {
            if (_object.multiTween) {
                for (var key in _transformProps) {
                    if (typeof _transformProps[key] === 'number') _object[key] = _transformProps[key];
                }
                _object.transform();
            } else {
                _object.transform(_transformProps);
            }
        }

        if (_update) _update();
    }

    function tweenComplete() {
        if (_this.playing) {
            clear();
            if (_callback) _callback();
            if (_this.completePromise) _this.completePromise.resolve();
        }
    }

    //*** Public methods

    /**
     * @name this.stop
     * @memberof FrameTween
     *
     * @function
     */
    this.stop = function() {
        if (!this.playing) return;
        if (_cssTween && _cssTween.stop) _cssTween.stop();
        if (_transformTween && _transformTween.stop) _transformTween.stop();
        clear();
    };

    /**
     * @name this.interpolate
     * @memberof FrameTween
     *
     * @function
     * @param {Number} elapsed - Number between 0.0 and 1.0
     */
    this.interpolate = function(elapsed) {
        if (_cssTween) _cssTween.interpolate(elapsed);
        if (_transformTween) _transformTween.interpolate(elapsed);
        update();
    };

    /**
     * @name this.getValues
     * @memberof FrameTween
     *
     * @function
     * @returns {Object} Object with startm, transformStart, end and transformEnd properties.
     */
    this.getValues = function() {
        return {
            start: _startValues,
            transformStart: _transformStart,
            end: _endValues,
            transformEnd: _transformEnd,
        };
    };

    /**
     * @name this.setEase
     * @memberof FrameTween
     *
     * @function
     * @param {String} ease
     */
    this.setEase = function(ease) {
        if (_cssTween) _cssTween.setEase(ease);
        if (_transformTween) _transformTween.setEase(ease);
    };

    /**
     * @name this.onUpdate
     * @memberof FrameTween
     *
     * @function
     * @returns {FrameTween}
     */
    this.onUpdate = function() {
        return this;
    };

    /**
     * @name this.onComplete
     * @memberof FrameTween
     *
     * @function
     * @param {Function} callback
     * @returns {FrameTween}
     */
    this.onComplete = function(callback) {
        _callback = callback;
        return this;
    };

    /**
     * @name this.promise
     * @memberof FrameTween
     *
     * @function
     * @param {Function}
     */
    this.promise = function() {
        if (!_this.completePromise) _this.completePromise = Promise.create();
        return _this.completePromise;
    };
});
class DOMAttribute {
    constructor({name, value, belongsTo, bindingLookup}) {
        this.name = name;
        this.value = value;
        this.belongsTo = belongsTo;
        this.bindingLookup = bindingLookup;
    }
}
class TemplateRoot {
    constructor(string, values) {
        this.string = string;
        this.values = values;
    }

    consolidate() {
        let template = this.string;
        const consolidatedValues = {};

        for (const [marker, value] of Object.entries(this.values)) {

            if (value instanceof TemplateHTML) {
                // If the marker resolves to a template we unroll the string and add the values of the
                // template to the root config.
                const [innerTemplate, innerValues] = value.consolidate();
                template = template.replace(marker , innerTemplate);
                Object.assign(consolidatedValues, innerValues);

            } else if (Array.isArray( value )) {
                // If the marker resolves to an array, we assume a collection of templates. All
                // templates are joined to one long template. Same for all configs.
                let childTemplate = "";

                for (let k = 0; k < value.length; k++ ) {
                    const [innerString, innerValue] = value[k].consolidate();
                    childTemplate += innerString;
                    Object.assign(consolidatedValues, innerValue);
                }

                template = template.replace(marker, childTemplate);
            } else {
                // All other markers are add to the accumulative config.
                consolidatedValues[marker] = value;
            }
        }

        return [template, consolidatedValues];
    }

    modifyMarkers(template, config, dataMarkers, bindings) {
        let count = 0;
        return template
            .replace(/@([a-z]+)="\{\{(hydra-[0-9]+)\}\}"/g, function(_, event, marker) {
                const dataMarker = `data-attach-event-${count++}`;
                dataMarkers.push(dataMarker);
                return `${dataMarker}="${event}|${marker}"`;
            })
            .replace(/\{\{hydra-[0-9]+\}\}/g, function(marker) {
                if (config[marker] && config[marker].state) {
                    bindings.push({lookup: marker.trim()});
                    return marker;
                }
                // handle converting style object references (i.e. from template.dynamicStyles)
                // to css properties and return a string
                // { fontSize: '1rem', letterSpacing: '2rem' } => "font-size: 1rem; letter-spacing: 2rem;"
                if (config[marker][`@style`]) {
                    const styles = config[marker][`@style`];
                    if (!styles || typeof styles !== 'object') {
                        console.error('@style must contain an object');
                        return;
                    }
                    let styleString = '';
                    Object.keys(styles).forEach(prop => {
                        // convert camelCase to kebab-case
                        const kebabProp = prop.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();
                        styleString += `${kebabProp}: ${styles[prop]};\n`;
                    })
                    return styleString;
                }
                return config[marker];
            });
    }
}

class TemplateHTML extends TemplateRoot {
    constructor(string, values) {
        super(string, values);
    }

    inflate(root, cssElement) {
        let [template, config] = this.consolidate();
        let dataMarkers = [];
        let nestedComponents = [];
        let bindings = new LinkedList();

        let scrollTop = root.firstChild?.scrollTop;

        const t = this.modifyMarkers(template, config, dataMarkers, bindings);

        while (root.firstChild) root.removeChild(root.firstChild);

        if (root.flatBindings) root.flatBindings.forEach(b => b.destroy());
        root.flatBindings = [];

        let fragment = document.createDocumentFragment();
        let newNode = DOMTemplate.parser.parseFromString(t, 'text/html');
        let els = newNode.body.firstChild.querySelectorAll('*');
        let length = els.length;
        fragment.appendChild(newNode.body.firstChild);
        if (cssElement) fragment.appendChild(cssElement);
        for (let index = length-1; index > -1; index--) {
            let el = els[index];

            // if an unknown elemnt is found, assume it is a nested component, in kabab-case
            if (~el.tagName.indexOf('-')) {
                nestedComponents.push(el);
            }

            let innerText = el.innerText;
            let innerHTML = el.innerHTML;
            let attributes = [...el.attributes].map(a => ({name: a.name, value: a.value}));

            if (~innerHTML.indexOf('<')) continue;
            let binding = bindings.start();
            while (binding) {
                let bindingLookup = binding.lookup;

                attributes.forEach(attr => {
                    if (~attr?.value?.indexOf(bindingLookup)) {
                        let obj = config[bindingLookup];
                        const attrObject = new DOMAttribute({
                            name: attr.name,
                            value: el.getAttribute(attr.name),
                            belongsTo: el,
                            bindingLookup
                        });
                        root.flatBindings.push(obj.state.bind(obj.key, attrObject));
                    }
                });

                if (~innerText.indexOf(bindingLookup)) {
                    let obj = config[bindingLookup];
                    if (~innerText.indexOf('@[')) el.innerText = innerText.replace(bindingLookup, obj.key);
                    root.flatBindings.push(obj.state.bind(obj.key, el));
                }
                binding = bindings.next();
            }
        }
        root.appendChild(fragment);

        dataMarkers.forEach(dataMarker => {
            const element = root.querySelector(`[${dataMarker}]`);
            const dataEvent = element.getAttribute(dataMarker);
            const [event, marker] = dataEvent.split("|");
            element.removeAttribute(dataMarker);
            element.addEventListener(`${event}`, config[`{{${marker}}}`]);
        });

        defer(() => {
            nestedComponents.forEach(template => {
                // kabab-case to PascalCase to infer class name
                const className = template.tagName.toLowerCase().replace(/(^\w|-\w)/g, str => str.replace(/-/, '').toUpperCase())
                const hydraObj = $(`#${template.id}`, className, true);
                hydraObj.add(new window[className]());
            });
        });

        if (scrollTop) root.firstChild.scrollTop = scrollTop;
    }
}

class TemplateCSS extends TemplateRoot {
    constructor(string, values) {
        super(string, values);
    }

    /**
     * Injects the template into a given parent element.
     *
     * @param {Element} root
     */
    inflate(root) {
        let [template, config] = this.consolidate();
        let dataMarkers = [];
        let bindings = new LinkedList();

        let element = document.createElement('style');
        element.innerHTML = this.modifyMarkers(template, config, dataMarkers, bindings);

        return element;
    }
}


function styleMap(object) {
    return Object.keys(object).map(key => object[key] ? key : "").join(" ");
}

/**
 * @name DOMTemplate
 */

(function() {
    let markerID = 0;

    function makeMarker() {
        return `{{hydra-${markerID++}}}`;
    }

    function html(strings, ...values) {
        const config = {};
        let string = '';

        for (let i = 0; i < strings.length - 1; i++) {
            const marker = makeMarker();
            string += strings[i];
            string += marker;
            config[marker] = values[i];
        }

        string += strings[strings.length - 1];

        return new TemplateHTML(string, config);
    }

    function css(strings, ...values) {
        const config = {};
        let string = '';

        for (let i = 0; i < strings.length - 1; i++) {
            const marker = makeMarker();
            string += strings[i];
            string += marker;
            config[marker] = values[i];
        }

        string += strings[strings.length - 1];

        return new TemplateCSS(string, config);
    }

    Class(function DOMTemplate() {
        Inherit(this, Element);
        const _this = this;

        this.data = [];

        if (Hydra.LOCAL && window.UILSocket) {
            let name = Utils.getConstructorName(_this);
            _this.events.sub(UILSocket.JS_FILE, e => {
                if (e.file.includes(name)) {
                    DOMTemplate.updateGlobalStyles();
                    _this.update();
                }
            });
        }

        function update() {
            let cssContent;
            if (_this.dynamicStyle) cssContent = _this.dynamicStyle(css).inflate(_this.element.div);
            _this.render?.(html).inflate?.(_this.element.div, cssContent);
            _this.postRender?.();
        }

        /**
         * @name this.update
         * @memberof DOMTemplate
         *
         * @function
         */
        this.update = function () {
            DOMTemplate.clearScheduled(update);
            DOMTemplate.schedule(update);
        };

        /**
         * @name this.render
         * @memberof DOMTemplate
         *
         * @function
         * @param html
         */
        this.render = function (html) {
            throw new Error('render() needs to be overwritten.');
        };

        /**
         * @name this.setSourceData
         * @memberof DOMTemplate
         *
         * @function
         * @param data
         */
        this.setSourceData = function(data) {
            _this.data = data;
            this.update();
            _this.events.sub(data, Events.UPDATE, this.update);
        }
        _this.update();
    }, _ => {
        DOMTemplate.parser = new DOMParser();

        const queue = [];
        const worker = new Render.Worker(_ => {
            let callback = queue.shift();
            if (callback) callback();
            else worker.pause();
        }, 2);
        worker.pause();

        DOMTemplate.schedule = function(callback) {
            queue.push(callback);
            worker.resume();
        }

        DOMTemplate.clearScheduled = function(callback) {
            for (let i = 0; i < queue.length; i++) {
                let cb = queue[i];
                if (cb == callback) return queue.splice(i, 1);
            }
        }

        var _css;
        DOMTemplate.updateGlobalStyles = function() {
            Utils.debounce(async _ => {
                let css = await get(Assets.getPath('assets/css/style-scss.css'));
                if (!_css) _css = $(document.head).create('DOMTemplate-hotload', 'style');
                _css.div.innerHTML = css;
            }, 20);
        }
    });
})();
/**
 * Mouse input controller class
 * @name Interaction
 * @example
 * const input = new Interaction(Stage);
 * _this.events.sub(input, Interaction.START, e => console.log(e, input.hold));
 * @example
 * // Events include
 * // Interaction.START - cursor down
 * // Interaction.MOVE - cursor move
 * // Interaction.DRAG - cursor move while down
 * // Interaction.END - cursor up
 * // Interaction.CLICK - cursor up within time and movement limits
 */

Class(function Interaction(_object) {
    Inherit(this, Events);
    const _this = this;
    var _touchId;

    var _velocity = [];
    var _moved = 0;
    var _time = performance.now();

    function Vec2() {
        this.x = 0;
        this.y = 0;
        this.length = function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        };
    }

    var _vec2Pool = new ObjectPool(Vec2, 10);

    /**
     * Current mouse x position
     * @name x
     * @memberof Interaction
     */
    this.x = 0;

    /**
     * Current mouse y position
     * @name y
     * @memberof Interaction
     */
    this.y = 0;

    /**
     * Value of last cursor down event position.
     * Object with x, y properties, and length method.
     * @name hold
     * @memberof Interaction
     */
    this.hold = new Vec2();

    /**
     * Value of cursor position from last event.
     * Object with x, y properties, and length method.
     * @name last
     * @memberof Interaction
     */
    this.last = new Vec2();

    /**
     * Movement since last cursor event position.
     * Object with x, y properties, and length method.
     * @name delta
     * @memberof Interaction
     */
    this.delta = new Vec2();

    /**
     * Movement since last down event position.
     * Object with x, y properties, and length method.
     * @name move
     * @memberof Interaction
     */
    this.move = new Vec2();

    /**
     * Movement delta divided by time delta.
     * Object with x, y properties, and length method.
     * @name velocity
     * @memberof Interaction
     */
    this.velocity = new Vec2();

    let _distance, _timeDown, _timeMove;

    //*** Constructor
    (function () {
        if (!_object instanceof HydraObject) throw `Interaction.Input requires a HydraObject`;
        addHandlers();
        Render.start(loop);
    })();

    function loop() {
        if (_moved++ > 10) {
            _this.velocity.x = _this.velocity.y = 0;
            _this.delta.x = _this.delta.y = 0;
        }
    }

    function addHandlers() {
        if (_object == Stage || _object == __window) Interaction.bind('touchstart', down);
        else {
            _object.bind('touchstart', down);
            Interaction.bindObject(_object);
        }

        Interaction.bind('touchmove', move);
        Interaction.bind('touchend', up);
        Interaction.bind('leave', leave);
    }

    //*** Event handlers
    function down(e) {
        if ((_this.isTouching && !_this.multiTouch) || (e.target.className == 'hit' && e.target.hydraObject != _object) || Interaction.hitIsBound(e.target, _object)) return;
        _this.isTouching = true;

        let x = e.x;
        let y = e.y;

        if (e.changedTouches) {
            x = e.changedTouches[0].clientX;
            y = e.changedTouches[0].clientY;
            _touchId = e.changedTouches[0].identifier;
        }

        if (e.touches && typeof e.touches[0].force === 'number') e.force = e.touches[0].force;

        e.x = _this.x = x;
        e.y = _this.y = y;

        _this.hold.x = _this.last.x = x;
        _this.hold.y = _this.last.y = y;

        _this.delta.x = _this.move.x = _this.velocity.x = 0;
        _this.delta.y = _this.move.y = _this.velocity.y = 0;
        _distance = 0;

        _this.events.fire(Interaction.START, e, true);
        _timeDown = _timeMove = Render.TIME;
    }

    function move(e) {
        if (!_this.isTouching && !_this.unlocked) return;
        let now = performance.now();
        if (now - _time < 16) return;
        _time = now;

        let x = e.x;
        let y = e.y;

        if (e.touches) {
            for (let i = 0; i < e.touches.length; i++) {
                let touch = e.touches[i];
                if (touch.identifier == _touchId) {
                    x = touch.clientX;
                    y = touch.clientY;
                }
            }
        }

        if (_this.isTouching) {
            _this.move.x = x - _this.hold.x;
            _this.move.y = y - _this.hold.y;
        }

        if (e.touches && typeof e.touches[0].force === 'number') e.force = e.touches[0].force;

        e.x = _this.x = x;
        e.y = _this.y = y;

        _this.delta.x = x - _this.last.x;
        _this.delta.y = y - _this.last.y;

        _this.last.x = x;
        _this.last.y = y;

        _moved = 0;

        _distance += _this.delta.length();

        let delta = Render.TIME - (_timeMove || Render.TIME);
        _timeMove = Render.TIME;

        if (delta > 0.01) {
            let velocity = _vec2Pool.get();
            velocity.x = Math.abs(_this.delta.x) / delta;
            velocity.y = Math.abs(_this.delta.y) / delta;

            _velocity.push(velocity);
            if (_velocity.length > 5) _vec2Pool.put(_velocity.shift());
        }

        _this.velocity.x = _this.velocity.y = 0;

        for (let i = 0; i < _velocity.length; i++) {
            _this.velocity.x += _velocity[i].x;
            _this.velocity.y += _velocity[i].y;
        }

        _this.velocity.x /= _velocity.length;
        _this.velocity.y /= _velocity.length;

        _this.velocity.x = _this.velocity.x || 0;
        _this.velocity.y = _this.velocity.y || 0;

        _this.events.fire(Interaction.MOVE, e, true);
        if (_this.isTouching) _this.events.fire(Interaction.DRAG, e, true);
    }

    function up(e) {
        if (e && e.changedTouches) {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier != _touchId) return;
            }
        }
        if (!_this.isTouching && !_this.unlocked) return;
        _this.isTouching = false;

        _this.move.x = 0;
        _this.move.y = 0;

        // If user waited without moving before releasing, clear delta movement for correct inertia calculation
        let delta = Math.max(0.001, Render.TIME - (_timeMove || Render.TIME));
        if (delta > 100) {
            _this.delta.x = 0;
            _this.delta.y = 0;
        }

        // If moved less than 20 pixels and quicker than 1000 milliseconds
        if (_distance < 20 && Render.TIME - _timeDown < 1000 && !e.isLeaveEvent) {
            _this.events.fire(Interaction.CLICK, e, true);
        }

        _this.events.fire(Interaction.END, e, true);

        if (Device.mobile) _this.velocity.x = _this.velocity.y = 0;
    }

    function leave() {
        if (_this.ignoreLeave) return;
        _this.delta.x = 0;
        _this.delta.y = 0;
        up({isLeaveEvent: true});
    }

    //*** Public methods
    this.onDestroy = function() {
        Interaction.unbind('touchstart', down);
        Interaction.unbind('touchmove', move);
        Interaction.unbind('touchend', up);
        Render.stop(loop);
        Interaction.unbindObject(_object);
        _object && _object.unbind && _object.unbind('touchstart', down);
    }
}, () => {
    Namespace(Interaction);

    Interaction.CLICK = 'interaction_click';
    Interaction.START = 'interaction_start';
    Interaction.MOVE = 'interaction_move';
    Interaction.DRAG = 'interaction_drag';
    Interaction.END = 'interaction_end';

    const _objects = [];
    const _events = {touchstart: [], touchmove: [], touchend: [], leave: []};

    Hydra.ready(async () => {
        await defer();
        __window.bind('touchstart', touchStart);
        __window.bind('touchmove', touchMove);
        __window.bind('touchend', touchEnd);
        __window.bind('touchcancel', touchEnd);
        __window.bind('contextmenu', touchEnd);
        __window.bind('mouseleave', leave);
        __window.bind('mouseout', leave);
    });

    function touchMove(e) {
        _events.touchmove.forEach(c => c(e));
    }

    function touchStart(e) {
        _events.touchstart.forEach(c => c(e));
    }

    function touchEnd(e) {
        _events.touchend.forEach(c => c(e));
    }

    function leave(e) {
        e.leave = true;
        _events.leave.forEach(c => c(e));
    }

    Interaction.bind = function(evt, callback) {
        _events[evt].push(callback);
    };

    Interaction.unbind = function(evt, callback) {
        _events[evt].remove(callback);
    };

    Interaction.bindObject = function(obj) {
        _objects.push(obj);
    };

    Interaction.unbindObject = function(obj) {
        _objects.remove(obj);
    };

    Interaction.hitIsBound = function(element, boundObj) {
        let obj = element.hydraObject;
        if (!obj) return false;

        while (obj) {
            if (obj != boundObj && _objects.includes(obj)) return true;
            obj = obj._parent;
        }

        return false;
    }
});
/**
 * Mouse global position
 * @name Mouse
 */

Class(function Mouse() {
    Inherit(this, Events);
    const _this = this;
    /**
     * Current mouse x position
     * @name Mouse.x
     * @memberof Mouse
     */
    this.x = 0;

    /**
     * Current mouse y position
     * @name Mouse.y
     * @memberof Mouse
     */
    this.y = 0;

    /**
     * Current mouse x position in window from 0 > 1
     * @name Mouse.normal
     * @memberof Mouse
     */
    this.normal = {
        x: 0,
        y: 0,
    };

    /**
     * Current mouse x position in window from -1 > 1
     * @name Mouse.tilt
     * @memberof Mouse
     */
    this.tilt = {
        x: 0,
        y: 0,
    };

    /**
     * Current mouse x position in window from 0 > 1 where y is flipped for use in WebGL
     * @name Mouse.inverseNormal
     * @memberof Mouse
     */
    this.inverseNormal = {
        x: 0,
        y: 0,
    };

    /**
     * Have the Mouse x and y values reset to 0,0 when interaction stops on mobile
     * @name Mouse.resetOnRelease
     * @memberof Mouse
     */
    this.resetOnRelease = false;

    const _offset = {
        x: 0,
        y: 0,
    };

    (function() {
        Hydra.ready(init);
    })();

    function init() {

        defer(_ => {
            if (_this.resetOnRelease && Device.mobile) {
                _this.x = Stage.width / 2;
                _this.y = Stage.height / 2;
            }
        });

        /**
         * Interaction instance attached to window.
         * @name Mouse.input
         * @memberof Mouse
         * @example
         * _this.events.sub(Mouse.input, Interaction.MOVE, move);
         */
        _this.input = new Interaction(__window);
        _this.input.unlocked = true;
        _this.events.sub(_this.input, Interaction.START, start);
        _this.events.sub(_this.input, Interaction.MOVE, update);
        _this.events.sub(_this.input, Interaction.END, end);

        _this.hold = _this.input.hold;
        _this.last = _this.input.last;
        _this.delta = _this.input.delta;
        _this.move = _this.input.move;
        _this.velocity = _this.input.velocity;

        // Defer to be called after Stage is possibly manipulated
        defer(() => {
            _this.events.sub(Events.RESIZE, resize);
            resize();
        });
    }

    function start(e) {
    	_this.down = true;
    	update(e);
    }

    function update(e) {
        _this.x = e.x;
        _this.y = e.y;

        if (!Stage.width || !Stage.height) return;

        _this.normal.x = e.x / Stage.width - _offset.x;
        _this.normal.y = e.y / Stage.height - _offset.y;
        _this.tilt.x = _this.normal.x * 2.0 - 1.0;
        _this.tilt.y = 1.0 - _this.normal.y * 2.0;
        _this.inverseNormal.x = _this.normal.x;
        _this.inverseNormal.y = 1.0 - _this.normal.y;
    }

    function end(e) {
        _this.down = false;
        if (Device.mobile && _this.resetOnRelease) update({x: Stage.width/2, y: Stage.height/2});
    }

    function resize() {
        if (Stage.css('top')) _offset.y = Stage.css('top') / Stage.height;
        if (Stage.css('left')) _offset.x = Stage.css('left') / Stage.width;
    }

}, 'Static');
/**
 * @name Keyboard
 */

Class(function Keyboard() {
    Inherit(this, Component);
    var _this = this;

   /**
    * @name DOWN
    * @memberof Keyboard
    * @property
    */
    _this.DOWN = 'keyboard_down';
   /**
    * @name PRESS
    * @memberof Keyboard
    * @property
    */
    _this.PRESS = 'keyboard_press';
   /**
    * @name UP
    * @memberof Keyboard
    * @property
    */
    _this.UP = 'keyboard_up';

    //*** Constructor
    (function () {
        Hydra.ready(addListeners);
    })();

    //*** Event handlers
    function addListeners() {
        __window.keydown(keydown);
        __window.keyup(keyup);
        __window.keypress(keypress);
    }

    function keydown(e) {
        _this.events.fire(_this.DOWN, e);
    }

    function keyup(e) {
        _this.events.fire(_this.UP, e);
    }

    function keypress(e) {
        _this.events.fire(_this.PRESS, e);
    }

    //*** Public methods

}, 'static');
/**
 * @name Mobile
 */

Class(function Mobile() {
    Inherit(this, Component);
    Namespace(this);
    const _this = this;

    var $html;
    var $featureDetects;
    var _is100vh = false;

    Hydra.ready(() => {
        if (!Device.mobile) return;

        initFeatureDetects();
        addHandlers();

        // mobile full screen hack
        // if (Device.mobile?.phone && !Device.mobile.native) {
        //     $html = $(document.documentElement);
        //     let ios = Device.system.browser === 'safari';
        //     if (ios) {
        //         $html.div.classList.add('ios');
        //     } else {
        //         $html.div.classList.add('mob');
        //     }
        //     _is100vh = true;
        //     if (ios) __body.css({height: '100%'}).div.scrollTop = 0;
        //     updateMobileFullscreen();
        // }
        if (Device.mobile.native || Device.system.os == 'ios') {
            if (Stage.width > Stage.height) Stage.css({width: '100vw', height: '100vh'});
            else Stage.css({width: '100%', height: '100%'});
        }
    });

    function initFeatureDetects() {
        $featureDetects = __body.create('feature-detects');
    }

    function addHandlers() {
        _this.events.sub(Events.RESIZE, resize);
        if (!Device.mobile.native) window.addEventListener('touchstart', preventNativeScroll, {passive: false});
    }

    function preventNativeScroll(e) {
        if (_this.isAllowNativeScroll) return;

        let target = e.target;

        // Return if element is input type
        if (target.nodeName == 'LABEL' || target.nodeName == 'INPUT' || target.nodeName == 'TEXTAREA' || target.nodeName == 'SELECT' || target.nodeName == 'A') return;

        // Only prevent if none of the elements have requested native scroll using Mobile.overflowScroll()
        let prevent = target.hydraObject;
        while (target.parentNode && prevent) {
            if (target._scrollParent) prevent = false;
            target = target.parentNode;
        }
        if (prevent) e.preventDefault();
    }

    function resize() {
        updateOrientation();
        checkResizeRefresh();
        updateMobileFullscreen();

        if (Stage.width > Stage.height) Stage.css({width: '100vw', height: '100vh'});
        else Stage.css({width: '100%', height: '100%'});

        // Keep page scrolled to the top for iOS fullscreen 101% hack
        if (!_this.isAllowNativeScroll) document.body.scrollTop = 0;
    }

    function updateOrientation() {
        _this.orientation = Stage.width > Stage.height ? 'landscape' : 'portrait';
        if (!_this.orientationSet) return;
        if (!window.Fullscreen.isOpen && !Device.mobile.pwa) return;
        if (window.screen && window.screen.orientation) window.screen.orientation.lock(_this.orientationSet);
    }

    const checkResizeRefresh = (function() {
        let _lastWidth;
        return function() {
            if (_this.isPreventResizeReload) return;
            if (_lastWidth == Stage.width) return;
            _lastWidth = Stage.width;
            if (Device.system.os !== 'ios' && !(Device.system.os == 'android' && Device.system.version >= 7)) return;

            // Need to use stage as screen doesn't reflect when user sets app to half of screen on tablet
            if (Device.mobile.tablet && !(Math.max(Stage.width, Stage.height) > 800)) window.location.reload();
        }
    })();

    function updateMobileFullscreen() {
        // iOS full screen hack, also works on Android Chrome after exiting a
        // fullscreen video.
        // if ($html) {
        //     let vh100 = $featureDetects.div.offsetHeight;
        //     if ($html.div.offsetHeight !== Stage.height) {
        //         if (Stage.height === vh100) {
        //             $html.css({height: ''});
        //             _is100vh = true;
        //         } else {
        //             $html.css({height: Stage.height});
        //             _is100vh = false;
        //         }
        //     } else if (!_is100vh && Stage.height === vh100) {
        //         $html.css({height: ''});
        //         _is100vh = true;
        //     }
        // }
    }

    //*** Public Methods
    /**
     * @name Mobile.vibrate
     * @memberof Mobile
     *
     * @function
     * @param {Number} duration
     */
    this.vibrate = function(duration) {
        navigator.vibrate && navigator.vibrate(duration);
    };

    /**
     * Add handler on touchend to go to fullscreen. Android-only.
     * @name Mobile.fullscreen
     * @memberof Mobile
     *
     * @function
     */
    this.fullscreen = function(now) {

        // Return if Native, Progressive Web App, or Emulator
        if (!Device.mobile || Device.mobile.native || Device.mobile.pwa || Dev.emulator) return;

        if (!window.Fullscreen) throw `Mobile.fullscreen requires Fullscreen module`;

        // Fullscreen doesn't work on iOS
        if (Device.system.os !== 'android') return;
        __window.bind('touchend', () => {
            Fullscreen.open();
        });

        if (now) Fullscreen.open();

        if (_this.ScreenLock && _this.ScreenLock.isActive) window.onresize();
    };

    /**
     * Lock orientation if possible.
     * If orientation is utterly important, pass isForce as true - this will force portrait orientation only by rotating stage when necessary.
     * Forced orientation required ScreenLock module.
     * @name Mobile.setOrientation
     * @memberof Mobile
     *
     * @function
     * @param {String} orientation - Either 'portrait' or 'landscape'
     * @param {Boolean} [isForce] Whether to force portrait by rotating stage. For iOS mainly, or Android when not fullscreen.
     */
    this.setOrientation = function(orientation, isForce) {
        // Native orientation lock
        if (_this.System && _this.NativeCore.active) return _this.System.orientation = _this.System[orientation.toUpperCase()];

        _this.orientationSet = orientation;

        updateOrientation();

        if (!isForce) return;
        if (!_this.ScreenLock) throw `Mobile.setOrientation isForce argument requires ScreenLock module`;
        if (orientation === 'any') _this.ScreenLock.unlock();
        else _this.ScreenLock.lock();
    };

    /**
     * Returns a boolean indicating if the user has selected an input or text field and has the keyboard open
     * @name Mobile.isKeyboardOpen
     * @memberof Mobile
     *
     * @function
     */
    this.isKeyboardOpen = function() {
        return Device.mobile && document.activeElement.tagName.toLowerCase().includes(['textarea', 'input']);
    };

    /**
     * Stops preventing default on touch. This will make the body shift on touchmove, which is unwanted in full-screen experiences.
     * @name Mobile.allowNativeScroll
     * @memberof Mobile
     *
     * @function
     */
    this.allowNativeScroll = function() {
        _this.isAllowNativeScroll = true;
        [
            $(document.documentElement),
            __body,
            Stage,
        ].forEach($el => $el.css({
            touchAction: 'unset',
            MSContentZooming: 'unset',
            MSTouchAction: 'unset',
        }));
    };

    /**
     * Prevent reload when resize is so drastic that re-definition of phone/tablet required
     * @name Mobile.preventResizeReload
     * @memberof Mobile
     *
     * @function
     */
    this.preventResizeReload = function() {
        _this.isPreventResizeReload = true;
    };

    /**
     * @name Mobile.addOverflowScroll
     * @memberof Mobile
     * @private
     *
     * @function
     * @param {HydraObject} $obj
     */
    this._addOverflowScroll = function($obj) {
        $obj.div._scrollParent = true;
        if (Device.mobile.native) return;
        $obj.div._preventEvent = function(e) {
            e.stopPropagation();
        };
        $obj.bind('touchmove', $obj.div._preventEvent);
    };

    /**
     * @name Mobile.removeOverflowScroll
     * @memberof Mobile
     * @private
     *
     * @function
     * @param {HydraObject} $obj
     */
    this._removeOverflowScroll = function($obj) {
        $obj.unbind('touchmove', $obj.div._preventEvent);
    };

    this.get('phone', () => {
        throw 'Mobile.phone is removed. Use Device.mobile.phone';
    });

    this.get('tablet', () => {
        throw 'Mobile.tablet is removed. Use Device.mobile.tablet';
    });

    this.get('os', () => {
        throw 'Mobile.os is removed. Use Device.system.os';
    });

    (function() {
        var _props = [
            '--safe-area-inset-top',
            '--safe-area-inset-right',
            '--safe-area-inset-bottom',
            '--safe-area-inset-left',
        ];

        function getSafeAreaInset(index) {
            if (!$featureDetects) return 0;
            let style = getComputedStyle($featureDetects.div);
            return parseInt(style.getPropertyValue(_props[index])) || 0;
        }

        _this.getSafeAreaInsets = () => _props.map((_, i) => getSafeAreaInset(i));
        _this.getSafeAreaInsetTop = () => getSafeAreaInset(0);
        _this.getSafeAreaInsetRight = () => getSafeAreaInset(1);
        _this.getSafeAreaInsetBottom = () => getSafeAreaInset(2);
        _this.getSafeAreaInsetLeft = () => getSafeAreaInset(3);
    })();

}, 'Static');


Class(function PushState(_isHash) {
    const _this = this;
    let _store, _useInternal

    let _root = '';

    if (typeof _isHash !== 'boolean') _isHash = Hydra.LOCAL || !Device.system.pushstate;

    this.isLocked = false;

    //*** Constructor
    (function() {
        if (!_this.flag) throw 'Inherit PushState/Router after main class';
        _this.flag('isNotBlocked', true);
        addHandlers();
        _store = getState();
    })();

    function addHandlers() {
        if (_isHash) return window.addEventListener('hashchange', () => handleStateChange(getState()), false);
        window.onpopstate = history.onpushstate = () => handleStateChange(getState());
    }

    function getState() {
        if (_useInternal) return new String(_store);
        else if (_isHash) return String(window.location.hash.slice(3));
        return (_root !== '/' ? location.pathname.split(_root)[1] : location.pathname.slice(1)) || '';
    }

    function handleStateChange(state, forced) {
        if (state === _store && !forced) return;
        if (_this.isLocked && !forced) {
            if (!_store) return;
            if (_useInternal) _store = _store;
            else if (_isHash) window.location.hash = '!/' + _store;
            else window.history.pushState(null, null, _root + _store);
            return;
        }
        _store = state;
        _this.events.fire(Events.UPDATE, {value: state, split: state.split('/')});
    }

    //*** Public methods

    this.getState = this._getState = function() {
        if (Device.mobile.native) return Storage.get('app_state') || '';
        return getState();
    };

    this.setRoot = function(root) {
        _root = root.charAt(0) === '/' ? root : '/' + root;
    };

    this.setState = this._setState  = async function(state, forced) {
        _this.events.fire(PushState.SET_STATE);
        await _this.wait('isNotBlocked');
        if (Device.mobile.native) Storage.set('app_state', state);
        if (state === _store && !forced) return;

        if (_useInternal) _store = state;
        else if (_isHash) window.location.hash = '!/' + state;
        else window.history.pushState(null, null, _root + state);

        if (_this.fireChangeWhenSet) handleStateChange(getState(), forced);
        _store = state;
        return true;
    };

    this.enableBlocker = function() {
        _this.flag('isNotBlocked', false);
    };

    this.disableBlocker = function() {
        _this.flag('isNotBlocked', true);
    };

    this.replaceState = function(state) {
        if (state === _store) return;
        _store = state;
        if (_useInternal) _store = state;
        if (_isHash) window.location.hash = '!/' + state;
        else window.history.replaceState(null, null, _root + state);
    };

    this.setTitle = function(title) {
        document.title = title;
    };

    this.lock = function() {
        this.isLocked = true;
        _this.events.fire(PushState.LOCK);
    };

    this.unlock = function() {
        this.isLocked = false;
        _this.events.fire(PushState.UNLOCK);
    };

    this.useHash = function() {
        _isHash = true;
    };

    this.useInternal = function() {
        _useInternal = true;
    };
}, _ => {
    PushState.SET_STATE = 'push_state_set_state';
    PushState.LOCK = 'push_state_lock';
    PushState.UNLOCK = 'push_state_unlock';
});
/**
 * @name Router
 * @example https://www.notion.so/activetheory/Router-640a48eeef824aecad4d56e4822347e5
 */

Class(function Router(_isHash, _rootPath) {
  Inherit(this, PushState, _isHash);
  const _this = this;
  var _debounce, _prevView, _nextView;

  var _routes = [];
  var _404Route;

  _this.currentRoute = null;
  _this.fireChangeWhenSet = true;

  //*** Constructor
  (function () {
    setRootPath();
    initEvents();
  })();

  function initEvents() {
    _this.events.sub(_this, Events.UPDATE, handleState);
  }

  function matchRoute(path) {
    let matchedRoute = null;

    _routes.forEach(routesList => {
      const match = routesList.list.find(route => {
        // match on the route root
        if (route.root === path[0]) {

          if((route.pathSplit.length === path.length) && route.pathSplit[path.length - 1] === '*') {
            // the route we're at is a wildcard
            return true;
          }
          if (!path[1] && !route.params) {
            // route has no params
            return true;
          } else if (path[1] && route.params && !((route.children && route.children.length > 0) || path[2])) {
            // route has param without nesting
            return true;
          } else if (path[1] && (route.children && route.children.length > 0)) {
            // route has param with nesting
            route.children.forEach(c => {
              c.active = c.path === path[2]
            });
            return true;
          } else if (path[1] && route.pathSplit.length === path.length) {
            // if a static route like /test/child, and we found a match this will get hit.
            let didMatchAll = true;
            route.pathSplit.forEach((pathSplitPath, index) => {
              if(pathSplitPath !== path[index]) {
                didMatchAll = false;
              }
            });

            if(didMatchAll) {
              return true;
            }
          }
        }

        return false;
      })

      if (match) {
        matchedRoute = match;
      }
    })

    return matchedRoute;
  }

  function handleState(e) {
    let value = e?.value;
    let split = e?.split;

    if (!value) {
      value = _this.getState();
      split = value.split('/');
    }

    let route = null;
    let cb = null;

    _this.lock();

    _routes.forEach(({ callback, list }) => {
      if (route) {
        return
      }
      route = matchRoute(split);
      cb = callback;
    });

    if(route && route.redirect) {
      let redirectedRoute = matchRoute(route.redirect.split('/'));
      if(redirectedRoute) {
        if(route.updateURL) {
          //if we need to update the URL, lets set the appstate, which will re-hit this handleState function.
          _this.unlock();
          _this.setState(route.redirect);
          return;
        }
        //else, lets set the route to the one we've chosen to go to.
        route = redirectedRoute;
      }
    }

    if (!route) {
      route = _404Route;
    }

    doRoute(route, split, cb)
  }

  async function doRoute(route, split, callback) {
    _nextView = route.view;

    let params = null;

    if (route.params) {
      params = {
        [Object.keys(route.params)[0]]: split?.[1]
      }
    } else {
      params = split?.[1]
    }

    await callback(_prevView, _nextView, split.join('/'), params, route);
    await _nextView?.onRouteChange?.({ params, path: split.join('/'), name: route.name, children: route.children, meta: route.meta });

    _prevView = _nextView;
    _this.currentRoute = {...route, params};
    _this.unlock();
  }

  function setRootPath(val) {
    let rootPath;
    if (typeof _rootPath === 'string') {
      //if this has manually been set in the constructor
      rootPath = _rootPath;
    } else {
      rootPath = Hydra.LOCAL ? '' : '/'; //without this, no routes get picked up on prod.
    }
    _this.setRoot(rootPath); //on PushState.js
  }

  //*** Public methods
  /**
   * @name this.registerRoutes
   * @memberof Router
   *
   * @function
   * @param callback
   * @param list
  */
  this.registerRoutes = function (callback, list) {
    // check routes with params and append params to a seperate object
    list.forEach(element => {
      const split = element.path.split('/');
      if(element.path.startsWith('/')) {
        throw new Error('router paths should not start with /');
      }
      element.root = split[0];
      element.pathSplit = split;

      if(element.path === '404') {
        _404Route = element;
      }
      split.forEach(s => {
        if (s[0] === ':') {
          element.params = {
            [`${s.substring(1)}`]: ''
          }
          return;
        }
      })
    });

    if(!_404Route) {
      throw new Error('Error: no 404 route defined.  Please define a route whos path is "404" ')
    }

    _routes.push({ callback, list });
    clearTimeout(_debounce);
    _debounce = _this.delayedCall(handleState, 1);
  }

  /**
   * @name this.navigate
   * @memberof Router
   * - navigates to a new URL
   * @function
   * @param path - a path to navigate to.
  */
  this.navigate = function(path) {
    if(path.startsWith('/')) {
      path = path.substring(1);
    }
    _this.setState(path);
  }

  /**
   * @name this.navigate
   * @memberof Router
   * - updates the URL only.
   * @function
   * @param path - a path to navigate to.
  */
  this.replace = function(path) {
    if(path.startsWith('/')) {
      path = path.substring(1);
    }
    _this.replaceState(path);
  }

  /**
   * @name this.getState
   * @memberof Router
   *
   * @function
   * @returns {String}
   */

  /**
   * @name this.setRoot
   * @memberof Router
   *
   * @function
   * @param {String} root
   */

  /**
   * @name this.setState
   * @memberof Router
   *
   * @function
   * @param {String} state
   */

  /**
   * @name this.enableBlocker
   * @memberof Router
   *
   * @function
   */

  /**
   * @name this.replaceState
   * @memberof Router
   *
   * @function
   * @param {String} state
   */

  /**
   * @name this.setTitle
   * @memberof Router
   *
   * @function
   * @param {String} title
   */

  /**
   * @name this.unlock
   * @memberof Router
   *
   * @function
   */
  /**
   * @name this.lock
   * @memberof Router
   *
   * @function
   */
  /**
   * @name this.useInternal
   * @memberof Router
   *
   * @function
   */
  /**
   * @name this.useHash
   * @memberof Router
   *
   * @function
   */
});
/**
 * @name AppState
 */

Class(function AppState(_default) {
    const _this = this;

    var _map = new Map();
    var _bindings = new Map();

    const iGLUI = !!window.GLUI;

    //internal class
    class StateBinding {
        constructor(_keys, _obj) {
            this._keys = _keys;
            this._obj = _obj;
            this._string = '';
            this._oldValue = '';
            this._type = '';
            this._bindingLookup = '';

            if (_obj instanceof HTMLElement) {
                if (_obj.nodeName == 'INPUT') this._string = _obj.value;
                else this._string = _obj.innerText;
                this._type = 'HTMLElement';
            } else if (_obj instanceof DOMAttribute) {
                this._string = _obj.value
                this._name = _obj.name
                this._belongsTo = _obj.belongsTo
                this._bindingLookup = _obj.bindingLookup
                this._type = 'DOMAttribute'
            } else if (_obj instanceof HydraObject) {
                if (_obj._type == 'input') this._string = _obj.val();
                else this._string = _obj.text();
                this._type = 'HydraObject';
            } else if (iGLUI && _obj instanceof GLUIText) {
                this._string = _obj.getTextString();
                this._type = 'GLUIText';
            } else {
                if (!!_obj.createLocal) this._type = 'appState';
                if (!!_obj.onStateChange) this._type = 'class';
                if (typeof _obj === 'function') this._type = 'function';
            }
        }

        parse(key, value) {
            if (!this._string || !this._string.includes('@[')) return value;

            let string = this._string;
            this._keys.forEach(key => {
                string = string.replace(`@[${key}]`, _this.get(key));
            });
            return string;
        }

        update(key, value) {
            let newValue = this.parse(key, value);
            if (newValue === this._oldValue && !(value && value.push)) return;
            this._oldValue = newValue;

            switch (this._type) {
                case 'HTMLElement':
                    if (this._obj._type == 'input') this._obj.value = newValue;
                    else this._obj.innerText = newValue;
                    break;

                case 'DOMAttribute':
                    this._obj.belongsTo.setAttribute(this._obj.name, this._obj.value.replace(this._obj.bindingLookup, newValue));
                    break;

                case 'HydraObject':
                    if (this._obj._type == 'input') this._obj.val(newValue);
                    else this._obj.text(newValue);
                    break;

                case 'GLUIText':
                    this._obj.setText(newValue);
                    break;

                case 'function':
                    this._obj(value);
                    break;

                case 'class':
                    this._obj.onStateChange(value);
                    break;

                case 'appState':
                    this._obj.set(key, value);
                    break;

            }
        }

        destroy() {
            this._keys = null
            this._obj = null;
            this._string = null;
            this._oldValue = null;
            this._type = null;
            this.update = null;
        }
    }

    //*** Event handlers

    //*** Public methods
    /**
     * @name this.set
     * @memberof AppState
     *
     * @function
     * @param key
     * @param value
    */
    this.set = function(key, value) {
        _map.set(key, value);
        let array = _bindings.get(key);
        if (array) {
            let len = array.length;
            for (let i = 0; i < len; i++) {
                let b = array[i];
                if (b && b.update) {
                    b.update(key, value);
                } else {
                    array.remove(b);
                }
            }
        }
    }

    /**
     * @name this.get
     * @memberof AppState
     *
     * @function
     * @param key
    */
    this.get = function(key) {
        return _map.get(key);
    }

    this.getMap = function() {
        return _map;
    }

    /**
     * @name this.bind
     * @memberof AppState
     *
     * @function
     * @param keys
     * @param obj
    */
    this.bind = function(keys, obj) {
        if (!obj) return {state: _this, key: keys};
        if (!Array.isArray(keys)) keys = [keys];

        let binding = new StateBinding(keys, obj);

        keys.forEach(key => {
            if (_bindings.has(key)) _bindings.get(key).push(binding);
            else _bindings.set(key, [binding]);

            let value = _map.get(key);
            if (typeof value !== 'undefined') binding.update(key, value);
        });

        return binding;
    }

    /**
     * @name this.createLocal
     * @memberof AppState
     *
     * @function
     * @param obj
    */
    this.createLocal = function(obj) {
        return new AppState(obj);
    }

    this.setAll = function(obj) {
        for (let key in obj) {
            _this.set(key, obj[key]);
        }
    }

    if (_default) this.setAll(_default);

}, 'static');
/**
 * @name AppStore
 */

Class(function AppStore() {
    const _this = this;

    this.state = AppState.createLocal();
    const _mutations = {};
    const _actions = {};
    let _subscribers = [];
    let _actionSubscribers = [];

    // *** Notes
    /*
    A mutation is only a convention.
    It allows us to work the state with a more "human" approach (i.e "Paint the car in red", compared to "set car paint red").
    A mutation can also be bound to one or more subscribers, which is nice for listening to changes in the state.

    An action is a promise that regroups a bunch of mutations together because it makes sense to do so ("Repair the car: change tyres, check oil levels, check brakes"). An action can have "before" and "after" subscribers

    Subscribers are callbacks that respond to a certain mutation/action. Their architecture makes it possible to have multiple callbacks per mutation type.

    See https://github.com/vuejs/vuex/blob/4.0/src/store.js for inspiration
    */

    function setInitState(_params) {
        const { state } = _params;

        for (let key in state) {
            _this.state.set(key, state[key]);
        }
    }

    function mapMutations(_params) {
        const { mutations } = _params;

        for (let key in mutations) {
            registerMutation(key, mutations[key]);
        }
    }

    function mapActions(_params) {
        const { actions } = _params;

        for (let key in actions) {
            registerAction(key, actions[key]);
        }
    }

    function registerMutation(type, handler) {
        // we want to be able to have multiple handlers per type
        const entry = _mutations[type] || (_mutations[type] = []);

        // automaticaly pass the state to the handler and bind _this
        entry.push(function wrappedMutationHandler(payload) {
            handler.call(_this, _this.state, payload);
        });
    }

    function registerAction(type, handler) {
        const entry = _actions[type] || (_actions[type] = []);
        entry.push(function wrappedActionHandler(payload) {
            let res = handler.call(_this, {
                dispatch: _this.dispatch,
                commit: _this.commit,
                state: _this.state,
                rootState: _this.state
            }, payload);

            if (!isPromise(res)) {
                res = Promise.resolve(res);
            }
            return res;
        });
    }

    function isPromise(val) {
        return val && typeof val.then === 'function';
    }

    //*** Event handlers

    //*** Public methods
    /**
     * @name this.createAppStore
     * @memberof AppStore
     *
     * @function
     * @param _params
    */
    this.createAppStore = function(_params) {
        setInitState(_params);
        mapMutations(_params);
        mapActions(_params);
    }


    /**
     * @name this.commit
     * @memberof AppStore
     *
     * @function
     * @param type
     * @param payload
    */
    this.commit = function (type, payload) {
        const mutation = { type, payload };
        const entry = _mutations[type];

        if (!entry) {
            if (Hydra.LOCAL) {
                console.error(`Error: no mutation for type ${type}`);
            }
            return;
        }

        entry.forEach(function commitIterator(handler) {
            handler(payload);
        });

        _subscribers
            .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
            .forEach(sub => sub(mutation, this.state));
    };

    /**
     * @name this.dispatch
     * @memberof AppStore
     *
     * @function
     * @param type
     * @param payload
    */
    this.dispatch = function (type, payload) {
        const action = { type, payload };
        const entry = _actions[type];

        if (!entry) {
            if (Hydra.LOCAL) {
                console.error(`Error: no action for type ${type}`);
            }
        }

        try {
            _actionSubscribers
                .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
                .filter(sub => sub.before)
                .forEach(sub => sub.before(action, _this.state));
        } catch (e) {
            if (Hydra.LOCAL) {
                console.warn('Error in before action subscribers: ');
                console.error(e);
            }
        }

        const result = entry.length > 1 ?
            Promise.all(entry.map(handler => handler(payload))) :
            entry[0](payload);

        return new Promise((resolve, reject) => {
            result.then(res => {
                try {
                    _actionSubscribers
                        .filter(sub => sub.after)
                        .forEach(sub => sub.after(action, _this.state));
                } catch (e) {
                    if (Hydra.LOCAL) {
                        console.warn(`Error in after action subscribers: `);
                        console.error(e);
                    }
                }
                resolve(res);
            }, error => {
                try {
                    _actionSubscribers
                        .filter(sub => sub.error)
                        .forEach(sub => sub.error(action, _this.state, error));
                } catch (e) {
                    if (Hydra.LOCAL) {
                        console.warn(`Error in error action subscribers: `);
                        console.error(e);
                    }
                }
                reject(error);
            });
        });
    };

    function genericSubscribe(fn, subscribers, options) {
        if (subscribers.indexOf(fn) < 0) {
            options && options.prepend ?
                subscribers.unshift(fn) :
                subscribers.push(fn);
        }

        // return the unsubscriber
        return () => {
            const i = subscribers.indexOf(fn);

            if (i > -1) {
                subscribers.splice(i, 1);
            }
        };
    }

    /**
     * @name this.subscribeAction
     * @memberof AppStore
     *
     * @function
     * @param key
     * @param fn
     * @param options
    */
    this.subscribeAction = function (key, fn, options) {
        // when an action happens, all the subscriber wrappers are called and only the ones that correspond to the action type execute the actual subscriber

        function subscriberEmptyBeforeWrapper(action) {
            if (action.type === key) {
                fn(action);
            }
        }

        function subscriberBeforeWrapper(action) {
            if (action.type === key) {
                fn.before(action);
            }
        }

        function subscriberAfterWrapper(action) {
            if (action.type === key) {
                fn.after(action);
            }
        }

        let subs = {};

        if (typeof fn === 'function') {
            subs.before = subscriberEmptyBeforeWrapper;
        } else {
            if (fn.before) {
                subs.before = subscriberBeforeWrapper;
            }

            if (fn.after) {
                subs.after = subscriberAfterWrapper;
            }
        }

        return genericSubscribe(subs, _actionSubscribers, options);
    };

    /**
     * @name this.subscribe
     * @memberof AppStore
     *
     * @function
     * @param key
     * @param fn
     * @param options
    */
    this.subscribe = function (key, fn, options) {
        // when a mutation happens, all the subscriber wrappers are called and only the ones that correspond to the mutation type execute the actual subscriber
        function subscriberWrapper(mutation) {
            if (mutation.type === key) {
                fn(mutation);
            }
        }
        return genericSubscribe(subscriberWrapper, _subscribers, options);
    };

    /**
     * Alias to this.state.bind
     * @name this.bind
     * @memberof AppStore
     *
     * @function
     */
    /**
     * Alias to this.state.watch
     * @name this.watch
     * @memberof AppStore
     *
     * @function
     */
    /**
     * Alias to this.state.get
     * @name this.get
     * @memberof AppStore
     *
     * @function
     */
    this.bind = this.state.bind;
    this.watch = this.state.bind; //an alias that is more vue like

    this.get = this.state.get;
});
/**
 * @name StateArray
 * @example
 */


Class(function StateArray(_src = []) {
    Inherit(this, Events);
    const _this = this;

    var _data = [];

    Object.defineProperty(_this, 'length', {
        get: function () {
            return _data.length;
        }
    });

    function wrap(obj) {
        if (!!obj.bindLocal) return obj;
        if (typeof obj !== 'object' || Array.isArray(obj)) throw `StateArray entries must be {objects}!`;
        let state = AppState.createLocal();
        for (let key in obj) {
            state.set(key, obj[key]);
        }
        state.origin = obj;
        return state;
    }

    /**
     * @name this.push
     * @memberof StateArray
     *
     * @function
     * @param obj
    */
    this.push = function(obj) {
        let state = wrap(obj);
        _data.push(state);
        _this.events.fire(Events.UPDATE, {type: 'add', state});

        let index = _data.length-1;
        if (_this[index] === undefined) {
            Object.defineProperty(_this, index, {
                set: function (v) {
                    for (let key in v) {
                        _data[index].set(key, v[key]);
                    }
                },

                get: function () {
                    return _data[index];
                }
            });
        }

        return state;
    }

    /**
     * @name this.remove
     * @memberof StateArray
     *
     * @function
     * @param obj
    */
    this.remove = function(obj) {
        for (let i = 0; i < _data.length; i++) {
            let state = _data[i];
            if (state.origin === obj || state === obj) {
                _this.events.fire(Events.UPDATE, {type: 'remove', state}, true);
                _data.splice(i, 1);
            }
        }
    }

    /**
     * @name this.forEach
     * @memberof StateArray
     *
     * @function
     * @param cb
    */
    this.forEach = function(cb) {
        _data.forEach(function (...args) {
            return cb.apply(this, args);
        });
    }

    /**
     * @name this.map
     * @memberof StateArray
     *
     * @function
     * @param cb
    */
    this.map = function(cb) {
        let array = [];
        _data.forEach(function (...args) {
            return array.push(cb.apply(this, args));
        });
        return array;
    }

    /**
     * @name this.indexOf
     * @memberof StateArray
     *
     * @function
     * @param obj
    */
    this.indexOf = function(obj) {
        for (let i = 0; i < _data.length; i++) {
            let state = _data[i];
            if (state.origin === obj || state === obj) {
                return i;
            }
        }
    }

    /**
     * @name this.refresh
     * @memberof StateArray
     *
     * @function
     * @param array
    */
    this.refresh = function(array) {
        _this.events.fire(StateArray.REFRESH, {type: 'refresh'}, true);

        if (!Array.isArray(array)) throw `StateArray can only take an array as a parameter`;
        for (let i = 0; i < _data.length; i++) {
            let state = _data[i];
            _this.events.fire(Events.UPDATE, {type: 'remove', state}, true);
        }

        _data.length = 0;
        array.forEach(_this.push);
    }

    this.reflow = function() {
        this.refresh(_data.map(d => d.origin));
    }

    if (!Array.isArray(_src)) throw `StateArray can only take an array as a parameter`;
    _src.forEach(_this.push);
}, _ => {
    StateArray.REFRESH = 'state_array_refresh';
});
/**
 * @name ViewState
 * @example
 */


Class(function ViewState(ViewClass) {
    const _this = this;
    var _stateArray;

    var _instances = this.views = [];

    function remove(data) {
        for (let i = 0; i < _instances.length; i++) {
            let inst = _instances[i];
            if (data == inst.data) {
                _this.onRemoveView?.(inst, i);
                _instances.splice(i, 1);
                return;
            }
        }
    }

    //*** Event handlers
    function dataUpdate(e) {
        switch (e.type) {
            case 'add':
                ViewState.schedule(_this, ViewClass, e.state, _stateArray.indexOf(e.state));
                break;

            case 'remove':
                remove(e.state);
                ViewState.clearScheduled(e.state);
                break;
        }
    }

    //*** Public methods
    /**
     * @name this.setSourceData
     * @memberof ViewState
     *
     * @function
     * @param array
    */
    this.setSourceData = function(array) {
        if (!(array instanceof StateArray)) throw `ViewState::setSourceData must be instance of StateArray`;
        _stateArray = _this.stateArray = array;
        _this.events.sub(array, Events.UPDATE, dataUpdate);

        array.forEach(state => {
            ViewState.schedule(_this, ViewClass, state, _stateArray.indexOf(state));
        });
    }

    /**
     * @name this.onInitialize
     * @memberof ViewState
     *
     * @function
     * @param instance
    */
    this.onInitialize = function(instance) {
        _instances.push(instance);
        _this.onAddView?.(instance, _instances.length-1);
    }
}, _ => {
    const queue = [];
    const worker = new Render.Worker(_ => {
        let obj = queue.shift();
        if (obj) {
            let {ref, ViewClass, data, index} = obj;
            let inst = ref.initClass(ViewClass, data, index);
            inst.data = data;
            ref.onInitialize(inst);
        } else {
            worker.pause();
        }
    }, 2);
    worker.pause();

    ViewState.clearScheduled = function(data) {
        for (let i = 0; i < queue.length; i++) {
            let obj = queue[i];
            if (obj.data === data) return queue.splice(i, 1);
        }
    }

    ViewState.schedule = function(ref, ViewClass, data, index) {
        queue.push({ref, ViewClass, data, index});
        worker.resume();
    }
});
/**
 * Inherit this class to add on some utility methods for subscribing to mutations / actions of an instance of an AppStore.
 * Important note: when using this class you should be inheriting from a class that eventually inherits Component.
 * If not, you should manually call this.unsubscribeAll on your own custom destroy method.
 * @name StateComponent
 * @example
 */
Class(function StateComponent() {
    const _this = this;

    let _mutationsUnsubscribers = [];
    let _actionsUnsubscribers = [];

    /**
     * @name this.unsubscribeMutations
     * @memberof StateComponent
     *
     * @function
    */
    this.unsubscribeMutations = function () {
        _mutationsUnsubscribers.forEach(u => u());
    };

    /**
     * @name this.unsubscribeActions
     * @memberof StateComponent
     *
     * @function
    */
    this.unsubscribeActions = function () {
        _actionsUnsubscribers.forEach(u => u());
    };

    /**
     * @name this.unsubscribeAll
     * @memberof StateComponent
     *
     * @function
    */
    this.unsubscribeAll = function () {
        _this.unsubscribeMutations();
        _this.unsubscribeActions();
    };

    /**
     * @name this.subscribeMutation
     * @memberof StateComponent
     *
     * @function
     * @param store
     * @param type
     * @param fn
    */
    this.subscribeMutation = function (store, type, fn) {
        _mutationsUnsubscribers.push(
            store.subscribe(type, fn)
        );
    };

    /**
     * @name this.subscribeAction
     * @memberof StateComponent
     *
     * @function
     * @param store
     * @param type
     * @param fn
    */
    this.subscribeAction = function (store, type, fn) {
        _actionsUnsubscribers.push(
            store.subscribeAction(type, fn)
        );
    };

    /**
     * @name this.commit
     * @memberof StateComponent
     *
     * @function
     * @param store
     * @param type
     * @param payload
    */
    this.commit = function (store, type, payload) {
        store.commit(type, payload);
    };

    this.dispatch = async function (store, type, payload) {
        await store.dispatch(type, payload);
    };

    /**
     * @name this.getState
     * @memberof StateComponent
     *
     * @function
     * @param store
     * @param key
    */
    this.getState = function (store, key) {
        return store.get(key);
    };

    /**
     * @name this.watch
     * @memberof StateComponent
     *
     * @function
     * @param store
     * @param key
     * @param fn
    */
    this.watch = function(store, key, fn) {
        return store.watch(key, fn);
    };

    this.bind = this.watch;

    if(typeof this._bindOnDestroy === 'function') {
        //this assumes your component you're inheriting with also inherits component.
        //if not, you'll have to manually unsubscribe these events on your own custom destroy method.
        this._bindOnDestroy(() => {
            _this.unsubscribeAll();
        });

    }

});
/**
 * @name Dev
 */

Class(function Dev() {
    var _this = this;
    var _post, _alert, _inter, _timerName;

    var _id = Utils.timestamp();

    this.emulator = Device.mobile && navigator.platform && navigator.platform.toLowerCase().includes(['mac', 'windows']);

    function catchErrors() {
        window.onerror = function(message, file, line, column, e) {
            postError({message, file, line, column, stack: e && e.stack.toString()});
        };

        window.addEventListener("unhandledrejection", e => {
            postError({type: 'unhandledrejection', message: e.reason.message, stack: e.reason.stack});
        });
    }

    function postError(error) {
        let device = {
            gpu: Device.graphics.webgl ? Device.graphics.webgl.gpu : 'WEBGL UNAVAILABLE',
            version: Device.graphics.webgl ? Device.graphics.webgl.version : 'WEBGL UNAVAILABLE',
            tier: Device.mobile ? (GPU ? GPU.M_TIER : GPU.TIER) : '',
            mobile: JSON.stringify(Device.mobile),
            userAgent: Device.agent,
            dpr: Device.pixelRatio,
            screenSize: `${screen.width} x ${screen.height}`,
            stageSize: `${Stage.width} x ${Stage.height}`,
        };

        let tests = {};
        try {
            if (window.Tests) {
                for (let key in Tests) {
                    if (typeof Tests[key] === 'function') {
                        tests[key] = Tests[key]();
                    }
                }
            }
        } catch(e) { }

        post(_post, {error, device, tests}).catch(function () {
            Hydra.LOCAL && console.log('Error whle posting to server')
        })
    }

    function getDebugInfo(string) {
        var obj = {};
        obj.time = new Date().toString();
        obj.deviceId = _id;
        obj.err = string;
        obj.ua = Device.agent;
        obj.width = Stage.width;
        obj.height = Stage.height;
        obj.screenWidth = screen.width;
        obj.screenHeight = screen.height
        return obj;
    }

    //*** Event handlers

    //*** Public Methods
    /**
     * @name this.postErrorsToServer
     * @memberof Dev
     *
     * @function
     * @param server
    */
    this.postErrorsToServer = function(server) {
        _post = server;
        catchErrors();
    }

    /**
     * @name this.expose
     * @memberof Dev
     *
     * @function
     * @param name
     * @param val
     * @param force
    */
    this.expose = function(name, val, force) {
        if (Hydra.LOCAL || force) window[name] = val;
    }

    /**
     * @name this.unsupported
     * @memberof Dev
     *
     * @function
     * @param needsAlert
    */
    this.unsupported = function(needsAlert) {
        if (needsAlert) alert('Hi! This build is not yet ready for this device, things may not work as expected. Refer to build schedule for when this device will be supported.');
    }

    /**
     * @name this.checkForLeaks
     * @memberof Dev
     *
     * @function
     * @param flag
     * @param array
    */
    this.checkForLeaks = function(flag, array) {
        if (window.AURA) return;

        var matchArray = function(prop) {
            if (!array) return false;
            for (var i = 0; i < array.length; i++) {
                if (prop.includes(array[i])) return true;
            }
            return false;
        };

        clearInterval(_inter);
        if (flag) {
            _inter = setInterval(function() {
                for (var prop in window) {
                    if (prop.includes('webkit')) continue;
                    var obj = window[prop];
                    if (typeof obj !== 'function' && prop.length > 2) {
                        if (prop.includes('_ga') || prop.includes('_typeface_js') || matchArray(prop)) continue;
                        var char1 = prop.charAt(0);
                        var char2 = prop.charAt(1);
                        if (char1 == '_' || char1 == '$') {
                            if (char2 !== char2.toUpperCase()) {
                                console.log(window[prop]);
                                throw 'Hydra Warning:: '+prop+' leaking into global scope';
                            }
                        }
                    }
                }
            }, 1000);
        }
    }

    /**
     * @name this.startTimer
     * @memberof Dev
     *
     * @function
     * @param name
    */
    this.startTimer = function(name) {
        _timerName = name || 'Timer';
        if (console.time && !window._NODE_) console.time(_timerName);
        else _timer = performance.now();
    }

    /**
     * @name this.stopTimer
     * @memberof Dev
     *
     * @function
    */
    this.stopTimer = function() {
        if (console.time && !window._NODE_) console.timeEnd(_timerName);
        else console.log('Render '+_timerName+': '+(performance.now() - _timer));
    }

    /**
     * @name this.writeFile
     * @memberof Dev
     *
     * @function
     * @param file
     * @param data
    */
    this.writeFile = function(file, data) {
        let promise = Promise.create();
        let protocol = location.protocol;
        let port = protocol === 'https:' ? ':8018' : ':8017';
        let url = protocol + '//' + location.hostname + port + location.pathname + file;
        post(url, data, {headers: {'content-type': 'text/plain'}}).then(e => {
            if (e != 'OK') {
                console.warn(`Unable to write to ${file}`);
                promise.reject();
            } else {
                promise.resolve();
            }
        });
        return promise;
    }

    /**
     * @name this.execUILScript
     * @memberof Dev
     *
     * @function
     * @param name
     * @param data
     */
    this.execUILScript = async function(name, data) {
        if (!Hydra.LOCAL) return;
        let url = location.protocol + '//' + location.hostname + ':8017' + (_this.pathName || location.pathname) + '/uil/' + name;
        let response = await post(url, data, {headers: {'content-type': 'text/plain'}});
        if (response == 'ERROR') throw response;
        return response;
    }

    if (Hydra.LOCAL) _this.checkForLeaks(true);
}, 'Static');

/**
 * @name Service
 */

Class(function Service() {
    Inherit(this, Component);
    var _this = this;
    var _sw;

   /**
    * @name active
    * @memberof Service
    * @property
    */
    this.active = false;
   /**
    * @name ready
    * @memberof Service
    * @property
    */
    this.ready = false;
   /**
    * @name cached
    * @memberof Service
    * @property
    */
    this.cached = false;
   /**
    * @name offline
    * @memberof Service
    * @property
    */
    this.offline = false;
   /**
    * @name disabled
    * @memberof Service
    * @property
    */
    this.disabled = false;

    //*** Constructor
    (function () {
    })();

    function initWorker() {
        _this.active = true;
        navigator.serviceWorker.register('sw.js').then(handleRegistration).then(handleReady).then(handleError);
    }

    function checkCache() {
        var cache = Storage.get('service_cache');
        if (cache != window._CACHE_) _this.post('clearCache');
    }

    function getSWAssets() {
        if (!window.ASSETS.SW || _this.cached) return [];
        var assets = window.ASSETS.SW;

        assets.forEach((asset, i) => {
            if (asset.includes('.js')) asset = assets[i].replace('.js', '.js?' + window._CACHE_);
        });

        return assets;
    }

    //*** Event handlers
    function handleRegistration(e) {

    }

    function handleReady(e) {
        _this.isReady = true;
        _this.events.fire(Events.READY, e, true);
        _sw = navigator.serviceWorker.controller;

        checkCache();
    }

    function handleError(e) {
        if (e) {
            _this.events.fire(Events.ERROR, e, true);
            _this.active = false;
        }
    }

    function handleMessage(e) {
        var data = e.data;
        if (data.evt) _this.events.fire(data.evt, data);
    }

    //*** Public methods
    /**
     * @name Service.ready
     * @memberof Service
     *
     * @function
    */
    this.ready = function() {
        return this.wait(this, 'isReady');
    }

    /**
     * @name Service.init
     * @memberof Service
     *
     * @function
    */
    this.init = function() {
        Hydra.ready(() => {
            if ('serviceWorker' in navigator && (!Hydra.LOCAL || location.port != '') && !window.process && !_this.disabled) initWorker();
        });
    }

    /**
     * @name Service.cache
     * @memberof Service
     *
     * @function
     * @param assets
    */
    this.cache = function(assets = []) {
        assets = Array.from(assets);

        let upload = function() {
            _this.post('upload', {assets: assets, cdn: Assets.CDN, hostname: location.hostname, sw: getSWAssets(), offline: _this.offline});
            Storage.set('service_cache', window._CACHE_);
            _this.cached = true;
        };

        if (_this.active) _this.wait(_this, 'ready', upload);
    }

    /**
     * @name Service.post
     * @memberof Service
     *
     * @function
     * @param fn
     * @param data
    */
    this.post = function(fn, data = {}) {
        if (!_this.active) return;

        let send = function() {
            let mc = new MessageChannel();
            mc.port1.onmessage = handleMessage;

            data.fn = fn;
            _sw && _sw.postMessage(data, [mc.port2]);
        };

        _this.wait(_this, 'ready', send);
    }
}, 'static');
/**
 * @name Storage
 */

Class(function Storage() {
    var _this = this;
    var _storage;

    (function() {
        testStorage();
    })();

    function testStorage() {
        try {
            if (window.localStorage) {
                try {
                    window.localStorage['test'] = 1;
                    window.localStorage.removeItem('test');
                    _storage = true;
                } catch (e) {
                    _storage = false;
                }
            } else {
                _storage = false;
            }
        } catch(e) {
            _storage = false;
        }
    }

    function cookie(key, value, expires) {
        var options;
        if (arguments.length > 1 && (value === null || typeof value !== "object")) {
            options = {};
            options.path = '/';
            options.expires = expires || 1;

            if (value === null) {
                options.expires = -1;
            }

            if (typeof options.expires === 'number') {
                var days = options.expires, t = options.expires = new Date();
                t.setDate(t.getDate() + days);
            }

            return (document.cookie = [
                encodeURIComponent(key), '=',
                options.raw ? String(value) : encodeURIComponent(String(value)),
                options.expires ? '; expires=' + options.expires.toUTCString() : '',
                options.path ? '; path=' + options.path : '',
                options.domain ? '; domain=' + options.domain : '',
                options.secure ? '; secure' : ''
            ].join(''));
        }

        options = value || {};
        var result, decode = options.raw ? function (s) { return s; } : decodeURIComponent;
        return (result = new RegExp('(?:^|; )' + encodeURIComponent(key) + '=([^;]*)').exec(document.cookie)) ? decode(result[1]) : null;
    }

    //*** Public Methods
    /**
     * @name Storage.setCookie
     * @memberof Storage
     *
     * @function
     * @param key
     * @param value
     * @param expires
    */
    this.setCookie = function(key, value, expires) {
        cookie(key, value, expires);
    }

    /**
     * @name Storage.getCookie
     * @memberof Storage
     *
     * @function
     * @param key
    */
    this.getCookie = function(key) {
        return cookie(key);
    }

    /**
     * @name Storage.set
     * @memberof Storage
     *
     * @function
     * @param key
     * @param value
    */
    this.set = function(key, value) {
        if (value != null && typeof value === 'object') value = JSON.stringify(value);
        if (_storage) {
            if (value === null) window.localStorage.removeItem(key);
            else window.localStorage[key] = value;
        } else {
            cookie(key, value, 365);
        }
    }

    /**
     * @name Storage.get
     * @memberof Storage
     *
     * @function
     * @param key
    */
    this.get = function(key) {
        var val;
        if (_storage) val = window.localStorage[key];
        else val = cookie(key);

        if (val) {
            var char0;
            if (val.charAt) char0 = val.charAt(0);
            if (char0 == '{' || char0 == '[') val = JSON.parse(val);
            if (val == 'true' || val == 'false') val = val == 'true' ? true : false;
        }
        return val;
    }
} ,'Static');
/**
 * @name Thread
 */

Class(function Thread(_class) {
    Inherit(this, Component);
    var _this = this;
    var _worker, _callbacks, _path, _mvc;

    var _msg = {};

    //*** Constructor
    (function() {
        init();
        importClasses();
        addListeners();
    })();

    function init() {
        let file = window._ES5_ ? 'assets/js/hydra/hydra-thread-es5.js' : 'assets/js/hydra/hydra-thread.js';
        _callbacks = {};
        _worker = new Worker(Thread.PATH + file);
    }

    function importClasses() {
        importClass(Utils);
        importClass(Component);
        importClass(Events);
        importClass(_class, true);
        importES5();
    }

    function importClass(_class, scoped) {
        if (!_class) return;
        var code, namespace;

        if (!scoped) {
            if (typeof _class !== 'function') {
                code = _class.constructor.toString();
                if (code.includes('[native')) return;
                namespace = _class.constructor._namespace ? _class.constructor._namespace +'.' : '';
                code = namespace + 'Class(' + code + ', "static");';
            } else {
                namespace = _class._namespace ? _class._namespace+'.' : '';
                code = namespace + 'Class(' + _class.toString() + ');';
            }
        } else {
            code = _class.toString().replace('{', '!!!');
            code = code.split('!!!')[1];

            var splitChar = window._MINIFIED_ ? '=' : ' ';

            while (code.includes('this')) {
                var split = code.slice(code.indexOf('this.'));
                var name = split.split('this.')[1].split(splitChar)[0];
                code = code.replace('this', 'self');
                createMethod(name);
            }

            code = code.slice(0, -1);
            code = code.replace(/_self/g, '_this');
        }

        _worker.postMessage({code: code});
    }

    function createMethod(name) {
        _this[name] = function(message = {}, callback, buffer) {
            let promise;

            if (Array.isArray(callback)) {
                buffer = callback;
                callback = undefined;
            }

            if (Array.isArray(buffer)) {
                message = {msg: message, transfer: true};
                message.buffer = buffer;
            }

            if (callback === undefined) {
                promise = Promise.create();
                callback = promise.resolve;
            }

            _this.send(name, message, callback);
            return promise;
        };
    }

    function importES5() {
        if (!window._ES5_) return;
        [
            '_createSuper',
            '_isNativeReflectConstruct',
        ].forEach(name => {
            let code = window[name].toString();
            if (code.includes('[native')) return;
            _worker.postMessage({code});
        });
        _worker.postMessage({code: `function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}`});
    }

    //*** Event Handlers
    function addListeners() {
        _worker.addEventListener('message', workerMessage);
    }

    function workerMessage(e) {
        if (e.data.console) {

            console.log(e.data.message);

        } else if (e.data.id) {

            var callback = _callbacks[e.data.id];
            if (callback) callback(e.data.message);
            delete _callbacks[e.data.id];

        } else if (e.data.emit) {

            var callback = _callbacks[e.data.evt];
            if (callback) callback(e.data.msg);

        } else {

            var callback = _callbacks['transfer'];
            if (callback) callback(e.data);

        }

    }

    //*** Public methods
    /**
     * @name Thread.on
     * @memberof Thread
     *
     * @function
     * @param evt
     * @param callback
    */
    this.on = function(evt, callback) {
        _callbacks[evt] = callback;
    }

    /**
     * @name Thread.off
     * @memberof Thread
     *
     * @function
     * @param evt
    */
    this.off = function(evt) {
        delete _callbacks[evt];
    }

    /**
     * @name Thread.loadFunction
     * @memberof Thread
     *
     * @function
    */
    this.loadFunction = function() {
        let names = [];
        let load = code => {
            code = code.toString();
            code = code.replace('(', '!!!');
            var split = code.split('!!!');
            var name = split[0].split(' ')[1];
            code = 'self.'+name+' = function('+split[1];
            _worker.postMessage({code: code});
            createMethod(name);
            names.push(name);
        };
        for (var i = 0; i < arguments.length; i++) load(arguments[i]);
        return names;
    }

    /**
     * @name Thread.importScript
     * @memberof Thread
     *
     * @function
     * @param path
    */
    this.importScript = function(path) {
        _worker.postMessage({path: Thread.absolutePath(path), importScript: true});
    }

    /**
     * @name Thread.importCode
     * @memberof Thread
     *
     * @function
     * @param code
    */
    this.importCode = function(code) {
        _worker.postMessage({code});
    }

    /**
     * @name Thread.importClass
     * @memberof Thread
     *
     * @function
    */
    this.importClass = function() {
        for (var i = 0; i < arguments.length; i++) {
            var code = arguments[i];
            importClass(code);
        }
    }

    /**
     * @name Thread.importModule
     * @memberof Thread
     *
     * @function
    */
    this.importModules = this.importModule = function() {
        for (var i = 0; i < arguments.length; i++) {
            let code = Modules.getConstructor(arguments[i]).toString();
            _worker.postMessage({code: `Module(${code})`});
        }
    }

    /**
     * @name Thread.importES6Class
     * @memberof Thread
     *
     * @function
     * @param name
    */
    this.importES6Class = function(name) {
        if (window._ES5_) {
            let Class = window[name];
            let base = Class.toString();
            let proto = [];
            let sup;
            // The class constructor may refer to an enclosed superclass
            // variable like _super37 in the below:
            //   _inherits(Shape, _Path);
            //   var _super37 = _createSuper(Shape);
            //   function Shape(points) {
            //     var _this47;
            //     _this47 = _super37.call(this, points);
            //     ...
            //   }
            let matches = /(_this\w+)\s*=\s*(_super\w+)\.call/g.exec(base);
            if (matches) {
                let superVar = matches[2];
                let superConstructor = Object.getPrototypeOf(Class);
                if (!superConstructor.toString().includes('[native')) {
                    let superName = Utils.getConstructorName(superConstructor);
                    sup = `_inherits(${name}, ${superName}); var ${superVar} = _createSuper(${name});`;
                }
            }
            Object.getOwnPropertyNames(Class.prototype).forEach(fn => {
                if (fn == 'constructor' || !Class.prototype[fn]) return;
                proto.push({key: fn, string: Class.prototype[fn].toString()});
            })
            _worker.postMessage({es5: base, name, proto, sup});
        } else {
            _worker.postMessage({es6: `(${eval(name)})`, name});
        }
    }

    /**
     * @name Thread.send
     * @memberof Thread
     *
     * @function
     * @param name
     * @param message
     * @param callback
    */
    this.send = function(name, message, callback) {
        if (typeof name === 'string') {
            var fn = name;
            message = message || {};
            message.fn = name;
        } else {
            callback = message;
            message = name;
        }

        if (Thread.UNIQUE_ID > 999999) Thread.UNIQUE_ID = 1;
        var id = Thread.UNIQUE_ID++;
        if (callback) _callbacks[id] = callback;

        if (message.transfer) {
            message.msg.id = id;
            message.msg.fn = message.fn;
            message.msg.transfer = true;
            _worker.postMessage(message.msg, message.buffer);
        } else {
            _msg.message = message;
            _msg.id = id;
            _worker.postMessage(_msg);
        }
    }

    /**
     * @name Thread.onDestroy
     * @memberof Thread
     *
     * @function
    */
    this.onDestroy = function() {
        if (_worker.terminate) _worker.terminate();
    }

}, () => {
    Thread.PATH = '';

    Thread.UNIQUE_ID = 1;

    Thread.absolutePath = Hydra.absolutePath;

    Thread.cluster = function() {
        return new function() {
            let index = 0;
            let array = [];

    /**
     * @name Thread.push
     * @memberof Thread
     *
     * @function
     * @param thread
    */
            this.push = function(thread) {
                array.push(thread);
            }

    /**
     * @name Thread.get
     * @memberof Thread
     *
     * @function
    */
            this.get = function() {
                let thread = array[index];
                index++;
                if (index >= array.length) index = 0;
                return thread;
            }

            this.array = array;
        }
    }

    Thread.upload = function(...args) {
        Thread.shared();
        let name;
        for (let i = 0; i < _shared.array.length; i++) {
            name = _shared.array[i].loadFunction(...args);
        }
        return name;
    }

    var _shared;
    Thread.shared = function(list) {
        if (!_shared) {
            _shared = Thread.cluster();
            let hardware = navigator.hardwareConcurrency || 4;
            let count = Math.max(Math.min(hardware, 8), 4);
            for (let i = 0; i < count; i++) {
                _shared.push(new Thread());
            }
        }

        return list ? _shared : _shared.get();
    }
});
/**
 * @name TweenManager
 */

Class(function TweenManager() {
    Namespace(this);
    var _this = this;
    var _tweens = [];

   /**
    * @name CubicEases
    * @memberof TweenManager
    * @property
    */
    this.CubicEases = [];

    //*** Constructor
    (function() {
        Render.start(updateTweens);
    })();

    function updateTweens(time, dt) {
        for (let i = _tweens.length - 1; i >= 0; i--) {
            let tween = _tweens[i];
            if (tween.update) tween.update(dt);
            else _this._removeMathTween(tween);
        }
    }

    function stringToValues(str) {
        var values = str.split('(')[1].slice(0, -1).split(',');
        for (var i = 0; i < values.length; i++) values[i] = parseFloat(values[i]);
        return values;
    }

    function findEase(name) {
        var eases = _this.CubicEases;
        for (var i = eases.length-1; i > -1; i--) {
            if (eases[i].name == name) {
                return eases[i];
            }
        }
        return false;
    }

    //*** Event Handlers

    //*** Public methods
    /**
     * @name TweenManager._addMathTween
     * @memberof TweenManager
     *
     * @function
     * @param tween
    */
    this._addMathTween = function(tween) {
        _tweens.push(tween);
    };

    /**
     * @name TweenManager._removeMathTween
     * @memberof TweenManager
     *
     * @function
     * @param tween
    */
    this._removeMathTween = function(tween) {
        _tweens.remove(tween);
    };

    /**
     * @name TweenManager._getEase
     * @memberof TweenManager
     *
     * @function
     * @param name
     * @param values
    */
	this._getEase = function(name, values) {
        var ease = findEase(name);
        if (!ease) return false;

        if (values) {
            return ease.path ? ease.path.solve : ease.values;
        } else {
            return ease.curve;
        }
	};

    /**
     * @name TweenManager._inspectEase
     * @memberof TweenManager
     *
     * @function
     * @param name
    */
    this._inspectEase = function(name) {
        return findEase(name);
    };

    /**
     * @name window.tween
     * @memberof TweenManager
     *
     * @function
     * @param {Object} object
     * @param {Object} props
     * @param {Number} time
     * @param {String} ease
     * @param {Number} [delay]
     * @param {Function} [complete]
     * @param {Function} [update]
     * @param {Boolean} [isManual]
     * @returns {MathTween}
     * @example
     * const obj = {x: 0};
     * tween(obj, {x: 1}, 1000, 'easeOutCubic')
     *     .onUpdate(() => console.log('update'))
     *     .onComplete(() => console.log('complete'));
     * @example
     * // Tweaking elastic ease using spring and damping
     * // 'spring' and 'damping' properties used for elastic eases
     * // 'spring' alters initial speed (recommended 1.0 > 5.0)
     * // 'damping' alters amount of oscillation, lower is more (recommended 0.1 > 1.0)
     * tween(obj, {x: 1, spring: 2, damping: 0.6}, 1000, 'easeOutElastic');
     */
    this.tween = function(object, props, time, ease, delay, complete, isManual, scaledTime) {
        if (typeof delay !== 'number') {
            update = complete;
            complete = delay;
            delay = 0;
        }

        const tween = new MathTween(object, props, time, ease, delay, complete, isManual, scaledTime);

        let usePromise = null;
        if (complete && complete instanceof Promise) {
            usePromise = complete;
            complete = complete.resolve;
        }

        return usePromise || tween;
    };

    /**
     * @name window.clearTween
     * @memberof TweenManager
     *
     * @function
     * @param object
     */
    this.clearTween = function(object) {
        if (object._mathTween && object._mathTween.stop) object._mathTween.stop();

        if (object._mathTweens) {
            var tweens = object._mathTweens;
            for (var i = 0; i < tweens.length; i++) {
                var tw = tweens[i];
                if (tw && tw.stop) tw.stop();
            }

            object._mathTweens = null;
        }
    };

    /**
     * @name TweenManager.addCustomEase
     * @memberof TweenManager
     *
     * @function
     * @param {Object} ease - {name, curve}
     * @returns {Object}
     */
    this.addCustomEase = function(ease) {
        var add = true;
        if (typeof ease !== 'object' || !ease.name || !ease.curve) throw 'TweenManager :: addCustomEase requires {name, curve}';
        for (var i = _this.CubicEases.length-1; i > -1; i--) {
            if (ease.name == _this.CubicEases[i].name) {
                add = false;
            }
        }

        if (add) {
            if (ease.curve.charAt(0).toLowerCase() == 'm') {
                if (!window.EasingPath) throw 'Using custom eases requires easingpath module';
                ease.path = new EasingPath(ease.curve);
            } else {
                ease.values = stringToValues(ease.curve);
            }

            _this.CubicEases.push(ease);
        }

        return ease;
    };

    /**
     * @name Math.interpolate
     * @memberof TweenManager
     *
     * @function
     * @param {Number} start
     * @param {Number} end
     * @param {Number} alpha - 0.0 to 1.0
     * @param {String} ease
     * @returns {Number}
     */
    Math.interpolate = function(start, end, alpha, ease) {
        const fn = _this.Interpolation.convertEase(ease);
        return Math.mix(start, end, (typeof fn == 'function' ? fn(alpha) : _this.Interpolation.solve(fn, alpha)));
    };

    window.tween = this.tween;
    window.clearTween = this.clearTween;
}, 'Static');
/**
 * @name Interpolation
 */

TweenManager.Class(function Interpolation() {

    function calculateBezier(aT, aA1, aA2) {
        return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
    }

    function getTForX(aX, mX1, mX2) {
        var aGuessT = aX;
        for (var i = 0; i < 4; i++) {
            var currentSlope = getSlope(aGuessT, mX1, mX2);
            if (currentSlope == 0.0) return aGuessT;
            var currentX = calculateBezier(aGuessT, mX1, mX2) - aX;
            aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
    }

    function getSlope(aT, aA1, aA2) {
        return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
    }

    function A(aA1, aA2) {
        return 1.0 - 3.0 * aA2 + 3.0 * aA1;
    }

    function B(aA1, aA2) {
        return 3.0 * aA2 - 6.0 * aA1;
    }

    function C(aA1) {
        return 3.0 * aA1;
    }

    /**
     * Converts easing string to relative function.
     * @name TweenManager.Interpolation.convertEase
     * @memberof Interpolation
     *
     * @function
     * @param {String} ease
     * @example
     * const ease = TweenManager.Interpolation.convertEase('easeOutCubic');
     * console.log(ease(0.7)); // logs 0.973
     */
    this.convertEase = function(ease) {
        var fn = (function() {
            switch (ease) {
                case 'easeInQuad': return TweenManager.Interpolation.Quad.In; break;
                case 'easeInCubic': return TweenManager.Interpolation.Cubic.In; break;
                case 'easeInQuart': return TweenManager.Interpolation.Quart.In; break;
                case 'easeInQuint': return TweenManager.Interpolation.Quint.In; break;
                case 'easeInSine': return TweenManager.Interpolation.Sine.In; break;
                case 'easeInExpo': return TweenManager.Interpolation.Expo.In; break;
                case 'easeInCirc': return TweenManager.Interpolation.Circ.In; break;
                case 'easeInElastic': return TweenManager.Interpolation.Elastic.In; break;
                case 'easeInBack': return TweenManager.Interpolation.Back.In; break;
                case 'easeInBounce': return TweenManager.Interpolation.Bounce.In; break;

                case 'easeOutQuad': return TweenManager.Interpolation.Quad.Out; break;
                case 'easeOutCubic': return TweenManager.Interpolation.Cubic.Out; break;
                case 'easeOutQuart': return TweenManager.Interpolation.Quart.Out; break;
                case 'easeOutQuint': return TweenManager.Interpolation.Quint.Out; break;
                case 'easeOutSine': return TweenManager.Interpolation.Sine.Out; break;
                case 'easeOutExpo': return TweenManager.Interpolation.Expo.Out; break;
                case 'easeOutCirc': return TweenManager.Interpolation.Circ.Out; break;
                case 'easeOutElastic': return TweenManager.Interpolation.Elastic.Out; break;
                case 'easeOutBack': return TweenManager.Interpolation.Back.Out; break;
                case 'easeOutBounce': return TweenManager.Interpolation.Bounce.Out; break;

                case 'easeInOutQuad': return TweenManager.Interpolation.Quad.InOut; break;
                case 'easeInOutCubic': return TweenManager.Interpolation.Cubic.InOut; break;
                case 'easeInOutQuart': return TweenManager.Interpolation.Quart.InOut; break;
                case 'easeInOutQuint': return TweenManager.Interpolation.Quint.InOut; break;
                case 'easeInOutSine': return TweenManager.Interpolation.Sine.InOut; break;
                case 'easeInOutExpo': return TweenManager.Interpolation.Expo.InOut; break;
                case 'easeInOutCirc': return TweenManager.Interpolation.Circ.InOut; break;
                case 'easeInOutElastic': return TweenManager.Interpolation.Elastic.InOut; break;
                case 'easeInOutBack': return TweenManager.Interpolation.Back.InOut; break;
                case 'easeInOutBounce': return TweenManager.Interpolation.Bounce.InOut; break;

                case 'linear': return TweenManager.Interpolation.Linear.None; break;
            }
        })();

        if (!fn) {
            var curve = TweenManager._getEase(ease, true);
            if (curve) fn = curve;
            else fn = TweenManager.Interpolation.Cubic.Out;
        }

        return fn;
    };

    /**
     * @name TweenManager.Interpolation.solve
     * @memberof Interpolation
     *
     * @function
     * @param {Number[]} values
     * @param {Number} elapsed
     * @returns {Number}
     */
    this.solve = function(values, elapsed) {
        if (values[0] == values[1] && values[2] == values[3]) return elapsed;
        return calculateBezier(getTForX(elapsed, values[0], values[2]), values[1], values[3]);
    };

    this.Linear = {
        None: function(k) {
            return k;
        }
    };
    this.Quad = {
        In: function(k) {
            return k*k;
        },
        Out: function(k) {
            return k * (2 - k);
        },
        InOut: function(k) {
            if ((k *= 2) < 1) return 0.5 * k * k;
            return - 0.5 * (--k * (k - 2) - 1);
        }
    };
    this.Cubic = {
        In: function(k) {
            return k * k * k;
        },
        Out: function(k) {
            return --k * k * k + 1;
        },
        InOut: function(k) {
            if ((k *= 2) < 1) return 0.5 * k * k * k;
            return 0.5 * ((k -= 2) * k * k + 2 );
        }
    };
    this.Quart = {
        In: function(k) {
            return k * k * k * k;
        },
        Out: function(k) {
            return 1 - --k * k * k * k;
        },
        InOut: function(k) {
            if ((k *= 2) < 1) return 0.5 * k * k * k * k;
            return - 0.5 * ((k -= 2) * k * k * k - 2);
        }
    };
    this.Quint = {
        In: function(k) {
            return k * k * k * k * k;
        },
        Out: function(k) {
            return --k * k * k * k * k + 1;
        },
        InOut: function(k) {
            if ((k *= 2) < 1) return 0.5 * k * k * k * k * k;
            return 0.5 * ((k -= 2) * k * k * k * k + 2);
        }
    };
    this.Sine = {
        In: function(k) {
            return 1 - Math.cos(k * Math.PI / 2);
        },
        Out: function(k) {
            return Math.sin(k * Math.PI / 2);
        },
        InOut: function(k) {
            return 0.5 * (1 - Math.cos(Math.PI * k));
        }
    };
    this.Expo = {
        In: function(k) {
            return k === 0 ? 0 : Math.pow(1024, k - 1);
        },
        Out: function(k) {
            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
        },
        InOut: function(k) {
            if (k === 0) return 0;
            if (k === 1) return 1;
            if ((k *= 2) < 1) return 0.5 * Math.pow(1024, k - 1);
            return 0.5 * (-Math.pow(2, - 10 * (k - 1)) + 2);
        }
    };
    this.Circ = {
        In: function(k) {
            return 1 - Math.sqrt(1 - k * k);
        },
        Out: function(k) {
            return Math.sqrt(1 - --k * k);
        },
        InOut: function(k) {
            if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1);
            return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1);
        }
    };
    this.Elastic = {
        In: function(k, a = 1, p = 0.4) {
            var s;
            if ( k === 0 ) return 0;
            if ( k === 1 ) return 1;
            if ( !a || a < 1 ) { a = 1; s = p / 4; }
            else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
            return - ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );
        },
        Out: function(k, a = 1, p = 0.4) {
            var s;
            if ( k === 0 ) return 0;
            if ( k === 1 ) return 1;
            if ( !a || a < 1 ) { a = 1; s = p / 4; }
            else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
            return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );
        },
        InOut: function(k, a = 1, p = 0.4) {
            var s;
            if ( k === 0 ) return 0;
            if ( k === 1 ) return 1;
            if ( !a || a < 1 ) { a = 1; s = p / 4; }
            else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
            if ( ( k *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );
            return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1;
        }
    };
    this.Back = {
        In: function(k) {
            var s = 1.70158;
            return k * k * ( ( s + 1 ) * k - s );
        },
        Out: function(k) {
            var s = 1.70158;
            return --k * k * ( ( s + 1 ) * k + s ) + 1;
        },
        InOut: function(k) {
            var s = 1.70158 * 1.525;
            if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );
            return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );
        }
    };
    this.Bounce = {
        In: function(k) {
            return 1 - this.Bounce.Out( 1 - k );
        },
        Out: function(k) {
            if ( k < ( 1 / 2.75 ) ) {
                return 7.5625 * k * k;
            } else if ( k < ( 2 / 2.75 ) ) {
                return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;
            } else if ( k < ( 2.5 / 2.75 ) ) {
                return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;
            } else {
                return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;
            }
        },
        InOut: function(k) {
            if ( k < 0.5 ) return this.Bounce.In( k * 2 ) * 0.5;
            return this.Bounce.Out( k * 2 - 1 ) * 0.5 + 0.5;
        }
    };
}, 'Static');
/**
 * Tween constructor class, initiated through window.tween().
 * @name MathTween
 *
 * @constructor
 */

Class(function MathTween(_object, _props, _time, _ease, _delay, _callback, _manual, _scaledTime) {
    var _this = this;

    var _startTime, _startValues, _endValues;
    var _easeFunction, _paused, _newEase;
    var _spring, _damping, _update, _currentTime;

    var _elapsed = 0;

   /**
    * @name object
    * @memberof MathTween
    * @property
    */
    _this.object = _object;
   /**
    * @name props
    * @memberof MathTween
    * @property
    */
    _this.props = _props;
   /**
    * @name time
    * @memberof MathTween
    * @property
    */
    _this.time = _time;
   /**
    * @name ease
    * @memberof MathTween
    * @property
    */
    _this.ease = _ease;
   /**
    * @name delay
    * @memberof MathTween
    * @property
    */
    _this.delay = _delay;

    //*** Constructor
    defer(function() {
        if (_this.overrideValues) {
            let values = _this.overrideValues(_this, _object, _props, _time, _ease, _delay);
            if (values) {
                _this.props = _props = values.props || _props;
                _this.time = _time = values.time || _time;
                _this.ease = _ease = values.ease || _ease;
                _this.delay = _delay = values.delay || _delay;
            }
        }

        if (_object && _props) {
            _this.object = _object;
            if (typeof _time !== 'number') throw 'MathTween Requires object, props, time, ease';
            start();
        }
    });

    function start() {
        if (!_object.multiTween && _object._mathTween && !_manual) TweenManager.clearTween(_object);
        if (!_manual) TweenManager._addMathTween(_this);

        _this.time = _time;
        _this.delay = _delay;

        let propString = getPropString();

            _object._mathTween = _this;
        if (_object.multiTween) {
            if (!_object._mathTweens) _object._mathTweens = [];
            _object._mathTweens.forEach(t => {
                if (t.props == propString) t.tween.stop();
            });
            _this._tweenWrapper = {props: propString, tween: _this};
            _object._mathTweens.push(_this._tweenWrapper);
        }

        if (!_ease) _ease = 'linear';

        if (typeof _ease == 'string') {
            _ease = TweenManager.Interpolation.convertEase(_ease);
            _easeFunction = typeof _ease === 'function';
        }

        _startTime = _scaledTime ? Render.now() : performance.now();
        _currentTime = _startTime;
        _startTime += _delay;
        _endValues = _props;
        _startValues = {};

        if (_props.spring) _spring = _props.spring;
        if (_props.damping) _damping = _props.damping;

        _this.startValues = _startValues;

        for (var prop in _endValues) {
            if (typeof _object[prop] === 'number') _startValues[prop] = _object[prop];
        }
    }

    function getPropString() {
        let string = '';
        for (let key in _props) {
            if (typeof _props[key] === 'number') string += key+' ';
        }
        return string;
    }

    function clear() {
        if (!_object && !_props) return false;
        _object._mathTween = null;
        TweenManager._removeMathTween(_this);
        Utils.nullObject(_this);

        if (_object._mathTweens) {
            _object._mathTweens.remove(_this._tweenWrapper);
        }
    }

    //*** Event Handlers

    //*** Public methods
    /**
     * @name this.update
     * @memberof MathTween
     *
     * @function
     * @param {Number} time - Performance.now value
     */
    this.update = function(dt) {
        if (_paused) return;
        _currentTime += _scaledTime ? dt : Render.DT;
        if (_currentTime < _startTime) return;

        _elapsed = (_currentTime - _startTime) / _time;
        _elapsed = _elapsed > 1 ? 1 : _elapsed;

        let delta = this.interpolate(_elapsed);

        if (_update) _update(delta);
        if (_elapsed == 1) {
            if (_callback) _callback();
            if (_this.completePromise) _this.completePromise.resolve();
            clear();
        }
    };

    /**
     * @name this.pause
     * @memberof MathTween
     *
     * @function
     */
    this.pause = function() {
        _paused = true;
    };

    /**
     * @name this.resume
     * @memberof MathTween
     *
     * @function
     */
    this.resume = function() {
        _paused = false;
    };

    /**
     * @name this.stop
     * @memberof MathTween
     *
     * @function
     */
    this.stop = function() {
        _this.stopped = true;
        clear();
        return null;
    };

    /**
     * @name this.setEase
     * @memberof MathTween
     *
     * @function
     * @param {String} ease
     */
    this.setEase = function(ease) {
        if (_newEase != ease) {
            _newEase = ease;
            _ease = TweenManager.Interpolation.convertEase(ease);
            _easeFunction = typeof _ease === 'function';
        }
    };

    /**
     * @name this.getValues
     * @memberof MathTween
     *
     * @function
     */
    this.getValues = function() {
        return {
            start: _startValues,
            end: _endValues,
        }
    };

    /**
     * @name this.interpolate
     * @memberof MathTween
     *
     * @function
     * @param {Number} elapsed - 0.0 to 1.0
     */
    this.interpolate = function(elapsed) {
        var delta = _easeFunction ? _ease(elapsed, _spring, _damping) : TweenManager.Interpolation.solve(_ease, elapsed);

        for (var prop in _startValues) {
            if (typeof _startValues[prop] === 'number' && typeof _endValues[prop] === 'number') {
                var start = _startValues[prop];
                var end = _endValues[prop];
                _object[prop] = start + (end - start) * delta;
            }
        }

        return delta;
    };

    /**
     * @name this.onUpdate
     * @memberof MathTween
     *
     * @function
     * @param {Function} callback
     */
    this.onUpdate = function(callback) {
        _update = callback;
        return this;
    };

    /**
     * @name this.onComplete
     * @memberof MathTween
     *
     * @function
     * @param {Function} callback
     */
    this.onComplete = function(callback) {
        _callback = callback;
        return this;
    };

    /**
     * @name this.promise
     * @memberof MathTween
     *
     * @function
     * @param {Function}
     */
    this.promise = function() {
        _this.completePromise = Promise.create();
        return _this.completePromise;
    };

    /**
     * @name this.setElapsed
     * @memberof MathTween
     *
     * @function
     * @param elapsed
    */
    this.setElapsed = function(elapsed) {
        _startTime = performance.now();
        _currentTime = _startTime + (_time * elapsed);
    }
});
/**
 * @name TweenTimeline
 *
 * @constructor
 */

Class(function TweenTimeline() {
    Inherit(this, Component);
    const _this = this;
    let _tween;

    let _total = 0;
    const _tweens = [];

    /**
     * @name this.elapsed
     * @memberof TweenTimeline
     */
    this.elapsed = 0;

    function calculate() {
        _tweens.sort(function(a, b) {
            const ta = a.time + a.delay;
            const tb = b.time + b.delay;
            return tb - ta;
        });

        const first = _tweens[0];
        _total = first.time + first.delay;
    }

    function loop() {
        let time = _this.elapsed * _total;
        for (let i = _tweens.length - 1; i > -1; i--) {
            let t = _tweens[i];
            let relativeTime = time - t.delay;
            let elapsed = Math.clamp(relativeTime / t.time, 0, 1);

            t.interpolate(elapsed);
        }

        _this.events.fire(Events.UPDATE, _this, true);
    }

    //*** Public methods

    /**
     * @name this.timeRemaining
     * @memberof TweenTimeline
     */
    this.get('timeRemaining', () => {
        return _total - (_this.elapsed * _total)
    });

    /**
     * @name this.add
     * @memberof TweenTimeline
     *
     * @function
     * @param {Object} object
     * @param {Object} props
     * @param {Number} time
     * @param {String} ease
     * @param {Number} delay
     * @returns {MathTween}
     */
    this.add = function(object, props, time, ease, delay = 0) {
        if (object instanceof MathTween || object instanceof FrameTween) {
            props = object.props;
            time = object.time;
            ease = object.ease;
            delay = object.delay;
            object = object.object;
        }

        let tween;
        if (object instanceof HydraObject) tween = new FrameTween(object, props, time, ease, delay, null, true);
        else tween = new MathTween(object, props, time, ease, delay, null, true);
        _tweens.push(tween);

        defer(calculate);

        return tween;
    };

    /**
     * Tween elapsed value, which controls the timing of the timeline animation.
     * @name this.tween
     * @memberof TweenTimeline
     *
     * @function
     * @param {Number} to
     * @param {Number} time
     * @param {String} ease
     * @param {Number} delay
     * @param {Function} callback
     */
    this.tween = function(to, time, ease, delay, callback) {
        _this.clearTween();
        _tween = tween(_this, {elapsed: to}, time, ease, delay).onUpdate(loop).onComplete(callback);
        return _tween;
    };

    /**
     * @name this.clearTween
     * @memberof TweenTimeline
     *
     * @function
     */
    this.clearTween = function() {
        if (_tween && _tween.stop) _tween.stop();
    };

    /**
     * @name this.startRender
     * @memberof TweenTimeline
     *
     * @function
     */
    this.start = function() {
        _this.startRender(loop);
    };

    /**
     * @name this.stopRender
     * @memberof TweenTimeline
     *
     * @function
     */
    this.stop = function() {
        _this.stopRender(loop);
    };

    /**
     * Manually call update. Useful if manipulating elapsed value.
     * @name this.update
     * @memberof TweenTimeline
     *
     * @function
     */
    this.update = function() {
        loop();
    };

    /**
     * @name this.destroy
     * @memberof TweenTimeline
     * @private
     *
     * @function
     */
    this.onDestroy = function() {
        _this.clearTween();
        Render.stop(loop);
        for (var i = 0; i < _tweens.length; i++) _tweens[i].stop();
    };

});

Class(function Data() {
    Inherit(this, Model);
    const _this = this;

    //*** Constructor
    !(async function () {
        await Hydra.ready();
        _this.dataReady = true;
    })();

    function addToPath(path, addition = '/') {
        if (_this.normalizePath(path).join('/').substr(-1) !== addition) path += addition;
        return path;
    }

    _this.request = async function (path, options = {}) {
        if (!Config.CMS) throw new Error('Missing CMS Config');

        let _path = path ? _this.normalizePath(path).join('/') : 'default';
        if (!options.nocache && _this.pull(_path)) return _this.pull(_path);

        let timestamp = Utils.timestamp();
        let fullPath = _path === 'default' ? addToPath(`${Config.CMS}`, `?${timestamp}`) : addToPath(`${Config.CMS}/${_path}`, `?${timestamp}`);

        let val = await fetch(fullPath).then(r => r.json());
        _this.push(_path, val);
        return val;
    };

    _this.normalizePath = function (path) {
        const _split = path.split('/');
        return _split[0] === '' ? _split.splice(1, _split.length) : _split;
    };
}, 'static');

window.ASSETS = ["assets/js/lib/brightcove.js","assets/js/lib/firebase-analytics.js","assets/js/lib/firebase-app.js","assets/js/lib/firebase-auth.js","assets/js/lib/firebase-database.js","assets/js/lib/firebase-firestore.js","assets/js/lib/firebase-functions.js","assets/js/lib/fm.liveswitch.js","assets/js/lib/oimo.min.js","assets/data/uil.json","assets/fonts/myriad.json","assets/fonts/myriad.png","assets/images/avatar/default.png","assets/images/avatar/matcap.jpg","assets/images/avatar/normal.png","assets/images/avatar/placeholder.png","assets/images/avatar/roughness.png","assets/images/avatar/shadow.jpg","assets/images/avatar/shadow1.jpg","assets/images/close-orange.svg","assets/images/conference/icons/1.svg","assets/images/conference/icons/2.svg","assets/images/conference/icons/chat-send.svg","assets/images/conference/icons/github.svg","assets/images/conference/icons/linkedin.svg","assets/images/conference/icons/twitter.svg","assets/images/conference/icons/user-multiple.svg","assets/images/conference/placeholder.png","assets/images/core-sprites.svg","assets/images/emotes/emotes.png","assets/images/icon/3rdView.svg","assets/images/icon/add.svg","assets/images/icon/altclock.svg","assets/images/icon/arrow-left.svg","assets/images/icon/arrow-right.svg","assets/images/icon/camera-off.svg","assets/images/icon/camera-on-grey.svg","assets/images/icon/camera-on-orange.svg","assets/images/icon/camera-on.svg","assets/images/icon/camera-video-zone-red.svg","assets/images/icon/camera-video-zone.svg","assets/images/icon/chat-alt.svg","assets/images/icon/check.svg","assets/images/icon/chevron-down-white.svg","assets/images/icon/chevron-down.svg","assets/images/icon/chevron-left.svg","assets/images/icon/chevron-up.svg","assets/images/icon/clock.svg","assets/images/icon/close-orange.svg","assets/images/icon/close.svg","assets/images/icon/download.svg","assets/images/icon/exit.svg","assets/images/icon/external-link.svg","assets/images/icon/filter.svg","assets/images/icon/location.svg","assets/images/icon/menu-alt.svg","assets/images/icon/menu.svg","assets/images/icon/mic-off.svg","assets/images/icon/mic-on-grey.svg","assets/images/icon/mic-on.svg","assets/images/icon/mic-video-zone-red.svg","assets/images/icon/mic-video-zone.svg","assets/images/icon/screenshare.svg","assets/images/icon/setting.svg","assets/images/icon/settings-video-chat-zone.svg","assets/images/icon/share2-alt.svg","assets/images/icon/share2.svg","assets/images/icon/sound-level2-grey.svg","assets/images/icon/sound-level2.svg","assets/images/icon/speaker-grey.svg","assets/images/icon/speaker.svg","assets/images/icon/spinner.png","assets/images/icon/user-alt.svg","assets/images/icon/user.svg","assets/images/icon/video.svg","assets/images/icon/warning.svg","assets/images/lobby/color.png","assets/images/pbr/lut.png","assets/images/prompt/button.png","assets/images/trivia/check.svg","assets/images/trivia/correct.svg","assets/images/trivia/incorrect.svg","assets/images/trivia/question.svg","assets/shaders/compiled.vs"];
ASSETS.SW = ["assets/fonts/myriad.json","assets/fonts/myriad.png","assets/css/style.css","assets/js/app.js"];
Class(function Config() {
    Inherit(this, Model);
    const _this = this;

    let _config;

    (async function () {
        if (window.CONFIG) {
            _config = window.CONFIG;
        } else {
            let _configPath = 'config.json';
            if (window.CONFIG_PATH) _configPath = window.CONFIG_PATH;
            _config = await get(_configPath);
        }

        Object.keys(_config).forEach((key) => {
            _this[key.toUpperCase()] = _config[key];
        });

        if (Utils.query('localSocket')) {
            _this.GAMECENTER_SOCKET = 'ws://localhost';
            _this.GAMECENTER_PORTS = 2;
        }

        if (Utils.query('localServer')) {
            _this.API = `http://localhost:5000/${_this.PLATFORM_CONFIG.projectId}/us-central1/dream`;
        }

        _this.dataReady = true;
    }());

    _this.getValue = function (path, defaultValue = null) {
        return String.prototype.split.call(path, /[,[\].]+?/)
            .filter(Boolean)
            .reduce((a, c) => (Object.hasOwnProperty.call(a, c) ? a[c] : defaultValue), _this);
    };
}, 'static');

/**
 * Attaches to Mobile namespace. Use as Mobile.Accelerometer
 * @name Accelerometer
 */

Mobile.Class(function Accelerometer() {
    var _this = this;

    this.x = 0;
    this.y = 0;
    this.z = 0;

    this.alpha = 0;
    this.beta = 0;
    this.gamma = 0;

    this.heading = 0;

    this.rotationRate = {};
    this.rotationRate.alpha = 0;
    this.rotationRate.beta = 0;
    this.rotationRate.gamma = 0;

    this.toRadians = Device.system.os == 'ios' ? Math.PI / 180 : 1;

    //*** Event Handlers
    function updateAccel(e) {
        switch (window.orientation) {
            case 0:
                _this.x = -e.accelerationIncludingGravity.x;
                _this.y = e.accelerationIncludingGravity.y;
                _this.z = e.accelerationIncludingGravity.z;

                if (e.rotationRate) {
                    _this.rotationRate.alpha = e.rotationRate.beta * _this.toRadians;
                    _this.rotationRate.beta = -e.rotationRate.alpha * _this.toRadians;
                    _this.rotationRate.gamma = e.rotationRate.gamma * _this.toRadians;
                }
            break;

            case 180:
                _this.x = e.accelerationIncludingGravity.x;
                _this.y = -e.accelerationIncludingGravity.y;
                _this.z = e.accelerationIncludingGravity.z;

                if (e.rotationRate) {
                    _this.rotationRate.alpha = -e.rotationRate.beta * _this.toRadians;
                    _this.rotationRate.beta = e.rotationRate.alpha * _this.toRadians;
                    _this.rotationRate.gamma = e.rotationRate.gamma * _this.toRadians;
                }
            break;

            case 90:
                _this.x = e.accelerationIncludingGravity.y;
                _this.y = e.accelerationIncludingGravity.x;
                _this.z = e.accelerationIncludingGravity.z;

                if (e.rotationRate) {
                    _this.rotationRate.alpha = e.rotationRate.alpha * _this.toRadians;
                    _this.rotationRate.beta = e.rotationRate.beta * _this.toRadians;
                    _this.rotationRate.gamma = e.rotationRate.gamma * _this.toRadians;
                }
            break;

            case -90:
                _this.x = -e.accelerationIncludingGravity.y;
                _this.y = -e.accelerationIncludingGravity.x;
                _this.z = e.accelerationIncludingGravity.z;

                if (e.rotationRate) {
                    _this.rotationRate.alpha = -e.rotationRate.alpha * _this.toRadians;
                    _this.rotationRate.beta = -e.rotationRate.beta * _this.toRadians;
                    _this.rotationRate.gamma = e.rotationRate.gamma * _this.toRadians;
                }
            break;
        }

        if (Device.system.os == 'android') {
            _this.x *= -1;
            _this.y *= -1;
            _this.z *= -1;
        }
    }

    function updateOrientation(e) {
        for (var key in e) {
            if (key.toLowerCase().includes('heading')) _this.heading = e[key];
        }

        switch (window.orientation) {
            case 0:
                _this.alpha = e.beta * _this.toRadians;
                _this.beta = -e.alpha * _this.toRadians;
                _this.gamma = e.gamma * _this.toRadians;
                break;

            case 180:
                _this.alpha = -e.beta * _this.toRadians;
                _this.beta = e.alpha * _this.toRadians;
                _this.gamma = e.gamma * _this.toRadians;
                break;

            case 90:
                _this.alpha = e.alpha * _this.toRadians;
                _this.beta = e.beta * _this.toRadians;
                _this.gamma = e.gamma * _this.toRadians;
                break;

            case -90:
                _this.alpha = -e.alpha * _this.toRadians;
                _this.beta = -e.beta * _this.toRadians;
                _this.gamma = e.gamma * _this.toRadians;
                break;
        }

        _this.tilt = e.beta * _this.toRadians;
        _this.yaw = e.alpha * _this.toRadians;
        _this.roll = -e.gamma * _this.toRadians;

        if (Device.system.os == 'android') _this.heading = compassHeading(e.alpha, e.beta, e.gamma);
    }

    function compassHeading(alpha, beta, gamma) {
        var degtorad = Math.PI / 180;

        var _x = beta  ? beta  * degtorad : 0; // beta value
        var _y = gamma ? gamma * degtorad : 0; // gamma value
        var _z = alpha ? alpha * degtorad : 0; // alpha value

        var cX = Math.cos( _x );
        var cY = Math.cos( _y );
        var cZ = Math.cos( _z );
        var sX = Math.sin( _x );
        var sY = Math.sin( _y );
        var sZ = Math.sin( _z );

        // Calculate Vx and Vy components
        var Vx = - cZ * sY - sZ * sX * cY;
        var Vy = - sZ * sY + cZ * sX * cY;

        // Calculate compass heading
        var compassHeading = Math.atan( Vx / Vy );

        // Convert compass heading to use whole unit circle
        if( Vy < 0 ) {
            compassHeading += Math.PI;
        } else if( Vx < 0 ) {
            compassHeading += 2 * Math.PI;
        }

        return compassHeading * ( 180 / Math.PI ); // Compass Heading (in degrees)

    }

    //*** Public methods
    this.capture = function() {
        if (!this.active) {
            this.active = true;
            window.ondevicemotion = updateAccel;
            window.addEventListener('deviceorientation', updateOrientation);
        }
    }

    this.stop = function() {
        this.active = false;
        window.ondevicemotion = null;
        _this.x = _this.y = _this.z = 0;
        window.removeEventListener('deviceorientation', updateOrientation);
    }
}, 'Static');
Module(function ConsoleSecurity() {
    this.exports = function() {
        let err = new Error();
        if (err.stack) {
            let stack = err.stack.toString().toLowerCase();
            if (stack.includes(['@debugger', '_evaluateandwrap', 'eval code:1:1)', 'at <anonymous>:1:'])) return true;
        }
        return false;
    }
});
Class(function CSSFilter($object, _vert, _frag) {
    Inherit(this, Component);
    var _this = this;
    var _filter = '';
    var _filters = ['grayscale', 'sepia', 'saturate', 'hue', 'invert', 'opacity', 'brightness', 'contrast', 'blur'];
    var _killTween, _tween;

    function checkFilter(key) {
        for (var i = _filters.length-1; i > -1; i--) {
            if (_filters[i] == key) return true;
        }
        return false;
    }

    function buildFilters() {
        var str = '';
        var len = _filters.length-1;

        for (var key in _this) {
            if (!checkFilter(key)) continue;
            var filter = key;
            var value = _this[key];
            if (typeof value === 'number') {
                filter = filter == 'hue' ? 'hue-rotate' : filter;
                value = filter == 'hue-rotate' ? value + 'deg' : value;
                value = filter == 'blur' ? value + 'px' : value;
                str += filter+'('+value+') ';
            }
        }

        _filter = str;
    }

    function clearTween() {
        if (_tween || !$object || !$object.div) return false;
        $object.div.style[HydraCSS.prefix('Transition')] = '';
    }

    //*** Event handlers

    //*** Public Methods
    this.apply = function() {
        buildFilters()
        $object.div.style[HydraCSS.prefix('Filter')] = _filter;
    }

    this.tween = async function(props, time, ease, delay, callback) {
        if (typeof delay === 'function') {
            callback = delay;
            delay = 0;
        }

        delay = delay || 0;
        _killTween = false;

        var filter = '-'+HydraCSS.styles.vendor.toLowerCase()+'-filter';
        $object.willChange(filter);

        await defer();
        await defer();

        if (_killTween) return;
        $object.div.style[HydraCSS.prefix('Transition')] =  filter + ' ' + time+'ms ' + TweenManager._getEase(ease) + ' ' + delay+'ms';

        for (var key in props) {
            _this[key] = props[key];
        }

        _tween = _this.delayedCall(function() {
            $object.willChange(null);
            if (callback) callback();
        }, time + delay);

        _this.apply();
    }

    this.stopTween = function() {
        clearTimeout(_tween);
        _killTween = true;
        clearTween();
    }

    this.clear = function() {
        for (var key in _this) {
            if (checkFilter(key)) delete _this[key];
        }
        if (_tween) this.stopTween();
        this.apply();
     }

    this.onDestroy = function() {
        this.clear();
        $object = null;
        _tween = null;
    }
});
Class(function SplitTextfield() {
	var _style = {padding: 0, margin: 0, position: 'relative', 'float': '', cssFloat: '', styleFloat: '', display: 'inline-block', whiteSpace: 'pre-wrap', width: 'auto', height: 'auto'};

	function splitLetter($obj, _nested) {
		var _array = [];
		var text = $obj.div.innerHTML;
		var split = text.split('');
		$obj.div.innerHTML = '';
		if (!_nested) $obj.attr('aria-label', text);

		for (var i = 0; i < split.length; i++) {
			if (split[i] == ' ') split[i] = '&nbsp;'
			var letter = $('t', 'span');
			letter.html(split[i], true).css(_style);
            letter.attr('aria-hidden', true);
			_array.push(letter);
			$obj.add(letter);
		}

		return _array;
	}

	function splitWord($obj, _nested) {
		var _array = [];
		var text = $obj.div.innerHTML;
		var inTag = false;
		var multiSpace = [];

		text = text.replace('&amp;', '&');
		text = text.replace('&nbsp;', ' ');
		var lines = text.split('\n');

		$obj.attr('aria-label', text);
		$obj.empty();

		for ( let [ l, line ] of lines.entries()) {
			var split = line.split(' ');
			for (var i = 0; i < split.length; i++) {
				var word = $('t', 'span');
				var empty = $('t', 'span');
				let w = split[i];
				if ( w.includes('<')) inTag = true;
				if ( w.includes('</')) inTag = false;

				if ( !inTag ) {
					w = `${multiSpace.join(' ')} ${w}`.trim();
					multiSpace = [];
					word.html(w).css(_style);
					let endOfLine = i === split.length - 1;
					empty.html( endOfLine ? '<br />' : '&nbsp', true).css(_style);
					if ( endOfLine ) empty.css({ display: l === lines.length - 1 ? 'none' : 'inline' });
					if (!_nested) {
						word.attr('aria-hidden', true);
						empty.attr('aria-hidden', true);
					}
					_array.push(word);
					_array.push(empty);
					$obj.add(word);
					$obj.add(empty);
				} else {
					multiSpace.push(w);
				}
			}
		}
		return _array;
	}

	async function splitLine($obj, _nested) {
		let $spans = splitWord($obj, _nested);

		let _linesArray = [];
		let _line = [];
		let _pos = $obj.div.offsetTop;
		let _lineStyle = {display: 'block', whiteSpace: 'pre-wrap'};

		await defer();
		await defer();
		await defer();
		
		for ( let [ sIndex, $span ] of $spans.entries()) {
			let _top = $span.div.offsetTop;
			let _text = $span.div.innerHTML;
			_text = _text.replace('&amp;', '&');
			_text = _text.replace('&nbsp;', ' ');

			if (_top != _pos || sIndex + 1 >= $spans.length) {
				let _lineText = _line.join('').trim();
				let $line = $('l', 'span');
				$line.html(_lineText).css(_lineStyle);
				if (!_nested) $line.attr('aria-hidden', true);
				_linesArray.push($line);
			}

			if (_top != _pos) {
				_line = [];
				if (_text != ' ') _line.push(_text);
				_pos = _top;
			} else {
				_line.push(_text);
			}
		}

		$obj.empty();
		for (let [l, line] of _linesArray.entries()) {
			$obj.add(line);
		}
	
		return _linesArray;
	}

	async function splitLetterLine($obj) {
		let _lettersArray  = [];
		let $lines = await splitLine($obj, true);
		
		$lines.forEach($line => {
			let _lineLetters = splitLetter($line, true);
			
			_lineLetters.forEach($letter => {
				_lettersArray.push($letter);
			});
		});

		return _lettersArray;
	}

	this.split = function($obj, by) {
		// if (by == 'word') return splitWord($obj);
		// else return splitLetter($obj);

		switch(by) {
			case 'word': return splitWord($obj);
			case 'line': return splitLine($obj);
			case 'letterline': return splitLetterLine($obj);
			default: return splitLetter($obj);
		}
	}

	this.calculate = function($spans, isParent = false) {
		const lines = [];
		let words = [];
		let position = $spans[0].div.getBoundingClientRect().top;
		
		$spans.forEach(($span, index) => {
			let offset = $span.div.getBoundingClientRect().top;

			if (offset === position) {
				words.push($span);
			}
		
			if (offset !== position) {
				lines.push(words);
			
				words = [];
				words.push($span);
			
				position = offset;
			}
		
			if (index + 1 === $spans.length) {
				lines.push(words);
			}
		});
	
		return lines;
	};
}, 'Static');
Class(function ImageDecoder() {
    Inherit(this, Component);
    var _this = this;
    var _compressed;

    const ACTIVE = !!(window.fetch && window.createImageBitmap && Device.system.browser.includes('chrome') && !window.AURA);

    this.scale = 1;

    (async function() {
        await Hydra.ready();
        Thread.upload(decodeImage);
        Thread.upload(decodeCompressedImage);
    })();

    function decodeImage(data, id) {
        let run = async _ => {
            try {
                let e = await fetch(data.path, {mode: 'cors'});

                if (e.status != 200) {
                    resolve({fail: true}, id);
                    throw `Image not found :: ${data.path}`;
                }

                let blob = await e.blob();

                let obj = {imageOrientation: 'flipY', crossOrigin: 'anonymous'};
                if (data.params && data.params.premultiplyAlpha === false) obj.premultiplyAlpha = 'none';
                obj.imageOrientation = data.params && data.params.flipY === false ? undefined : 'flipY';

                let bitmap = await createImageBitmap(blob, obj);
                let message = {post: true, id, message: bitmap};
                self.postMessage(message, [bitmap]);

            } catch(e) {
                resolve({fail: true}, id);
                throw e;
            }
        };

        run();
    }

    function decodeCompressedImage(data, id) {
        let run = async _ => {

            let ext;
            if (data.settings.dxt) ext = 'dxt';
            else if (data.settings.etc) ext = 'astc';
            else if (data.settings.pvrtc) ext = 'pvrtc';
            else if (data.settings.astc) ext = 'astc';

            let fileName = data.path.split('/');
            fileName = fileName[fileName.length-1];

            let e = await fetch(`${data.path}/${fileName}-${ext}.ktx`);
            if (e.status != 200) throw `Image not found :: ${data.path}`;

            try {
                let arrayBuffer = await e.arrayBuffer();
                let header = new Int32Array(arrayBuffer, 12, 13);

                let glType = header[1];
                let glTypeSize = header[2];
                let glFormat = header[3];
                let gliFormat = header[4];
                let glBaseInternalFormat = header[5];
                let width = header[6];
                let height = header[7];
                let miplevels = header[11];
                let bytesOfKeyValueData = header[12];

                let buffers = [];
                let compressedData = [];
                let sizes = [];

                let dataOffset = 12 + (13 * 4) + bytesOfKeyValueData;

                for (let level = 0; level < miplevels; level++) {
                    let imageSize = new Int32Array(arrayBuffer, dataOffset, 1)[0];
                    dataOffset += 4;

                    let byteArray = new Uint8Array(arrayBuffer, dataOffset, imageSize);

                    dataOffset += imageSize;
                    dataOffset += 3 - ((imageSize + 3) % 4);

                    sizes.push(width);
                    width = Math.max(1.0, width * 0.5);
                    height = Math.max(1.0, height * 0.5);

                    let clone = new Uint8Array(byteArray);

                    compressedData.push(clone);
                    buffers.push(clone.buffer);
                }

                resolve({gliFormat, compressedData, sizes, width, height}, id, buffers);

            } catch(e) {
                throw `${data.path} could not be decoded`;
            }
        };

        run();
    }

    function process(bitmap, scale) {
        let s = scale * _this.scale;
        if (s == 1) return bitmap;

        let pow2 = Math.isPowerOf2(bitmap.width, bitmap.height);

        let canvas = document.createElement('canvas');
        canvas.context = canvas.getContext('2d');
        canvas.width = Math.round(bitmap.width * _this.scale * scale);
        canvas.height = Math.round(bitmap.height * _this.scale * scale);

        if (pow2 && scale * _this.scale < 1) {
            canvas.width = canvas.height = Math.floorPowerOf2(Math.max(canvas.width, canvas.height));
        }

        canvas.context.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
        return canvas;
    }

    //*** Event handlers

    //*** Public methods
    this.decode = async function(path, params = {}) {
        let fallback = Thread.absolutePath(Assets.getPath('assets/images/_scenelayout/uv.jpg'));
        path = Thread.absolutePath(Assets.getPath(path));

        if (!_compressed) {
            _compressed = {dxt: !!Renderer.extensions.s3tc, etc: !!Renderer.extensions.etc1, pvrtc: !!Renderer.extensions.pvrtc, astc: !!Renderer.extensions.astc};
            let found = false;
            for (let key in _compressed) {
                if (_compressed[key] == true) found = true;
            }
            if (!found) _compressed = null;
        }

        if (!_compressed && path.includes('-compressedKtx')) {
            path = path.replace('-compressedKtx', '');
        }

        if (path.includes('-compressedKtx')) {
            try {
                path = path.substring(0, path.lastIndexOf('.'));
                let bitmap = await Thread.shared().decodeCompressedImage({path, params, settings: _compressed});
                return bitmap;
            } catch(e) {
                return _this.decode( fallback, params);
            }
        } else {
            let getBitmap = ( path, params ) => (ACTIVE ? Thread.shared().decodeImage({path, params}) : Assets.decodeImage(path, params));
            try {
                let bitmap = await getBitmap( path, params );
                if (bitmap.fail) {
                    bitmap = await getBitmap( fallback, params );
                    if (bitmap.fail) throw 'could not decode '+path;
                }
                return process(bitmap, params.scale || 1);
            } catch(e) {
                throw 'could not decode '+path;
            }
        }
    }
}, 'static');

/**
 * Decode images on a separate thread, preventing jank
 * @name ImageDecoder
 * @constructor
 * @example
 *
 * async function loadImage() {
        let canvas = await ImageDecoder.decode(_data.image);
        let texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        texture.minFilter = texture.magFilter = THREE.LinearFilter;
        _shader.set('tBG', texture);
    }
 **/
Class(function Firebase() {
    Inherit(this, Model);
    const _this = this;

    var _hasInit;

    //*** Constructor
    (function () {
    })();

    this.init = async function() {
        if (_hasInit) return;
        _hasInit = true;
        await AssetLoader.loadAssets(['~assets/js/lib/firebase-app.js']);
        await AssetLoader.waitForLib('firebase');
        init();
    }

    function init() {
        if (!firebase) return _this.delayedCall(init, 100);
        _this.dataReady = true;
    }

}, 'Static');
Class(function FirebaseAnalytics() {
    Inherit(this, Model);
    const _this = this;

    var _hasInit;

    //*** Constructor
    (function () {
    })();

    this.init = async function() {
        if (_hasInit) return;
        _hasInit = true;
        await Firebase.ready();
        await AssetLoader.loadAssets(['assets/js/lib/firebase-analytics.js'])
        init();
    }

    function init() {
        if (!firebase.analytics) return _this.delayedCall(init);
        _this.dataReady = true;
    }

}, 'Static');
Class(function Auth() {
    Inherit(this, Model);
    const _this = this;

    let _hasInit = false;
    let _app;
    let _auth;
    let _user;
    let _loggedIn;
    let _reload;
    let _providers = {};

    //*** Constructor
    (function () {
    })();

    this.init = async function(app) {
        if (_hasInit) return;
        await FirebaseAuth.ready();
        _app = app;
        init();
    }

    function init() {
        _auth = _app.auth();
        initProviders();
        addListeners();
        _hasInit = true;
    }

    function initProviders() {
        // google on by default
        _providers['google'] = new firebase.auth.GoogleAuthProvider();
    }

    //*** Event handlers
    function addListeners() {
        _auth.onAuthStateChanged( onAuth );
    }

    function onAuth(user) {
        if (user) {
            // signed in
            _user = user;
            _loggedIn = true;
            if (_reload) return window.location.reload();
            _this.events.fire('logged_in');
        } else {
            // signed out
            _user = null;
            _loggedIn = false;
            _this.events.fire('logged_out');
        }
        _this.dataReady = true;
    }

    //*** Public methods
    this.isLoggedIn = function() {
        return _loggedIn;
    }

    this.user = function() {
        if (_user) return _user;
        return null;
    }

    this.login = function(email, password) {
        if (_auth) {
            return _auth.signInWithEmailAndPassword(email, password);
        } else {
            console.error('Auth not ready');
        }
    }

    this.loginGoogle = function(r = false) {
        _reload = r;
        if (_auth && _providers['google']) {
            return _auth.signInWithPopup(_providers['google']);
        } else {
            console.error('Google login error');
        }
    }

    this.logout = function() {
        if (_auth) {
            _user = null;
            return _auth.signOut();
        } else {
            console.error('Auth not ready');
        }
    }

    //*** Private class
}, 'Static');
Class(function FirebaseAuth() {
    Inherit(this, Model);
    const _this = this;

    var _hasInit;

    //*** Constructor
    (function () {
    })();

    this.init = async function() {
        if (_hasInit) return;
        _hasInit = true;
        await Firebase.ready();
        await AssetLoader.loadAssets(['~assets/js/lib/firebase-auth.js'])
        init();
    }

    function init() {
        if (!firebase.auth) return _this.delayedCall(init);
        _this.dataReady = true;
    }

}, 'Static');
Class(function FirebaseDB() {
    Inherit(this, Model);
    const _this = this;

    var _hasInit;

    //*** Constructor
    (function () {
    })();

    this.init = async function() {
        if (_hasInit) return;
        _hasInit = true;
        await Firebase.ready();
        await AssetLoader.loadAssets(['~assets/js/lib/firebase-database.js']);
        init();
    }

    function init() {
        if (!firebase.database) return _this.delayedCall(init);
        _this.dataReady = true;
    }

    this.sanitize = function(key) {
        return key.replace(/[.$#[\]/]/g, '-'); // $& means the whole matched string
    };

}, 'Static');
Class(function FirebaseFunctions() {
    Inherit(this, Model);
    const _this = this;

    var _hasInit;

    //*** Constructor
    (function () {
    })();

    this.init = async function () {
        if (_hasInit) return;
        _hasInit = true;
        await Firebase.ready();
        await AssetLoader.loadAssets(['~assets/js/lib/firebase-functions.js']);
        init();
    };

    function init() {
        if (!firebase.functions) return _this.delayedCall(init);
        _this.dataReady = true;
    }
}, 'Static');

Class(function Firestore() {
    Inherit(this, Model);
    const _this = this;

    var _hasInit;

    //*** Constructor
    (function () {
    })();

    this.init = async function() {
        if (_hasInit) return;
        _hasInit = true;
        await Firebase.ready();
        await AssetLoader.loadAssets(['~assets/js/lib/firebase-firestore.js'])
        init();
    }

    function init() {
        if (!firebase.firestore) return _this.delayedCall(init);
        _this.FieldValue = firebase.firestore.FieldValue;
        _this.dataReady = true;
    }

}, 'Static');
/**
 * Fullscreen controller.<br />
 * IE 10 and below has no fullscreen API
 * @name Fullscreen
 */

Class(function Fullscreen() {
    Inherit(this, Events);
    const _this = this;

    /**
     * @name Fullscreen.isOpen
     * @memberof Fullscreen
     */
    this.isOpen = false;

    (function() {
        addHandlers();

        // TODO: May not need to check in loop
        // Render.start(check, 2);
    })();

    function addHandlers() {
        [
            'onfullscreenchange',
            'onwebkitfullscreenchange',
            'onmozfullscreenchange',
            'onmsfullscreenchange',

            'onfullscreenerror',
            'onwebkitfullscreenerror',
            'onmozfullscreenerror',
            'onmsfullscreenerror'
        ].forEach(evt => {
            if (typeof document[evt] !== 'undefined') document[evt] = update;
        });
    }

    function update() {
        const isOpen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
        if (isOpen === _this.isOpen) return;
        _this.isOpen = isOpen;

        _this.events.fire(Events.FULLSCREEN, {fullscreen: _this.isOpen});
    }

    //*** Public methods

    /**
     * @name Fullscreen.open
     * @memberof Fullscreen
     *
     * @function
     * @param {DocumentElement} element
     */
    this.open = function(element) {
        element = element || document.body;

        if (_this.isOpen) return;

        [
            'requestFullscreen',
            'webkitRequestFullscreen',
            'mozRequestFullScreen',
            'msRequestFullscreen'
        ].every(method => {
            if (typeof element[method] == 'undefined') return true;
            element[method]({navigationUI: 'hide'});
        });
    };

    /**
     * @name Fullscreen.close
     * @memberof Fullscreen
     *
     * @function
     */
    this.close = function() {
        [
            'exitFullscreen',
            'webkitExitFullscreen',
            'mozCancelFullScreen',
            'msExitFullscreen'
        ].every(method => {
            if (typeof document[method] == 'undefined') return true;
            document[method]();
        });
    };

    Object.defineProperty(this, 'enabled', {
        get() {
            return [
                'fullscreenEnabled',
                'webkitFullscreenEnabled',
                'mozFullScreenEnabled',
                'msFullscreenEnabled'
            ].some(prop => Boolean(document[prop]));
        }
    });

}, 'static');
Class(function FXAA() {
    Inherit(this, NukePass);
    const _this = this;

    this.uniforms = {
        tMask: {value: null}
    };

    this.init('FXAA', 'FXAA');

    //*** Event handlers

    //*** Public methods
    this.setMask = function(texture) {
        this.uniforms.tMask.value = texture;
    }
});

Class(function GLScreenProjection(_camera = World.CAMERA, _target = new Vector2()) {
    Inherit(this, Object3D);
    var _this = this;

    var _projection = new ScreenProjection(_camera);
    var _m0 = new Matrix4();
    var _m1 = new Matrix4();

    this.resolution = new Vector2();
    this.pos = new Vector2();
    this.pos3D = new Vector3();
    this.matrix = new Matrix4();

    this.uniforms = {
        projMatrix: {type: 'm4', value: this.matrix},
        pos: {type: 'v2', value: this.pos},
        pos3D: {type: 'v3', value: this.pos3D},
        normalMatrix: {type: 'm4', value: new Matrix4()},
        modelMatrix: {type: 'm4', value: new Matrix4()}
    };

    function loop() {
        _this.pos.set(_target.x, _target.y);
        _this.pos3D.copy(_projection.unproject(_this.pos));

        _this.group.updateMatrixWorld();

        _m0.copy(_camera.projectionMatrix);
        _m1.getInverse(_camera.matrixWorld);

        _this.matrix.multiplyMatrices(_m0, _m1);

        _this.uniforms.normalMatrix.value.copy(_camera.matrixWorld);
        _this.uniforms.modelMatrix.value.copy(_this.group.matrixWorld);
    }

    //*** Public methods
    this.set('camera', v => {
        _camera = v;
        _projection.camera = _camera;
    });

    this.set('target', v => {
        _target = v;
    });

    this.update = loop;

    this.start = function() {
        _this.startRender(loop);
    }

    this.stop = function() {
        _this.stopRender(loop);
    }
});
Class(function GLSEO() {
    Inherit(this, Element);
    const _this = this;
    var $this;

    var _groups = [];
    var _links = [];

    //*** Constructor
    (async function () {
        await Hydra.ready();
        initHTML();
        HydraCSS.style('.GLSEO *', {position: 'relative'});
    })();

    function initHTML() {
        $this = _this.element;
        $this.setZ(-1);
        Stage.add($this);
    }

    function isVisible(group) {
        if (group.__glseoParent) {
            return !group.__glseoParent.seoHidden;
        }

        return group.seo.enabled && group.determineVisible();
    }

    function isDeleted(group) {
        if (group.__glseoParent) {
            return group.__glseoParent.deleted;
        }

        return group.deleted;
    }

    function loop() {
        for (let i = _groups.length-1; i > -1; i--) {
            let group = _groups[i];

            if (isDeleted(group)) {
                $this.removeChild(group.seo);
                return _groups.splice(i, 1);
            }

            if (isVisible(group)) {
                if (group.seo && group.seo.hidden) {
                    group.seo.hidden = false;
                    $this.add(group.seo);
                }
            } else {
                if (group.seo && !group.seo.hidden) {
                    group.seo.hidden = true;
                    $this.removeChild(group.seo, true);
                }
            }
        }

        for (let i = _links.length-1; i > -1; i--) {
            let group = _links[i];

            if (isDeleted(group)) {
                $this.removeChild(group.seo);
                return _groups.splice(i, 1);
            }

            if (isVisible(group)) {
                if (group.seoHidden) {
                    group.seoHidden = false;
                    group.seoDOM.forEach(obj => obj.show());
                }
            } else {
                if (!group.seoHidden) {
                    group.seoHidden = true;
                    group.seoDOM.forEach(obj => obj.hide());
                }
            }
        }
    }

    //*** Event handlers

    //*** Public methods
    this.registerPage = function(group, name) {
        let topLevel = group;

        group = group instanceof GLUIObject ? group : (group.group || group.scene || group);
        if (!group.determineVisible && group.group) group.determineVisible = group.group.determineVisible.bind(group.group);

        if (!Global.PLAYGROUND) World.ELEMENT.mouseEnabled(false);

        topLevel.seo = group.seo = $(name);
        group.seo.hidden = true;
        group.seo.enabled = true;

        let remove = group.seo.remove.bind(group.seo);
        group.seo.remove = _ => {
            _groups.remove(group);
            remove();
        };

        _groups.push(group);
        _this.startRender(loop, 10);
    }

    this.registerPersist = function(group, name) {
        let topLevel = group;
        group = group instanceof GLUIObject ? group : (group.group || group.scene || group);
        if (!Global.PLAYGROUND) World.ELEMENT.mouseEnabled(false);
        topLevel.seo = group.seo = $this.create(name);
    }

    this.link = function($dom, group) {
        if ($dom instanceof HydraObject) {
            group = group.group || group.scene || group;

            if (!group.seoDOM) group.seoDOM = [];
            group.seoDOM.push($dom);

            _links.push(group);
        }

        if ($dom instanceof GLUIObject) {
            $dom.seo = group.seo;
        }
    }

    this.textNode = function($text, text) {
        let parent = ($text._3d ? $text.anchor || $text.group : $text)._parent;
        if ($text.parentSeo) {
            let parentSeo = $text.parentSeo;
            if (parentSeo.group && parentSeo.group.seo) parent = parentSeo.group
            else parent = parentSeo;

        } else if (parent) {
            while (parent && !parent.seo) {
                parent = parent._parent;
            }
        }

        if (!parent) return;

        if (parent.seo) {
            if (!$text.seo) {
                $text.seo = $('text');
                $text.seo.text(text);
                $text.seo.accessible();
                parent.seo.add($text.seo);

                $text.seo.aLink = function (url) {
                    let index = Array.prototype.slice.call( parent.seo.div.children ).indexOf($text.seo.div);
                    $text.seo.remove();
                    $text.seo = $('link', 'a');
                    $text.seo.attr('href', Hydra.absolutePath(url));
                    $text.seo.text(text);
                    $text.seo.accessible();
                    $text.seo.div.onfocus = _ => $text._divFocus();
                    $text.seo.div.onblur = _ => $text._divBlur();
                    $text.seo.div.onclick = e => {
                        e.preventDefault();
                        $text._divSelect();
                    };
                    parent.seo.div.insertBefore($text.seo.div, parent.seo.div.children[index]);
                };

                $text.seo.unlink = function() {
                    parent.seo.div.removeChild($text.seo.div);
                    $text.seo = null;
                };
            } else {
                $text.seo.text(text);
                $text.seo.accessible();
            }
        }
    }

    this.bindToPage = function(parent, child, name) {
        child.__glseoParent = parent;
        _this.registerPage(child, name);
    }

    this.objectNode = function($object, $parent) {
        let parent = $parent || ($object._3d ? $object.group : $object)._parent;
        if ($object.parentSeo) parent = $object.parentSeo.group || $object.parentSeo;
        else {
            if (!parent) return;
            while (parent && !parent.seo) {
                parent = parent._parent;
            }
        }

        if (!parent) return;
        if (parent.seo) {
            if (!$object.seo) {
                $object.seo = {};

                $object.seo.aLink = function(url, label) {
                    let index = Array.prototype.slice.call( parent.seo.div.children ).indexOf($object.seo.div);
                    $object.seo = $('link', 'a');
                    $object.seo.attr('href', Hydra.absolutePath(url));
                    $object.seo.text(label);
                    $object.seo.accessible();
                    $object.seo.div.onfocus = _ => $object._divFocus();
                    $object.seo.div.onblur = _ => $object._divBlur();
                    $object.seo.div.onclick = e => {
                        e.preventDefault();
                        $object._divSelect();
                    };
                    parent.seo.div.insertBefore($object.seo.div, parent.seo.div.children[index]);

                    $object.seo.unlink = function() {
                        parent.seo.div.removeChild($object.seo.div);
                        $object.seo = null;
                    };
                }
            }
        }
    }
}, 'static');
Class(function GLText({

    // Generation props
    font,
    italic = false,
    bold = false,
    text,
    width = Infinity,
    align = 'left',
    size = 1,
    direction = 'ltr',
    letterSpacing = 0,
    lineHeight = 1.4,
    wordSpacing = 0,
    wordBreak = false,
    langBreak = false,
    paragraphSpacing = 1,

    // Shader props
    color = new Color('#000000'),
    alpha = 1,
    shader = 'DefaultText'
}) {
    const _this = this;
    var _override;
    var _promise = Promise.create();

    const config = GLText.FONT_CONFIG[font];

    //*** Constructor
    (function () {
        init();
        if ( typeof font === 'undefined' ) console.log( font, text );
    })();

    function init() {
        overrideParams();
        _this.charLength = text.length;
        _this.text = new GLTextGeometry({font, italic, bold, text, width, align, direction, wordSpacing, letterSpacing, paragraphSpacing, size, lineHeight, wordBreak, langBreak, config});

        _this.string = text;

        resetOverride();

        _this.text.loaded.then(({buffers, image, imageBold, imageItalic, height, numLines}) => {
            _this.texture = GLText.getTexture(image);
            if (bold) _this.textureBold = GLText.getTexture(imageBold);
            if (italic) _this.textureItalic = GLText.getTexture(imageItalic);

            _this.shader = new Shader(shader, {
                tMap: { value:_this.texture, ignoreUIL: true},
                tMapBold: {value: _this.textureBold || Utils3D.getEmptyTexture(), ignoreUIL: true},
                tMapItalic: {value: _this.textureItalic || Utils3D.getEmptyTexture(), ignoreUIL: true},
                uColor: {value: color, ignoreUIL: true},
                uAlpha: {value: alpha, ignoreUIL: true},
                transparent: true,
            });

            if (_this.onCreateShader) _this.onCreateShader(_this.shader);

            createGeometry(buffers);

            _this.mesh = new Mesh(_this.geometry, _this.shader);
            _this.height = height;

            _promise.resolve();
        });
    }

    function overrideParams() {
        if (GLText.overrideParams) {
            _override = {letterSpacing, size, wordSpacing, lineHeight};
            let obj = GLText.overrideParams({letterSpacing, size, wordSpacing, lineHeight});
            letterSpacing = obj.letterSpacing;
            size = obj.size;
            wordSpacing = obj.wordSpacing;
            lineHeight = obj.lineHeight;
        }
    }

    function resetOverride() {
        if (_override) {
            letterSpacing = _override.letterSpacing;
            size = _override.size;
            wordSpacing = _override.wordSpacing;
            lineHeight = _override.lineHeight;
        }
    }

    function createGeometry(buffers) {
        _this.geometry = new Geometry();
        _this.geometry.addAttribute('position', new GeometryAttribute(buffers.position, 3));
        _this.geometry.addAttribute('uv', new GeometryAttribute(buffers.uv, 2));
        _this.geometry.addAttribute('animation', new GeometryAttribute(buffers.animation, 3));
        _this.geometry.addAttribute('weight', new GeometryAttribute(buffers.weight, 1));
        _this.geometry.setIndex(new GeometryAttribute(buffers.index, 1));
        _this.geometry.boundingBox = buffers.boundingBox;
        _this.geometry.boundingSphere = buffers.boundingSphere;

        _this.geometry.letterCount = buffers.letterCount+1;
        _this.geometry.wordCount = buffers.wordCount+1;
        _this.geometry.lineCount = buffers.lineCount+1;
    }

    function updateGeometry(buffers) {
        _this.geometry.attributes.position.setArray(buffers.position);
        _this.geometry.attributes.uv.setArray(buffers.uv);
        _this.geometry.attributes.animation.setArray(buffers.animation);
        _this.geometry.attributes.weight.setArray(buffers.weight);
        _this.geometry.index = buffers.index;
        _this.geometry.indexNeedsUpdate = true;
        _this.geometry.boundingBox = buffers.boundingBox;
        _this.geometry.boundingSphere = buffers.boundingSphere;

        _this.geometry.letterCount = buffers.letterCount+1;
        _this.geometry.wordCount = buffers.wordCount+1;
        _this.geometry.lineCount = buffers.lineCount+1;
    }

    function setVars(options) {
        font = options.font || font;
        bold = options.bold || bold;
        italic = options.italic || italic;
        width = options.width || width;
        align = options.align || align;
        wordSpacing = options.wordSpacing || wordSpacing;
        letterSpacing = options.letterSpacing || letterSpacing;
        paragraphSpacing = options.paragraphSpacing || paragraphSpacing;
        size = options.size || size;
        lineHeight = options.lineHeight || lineHeight;
        wordBreak = options.wordBreak || wordBreak;
        langBreak = options.langBreak || langBreak;
        direction = options.direction || direction;
    }

    function match(options) {
        if (!options) return true;
        if (options.font != font) return false;
        if (options.italic != italic) return false;
        if (options.bold != bold) return false;
        if (options.width != width) return false;
        if (options.align != align) return false;
        if (options.direction != direction) return false;
        if (options.wordSpacing > 0 && options.wordSpacing != wordSpacing) return false;
        if (options.letterSpacing != letterSpacing) return false;
        if (options.paragraphSpacing != paragraphSpacing) return false;
        if (options.size != size) return false;
        if (options.lineHeight != lineHeight) return false;
        if ((options.wordBreak === true && !options.wordBreak) || (options.wordBreak == false && options.wordBreak)) return false;
        return true;
    }

    //*** Event handlers
    function loop() {
    }

    //*** Public methods
    this.destroy = function() {
        _this.mesh && _this.mesh.destroy && _this.mesh.destroy();
    }

    this.ready = this.loaded = function() {
        return _promise;
    }

    this.centerY = function() {
        _this.mesh.position.y = _this.height * 0.5;
        _this.needsCenterY = true;
    }

    this.resize = function(options) {
        return this.setText(text, options);
    }

    this.tweenColor = function(c, time = 300, ease = 'easeOutCubic') {
        if (c) color.tween(c, time, ease);
    }

    this.setColor = function(c) {
        if (c) color.set(c);
    }

    this.setText = function(txt, options) {
        if (text == txt && match(options)) return;
        text = txt;
        if (!text) return;
        setVars(options || {});
        overrideParams();

        _this.string = text;

        _this.charLength = text.length;
        _this.text = new GLTextGeometry({font, italic, bold, text, width, align, direction, wordSpacing, letterSpacing, paragraphSpacing, size, lineHeight, wordBreak, langBreak, config});

        resetOverride();
        _promise = Promise.create();
        _this.text.loaded.then(({buffers, image, imageBold, imageItalic, height, numLines}) => {
            updateGeometry(buffers);

            _this.height = height;

            if (_this.needsCenterY) _this.centerY();
            _promise.resolve();
        });

        return _promise;
    }

    this.getData = function() {
        return {font, italic, bold, text, width, align, direction, wordSpacing, letterSpacing, paragraphSpacing, size, lineHeight, wordBreak, langBreak, color};
    }
}, _ => {
    GLText.FONT_CONFIG = {};

    var _map = new Map();
    GLText.getTexture = function(image) {
        if (!_map.get(image)) {
            let texture = new Texture(image);
            texture.generateMipmaps = false;
            texture.minFilter = Texture.LINEAR;

            _map.set(image, texture);
        }

        return _map.get(image);
    }
});

Class(function GLTextGeometry({
    font,
    italic,
    bold,
    text,
    width = Infinity,
    align = 'left',
    size = 1,
    direction = 'ltr',
    letterSpacing = 0,
    paragraphSpacing = 1,
    lineHeight = 1.4,
    wordSpacing = 0,
    wordBreak = false,
    langBreak = false,
    config = {}
}) {
    let _this = this;
    let json, image, glyphs, buffers;
    let bJson, bImage, bGlyphs;
    let iJson, iImage, iGlyphs;
    let fontHeight, baseline, scale;

    _this.loaded = Promise.create();

    (async function init() {
        await loadFont();
        createGeometry();
    })();

    async function loadFont() {
        [json, image, glyphs] = await GLTextGeometry.loadFont(font);
        if ( bold ) [bJson, bImage, bGlyphs] = await GLTextGeometry.loadFont(bold);
        if ( italic ) [iJson, iImage, iGlyphs] = await GLTextGeometry.loadFont(italic);
    }

    async function createGeometry() {
        let buffers = await GLTextThread.generate({
			font, bold, italic, text, width, align, size, direction, letterSpacing,
			paragraphSpacing, lineHeight, wordSpacing, wordBreak, langBreak,
			json, glyphs, bJson, bGlyphs, iJson, iGlyphs, config
        });

        _this.buffers = buffers;
        _this.image = image;
        _this.imageBold = bImage;
        _this.imageItalic = iImage;
        _this.numLines = buffers.lineLength;
        _this.height = _this.numLines * size * lineHeight;

        _this.onLayout && _this.onLayout(buffers, image, _this.height, _this.numLines);

        _this.loaded.resolve({buffers, image, imageBold: bImage, imageItalic: iImage, height: _this.height, numLines: _this.numLines});
    }
}, _ => {
    async function loadJSON(font) {
        return await get(getPathTo(font, 'json'));
    }

    async function loadImage(font) {
        return await new Promise(resolve => {
            let img = new Image();
            img.onload = () => resolve(img);
            img.crossOrigin = 'anonymous';
            img.src = getPathTo(font, 'png');
        });
    }

    function getPathTo(font, ext) {
        let mapped = false;
        let fontName = (function() {
            for (let key in GLTextGeometry.fontMapping) {
                let mapping = GLTextGeometry.fontMapping[key];
                // console.log(mapping, key, font)
                if (key == font) {
                    mapped = true;
                    return mapping;
                }
            }


            return font;
        })();

        let path = mapped && GLTextGeometry.fontPath ? GLTextGeometry.fontPath : 'assets/fonts/';
        return Assets.getPath(path + fontName + '.' + ext + `?${window._CACHE_ || Date.now()}`);
    }

    let _promises = {};

    GLTextGeometry.fontMapping = {};
    GLTextGeometry.chars = {};

    GLTextGeometry.loadFont = function(font) {
        if (!_promises[font]) {
            let promise = Promise.create();
            _promises[font] = promise;

            (async function() {
                let [json, image] = await Promise.all([loadJSON(font), loadImage(font)]);
                glyphs = {};
                json.chars.forEach(d => glyphs[d.char] = d);
                promise.resolve([json, image, glyphs]);
                GLTextGeometry.chars[font] = json.chars;
            })();
        }

        return _promises[font];
    };
});

Class(function GLTextThread() {
    const _this = this;

    //*** Constructor
    (function () {
        Thread.upload(loadTextGeometry);
    })();

    function loadTextGeometry({font, bold, italic, text, width, align, size, direction, letterSpacing, paragraphSpacing, lineHeight, wordSpacing, wordBreak, langBreak, json, glyphs, bJson, bGlyphs, iJson, iGlyphs, config}, pid) {
        const newline = /\n/;
        const whitespace = /[^\S]/; // matches whitespace except NBSP
        const langbreak = langBreak ? new RegExp( langBreak ) : false;
        const dir = direction === 'rtl' ? -1: 1;

        if (!config) config = {};

        config.boldBaseOffset = config.boldBaseOffset ? config.boldBaseOffset : 0;
        config.italicBaseOffset = config.italicBaseOffset ? config.italicBaseOffset : 0;

        let weights = [];
        let weight = {
            0: glyphs,
            1: bGlyphs,
            2: iGlyphs
        };

        var buffers;

        setWeights();
        createGeometry();

        function setWeights() {
            let i = 0;
            let w = 0;
            while ( i < text.length ) {
                let code = text.substring(i, i+3);
                let endcode = text.substring(i, i+4);

                if ( code === '<b>' || code === '<i>') {
                    w = code === '<b>' ? 1 : 2;
                    text = text.substr(0,i) + text.substr(i + 3);
                }

                if ( endcode === '</b>' || endcode === '</i>') {
                    w = 0;
                    text = text.substr(0,i) + text.substr(i + 4);
                }

                weights.push(w);
                i++;
            }
        }

        function createGeometry() {
            fontHeight = json.common.lineHeight;
            baseline = json.common.base;

            // Use baseline so that actual text height is as close to 'size' value as possible
            scale = size / baseline;

            // Strip spaces and newlines to get actual character length for buffers
            let chars = text.replace(/[ \n]/g, '');
            let numChars = chars.length;

            // Create output buffers
            buffers = {
                position: new Float32Array(numChars * 4 * 3),
                uv: new Float32Array(numChars * 4 * 2),
                animation: new Float32Array(numChars * 3 * 4),
                index: new Uint16Array(numChars * 6),
                weight: new Float32Array( numChars * 4 )
            };

            // Set values for buffers that don't require calculation
            for (let i = 0; i < numChars; i++) {
                buffers.index.set([i * 4, i * 4 + 2, i * 4 + 1, i * 4 + 1, i * 4 + 2, i * 4 + 3], i * 6);
            }

            layout();
        }

        function layout() {
            const lines = [];

            let cursor = 0;

            let wordCursor = 0;
            let wordWidth = 0;
            let line = newLine();

            function newLine( br = false ) {
                const line = {
                    width: 0,
                    glyphs: [],
                };
                if ( lines.last() ) lines.last().br = br;
                lines.push(line);
                wordCursor = cursor;
                wordWidth = 0;
                return line;
            }

            // let maxTimes = 999;
            // let count = 0;
            while (cursor < text.length) {
                // count++;

                let prev = text[cursor - 1];
                let char = text[cursor];
                let next = text[cursor + 1];
                // if (!glyphs[char]) char = 'x';

                // Skip whitespace at start of line
                if (!line.width && whitespace.test(char) && !(prev && newline.test(char) && newline.test(prev))) {
                    cursor++;
                    wordCursor = cursor;
                    wordWidth = 0;
                    continue;
                }

                // If newline char, skip to next line
                if (newline.test(char)) {
                    cursor++;
                    line = newLine( true );
                    continue;
                }

                let style = weight[weights[cursor]] || weight[0];
                let glyph = style[char];
                if (!glyph) {
                    console.warn(`font ${font} missing character '${char}'`);
                    char = Object.keys(style)[0];
                    glyph = style[char];
                }

                glyph.weight = weights[cursor];


                // Find any applicable kern pairs
                if (line.glyphs.length) {
                    const prevGlyph = line.glyphs[line.glyphs.length - 1][0];
                    let kern = getKernPairOffset(glyph.id, prevGlyph.id) * scale;
                    line.width += kern;
                    wordWidth += kern * dir;
                }

                // add char to line
                let gl = Object.assign({}, glyph);
                gl.weight = weights[cursor];
                line.glyphs.push([gl, line.width]);

                // calculate advance for next glyph
                let advance = 0;

                // If whitespace, update location of current word for line breaks
                if (whitespace.test(char)) {
                    gl.whitespace = true;
                    wordCursor = cursor;
                    wordWidth = 0;

                    // Add wordspacing
                    advance += wordSpacing * size;
                } else {

                    // Add letterspacing
                    advance += letterSpacing * size;
                }

                advance += glyph.xadvance * scale;

                line.width += advance;
                wordWidth += advance;

                // If width defined
                if (line.width > width) {

                    // If can break words, undo latest glyph if line not empty and create new line
                    if ((wordBreak || ( char && langBreak && !langbreak.test(char))) && line.glyphs.length > 1) {
                        line.width -= advance;
                        line.glyphs.pop();
                        line = newLine();
                        continue;

                        // If not first word, undo current word and cursor and create new line
                    } else if (!wordBreak && wordWidth !== line.width) {
                        let numGlyphs = cursor - wordCursor + 1;
                        line.glyphs.splice(-numGlyphs, numGlyphs);
                        cursor = wordCursor;
                        line.width -= wordWidth;
                        line = newLine();
                        continue;
                    }
                }

                cursor++;
            }

            // Remove last line if empty
            if (!line.width) lines.pop();

            // If justify
            if (align === 'justify') {
                let max = -Infinity;
                lines.forEach(l => {
                    l.whitespaces = 0;
                    if (max < l.width) max = l.width;
                    l.glyphs.forEach(g => {
                        if (g[0].whitespace) l.whitespaces++;
                    })
                });

                // Calc how much we should add to each whitespace so all lines are equal width
                lines.forEach(l => {
                    let totalToAdd = max - l.width;
                    let addToWhitespace = l.whitespaces === 0 ? 0 : totalToAdd / l.whitespaces;

                    l.width = max;

                    let additionalOffset = 0;
                    l.glyphs.forEach(g => {
                        g[1] += additionalOffset;
                        if (g[0].whitespace) additionalOffset += addToWhitespace;
                    })
                });
            }

            populateBuffers(lines);
        }

        function populateBuffers(lines) {
            const texW = json.common.scaleW;
            const texH = json.common.scaleH;
            const baseOffset = config.baseOffset ? config.baseOffset : 0.07;

            // For all fonts tested, a little offset was needed to be right on the baseline, hence 0.07.
            let y = baseOffset * size;
            let j = 0;

            let glyphIndex = 0;
            let wordIndex = -1;
            let lineId = -1;

            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                let line = lines[lineIndex];

                wordIndex++;
                lineId++;

                for (let i = 0; i < line.glyphs.length; i++) {
                    const glyph = line.glyphs[i][0];
                    let x = line.glyphs[i][1];

                    if ( dir === -1 ) x = line.width - x;
                    if (align === 'center' || align === 'justify') {
                        x -= line.width * 0.5;
                    } else if (align === 'right') {
                        x -= line.width * dir;
                    }

                    // If space, don't add to geometry
                    if (whitespace.test(glyph.char)) {
                        wordIndex++;
                        continue;
                    }

                    if ( glyph.weight === 1 ) y += config.boldBaseOffset * scale;
                    if ( glyph.weight === 2 ) y += config.italicBaseOffset * scale;

                    // Apply char sprite offsets
                    x += glyph.xoffset * scale * dir;
                    y -= glyph.yoffset * scale;

                    buffers.weight.set([
                        glyph.weight,
                        glyph.weight,
                        glyph.weight,
                        glyph.weight
                    ], glyphIndex * 4 );

                    // each letter is a quad. axis bottom left
                    let w = glyph.width * scale;
                    let h = glyph.height * scale;

                    if ( dir === -1 ) {
						buffers.position.set([
							x - w,  y - h, 0,
							x - w,  y,     0,
							x, 		y - h, 0,
							x, 		y,     0
						], j * 4 * 3);
					} else {
						buffers.position.set([
							x,     y - h, 0,
							x,     y,     0,
							x + w, y - h, 0,
							x + w, y,     0
						], j * 4 * 3);
					}

                    buffers.animation.set([
                        glyphIndex, wordIndex, lineId,
                        glyphIndex, wordIndex, lineId,
                        glyphIndex, wordIndex, lineId,
                        glyphIndex, wordIndex, lineId
                    ],  glyphIndex * 3 *  4);

                    glyphIndex++;

                    let u = glyph.x / texW;
                    let uw = glyph.width / texW;
                    let v = 1.0 - glyph.y / texH;
                    let vh = glyph.height / texH;
                    buffers.uv.set([
                        u,      v - vh,
                        u,      v,
                        u + uw, v - vh,
                        u + uw, v,
                    ], j * 4 * 2);

                    if ( glyph.weight === 1 ) y -= config.boldBaseOffset * scale;
                    if ( glyph.weight === 2 ) y -= config.italicBaseOffset * scale;

                    // Reset cursor to baseline
                    y += glyph.yoffset * scale;

                    j++;
                }

                y -= size * lineHeight * ( line.br ? paragraphSpacing : 1 );
            }

            let geom;
            if (window.zUtils3D) {
                geom = new Geometry();
                geom.addAttribute('position', new GeometryAttribute(buffers.position, 3));
                geom.computeBoundingBox();
                geom.computeBoundingSphere();
            }

            let backing = [];
            for (let key in buffers) {
                backing.push(buffers[key].buffer);
            }

            buffers.lineLength = lines.length;
            if (geom) {
                buffers.boundingBox = geom.boundingBox;
                buffers.boundingSphere = geom.boundingSphere;
            }
            buffers.letterCount = glyphIndex;
            buffers.lineCount = lineId;
            buffers.wordCount = wordIndex;

            resolve(buffers, pid, backing);
        }

        function getKernPairOffset(id1, id2) {
            for (let i = 0; i < json.kernings.length; i++) {
                let k = json.kernings[i];
                if (k.first < id1) continue;
                if (k.second < id2) continue;
                if (k.first > id1) return 0;
                if (k.first === id1 && k.second > id2) return 0;
                return k.amount;
            }
            return 0;
        }
    }

    //*** Event handlers

    //*** Public methods
    this.generate = async function(obj) {
        return Thread.shared().loadTextGeometry(obj);
    }
}, 'static');

    /**
     * @name this.init
     * @memberof GLUI
     *
     * @function
     * @param is2D
     * @param is3D
    */
/**
 * @name GLUI
 */
Class(function GLUI() {
    Inherit(this, Component);
    const _this = this;

    const hasMetal = !!window.Metal;
    const hasAuraAR = !!window.AURA_AR;

    function loop() {
        if (hasMetal) return;

        //sad little workaround for native AR
        if (hasAuraAR && AURA_AR.active) {
            World.NUKE.postRender = null;
            AURA_AR.postRender = loop;
        }

        if (_this.Scene) _this.Scene.render();
        if (_this.Stage) _this.Stage.render();
    }

    //*** Event handlers

    //*** Public methods
    window.$gl = function(width, height, map) {
        return new GLUIObject(width, height, map);
    }

    window.$glText = function(text, fontName, fontSize, options) {
        return new GLUIText(text, fontName, fontSize, options);
    }

    this.init = async function(is2D, is3D) {
        if (_this.initialized) return;

        if (is2D === undefined) {
            is2D = true;
            is3D = true;
        }

        await AssetLoader.waitForLib('zUtils3D');
        if (is2D) _this.Stage = new GLUIStage();
        if (is3D) {
            _this.Scene = new GLUIStage3D();
            _this.Scene.interaction.input = Mouse;
        }

        _this.wait(World, 'NUKE', _ => {
            _this.initialized = true;
            if (_this.Scene) World.NUKE.onBeforeRender = _this.Scene.mark;
            World.NUKE.postRender = loop;
        });
    }

    /**
     * @name this.clear
     * @memberof GLUI
     *
     * @function
    */
    this.clear = function() {
        _this.Stage.clear();
        _this.Scene.clear();
    }

    /**
     * @name this.ready
     * @memberof GLUI
     *
     * @function
    */
    this.ready = function() {
        return _this.wait(_this, 'initialized');
    }

    /**
     * @name this.renderDirect
     * @memberof GLUI
     *
     * @function
     * @param render
    */
    this.renderDirect = function(render) {
        if (_this.Scene) _this.Scene.renderDirect(render);
        if (_this.Stage) _this.Stage.renderDirect(render);
    }
}, 'static');
/**
 * @name GLUIElement
 */
Class(function GLUIElement() {
    Inherit(this, Component);
    const _this = this;

    this.element = $gl();

    /**
     * @name this.create
     * @memberof GLUIElement
     *
     * @function
     * @param w
     * @param h
     * @param t
    */
    this.create = function (w, h, t) {
        return this.element.create(w, h, t);
    }
});
Class(function GLUIUtils () {
    const _this = this;

    //*** Constructor
    (function () {

    })()

    //*** Event handlers

    //*** Public methods

    /**
     * Enables or disables retina mode for the given GLUI $obj - that is,
     * whether the object is rendered as part of the main 3D scene at the
     * configured DPR, or rendered directly to the framebuffer at the canvas
     * full native resolution.
     * For convenience, this function can also be used to add a newly created
     * GLUI object to the scene with the requested `retinaMode` setting, by
     * passing the objects logical parent as the third parameter.
     * If `parent` is omitted, and the object is not already in the scene,
     * this function does nothing.
     * If the renderer does not support retina mode, the `retinaMode` parameter
     * is effectively ignored - the GLUI object is always added to the main
     * scene.
     *
     * @name GLUIUtils.setRetinaMode()
     * @memberof GLUIUtils
     *
     * @param $obj GLUIObject
     * @param retinaMode boolean
     * @param parent Base3D
     */
    _this.setRetinaMode = function($obj, retinaMode = true, parent) {
        if (RenderManager.type === RenderManager.WEBVR) retinaMode = false;
        if (!parent) {
            parent = ($obj.anchor && $obj.anchor._parent) || $obj.group._parent;
            if (!parent) return;
        }
        if (retinaMode) {
            let gluiToRTScene;
            let p = parent;
            while (p) {
                if (p.glSceneEnabled) gluiToRTScene = p;
                p = p.parent;
            }

            if (gluiToRTScene) {
                gluiToRTScene.glScene.add($obj);
            } else {
                GLUI.Scene.add($obj); // Note: this may replace obj.anchor
            }

            parent.add($obj.anchor);
            $obj.anchor.retinaAnchorFor = $obj;
            if ($obj.scaleX !== 1 || $obj.scaleY !== 1) {
                $obj.isDirty = true;
                $obj.mesh && $obj.mesh.onBeforeRender && $obj.mesh.onBeforeRender();
            }
        } else {
            if (_this.isRetinaMode($obj)) {
                parent.remove($obj.anchor);
                GLUI.Scene.remove($obj);
                $obj.anchor._parent = null;
                $obj.group.visible = parent.determineVisible(); // because mark() in GLUIStage3D may have set this to false, and it wont be called again.
                // Because loop() in GLUIStage3D decomposes the anchors world matrix into the group,
                // will need to reset the group transform.
                if (typeof $obj.isDirty === 'boolean' && $obj.mesh && $obj.mesh.onBeforeRender) {
                    $obj.isDirty = true;
                    $obj.mesh.onBeforeRender();
                } else {
                    $obj.group.position.setScalar(0);
                    $obj.group.quaternion.set(0, 0, 0, 1);
                    $obj.group.scale.setScalar(1);
                }
                $obj.deferred = false;
                $obj.parent = null;
            }
            parent.add($obj.group);
        }
    };

    /**
     * Returns `true` if the given GLUI object will be rendered in retina mode.
     * Always returns `false` on VR where there is no retina mode.
     *
     * @name GLUIUtils.isRetinaMode()
     * @memberof GLUIUtils
     *
     * @param $obj GLUIObject
     * @return boolean
     */
    _this.isRetinaMode = function($obj) {
        return RenderManager.type !== RenderManager.WEBVR &&
            $obj.anchor && $obj.anchor._parent && $obj.parent === GLUI.Scene;
    }

}, 'static')

/**
 * @name GLUIBatch
 */
Class(function GLUIBatch(globalUniforms = {}, _useWorldCoords) {
    Inherit(this, Component);
    const _this = this;
    var _timer, _geometry, _shader;

    var _objects = [];

   /**
    * @name group
    * @memberof GLUIBatch
    * @property
    */
    this.group = new Group();

    //*** Constructor
    (function () {
        if (typeof globalUniforms === 'boolean') {
            _useWorldCoords = globalUniforms;
            globalUniforms = {};
        }
        if (!GLUIBatch.cache) GLUIBatch.cache = {};
        _this.startRender(loop);
    })();

    function loop() {
        if (!_geometry) return;

        for (let i = 0; i < _objects.length; i++) {
            let obj = _objects[i];
            if (!obj._buffers) continue;

            obj.mesh.onBeforeRender();

            if (_useWorldCoords) {
                obj.group.updateMatrixWorld();
                obj.mesh.getWorldPosition(obj.worldPosition);
                obj.worldRotation.setFromQuaternion(obj.mesh.getWorldQuaternion());
                obj.mesh.getWorldScale(obj.worldScale);
            }

            obj._buffers.forEach(buffer => {
                let dirty = false;
                dirty = !buffer.value.equals(buffer.lookup);
                buffer.value.copy(buffer.lookup);

                if (dirty) {
                    let attribute = _geometry.attributes[buffer.key];
                    let array = attribute.array;
                    switch (buffer.key) {
                        case 'scale':
                            if (_useWorldCoords) {
                                array[i * 2 + 0] = obj.worldScale.x;
                                array[i * 2 + 1] = obj.worldScale.y;
                            } else {
                                array[i * 2 + 0] = obj.group.scale.x * obj.mesh.scale.x;
                                array[i * 2 + 1] = obj.group.scale.y * obj.mesh.scale.y;
                            }
                            break;

                        case 'rotation':
                            array[i] = buffer.lookup.z;
                            break;

                        default:
                            if (!_useWorldCoords) {
                                array[i * 3 + 0] = obj.group.position.x;
                                array[i * 3 + 1] = obj.group.position.y;
                            } else {
                                array[i * 3 + 0] = obj.worldPosition.x;
                                array[i * 3 + 1] = obj.worldPosition.y;
                            }
                            array[i * 3 + 2] = obj.mesh.renderOrder;
                            break;
                    }

                    attribute.needsUpdate = true;
                }
            });

            obj._uniforms.forEach(uniform => {
                let dirty = false;
                if (uniform.type == 'f') {
                    dirty = obj.mesh.shader.uniforms[uniform.key].value != uniform.value;
                    uniform.value = obj.mesh.shader.uniforms[uniform.key].value;
                } else {
                    dirty = !obj.mesh.shader.uniforms[uniform.key].value.equals(uniform.value);
                    uniform.value.copy(obj.mesh.shader.uniforms[uniform.key].value);
                }

                if (dirty) {
                    let attribute = _geometry.attributes['a_' + uniform.key];
                    let array = attribute.array;

                    if (uniform.type == 'f') {
                        array[i] = uniform.value;
                    } else {
                        uniform.value.toArray(array, i * uniform.components);
                    }

                    attribute.needsUpdate = true;
                }
            });
        }
    }

    function getTypeFromSize(size) {
        switch (size) {
            case 1: return 'float'; break;
            case 2: return 'vec2'; break;
            case 3: return 'vec3'; break;
            case 4: return 'vec4'; break;
        }
    }

    function createMesh() {
        let obj = _objects[0];
        let shader = obj.mesh.shader;
        _geometry = new Geometry().instanceFrom(_objects[0].mesh.geometry.clone());

        let map = {};
        let arrays = {};
        _objects.forEach((obj, i) => {
            obj.mesh.onBeforeRender();

            let buffers = [];
            let uniforms = [];
            for (let key in shader.uniforms) {
                let uniform = shader.uniforms[key];
                if (!uniform) continue;
                if (uniform.value instanceof Color) uniforms.push({key, type: 'c', components: 3});
                if (uniform.value instanceof Vector4) uniforms.push({key, type: 'v4', components: 4});
                if (uniform.value instanceof Vector3) uniforms.push({key, type: 'v3', components: 3});
                if (uniform.value instanceof Vector2) uniforms.push({key, type: 'v', components: 2});
                if (typeof uniform.value === 'number') uniforms.push({key, type: 'f', components: 1});
            }

            if (_useWorldCoords) {
                obj.worldScale = new Vector3();
                obj.worldRotation = new Euler();
                obj.worldPosition = new Vector3();
            }

            buffers.push({key: 'scale', lookup: _useWorldCoords ? obj.worldScale : obj.group.scale, components: 2});
            buffers.push({key: 'rotation', lookup: _useWorldCoords ? obj.worldRotation : obj.group.rotation, components: 1});
            buffers.push({ key: 'offset', lookup: _useWorldCoords ? obj.worldPosition : obj.group.position, components: 3 });

            uniforms.forEach(uniform => {
                if (!arrays['a_' + uniform.key]) arrays['a_' + uniform.key] = [];
                if (!map['a_' + uniform.key]) map['a_' + uniform.key] = uniform;
                let value = shader.uniforms[uniform.key].value;
                if (typeof value === 'object') {
                    uniform.value = value.clone();
                    uniform.value.toArray(arrays['a_' + uniform.key], i * uniform.components);
                } else {
                    uniform.value = shader.uniforms[uniform.key].value;
                    arrays['a_' + uniform.key].push(uniform.value);
                }
            });

            buffers.forEach(buffer => {
                if (!arrays[buffer.key]) arrays[buffer.key] = [];
                if (!map[buffer.key]) map[buffer.key] = buffer;
                buffer.value = buffer.lookup.clone();

                switch (buffer.key) {
                    case 'scale':
                        arrays[buffer.key].push(obj.group.scale.x * obj.mesh.scale.x, obj.group.scale.y * obj.mesh.scale.y);
                        break;

                    case 'rotation':
                        arrays[buffer.key].push(buffer.lookup.z);
                        break;

                    default:
                        arrays[buffer.key].push(buffer.lookup.x, buffer.lookup.y, obj.mesh.renderOrder);
                        break;
                }
            });

            obj._buffers = buffers;
            obj._uniforms = uniforms;

            obj.shader.neverRender = true;
        });

        let attributes = [];
        let defines = [];
        for (let key in map) {
            if (key.includes('a_')) {
                attributes.push(`% ${getTypeFromSize(map[key].components)} ${key};`);
                defines.push(`${key.replace('a_', 'v_')} = ${key};`);
            }
        }
        attributes = attributes.join('\n');
        defines = defines.join('\n');

        for (let key in arrays) {
            _geometry.addAttribute(key, new GeometryAttribute(new Float32Array(arrays[key]), map[key].components, 1));
        }

        if (GLUIBatch.cache[shader.fsName]) _shader = GLUIBatch.cache[shader.fsName];
        else {
            _shader = _this.initClass(Shader, 'GLUIBatch', shader.fsName, Object.assign({}, {
                transparent: true,
                depthWrite: false,
                depthTest: false
            }, globalUniforms));

            let vsSplit = _shader.vertexShader.split('__ACTIVE_THEORY_LIGHTS__');
            let fsSplit = _shader.fragmentShader.split('__ACTIVE_THEORY_LIGHTS__');

            let definitions = [];
            fsSplit[1].split('\n').forEach(line => {
                if (line.includes('uniform')) {
                    if (line.includes('sampler2D')) return;
                    let data = line.split(' ');
                    definitions.push(`${data[2].replace(';', '')} = a_${data[2]}`);
                    vsSplit[1] = `\nattribute ${data[1]} a_${data[2]}\nvarying ${data[1]} ${data[2]}` + vsSplit[1];
                    vsSplit[1] = vsSplit[1].replace(line, '');
                    fsSplit[1] = fsSplit[1].replace(line, `varying ${data[1]} ${data[2]}`);
                }
            });

            vsSplit[1] = vsSplit[1].replace('//vdefines', '\n' + definitions.join('\n'));

            _shader.vertexShader = vsSplit.join('__ACTIVE_THEORY_LIGHTS__');
            _shader.fragmentShader = fsSplit.join('__ACTIVE_THEORY_LIGHTS__');

            GLUIBatch.cache[shader.fsName] = _shader;
        }

        shader.copyUniformsTo(_shader);
        _this.mesh = new Mesh(_geometry, _shader);
        _this.mesh.frustumCulled = false;
        _this.group.add(_this.mesh);
    }

    //*** Event handlers

    //*** Public methods
    /**
     * @name this.add
     * @memberof GLUIBatch
     *
     * @function
     * @param obj
    */
    this.add = function(obj) {
        clearTimeout(_timer);
        _timer = _this.delayedCall(createMesh, 50);
        if (_useWorldCoords) {
            let getAlpha = obj.getAlpha;
            if (getAlpha) {
                obj.getAlpha = () => {
                    let parentAlpha = _this.parent ? _this.parent.getAlpha() : 1;
                    return parentAlpha * getAlpha.call(obj);
                };
            }
        } else {
            _this.parent.add(obj);
        }
        _objects.push(obj);
    }

    /**
     * @name this.setZ
     * @memberof GLUIBatch
     *
     * @function
     * @param z
     */
    this.setZ = async function(z) {
        await _this.wait('mesh');
        _this.mesh.renderOrder = z;
    }

    /**
     * @name this.onDestroy
     * @memberof GLUIBatch
     *
     * @function
    */
    this.onDestroy = function() {
        if (_this.mesh) {
            _this.mesh.destroy();
        }
    }
});

/**
 * @name GLUIBatchText
 */
Class(function GLUIBatchText(globalUniforms = {}, _useWorldCoords) {
    Inherit(this, Component);
    const _this = this;
    var _geometry, _shader, _timer, _forceUpdate;

    var _promises = [];
    var _toSplice = [];
    var _objects = [];
    var _offset = 0;

   /**
    * @name group
    * @memberof GLUIBatchText
    * @property
    */
    this.group = new Group();

    //*** Constructor
    (function () {
        if (typeof globalUniforms === 'boolean') {
            _useWorldCoords = globalUniforms;
            globalUniforms = {};
        }
        _this.flag('canLoad', true);
        _this.startRender(loop);
    })();

    function loop() {
        if (!_geometry) return;
        let updated = false;

        for (let key in _geometry.attributes) {
            let attrib = _geometry.attributes[key];
            if (attrib.updateRange.length) attrib.updateRange.length = 0;
        }

        let len = _objects.length;
        for (let i = 0; i < len; i++) {
            let obj = _objects[i];
            obj.mesh.onBeforeRender();

            if (_useWorldCoords) {
                obj.group.updateMatrixWorld();
                obj.mesh.getWorldPosition(obj.worldPosition);
                obj.worldRotation.setFromQuaternion(obj.mesh.getWorldQuaternion());
                obj.mesh.getWorldScale(obj.worldScale);
            }

            let offset = obj._offset;
            let count = obj._count;
            let end = offset + count;

            obj._buffers.forEach(buffer => {
                let dirty = false;
                dirty = !buffer.value.equals(buffer.lookup);
                buffer.value.copy(buffer.lookup);

                if (dirty) {
                    let array = _geometry.attributes[buffer.key].array;
                    for (let j = offset; j < end; j++) {
                        switch (buffer.components) {
                            case 4:
                                array[j * 4 + 0] = buffer.lookup.x;
                                array[j * 4 + 1] = buffer.lookup.y;
                                array[j * 4 + 2] = buffer.lookup.z;
                                array[j * 4 + 3] = buffer.lookup.w;
                                break

                            case 3:
                                array[j * 3 + 0] = buffer.lookup.x;
                                array[j * 3 + 1] = buffer.lookup.y;
                                array[j * 3 + 2] = buffer.lookup.z;
                                break;

                            case 2:
                                array[j * 2 + 0] = buffer.lookup.x;
                                array[j * 2 + 1] = buffer.lookup.y;
                                break;

                            case 1:
                                array[j] = buffer.lookup.z;
                                break;
                        }
                    }

                    updated = true;
                    buffer.updateRange.offset = offset * buffer.components;
                    buffer.updateRange.count = count * buffer.components;
                    _geometry.attributes[buffer.key].updateRange.push(buffer.updateRange);
                    _geometry.attributes[buffer.key].needsUpdate = true;
                }
            });

            obj._uniforms.forEach(uniform => {
                let dirty = false;
                if (uniform.type == 'f') {
                    dirty = obj.mesh.shader.uniforms[uniform.key].value != uniform.value;
                    uniform.value = obj.mesh.shader.uniforms[uniform.key].value;
                } else {
                    dirty = !obj.mesh.shader.uniforms[uniform.key].value.equals(uniform.value);
                    uniform.value.copy(obj.mesh.shader.uniforms[uniform.key].value);
                }

                if (dirty || _forceUpdate) {
                    let array = _geometry.attributes['a_' + uniform.key].array;
                    for (let j = offset; j < end; j++) {
                        if (uniform.type == 'f') {
                            array[j] = obj.mesh.shader.uniforms[uniform.key].value;
                        } else {
                            obj.mesh.shader.uniforms[uniform.key].value.toArray(array, j * uniform.components);
                        }
                    }

                    updated = true;
                    uniform.updateRange.offset = offset * uniform.components;
                    uniform.updateRange.count = count * uniform.components;
                    _geometry.attributes['a_' + uniform.key].updateRange.push(uniform.updateRange);
                    _geometry.attributes['a_' + uniform.key].needsUpdate = true;
                }
            });
        }

        if (updated) {
            for (let key in _geometry.attributes) {
                let attrib = _geometry.attributes[key];
                if (!attrib.updateRange.length) continue;

                let bottom;
                let toSplice = _toSplice;
                toSplice.length = 0;
                for (let i = 0; i < attrib.updateRange.length; i++) {
                    let current = attrib.updateRange[i];
                    let prev = attrib.updateRange[i-1];
                    if (!prev) {
                        bottom = current;
                        continue;
                    }
                    let prevRange = prev.offset + prev.count;
                    if (prevRange == current.offset) {
                        bottom.count += current.count;
                        toSplice.push(i);
                    } else {
                        bottom = current;
                    }
                }
                for (let i = toSplice.length-1; i > -1; i--) attrib.updateRange.splice(toSplice[i], 1);
            }
        }
        _forceUpdate = false;
    }

    function addAttributes(obj, mesh) {
        let {geometry, shader} = mesh;
        let count = geometry.attributes.uv.count;

        mesh.onBeforeRender();

        let buffers = [];
        let uniforms = [];
        for (let key in shader.uniforms) {
            let uniform = shader.uniforms[key];
            if (uniform.value instanceof Color) uniforms.push({key, type: 'c', components: 3});
            if (uniform.value instanceof Vector3) uniforms.push({key, type: 'v3', components: 3});
            if (uniform.value instanceof Vector4) uniforms.push({key, type: 'v4', components: 4});
            if (uniform.value instanceof Vector2) uniforms.push({key, type: 'v', components: 2});
            if (typeof uniform.value === 'number') uniforms.push({key, type: 'f', components: 1});
        }

        if (_useWorldCoords) {
            obj.worldScale = new Vector3();
            obj.worldRotation = new Euler();
            obj.worldPosition = new Vector3();
        }

        buffers.push({key: 'offset', lookup: _useWorldCoords ? obj.worldPosition : obj.group.position, components: 3});
        buffers.push({key: 'scale', lookup: _useWorldCoords ? obj.worldScale : obj.group.scale, components: 2});
        buffers.push({key: 'rotation', lookup: _useWorldCoords ? obj.worldRotation : obj.group.rotation, components: 1});

        uniforms.forEach(uniform => {
            uniform.updateRange = {};
            uniform.value = shader.uniforms[uniform.key].value;
            if (typeof uniform.value === 'object') uniform.value = uniform.value.clone();
            uniform.buffer = new Float32Array(count * uniform.components);
        });

        buffers.forEach(buffer => {
            buffer.updateRange = {};
            buffer.value = buffer.lookup.clone();
            buffer.buffer = new Float32Array(count * buffer.components);
        });

        for (let i = 0; i < count; i++) {
            buffers.forEach(buffer => {
                switch (buffer.components) {
                    case 4:
                        buffer.buffer[i * 4 + 0] = buffer.lookup.x;
                        buffer.buffer[i * 4 + 1] = buffer.lookup.y;
                        buffer.buffer[i * 4 + 2] = buffer.lookup.z;
                        buffer.buffer[i * 4 + 3] = buffer.lookup.w;
                        break

                    case 3:
                        buffer.buffer[i * 3 + 0] = buffer.lookup.x;
                        buffer.buffer[i * 3 + 1] = buffer.lookup.y;
                        buffer.buffer[i * 3 + 2] = buffer.lookup.z;
                        break;

                    case 2:
                        buffer.buffer[i * 2 + 0] = buffer.lookup.x;
                        buffer.buffer[i * 2 + 1] = buffer.lookup.y;
                        break;

                    case 1:
                        buffer.buffer[i] = buffer.lookup.z;
                        break;
                }
            });

            uniforms.forEach(uniform => {
                if (uniform.type == 'f') uniform.buffer[i] = shader.uniforms[uniform.key].value;
                else shader.uniforms[uniform.key].value.toArray(uniform.buffer, i * uniform.components);
            });
        }

        buffers.forEach(buffer => {
            geometry.addAttribute(buffer.key, new GeometryAttribute(buffer.buffer, buffer.components));
        })

        uniforms.forEach(uniform => {
            geometry.addAttribute('a_' + uniform.key, new GeometryAttribute(uniform.buffer, uniform.components));
        });

        obj._offset = _offset;
        obj._count = count;
        obj._uniforms = uniforms;
        obj._buffers = buffers;
        _objects.push(obj);
        _offset += count;
    }

    function getTypeFromSize(size) {
        switch (size) {
            case 1: return 'float'; break;
            case 2: return 'vec2'; break;
            case 3: return 'vec3'; break;
            case 4: return 'vec4'; break;
        }
    }

    function initGeometry(mesh) {
        _shader = _this.initClass(Shader, 'GLUIBatchText', mesh.shader.fsName, Object.assign({}, {
            transparent: true,
            depthWrite: false,
            customCompile: `${mesh.shader.vsName}|${mesh.shader.fsName}|instance`,
        }, globalUniforms));

        if (!_shader.vertexShader) {
            _shader.resetProgram();
        }
        let vsSplit = _shader.vertexShader.split('__ACTIVE_THEORY_LIGHTS__');
        let fsSplit = _shader.fragmentShader.split('__ACTIVE_THEORY_LIGHTS__');

        let definitions = [];
        let definitionSplit = [];
        fsSplit[1].split('\n').forEach(line => {
            if (line.includes('uniform')) {
                if (line.includes('sampler2D')) return;
                let data = line.split(' ');
                definitions.push(`${data[2].replace(';', '')} = a_${data[2]}`);
                vsSplit[1] = `\nattribute ${data[1]} a_${data[2]}\nvarying ${data[1]} ${data[2]}` + vsSplit[1];
                vsSplit[1] = vsSplit[1].replace(line, '');
                fsSplit[1] = fsSplit[1].replace(line, `varying ${data[1]} ${data[2]}`);
            }
        });

        definitions.forEach(def => definitionSplit.push(def.split(' =')[0].trim()));

        let baseVS = Shaders.getShader(mesh.shader.vsName+'.vs');
        if (baseVS.includes('//start batch main')) {
            let main = baseVS.split('//start batch main')[1].split('//end batch main')[0];
            vsSplit[1] = vsSplit[1].replace('//custommain', main);

            let beforeMain = baseVS.split('void main() {')[0];
            beforeMain = beforeMain.replace('uniform sampler2D tMap;', '');
            beforeMain = beforeMain.replace('varying vec2 vUv;', '');
            beforeMain.split('\n').forEach(line => {
                definitionSplit.forEach(def => {
                    if (line.includes(def) && line.includes(['uniform', 'varying'])) {
                        beforeMain = beforeMain.replace(line, '');
                    }
                });
            });
            vsSplit[0] += beforeMain;
        }

        vsSplit[1] = vsSplit[1].replace('//vdefines', '\n' + definitions.join('\n'));

        _shader.vertexShader = vsSplit.join('__ACTIVE_THEORY_LIGHTS__');
        _shader.fragmentShader = fsSplit.join('__ACTIVE_THEORY_LIGHTS__');

        mesh.shader.copyUniformsTo(_shader);

        _geometry = mesh.geometry.clone();

        for (let key in _geometry.attributes) _geometry.attributes[key].updateRange = [];
    }

    async function createMesh() {
        if (_this.flag('mesh')) return;
        _this.flag('mesh', true);
        await Promise.all(_promises);
        await _this.wait(100);
        let mesh = new Mesh(_geometry, _shader);
        _this.mesh = mesh;
        mesh.frustumCulled = false;
        _this.group.add(mesh);
    }

    //*** Event handlers

    //*** Public methods
    /**
     * @name this.add
     * @memberof GLUIBatchText
     *
     * @function
     * @param obj
     */
    _this.add = async function(obj) {
        await _this.flag('canLoad');
        _this.flag('canLoad', false);
        await obj.loaded();
        obj.mesh.shader.neverRender = true;

        _promises.push(obj.loaded());

        addAttributes(obj, obj.mesh);

        if (_useWorldCoords) {
            let getAlpha = obj.getAlpha;
            if (getAlpha) {
                obj.getAlpha = () => {
                    let parentAlpha = _this.parent ? _this.parent.getAlpha() : 1;
                    return parentAlpha * getAlpha.call(obj);
                };
            }
        } else {
            _this.parent.add(obj);
        }

        if (!_geometry) initGeometry(obj.mesh);
        else _geometry.merge(obj.mesh.geometry);
        _this.flag('canLoad', true);

        clearTimeout(_timer);
        _timer = _this.delayedCall(createMesh, 50);

        obj.isDirty = true;
    }

    /**
     * @name this.forceUpdate
     * @memberof GLUIBatchText
     *
     * @function
    */
    _this.forceUpdate = function() {
        _forceUpdate = true;
    }

    /**
     * @name this.onDestroy
     * @memberof GLUIBatchText
     *
     * @function
    */
    _this.onDestroy = function() {
        if (_this.mesh) _this.mesh.destroy();
    }
});

Class(function GLUIStageInteraction2D(_camera, _scene, _stage, _custom) {
    Inherit(this, Component);
    const _this = this;
    var _ray, _over, _click, _customTest, _disabled, _blocked;

    var _test = [];
    var _objects = this.objects = [];
    var _hold = new Vector2();
    var _calc = new Vector2();
    var _lastTestedPoint = new Vector2();

    this.preventDoubleClickTime = 300;

    //*** Constructor
    (function () {
        addListeners();
        _this.startRender(_ => {});
    })();

    function cacheTopScene(obj) {
        let p = obj;
        while (p) {
            if (p instanceof Scene) obj.interactionScene = p;
            p = p._parent;
        }
    }

    function testObjects() {
        let objects = GLUI.Stage.interaction.objects;
        _test.length = 0;
        for (let i = objects.length-1; i > -1; i--) {
            let obj = objects[i];
            if (!obj.interactionScene) cacheTopScene(obj);
            if (obj.forceGLUIInteraction || (obj.determineVisible() && _scene == obj.interactionScene)) _test.push(obj);
        }
        return _test;
    }

    //*** Event handlers
    function addListeners() {
        if (!_custom) _this.events.sub(Mouse.input, Interaction.MOVE, move);
        _this.events.sub(Mouse.input, Interaction.START, start);
        _this.events.sub(Mouse.input, Interaction.END, end);
        _this.events.sub(Interaction3D.EXTERNAL_PRESS, externalStart);
        _this.events.sub(Interaction3D.EXTERNAL_RELEASE, externalRelease);
    }

    function externalStart() {
        if (_this._invisible) return;
        start(_lastTestedPoint);
    }

    function externalRelease() {
        if (_this._invisible) return;
        end(_lastTestedPoint);
    }

    function move(e) {
        if (GLUI.PREVENT_INTERACTION || _this._invisible || _disabled || _blocked) return;
        if (!_ray) {
            _ray = new Raycaster(_camera);
            _ray.testVisibility = false;
        }

        let objects = testObjects();
        if (!objects.length) {
            if (_over) {
                _over._onOver({action: 'out', object: _over});
                _over = null;
                Stage.cursor('auto');
            }
            return;
        }

        let hit = _ray.checkHit(objects, e, _stage);
        try {
            if (hit[0]) {
                if (!_customTest) GLUI.HIT = true;
                let obj = hit[0].object.glui;
                if (!_over) {
                    _over = obj;
                    _over._onOver({action: 'over', object: obj});
                    Stage.cursor('pointer');
                }

                if (_over != obj) {
                    _over._onOver({action: 'out', object: _over});
                    _over = obj;
                    _over._onOver({action: 'over', object: obj});
                    Stage.cursor('pointer');
                }
            } else {
                if (!_customTest) GLUI.HIT = false;
                if (_over) {
                    _over._onOver({action: 'out', object: _over});
                    _over = null;
                    Stage.cursor('auto');
                }
            }
        } catch(e) {
            console.warn(e);
        }
    }

    function start(e) {
        let checkDefault = GLUI.PREVENT_DEFAULT_INTERACTION && !(e instanceof Vector2);
        let checkPrevention = GLUI.PREVENT_INTERACTION || _this._invisible || _disabled || _blocked;
        if (checkDefault || checkPrevention) return;
        if (Device.mobile || RenderManager.type == RenderManager.WEBVR) move(e);
        if (_over && !_click) {
            _click = _over;
            _hold.copy(e);
            _hold.time = Date.now();
        }
    }

    function end(e) {
        if (GLUI.PREVENT_INTERACTION || _this._invisible || _disabled || _blocked) return;

        if (_customTest) {
            if (Device.mobile) {
                if (_click && _over == null) _over = _click;
            }
        }

        GLUI.HIT = false;
        if (_click) {
            if (Date.now() - _hold.time > 750) return _click = null;
            if (_click == _over) {
                try {
                    _blocked = true;
                    _this.delayedCall(_ => {
                        _blocked = false;
                    }, _this.preventDoubleClickTime);

                    _click._onClick({action: 'click', object: _click});
                    if ((Device.mobile || _custom) && _over) {
                        _over._onOver({action: 'out', object: _over});
                        _over = null;
                        Stage.cursor('auto');
                    }
                } catch(e) {
                    console.warn(e);
                }
            }
        }

        _click = null;
    }

    //*** Public methods
    this.add = function(obj) {
        if (obj) _objects.push(obj.mesh || obj);
    }

    this.remove = function(obj) {
        if (obj) _objects.remove(obj.mesh || obj);
    }

    this.testWith = function(point, id) {
        point.customTest = true;
        _lastTestedPoint.copy(point);
        _lastTestedPoint.customTest = true;

        _customTest = true;

        move(point);
        if (Device.mobile && RenderManager.type != RenderManager.WEBVR) {
            if (_over) start(point);
        }
    }

    this.testWithFinger = function(point, distance, minDistance) {
        if (!_ray) {
            _ray = new Raycaster(_camera);
            _ray.testVisibility = false;
        }

        _customTest = true;

        let objects = testObjects();
        if (!objects.length) return;

        if (distance < 0.02) {
            let hit = _ray.checkHit(objects, point, _stage);
            try {
                if (hit[0]) {
                    let obj = hit[0].object.glui;
                    if (!obj._preventClickTime || Render.TIME - obj._preventClickTime > _this.preventDoubleClickTime) {
                        if (!obj._requiresClear) {
                            _over = obj;
                            obj._onOver({ action: 'over', object: obj });
                            obj._onClick({ action: 'click', object: obj });
                            obj._preventClickTime = Render.TIME;
                            obj._requiresClear = true;
                        }
                    }
                } else {
                    if (_over) {
                        _over._requiresClear = false;
                        _over._onOver({action: 'out', object: _over});
                        _over = null;
                    }
                }
            } catch (e) {
                console.warn(e);
            }
        } else {
            if (_over) {
                _over._requiresClear = false;
                _over._onOver({action: 'out', object: _over});
                _over = null;
            }
        }
    }

    this.set('_disabled', v => {
        _disabled = v;
        if (_disabled) {
            _click = null;
            if (_over) {
                _over._onOver({action: 'out', object: _over});
                _over = null;
                Stage.cursor('auto');
            }
        }
    });

    this.onInvisible = () => {
        _click = null;
        if (_over) {
            _over._onOver({action: 'out', object: _over});
            _over = null;
            Stage.cursor('auto');
        }
    };
});
Class(function GLUIStageInteraction3D() {
    Inherit(this, Component);
    const _this = this;

    //*** Event handlers
    function onHover(e) {
        e.mesh.glui._onOver({action: e.action, object: e.mesh.glui});
    }

    function onClick(e) {
        e.mesh.glui._onClick({action: e.action, object: e.mesh.glui});
    }

    //*** Public methods
    this.add = function(obj, camera = World.CAMERA) {
        Interaction3D.find(camera).add(obj.mesh || obj, onHover, onClick);
    }

    this.remove = function(obj, camera = World.CAMERA) {
        Interaction3D.find(camera).remove(obj.mesh || obj);
    }
});
/**
 * @name GLUICornerPin
 */
Class(function GLUICornerPin($obj) {
    Inherit(this, Component);
    const _this = this;
    var _geom, _vertices, _last;

   /**
    * @name tl
    * @memberof GLUICornerPin
    * @property
    */
    this.tl = new Vector2(0, 0);
   /**
    * @name tr
    * @memberof GLUICornerPin
    * @property
    */
    this.tr = new Vector2($obj.width, 0);
   /**
    * @name bl
    * @memberof GLUICornerPin
    * @property
    */
    this.bl = new Vector2(0, $obj.height);
   /**
    * @name br
    * @memberof GLUICornerPin
    * @property
    */
    this.br = new Vector2($obj.width, $obj.height);

    //*** Constructor
    (function () {
        initGeometry();
        _this.startRender(loop);
    })();

    function initGeometry() {
        _geom = $obj.mesh.geometry.toNonIndexed();
        $obj.useGeometry(_geom);
        $obj.mesh.scale.set(1, 1, 1);

        _vertices = _geom.attributes.position.array;
        _last = new Float32Array(_vertices);
    }

    function loop() {
        _vertices[0] = _this.tl.x;
        _vertices[1] = -_this.tl.y;

        _vertices[3] = _vertices[9] = _this.bl.x;
        _vertices[4] = _vertices[10] = -_this.bl.y;

        _vertices[6] = _vertices[15] = _this.tr.x;
        _vertices[7] = _vertices[16] = -_this.tr.y;

        _vertices[12] = _this.br.x;
        _vertices[13] = -_this.br.y;

        if (dirty()) _geom.attributes.position.needsUpdate = true;
        _last.set(_vertices);
    }

    function dirty() {
        let a = _vertices;
        let b = _last;
        for (let i = a.length-1; i > -1; i--) {
            if (a[i] != b[i]) return true;
        }
        return false;
    }

    //*** Event handlers

    //*** Public methods
    /**
     * @name this.update
     * @memberof GLUICornerPin
     *
     * @function
    */
    this.update = function() {
        this.tl.set(0, 0);
        this.tr.set($obj.width, 0);
        this.bl.set(0, $obj.height);
        this.br.set($obj.width, $obj.height);
    }

    /**
     * @name this.tween
     * @memberof GLUICornerPin
     *
     * @function
     * @param type
     * @param val
     * @param time
     * @param ease
     * @param delay
    */
    this.tween = function(type, val, time, ease, delay) {
        val = val instanceof Vector2 ? val : new Vector2(val.x, val.y);
        return tween(_this[type], val, time, ease, delay);
    }
});

/**
 * @name GLUIObject
 */
class GLUIObject {
    constructor(width, height, map) {
        let getMap = _ => {
            if (typeof map === 'string') {
                if (map.includes(['#', '0x'])) return map;
                if (map === 'empty' || map === '') return null;
                return Utils3D.getTexture(map, { premultiplyAlpha: false })
            }
            return map;
        };

        let shader = this.textureShader = new Shader('GLUIObject', {
            tMap: { value: null },
            uAlpha: { type: 'f', value: 1 },
            transparent: true,
            depthTest: false
        });

        shader.persists = true;

        if (!map) shader.visible = false;

        this.usingMap = map != undefined && map != 'empty' && map != '';
        this.tMap = shader.uniforms.tMap;
        this.group = new Group();
        this.alpha = 1;
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._scaleX = 1;
        this._scaleY = 1;
        this._scale = 1;
        this._rotation = 0;
        this.multiTween = true;
        this.children = [];
        this.dimensions = new Vector3(width, height, 1);
        this._shader = shader;

        this.mesh = new Mesh(GLUIObject.getGeometry('2d'), shader);
        this.mesh.glui = this;
        this.group.add(this.mesh);

        shader.mesh = this.mesh;

        if (window.GLSEO) GLSEO.objectNode(this);

        this.bg(getMap());

        const _this = this;
        this.mesh.onBeforeRender = _ => {
            if (!_this.mesh.determineVisible() && _this.firstRender) return;
            let alpha = _this.getAlpha();
            if (_this.mesh.shader.uniforms.uAlpha) _this.mesh.shader.uniforms.uAlpha.value = alpha;

            if (_this.usingMap) {
                if (alpha == 0) {
                    _this.mesh.shader.visible = false;
                    if (!_this.isDirty && _this.firstRender) return;
                } else {
                    _this.mesh.shader.visible = true;
                }
            }

            if (!_this.isDirty && _this.firstRender) return;

            if (RenderStats.active) RenderStats.update('GLUIObject', 1, _this.mesh.shader.vsName + '|' + _this.mesh.shader.fsName, _this.mesh);

            _this.group.position.x = _this._x;
            _this.group.position.y = _this._3d ? _this._y : -_this._y;
            _this.group.position.z = _this._z;

            if (_this.scale != 1) {
                _this.group.position.x += (_this.dimensions.x - (_this.dimensions.x * _this.scale)) / 2;
                _this.group.position.y -= (_this.dimensions.y - (_this.dimensions.y * _this.scale)) / 2;
            }

            let shader = _this.mesh.shader;

            if (_this.calcMask) {
                let v = _this.isMasked;
                v.copy(v.origin);
                _this.group.localToWorld(v);
                v.z = v.width;
                v.w = v.height;
            }

            if (map) {
                if (!_this.corners) {
                    _this.mesh.scale.set(1, 1, 1).multiply(_this.dimensions);
                    _this.group.scale.x = _this._scaleX * _this._scale;
                    _this.group.scale.y = _this._scaleY * _this._scale;
                }
            } else {
                _this.group.scale.set(_this._scaleX * _this._scale, _this._scaleY * _this._scale, 1);
            }

            if (!_this._3d) _this.group.rotation.z = Math.radians(_this._rotation);

            if (_this.anchor && _this.anchor._parent) {
                _this.anchor.position.copy(_this.group.position);
                _this.anchor.scale.copy(_this.group.scale);
                _this.anchor.quaternion.setFromEuler(_this._rotation);
                _this.anchor.isDirty = true;
            } else {
                _this.group.quaternion.setFromEuler(_this._rotation);
                _this.group.matrixDirty = true;
            }

            if (!_this.firstRender) {
                _this.group.updateMatrixWorld(true);
                _this.firstRender = true;
            }

            _this.isDirty = false;
        };

        _this.isDirty = true;
    }

    get width() {
        return this.dimensions.x;
    }

    /**
      * @name width
      * @memberof GLUIObject
      * @property
      */
    set width(w) {
        this.dimensions.x = w;
        this.isDirty = true;
        this.__internalDirty && this.__internalDirty();
    }

    get height() {
        return this.dimensions.y;
    }

    /**
      * @name height
      * @memberof GLUIObject
      * @property
      */
    set height(h) {
        this.dimensions.y = h;
        this.isDirty = true;
        this.__internalDirty && this.__internalDirty();
    }

    get x() {
        return this._x;
    }

    /**
      * @name x
      * @memberof GLUIObject
      * @property
      */
    set x(v) {
        this._x = v;
        this.isDirty = true;
        this.__internalDirty && this.__internalDirty();
    }

    get y() {
        return this._y;
    }

    /**
      * @name y
      * @memberof GLUIObject
      * @property
      */
    set y(v) {
        this._y = v;
        this.isDirty = true;
        this.__internalDirty && this.__internalDirty();
    }

    get z() {
        return this._z;
    }

    /**
      * @name z
      * @memberof GLUIObject
      * @property
      */
    set z(v) {
        this._z = v;
        this.isDirty = true;
        this.__internalDirty && this.__internalDirty();
    }

    get scale() {
        return this._scale;
    }

    /**
      * @name scale
      * @memberof GLUIObject
      * @property
      */
    set scale(v) {
        this._scale = v;
        this.isDirty = true;
        this.__internalDirty && this.__internalDirty();
    }

    get scaleX() {
        return this._scaleX;
    }

    /**
      * @name scaleX
      * @memberof GLUIObject
      * @property
      */
    set scaleX(v) {
        this._scaleX = v;
        this.isDirty = true;
        this.__internalDirty && this.__internalDirty();
    }

    get scaleY() {
        return this._scaleY;
    }

    /**
      * @name scaleY
      * @memberof GLUIObject
      * @property
      */
    set scaleY(v) {
        this._scaleY = v;
        this.isDirty = true;
        this.__internalDirty && this.__internalDirty();
    }

    get rotation() {
        return this._rotation;
    }

    /**
      * @name rotation
      * @memberof GLUIObject
      * @property
      */
    set rotation(v) {
        this._rotation = v;
        this.isDirty = true;
        this.__internalDirty && this.__internalDirty();
    }

    /**
     * @name this.style
     * @memberof GLUIObject
     *
     * @function
     * @param props
    */
    style(props) {
        for (let prop in props) {
            if (this[prop] !== undefined) this[prop] = props[prop];
        }
        return this;
    }

    /**
     * @name this.size
     * @memberof GLUIObject
     *
     * @function
     * @param w
     * @param h
    */
    size(w, h) {
        this.width = w;
        this.height = h;
        if (this.corners) this.corners.update();
        return this;
    }

    /**
     * @name this.add
     * @memberof GLUIObject
     *
     * @function
     * @param $obj
    */
    add($obj) {
        $obj.parent = this;
        this.group.add($obj.group);
        this.children.push($obj);

        if (this.isMasked) $obj.mask(this.isMasked, this.maskShader);
        if (this._3d && !$obj._3d) $obj.enable3D();
        if (this.deferred) {
            $obj.deferRender(true);
            if ($obj.anchor && this.anchor) this.anchor.add($obj.anchor);
        }

        return this;
    }

    /**
     * @name this.interact
     * @memberof GLUIObject
     *
     * @function
     * @param over
     * @param click
     * @param camera
     * @param url
     * @param label
    */
    interact(over, click, camera = World.CAMERA, url, label) {
        if (typeof camera === 'string') {
            label = url;
            url = camera;
            camera = World.CAMERA;
        }

        const bubble = (e, fn) => {
            e.stopPropagation = function () {
                e._stopProp = true;
            };
            let parent = this._parent;
            while (parent) {
                if (e._stopProp) return;
                parent[fn]?.(e);
                parent = parent.parent;
            }
        };

        this._onOver = e => {
            bubble(e, '_onChildHover');
            over(e);
        };
        this._onClick = e => {
            bubble(e, '_onChildClick');
            click(e);
        };
        this._interactCamera = camera;
        let stage = this._3d ? GLUI.Scene : GLUI.Stage;
        if (over) stage.interaction.add(this, camera);
        else stage.interaction.remove(this, camera);

        if (typeof url === 'string' && typeof label === 'string') {
            const _this = this;
            defer(_ => {
                if (!_this.seo && window.GLSEO) {
                    GLSEO.objectNode(_this);
                }

                _this.seo && _this.seo.aLink && _this.seo.aLink(url, label);
            });
        }

        return this;
    }

    /**
     * @name this.clearInteract
     * @memberof GLUIObject
     *
     * @function
    */
    clearInteract() {
        if (this._onOver) {
            let stage = this._3d ? GLUI.Scene : GLUI.Stage;
            stage.interaction.remove(this, this._interactCamera);
            this._onClick = GLUIObject.noop;
            this._onOver = GLUIObject.noop;
        }

        if (this.seo) {
            this.seo.unlink();
        }

        return this;
    }

    /**
     * @name this.remove
     * @memberof GLUIObject
     *
     * @function
    */
    remove() {
        // Take a copy of children before iterating, otherwise well miss
        // some children because this.children may be mutated by child.remove()
        // [it calls this.parent.children.remove()].
        let children = this.children.slice();
        children.forEach(child => {
            if (child.remove) child.remove();
            else if (child.destroy) child.destroy();
        });

        this.clearInteract();
        if (this.parent) {
            if (this.parent.children) this.parent.children?.remove(this);
            else GLUI.Stage.remove(this);
        }
        if (this.mesh._parent) {
            this.group._parent?.remove(this.group);
        } else {
            if (!this._3d) GLUI.Stage.remove(this);
            else GLUI.Scene.remove(this);
        }

        let textureShader = this.textureShader;
        for (let key in textureShader.uniforms) {
            let uniform = textureShader.uniforms[key];
            if (uniform && uniform.value && uniform.value.destroy) uniform.value.destroy();
        }
    }

    /**
     * @name this.create
     * @memberof GLUIObject
     *
     * @function
     * @param width
     * @param height
     * @param map
    */
    create(width, height, map) {
        let $obj = $gl(width, height, map);
        this.add($obj);
        if (this._3d) $obj.enable3D();
        return $obj;
    }

    /**
     * @name this.removeChild
     * @memberof GLUIObject
     *
     * @function
     * @param obj
    */
    removeChild(obj) {
        this.group.remove(obj.group);
        return this;
    }

    /**
     * @name this.tween
     * @memberof GLUIObject
     *
     * @function
     * @param obj
     * @param time
     * @param ease
     * @param delay
    */
    tween(obj, time, ease, delay) {
        return tween(this, obj, time, ease, delay);
    }

    /**
     * @name this.enable3D
     * @memberof GLUIObject
     *
     * @function
     * @param style2d
    */
    enable3D(style2d) {
        this._3d = true;
        this.mesh.geometry = GLUIObject.getGeometry(style2d ? '2d' : '3d');
        this.mesh.shader.depthTest = true;
        this._rotation = new Euler();

        if(!this.anchor) this.anchor = new Group();

        const _this = this;
        _this._rotation.onChange(_ => {
            _this.isDirty = true;
        });

        return this;
    }

    /**
     * @name this.loaded
     * @memberof GLUIObject
     *
     * @function
    */
    loaded() {
        return true;
    }

    /**
     * @name this.setZ
     * @memberof GLUIObject
     *
     * @function
     * @param z
    */
    setZ(z) {
        this.mesh.renderOrder = z;
        return this;
    }

    /**
     * @name this.bg
     * @memberof GLUIObject
     *
     * @function
     * @param path
    */
    bg(path) {
        if (path === undefined) return;

        if (typeof path === 'string') {
            if (path.includes(['#', '0x'])) {
                if (!this.colorShader) {
                    this.colorShader = new Shader('GLUIColor', {
                        transparent: true,
                        uAlpha: { type: 'f', value: 1 },
                        uColor: { value: new Color(path) }
                    });
                }
                this.colorShader.set('uColor', new Color(path));
                if (this._shader != this.colorShader) this.useShader(this.colorShader);
            } else {
                this.textureShader.uniforms.tMap.value = Utils3D.getTexture(path, { premultiplyAlpha: false });
                if (this._shader != this.textureShader) this.useShader(this.textureShader);
            }
        } else {
            this._shader.uniforms.tMap.value = path;
        }
        return this;
    }

    /**
     * @name this.show
     * @memberof GLUIObject
     *
     * @function
    */
    show() {
        this.group.matrixDirty = true;
        this.mesh.matrixDirty = true;
        this.group.visible = true;
        return this;
    }

    /**
     * @name this.hide
     * @memberof GLUIObject
     *
     * @function
    */
    hide() {
        this.group.visible = false;
        return this;
    }

    /**
     * @name this.useShader
     * @memberof GLUIObject
     *
     * @function
     * @param shader
    */
    useShader(shader) {
        if (shader) {
            if (shader != this.textureShader && shader != this.colorShader) {
                shader.uniforms.tMap = this.mesh.shader.uniforms.tMap;
                shader.uniforms.uAlpha = this.mesh.shader.uniforms.uAlpha;
            }
            if (!this._3d) shader.depthTest = false;
            shader.transparent = true;
        }

        this._shader = shader;
        this.mesh.shader = shader || this._shader;
        shader.mesh = this.mesh;
        return this;
    }

    /**
     * @name this.depthTest
     * @memberof GLUIObject
     *
     * @function
     * @param bool
    */
    depthTest(bool) {
        this.mesh.shader.depthTest = bool;
    }

    /**
     * @name this.childInteract
     * @memberof GLUIObject
     *
     * @function
     * @param hover
     * @param click
    */
    childInteract(hover, click) {
        this._onChildHover = hover;
        this._onChildClick = click;
    }

    /**
     * @name this.useGeometry
     * @memberof GLUIObject
     *
     * @function
     * @param geom
    */
    useGeometry(geom) {
        this.mesh.geometry = geom;
        return this;
    }

    /**
     * @name this.updateMap
     * @memberof GLUIObject
     *
     * @function
     * @param src
    */
    updateMap(src) {
        this._shader.uniforms.tMap.value = typeof src === 'string' ? Utils3D.getTexture(src) : src;
    }

    /**
     * @name this.mask
     * @memberof GLUIObject
     *
     * @function
     * @param obj
     * @param shader
    */
    async mask(obj, shader) {
        await defer();

        let dimensions = {};
        let p = this._parent;
        while (p) {
            if (p.stageLayoutCapture) {
                dimensions.width = p.stageLayoutCapture.width;
                dimensions.height = p.stageLayoutCapture.height;
            }
            p = p._parent;
        }
        if (!dimensions.width) {
            dimensions.width = Stage.width;
            dimensions.height = Stage.height;
        }

        obj.group.updateMatrixWorld(true);
        obj.mesh.onBeforeRender();
        let box = new Box3().setFromObject(obj.mesh);
        let minX = box.min.x / dimensions.width;
        let minY = box.max.y / dimensions.height;
        let maxX = box.max.x / dimensions.width;
        let maxY = -box.min.y / dimensions.height;

        if (this.shader) {
            this.useShader(shader);
            this.shader.addUniforms({
                uMaskValues: { value: new Vector4(minX, minY, maxX, maxY) }
            });
        }

        obj.hide();

        this.group.traverse(o => {
            if (!!o.glui && o.glui != this) {
                o.glui.mask(obj, shader);
            }
        });
    }

    /**
     * @name this.deferRender
     * @memberof GLUIObject
     *
     * @function
     * @param parent
    */
    deferRender(parent) {
        this.deferred = true;
        if (!parent) {
            this.anchor = new Group();
            GLUI.Scene.addDeferred(this);
        }
    }

    /**
     * @name this.clearTween
     * @memberof GLUIObject
     *
     * @function
    */
    clearTween() {
        if (this._mathTweens) {
            this._mathTweens.forEach(t => {
                t.tween.stop();
            });
        }

        return this;
    }

    /**
     * @name this.createCorners
     * @memberof GLUIObject
     *
     * @function
    */
    createCorners() {
        this.corners = new GLUICornerPin(this);
    }

    /**
     * @name this.getAlpha
     * @memberof GLUIObject
     *
     * @function
    */
    getAlpha() {
        if (this._gluiParent) {
            let alpha = this._gluiParent.getAlpha();
            this.alpha = alpha;
            return alpha;
        }

        let alpha = this.alpha;
        let $parent = this.parent;
        /**
         * @name this.while
         * @memberof GLUIObject
         *
         * @function
         * @param $parent
        */
        while ($parent) {
            alpha *= $parent.alpha;
            $parent = $parent.parent;
        }
        return alpha;
    }

    get shader() {
        return this._shader;
    }

    _divFocus() {
        if (this._onOver) this._onOver({ action: 'over', object: this });
        if (this.onDivFocus) this.onDivFocus();
    }

    _divBlur() {
        if (this._onOver) this._onOver({ action: 'out', object: this });
        if (this.onDivBlur) this.onDivBlur();
    }

    _divSelect() {
        if (this._onClick) this._onClick({ action: 'click', object: this });
        if (this.onDivBlurSelect) this.onDivSelect();
    }

    get _parent() {
        return this.parent;
    }
}

(function () {
    var _geom2d, _geom3d;
    GLUIObject.getGeometry = function (type) {
        if (type == '2d') {
            if (!_geom2d) {
                _geom2d = new PlaneGeometry(1, 1);
                _geom2d.applyMatrix(new Matrix4().makeTranslation(0.5, -0.5, 0));
            }
            return _geom2d;
        } else {
            if (!_geom3d) {
                _geom3d = World.PLANE;
            }

            return _geom3d;
        }
    }

    GLUIObject.clear = function () {
        _geom2d = _geom3d = null;
    }

    GLUIObject.noop = _ => { };
})();
/**
 * @name GLUIText
 */
class GLUIText {
    constructor(text, fontName, fontSize, options = {}) {
        options.font = fontName || options.font;
        options.text = text;
        options.width = options.width;
        options.align = options.align || 'left';
        options.size = fontSize || options.size;
        options.lineHeight = options.lineHeight;
        options.letterSpacing = options.letterSpacing;
        options.wordSpacing = options.wordSpacing;
        options.wordBreak = options.wordBreak;
        options.langBreak = options.langBreak;
        options.color = new Color(options.color);

        this.text = new GLText(options);
        this.group = new Group();
        this.alpha = 1;

        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._scaleX = 1;
        this._scaleY = 1;
        this._scale = 1;
        this._rotation = 0;
        this.multiTween = true;

        const _this = this;

        defer(_ => text && _this.seoText(text));

    /**
     * @name this.this.text.ready
     * @memberof GLUIText
     *
     * @function
    */
        this.text.ready().then(_ => {
            let mesh = _this.text.mesh;
            mesh.glui = _this;
            mesh.shader.visible = false;

            _this.mesh = mesh;
            _this.group.add(mesh);

            if (_this._3d && !_this._style2d) _this.text.centerY();
            if (!_this._3d) _this.text.mesh.shader.depthTest = false;

            mesh.shader.mesh = mesh;

            mesh.onBeforeRender = _ => {
                if (!mesh.determineVisible() && _this.firstRender) return;
                let alpha = _this.getAlpha();
                if (mesh.shader.uniforms.uAlpha) mesh.shader.uniforms.uAlpha.value = alpha;

                if (alpha == 0) {
                    mesh.shader.visible = false;
                    if (!_this.isDirty && _this.firstRender) return;
                } else {
                    mesh.shader.visible = true;
                }

                if (!_this.isDirty && _this.firstRender) return;

                if (RenderStats.active) RenderStats.update('GLUIText', 1, mesh.shader.vsName+'|'+mesh.shader.fsName, mesh);

                _this.group.position.x = _this._x;
                _this.group.position.y = _this._3d ? _this._y : -_this._y;
                _this.group.position.z = _this._z;

                _this.group.scale.set(_this._scaleX * _this._scale, _this._scaleY * _this._scale, 1);

                if (!_this._3d) _this.group.rotation.z = Math.radians(_this._rotation);
                else {
                    if (_this.anchor && _this.anchor._parent) {
                        _this.anchor.position.copy(_this.group.position);
                        _this.anchor.scale.copy(_this.group.scale);
                        _this.anchor.quaternion.setFromEuler(_this._rotation);
                    } else {
                        _this.group.quaternion.setFromEuler(_this._rotation);
                    }
                }

                if (!_this.firstRender) {
                    _this.group.updateMatrixWorld(true);
                    _this.firstRender = true;
                    mesh.shader.visible = true;
                }

                _this.onInternalUpdate && _this.onInternalUpdate();

                _this.isDirty = false;
            };
        });
    }

    get x() {
        return this._x;
    }

   /**
     * @name x
     * @memberof GLUIText
     * @property
     */
    set x(v) {
        this._x = v;
        this.isDirty = true;
    }

    get y() {
        return this._y;
    }

   /**
     * @name y
     * @memberof GLUIText
     * @property
     */
    set y(v) {
        this._y = v;
        this.isDirty = true;
    }

    get z() {
        return this._z;
    }

   /**
     * @name z
     * @memberof GLUIText
     * @property
     */
    set z(v) {
        this._z = v;
        this.isDirty = true;
    }

    get scale() {
        return this._scale;
    }

   /**
     * @name scale
     * @memberof GLUIText
     * @property
     */
    set scale(v) {
        this._scale = v;
        this.isDirty = true;
    }

    get scaleX() {
        return this._scaleX;
    }

   /**
     * @name scaleX
     * @memberof GLUIText
     * @property
     */
    set scaleX(v) {
        this._scaleX = v;
        this.isDirty = true;
    }

    get scaleY() {
        return this._scaleY;
    }

   /**
     * @name scaleY
     * @memberof GLUIText
     * @property
     */
    set scaleY(v) {
        this._scaleY = v;
        this.isDirty = true;
    }

    get rotation() {
        return this._rotation;
    }

   /**
     * @name rotation
     * @memberof GLUIText
     * @property
     */
    set rotation(v) {
        this._rotation = v;
        this.isDirty = true;
    }

    get dimensions() {
        if (!this._dimensions) this._dimensions = {};
        if (this.text && this.text.geometry && !this._dimensions.max) {
            this._dimensions = this.text.geometry.boundingBox;
            this._dimensions.width = Math.abs(this._dimensions.min.x - this._dimensions.max.x);
            this._dimensions.height = Math.abs(this._dimensions.min.y - this._dimensions.max.y);
        }
        return this._dimensions;
    }

    /**
     * @name this.interact
     * @memberof GLUIText
     *
     * @function
     * @param over
     * @param click
     * @param camera
     * @param seoLink
    */
    interact(over, click, camera = World.CAMERA, seoLink) {
        if (typeof camera == 'string') {
            seoLink = camera;
            camera = World.CAMERA;
        }

        this._onOver = over;
        this._onClick = click;
        this._interactCamera = camera;

        let stage = this._3d ? GLUI.Scene : GLUI.Stage;

        const _this = this;
        _this.text.ready().then(_ => {
            if (over) {
                if (!_this.text.geometry.boundingBox) _this.text.geometry.computeBoundingBox();

                if (!_this.hitArea) {
                    let bb = _this.text.geometry.boundingBox;
                    let shader = Utils3D.getTestShader();
                    shader.visible = false;
                    _this.hitArea = new Mesh(World.PLANE, shader);
                    _this.hitArea.glui = _this;
                    _this.hitArea.scale.set(Math.abs(bb.min.x) + Math.abs(bb.max.x), Math.abs(bb.min.y) + Math.abs(bb.max.y), 1);
                    if (!_this._3d || _this._style2d) _this.hitArea.position.x = (bb.max.x - bb.min.x)/2;
                    _this.hitArea.position.y = (bb.min.y - bb.max.y)/2;

                    if (_this._3d) {
                        switch (_this.text.getData().align) {
                            case 'center': _this.hitArea.position.x = 0; break;
                            case 'right': _this.hitArea.position.x = (bb.min.x - bb.max.x) / 2; break;
                        }
                    } else {
                        switch (_this.text.getData().align) {
                            case 'center': _this.hitArea.position.x = 0; break;
                            case 'right': _this.hitArea.position.x = -(bb.max.x - bb.min.x)/2; break;
                        }
                    }

                    _this.text.mesh.add(_this.hitArea);
                }

                stage.interaction.add(_this.hitArea, camera);
            } else {
                stage.interaction.remove(_this.hitArea, camera);
            }
        });

        defer(_ => {
            if (seoLink) _this.seo && _this.seo.aLink && _this.seo.aLink(seoLink);
        });

        return this;
    }

    /**
     * @name this.clearInteract
     * @memberof GLUIText
     *
     * @function
    */
    clearInteract() {
        if (this._onOver) {
            let stage = this._3d ? GLUI.Scene : GLUI.Stage;
            stage.interaction.remove(this.hitArea, this._interactCamera);
            this._onClick = GLUIObject.noop;
            this._onOver = GLUIObject.noop;
        }
        return this;
    }

    /**
     * @name this.remove
     * @memberof GLUIText
     *
     * @function
    */
    remove() {
        let stage = this._3d ? GLUI.Scene : GLUI.Stage;

        if (this.mesh && this.mesh.parent) {
            this.group.parent.remove(this.group);
        } else {
            stage.remove(this);
        }

        if (this.hitArea) stage.interaction.remove(this.hitArea, this._interactCamera);
        if (this.text && this.text.destroy) this.text.destroy();

        Utils.nullObject(this.mesh);
        Utils.nullObject(this);
    }

    /**
     * @name this.tween
     * @memberof GLUIText
     *
     * @function
     * @param obj
     * @param time
     * @param ease
     * @param delay
    */
    tween(obj, time, ease, delay) {
        return tween(this, obj, time, ease, delay);
    }

    /**
     * @name this.enable3D
     * @memberof GLUIText
     *
     * @function
     * @param style2d
    */
    enable3D(style2d) {
        this._3d = true;
        this._style2d = style2d;
        this._rotation = new Euler();

        const _this = this;
        _this._rotation.onChange(_ => {
            _this.isDirty = true;
        });

        _this.text.ready().then(_ => {
            _this.text.mesh.shader.depthTest = true;
        });

        if(!this.anchor) this.anchor = new Group();

        _this.isDirty = true;

        return this;
    }

    /**
     * @name this.depthTest
     * @memberof GLUIText
     *
     * @function
     * @param bool
    */
    depthTest(bool) {
        const _this = this;
        _this.text.ready().then(_ => {
            _this.text.mesh.shader.depthTest = bool;
        });

        return this;
    }

    /**
     * @name this.setZ
     * @memberof GLUIText
     *
     * @function
     * @param z
    */
    setZ(z) {
        const _this = this;

        _this.text.ready().then(_ => {
            _this.text.mesh.renderOrder = z;
        });

        return this;
    }

    /**
     * @name this.height
     * @memberof GLUIText
     *
     * @function
    */
    height() {
        if (!this.mesh) return 0;
        return this.text.height;
    }

    /**
     * @name this.setText
     * @memberof GLUIText
     *
     * @function
     * @param text
     * @param options
    */
    async setText(text, options) {
        if (text) {
            text = text.toString();
            this.seoText(text);
        }
        await this.text.ready();
        await this.text.setText(text, options);
        this._dimensions = null;
        return this;
    }

    /**
     * @name this.seoText
     * @memberof GLUIText
     *
     * @function
     * @param text
    */
    seoText(text) {
        if (window.GLSEO) {
            GLSEO.textNode(this, text);
        }
    }

    /**
     * @name this.getTextString
     * @memberof GLUIText
     *
     * @function
    */
    getTextString() {
        return this.text.string;
    }

    /**
     * @name this.setColor
     * @memberof GLUIText
     *
     * @function
     * @param color
    */
    setColor(color) {
        const _this = this;
        _this.text.ready().then(_ => _this.text.setColor(color));
        return this;
    }

    /**
     * @name this.tweenColor
     * @memberof GLUIText
     *
     * @function
     * @param color
     * @param time
     * @param ease
     * @param delay
    */
    tweenColor(color, time, ease, delay) {
        const _this = this;
        _this.text.ready().then(_ => _this.text.tweenColor(color, time, ease, delay));
        return this;
    }

    /**
     * @name this.resize
     * @memberof GLUIText
     *
     * @function
     * @param options
    */
    resize(options) {
        const _this = this;
        _this.text.ready().then(_ => _this.text.resize(options));
    }

    /**
     * @name this.show
     * @memberof GLUIText
     *
     * @function
    */
    show() {
        const _this = this;
        _this.text.ready().then(_ => {
            this.text.mesh.visible = true;
            this.text.mesh.updateMatrixWorld(true);
        });
        return this;
    }

    /**
     * @name this.mask
     * @memberof GLUIText
     *
     * @function
     * @param obj
     * @param shader
    */
    async mask(obj, shader) {
        await defer();

        let dimensions = {};
        let p = this._parent;

        while (p) {
            if (p.stageLayoutCapture) {
                dimensions.width = p.stageLayoutCapture.width;
                dimensions.height = p.stageLayoutCapture.height;
            }
            p = p._parent;
        }
        if (!dimensions.width) {
            dimensions.width = Stage.width;
            dimensions.height = Stage.height;
        }

        obj.group.updateMatrixWorld(true);
        obj.mesh.onBeforeRender();
        let box = new Box3().setFromObject(obj.mesh);
        let minX = box.min.x / dimensions.width;
        let minY = box.max.y / dimensions.height;
        let maxX = box.max.x / dimensions.width;
        let maxY = -box.min.y / dimensions.height;

        if (this.shader) {
            this.useShader(shader);
            this.shader.addUniforms({
                uMaskValues: {value: new Vector4(minX, minY, maxX, maxY)}
            });
        }

        obj.hide();

        this.group.traverse(o => {
            if (!!o.glui && o.glui != this) {
                o.glui.mask(obj, shader);
            }
        });
    }

    /**
     * @name this.hide
     * @memberof GLUIText
     *
     * @function
    */
    hide() {
        const _this = this;
        _this.text.ready().then(_ => _this.text.mesh.visible = false);
        return this;
    }

    /**
     * @name this.loaded
     * @memberof GLUIText
     *
     * @function
    */
    loaded() {
        return this.text.ready();
    }

    /**
     * @name this.length
     * @memberof GLUIText
     *
     * @function
    */
    length() {
        return this.text.charLength;
    }

    /**
     * @name this.deferRender
     * @memberof GLUIText
     *
     * @function
     * @param parent
    */
    deferRender(parent) {
        this.deferred = true;
        if (!parent) {
            if (!this.anchor) this.anchor = new Group();
            GLUI.Scene.addDeferred(this);
        }
    }

    /**
     * @name this.getAlpha
     * @memberof GLUIText
     *
     * @function
    */
    getAlpha() {
        if (this._gluiParent) {
            let alpha = this._gluiParent.getAlpha();
            this.alpha = alpha;
            return alpha;
        }

        let alpha = this.alpha;
        let $parent = this.parent;
        while ($parent) {
            alpha *= $parent.alpha;
            $parent = $parent.parent;
        }
        return alpha;
    }

    /**
     * @name this.size
     * @memberof GLUIText
     *
     * @function
    */
    size() {

    }

    /**
     * @name this.upload
     * @memberof GLUIText
     *
     * @function
    */
    upload() {
        const _this = this;
        _this.text.ready().then(_ => _this.text.mesh.upload());
        return this;
    }

    /**
     * @name this._divFocus
     * @memberof GLUIText
     *
     * @function
    */
    _divFocus() {
        if (this._onOver) this._onOver({action: 'over', object: this});
        if (this.onDivFocus) this.onDivFocus();
    }

    /**
     * @name this._divBlur
     * @memberof GLUIText
     *
     * @function
    */
    _divBlur() {
        if (this._onOver) this._onOver({action: 'out', object: this});
        if (this.onDivBlur) this.onDivBlur();
    }

    /**
     * @name this._divSelect
     * @memberof GLUIText
     *
     * @function
    */
    _divSelect() {
        if (this._onClick) this._onClick({action: 'click', object: this});
        if (this.onDivBlurSelect) this.onDivSelect();
    }

    get _parent() {
        return this.parent;
    }

    /**
     * @name this.useShader
     * @memberof GLUIText
     *
     * @function
     * @param shader
    */
    async useShader(shader) {
        await this.text.ready();
        shader.uniforms.tMap = this.text.shader.uniforms.tMap;
        shader.uniforms.uAlpha = this.text.shader.uniforms.uAlpha;
        shader.uniforms.uColor = this.text.shader.uniforms.uColor;
        shader.transparent = true;

        if (!this._3d || !(!this._3d && !this.parent)) shader.depthTest = false;

        this.text.mesh.shader = shader || this.text.shader;
        this.text.shader = shader;
        this.text.mesh.shader.mesh = this.text.mesh;
    }
}

/**
 * @name GLUIStage
 */
Class(function GLUIStage() {
    Inherit(this, Component);
    const _this = this;

    var _scene = new Scene();
    var _camera = new OrthographicCamera(1, 1, 1, 1, 0.1, 1);

   /**
    * @name interaction
    * @memberof GLUIStage
    * @property
    */
    this.interaction = new GLUIStageInteraction2D(_camera, _scene, Stage);
   /**
    * @name alpha
    * @memberof GLUIStage
    * @property
    */
    this.alpha = 1;
   /**
    * @name scene
    * @memberof GLUIStage
    * @property
    */
    this.scene = _scene;

    //*** Constructor
    (function () {
        _scene.disableAutoSort = true;
        _camera.position.z = 1;
        addListeners();
        resizeHandler();
    })();

    function loop() {
        if (!_scene.children.length) return;
        let clear = World.RENDERER.autoClear;
        World.RENDERER.autoClear = false;
        World.RENDERER.render(_scene, _camera, null, true);
        World.RENDERER.autoClear = clear;
    }

    //*** Event handlers
    function addListeners() {
        _this.events.sub(Events.RESIZE, resizeHandler);
    }

    function resizeHandler() {
        _camera.left = Stage.width / -2;
        _camera.right = Stage.width / 2;
        _camera.top = Stage.height / 2;
        _camera.bottom = Stage.height / -2;
        _camera.near = 0.01;
        _camera.far = 1000;
        _camera.updateProjectionMatrix();
        _camera.position.x = Stage.width/2;
        _camera.position.y = -Stage.height/2;
    }

    //*** Public methods
    /**
     * @name this.add
     * @memberof GLUIStage
     *
     * @function
     * @param $obj
    */
    this.add = function($obj) {
        $obj.parent = _this;
        _scene.add($obj.group || $obj.mesh);
    }

    /**
     * @name this.remove
     * @memberof GLUIStage
     *
     * @function
     * @param $obj
    */
    this.remove = function($obj) {
        $obj.parent = null;
        _scene.remove($obj.group);
    }

    /**
     * @name this.clear
     * @memberof GLUIStage
     *
     * @function
    */
    this.clear = function() {
        _scene.traverse(obj => {
            if (obj.geometry && obj.shader) {
                obj.destroy();
            }
        });

        _scene.children.length = _scene.childrenLength = 0;
    }

    /**
     * @name this.renderToRT
     * @memberof GLUIStage
     *
     * @function
     * @param scene
     * @param rt
    */
    this.renderToRT = function(scene, rt) {
        let clearAlpha;
        if (rt.fxscene && rt.fxscene.clearAlpha > -1) {
            clearAlpha = World.RENDERER.getClearAlpha();
            World.RENDERER.setClearAlpha(0);
        }

        let autoClear = World.RENDERER.autoClear;
        World.RENDERER.autoClear = false;
        World.RENDERER.render(scene, _camera, rt);
        World.RENDERER.autoClear = autoClear;

        if (clearAlpha) World.RENDERER.setClearAlpha(clearAlpha);
    };

    this.resize = resizeHandler;
    this.render = loop;
    this.renderDirect = callback => {
        if (_scene.children.length) {
            _scene.traverse(obj => {
                if (obj.shader) obj.shader.depthTest = false;
            });
            callback(_scene, _camera);
        }
    };
});
/**
 * @name GLUIStage3D
 */
Class(function GLUIStage3D() {
    Inherit(this, Object3D);
    const _this = this;
    var _camera;

    var _externalRenders = [];
    var _scene = new Scene();
    var _list = new LinkedList();

    this.alpha = 1;

    this.interaction = new GLUIStageInteraction3D();

    function mark() {
        let obj = _list.start();
        while (obj) {
            if (obj.anchor._parent) obj.group.visible = obj.anchor.determineVisible();
            if (obj.mesh && obj.mesh.determineVisible() && obj.anchor._parent) {
                obj._marked = true;
            }
            obj = _list.next();
        }
    }

    function loop() {
        if (window.Metal) return;
        if (_list.length) {
            let obj = _list.start();
            while (obj) {
                if (obj._marked) {
                    obj._marked = false;
                    Utils3D.decompose(obj.anchor, obj.group);
                }
                obj = _list.next();
            }

            let clear = World.RENDERER.autoClear;
            Renderer.context.clear(Renderer.context.DEPTH_BUFFER_BIT);
            World.RENDERER.autoClear = false;
            World.RENDERER.render(_scene, _camera || World.CAMERA);
            World.RENDERER.autoClear = clear;
        }

        if (_externalRenders.length) {
            while (_externalRenders.length) {
                let scene = _externalRenders.shift();
                let camera = scene._textRenderCamera;

                let clear = World.RENDERER.autoClear;
                Renderer.context.clear(Renderer.context.DEPTH_BUFFER_BIT);
                World.RENDERER.autoClear = false;
                World.RENDERER.render(scene, camera);
                World.RENDERER.autoClear = clear;
            }
        }
    }

    //*** Public methods
    /**
     * @name this.add
     * @memberof GLUIStage3D
     *
     * @function
     * @param obj
     * @param parent
    */
    this.add = function(obj, parent) {
        obj.parent = _this;
        obj._gluiParent = parent;

        if(obj.anchor) {
            obj.anchor._gluiParent = parent;
        }

        if (!obj._3d) obj.enable3D();
        obj.deferRender();
    }

    /**
     * @name this.clear
     * @memberof GLUIStage3D
     *
     * @function
    */
    this.clear = function() {
        _scene.traverse(obj => {
            if (obj.geometry && obj.shader) {
                obj.destroy();
            }
        });

        _scene.children.length = _scene.childrenLength = 0;
    }

    /**
     * @name this.addDeferred
     * @memberof GLUIStage3D
     *
     * @function
     * @param obj
    */
    this.addDeferred = function(obj) {
        _list.push(obj);
        _scene.add(obj.group || obj.mesh);
    }

    /**
     * @name this.remove
     * @memberof GLUIStage3D
     *
     * @function
     * @param obj
    */
    this.remove = function(obj) {
        _scene.remove(obj.group || obj.mesh);
        _list.remove(obj);
    }

    /**
     * @name this.disableAutoSort
     * @memberof GLUIStage3D
     *
     * @function
    */
    this.disableAutoSort = function() {
        _scene.disableAutoSort = true;
    }

    /**
     * @name this.renderToRT
     * @memberof GLUIStage3D
     *
     * @function
     * @param scene
     * @param camera
    */
    this.renderToRT = function(scene, camera) {
        camera = camera.camera || camera;

        scene.traverse(mesh => {
            let obj = mesh.glui;
            if (!obj) return;

            if (obj.anchor.determineVisible()) {
                Utils3D.decompose(obj.anchor, obj.group);
            }
        });

        scene._textRenderCamera = camera;
        _externalRenders.push(scene);
    }

    /**
     * @name this.renderToRT2
     * @memberof GLUIStage3D
     *
     * @function
     * @param scene
     * @param rt
     * @param camera
    */
    this.renderToRT2 = function(scene, rt, camera) {
        let clearAlpha;
        if (rt.fxscene && rt.fxscene.clearAlpha > -1) {
            clearAlpha = World.RENDERER.getClearAlpha();
            World.RENDERER.setClearAlpha(0);
        }

        let autoClear = World.RENDERER.autoClear;
        World.RENDERER.autoClear = false;
        World.RENDERER.render(scene, camera, rt);
        World.RENDERER.autoClear = autoClear;

        if (clearAlpha) World.RENDERER.setClearAlpha(clearAlpha);
    }

    this.render = loop;
    this.mark = mark;

    /**
     * @name this.renderDirect
     * @memberof GLUIStage3D
     *
     * @function
     * @param callback
    */
    this.renderDirect = function(callback) {
        if (_list.length) {
            let obj = _list.start();
            while (obj) {
                if (obj._marked) {
                    obj._marked = false;
                    Utils3D.decompose(obj.anchor, obj.group);
                }
                obj = _list.next();
            }

            _scene.traverse(obj => {
                if (obj.shader) obj.shader.depthTest = false;
            });

            callback(_scene, _camera || World.CAMERA);
        }
    }

    this.set('camera', c => {
        _camera = c.camera || c;
    });
});
Class(function GPU() {
    Inherit(this, Component);
    var _this = this;
    var _split = {};


    Hydra.ready(async () => {

        _this.detect = function (match) {
            if (!Device.graphics.gpu) return;
            return Device.graphics.gpu.detect(match);
        }

        _this.detectAll = function() {
            if (!Device.graphics.gpu) return;
            var match = true;
            for (var i = 0; i < arguments.length; i++) {
                if (!Device.graphics.gpu.detect(arguments[i])) match = false;
            }
            return match;
        }

        _this.matchGPU = function(str, min, max = 99999) {
            let num = splitGPU(str);
            return num >= min && num < max;
        }

        _this.gpu = Device.graphics.gpu ? Device.graphics.gpu.identifier : '';

        if (_this.gpu == 'apple gpu') {
            if (Device.mobile) await require('iOSGPUTest')();
            else require('MacOSPerformanceTest')();
        }

        function splitGPU(string) {
            if (_split[string]) return _split[string];
            if (!_this.detect(string)) return -1;
            try {
                var num = Number(_this.gpu.split(string)[1].split(' ')[0]);
                _split[string] = num;
                return num;
            } catch (e) {
                return -1;
            }
        }

        _this.BLACKLIST = require('GPUBlacklist').match();

        _this.T0 = (function () {
            if (Device.mobile) return false;
            if (_this.BLACKLIST) return true;

            if (_this.detect('radeon(tm) r5')) return true;
            if (_this.detect('hd graphics family')) return true;
            if (_this.detect('intel(r) uhd graphics direct')) return true;
            if (_this.matchGPU('hd graphics ', 1000, 5001)) return true;
            if (_this.matchGPU('hd graphics ', 0, 618) && Device.pixelRatio > 1) return true;
            if (_this.detect(['hd graphics', 'iris']) && Math.max(Stage.width, Stage.height) > 1800) return true;
            if (_this.gpu.toLowerCase() === 'intel iris opengl engine') return true;
            if (_this.matchGPU('iris(tm) graphics ', 1000)) return true;

            return false;
        })();

        _this.T1 = (function () {
            if (_this.BLACKLIST) return false;
            if (Device.mobile) return false;

            if (_this.T0) return false;
            if (_this.matchGPU('iris(tm) graphics ', 540, 1000)) return true;
            if (_this.matchGPU('hd graphics ', 514, 1000)) return true;
            if (_this.matchGPU('intel(r) uhd graphics ', 600, 1000)) return true;
            if (!_this.detect(['nvidia', 'amd', 'radeon', 'geforce'])) return true;

            return false;
        })();

        _this.T2 = (function () {
            if (_this.BLACKLIST) return false;
            if (Device.mobile) return false;
            if (_this.detect(['nvidia', 'amd', 'radeon', 'geforce']) && !_this.T1 && !_this.T0) return true;
            return false;
        })();

        _this.T3 = (function () {
            if (_this.BLACKLIST) return false;
            if (Device.mobile) return false;
            if (_this.detect(['titan', 'amd radeon pro', 'quadro', 'apple m'])) return true;
            if (_this.matchGPU('gtx ', 940)) return true;
            if (_this.matchGPU('radeon (tm) rx ', 400)) return true;
            if (_this.detect('amd radeon(tm) graphics direct3d11 vs_5_0')) return true;
            if (_this.matchGPU('radeon rx ', 400)) return true;
            if (_this.matchGPU('radeon pro ', 420)) return true;
            return false;
        })();

        _this.T4 = (function () {
            if (_this.BLACKLIST) return false;
            if (Device.mobile) return false;
            if (_this.detect(['titan', 'quadro', 'radeon vii'])) return true;
            if (_this.matchGPU('gtx ', 1040)) return true;
            if (_this.matchGPU('rtx')) return true;
            if (_this.matchGPU('radeon rx ', 500)) return true;
            if (_this.matchGPU('vega ', 50)) return true;
            if (_this.detect(['radeon pro 5500m', 'radeon pro 5600m'])) return true;
            return false;
        })();

        _this.T5 = (function () {
            if (_this.BLACKLIST) return false;
            if (Device.mobile) return false;
            if (_this.detect(['titan', 'radeon vii'])) return true;
            if (_this.matchGPU('gtx ', 1080)) return true;
            if (_this.matchGPU('rtx ', 2060)) return true;
            if (_this.matchGPU('radeon rx ', 5500)) return true;
            return false;
        })();

        _this.MT0 = (function () {
            if (!Device.mobile) return false;
            if (_this.BLACKLIST) return true;
            if (Device.system.os == 'ios' && _this.detect('a7')) return true;

            if (Device.system.os == 'android' && _this.detect('sgx')) return true;

            if (_this.detect('adreno')) return _this.matchGPU('adreno (tm) ', 0, 415);
            if (_this.detect('mali')) return _this.matchGPU('mali-t', 0, 628);

            return false;
        })();

        _this.MT1 = (function () {
            if (!Device.mobile) return false;
            if (_this.BLACKLIST) return false;
            if (Device.system.os == 'ios' && _this.detect(['a8', 'a9'])) return true;
            if (Device.system.os == 'android' && !_this.MT0) return true;
            return false;
        })();

        _this.MT2 = (function () {
            if (!Device.mobile) return false;
            if (_this.BLACKLIST) return false;
            if (Device.system.os == 'ios' && _this.detect('a10')) return true;

            if (_this.detect('nvidia tegra') && Device.detect('pixel c')) {
                return true;
            }

            if (_this.detect('mali-g')) return _this.matchGPU('mali-g', 73);

            if (_this.detect('adreno')) {
                if (_this.matchGPU('adreno (tm) ', 600, 616)) return true;
                if (_this.matchGPU('adreno (tm) ', 420)) return true;
            }
            if (_this.detect('mali-g')) return true;
            return false;
        })();

        _this.MT3 = (function () {
            if (!Device.mobile) return false;
            if (_this.BLACKLIST) return false;
            if (Device.system.os == 'ios' && _this.detect(['a11', 'a12'])) return true;

            if (_this.matchGPU('adreno (tm) ', 530, 600)) return true;
            if (_this.detect('mali-g')) return _this.matchGPU('mali-g', 71);

            if (navigator.platform.toLowerCase().includes(['mac', 'windows']) && Device.system.browser == 'chrome') return true;

            return false;
        })();

        _this.MT4 = (function () {
            if (!Device.mobile) return false;
            if (_this.BLACKLIST) return false;
            if (Device.system.os == 'ios' && _this.detect(['a13', 'a14', 'a15', 'a16', 'a17', 'a18'])) return true;

            if (_this.detect('adreno')) return _this.matchGPU('adreno (tm) ', 630);

            if (navigator.platform.toLowerCase().includes(['mac', 'windows']) && Device.system.browser == 'chrome') return true;

            return false;
        })();

        _this.lt = function(num) {
            if (_this.TIER > -1) {
                return _this.TIER <= num;
            }
            return false;
        }

        _this.gt = function(num) {
            if (_this.TIER > -1) {
                return _this.TIER >= num;
            }
            return false;
        }

        _this.eq = function(num) {
            if (_this.TIER > -1) {
                return _this.TIER == num;
            }

            return false;
        }

        _this.mobileEq = function(num) {
            if (_this.M_TIER > -1) {
                return _this.M_TIER == num;
            }

            return false;
        }

        _this.mobileLT = function(num) {
            if (_this.M_TIER > -1) {
                return _this.M_TIER <= num;
            }
            return false;
        }

        _this.mobileGT = function(num) {
            if (_this.M_TIER > -1) {
                return _this.M_TIER >= num;
            }
            return false;
        }

        for (var key in _this) {
            if (key.charAt(0) == 'T' && _this[key] === true) _this.TIER = Number(key.charAt(1));
            if (key.slice(0, 2) == 'MT' && _this[key] === true) _this.M_TIER = Number(key.charAt(2));
        }

        if (Utils.query('gpu') !== false) {
            if (Device.mobile || Utils.query('gpu').toString().includes('m')) {
                _this.TIER = -1;
                _this.M_TIER = Number(Utils.query('gpu').slice(1));
            }
            else _this.TIER = Number(Utils.query('gpu'));
        }

        _this.OVERSIZED = (function() {
            if (!Device.mobile && _this.TIER <= 0 && Math.max(window.innerWidth, window.innerHeight) > 1440) return true;
            if (!Device.mobile && _this.TIER <= 1 && Math.max(window.innerWidth, window.innerHeight) > 1600) return true;
            return false;
        })();
        if (Device.system.browser == 'ie') _this.OVERSIZED = true;

        _this.initialized = true;

    });

    this.ready = function() {
        return this.wait('initialized');
    }
}, 'static');

Module(function MacOSPerformanceTest() {
    function test() {
        let results = [];
        function getPrime() {
            return largest_prime_factor(1000000000000);
        }
        function factors(n) {
            var i;
            var out = [];
            var sqrt_n = Math.sqrt(n);
            for (i = 2; i <= sqrt_n; i++) {
                if (n % i === 0) {
                    out.push(i);
                }
            }
            return out;
        }
        function primep(n) {
            return factors(n).length === 0;
        }
        function largest_prime_factor(n) {
            return factors(n).filter(primep).pop();
        }

        for (let i = 0; i < 3; i++) {
            let time = performance.now();
            getPrime();
            results.push((performance.now() - time) * 10);
        }

        results.sort((a, b) => a - b);
        return results[0];
    }

    this.exports = function() {
        let result = test();

        if (screen.width <= 1440 && screen.height <= 900) {
            //probably a 13" laptop
            if (result > 540) {
                Device.graphics.webgl.gpu = 'intel iris opengl engine';
            } else {
                Device.graphics.webgl.gpu = 'safari tier 1';
            }
        } else {
            //probably a mbp
            if (result > 475) {
                if (result > 540) {
                    Device.graphics.webgl.gpu = 'intel iris opengl engine';
                } else {
                    Device.graphics.webgl.gpu = 'safari tier 1';
                }
            } else {
                if (result < 375) {
                    Device.graphics.webgl.gpu = 'amd radeon pro 455 opengl engine';
                } else {
                    Device.graphics.webgl.gpu = 'nvidia geforce 750m opengl engine';
                }
            }
        }
    }
});
Module(function iOSGPUTest() {
    function getRenderer(complete) {
        var nodes =
            [
                {
                    "x": "Unknown",
                    "m": function(n){return family(n);},
                    "n": [
                        4,
                        2,
                        1,
                        3
                    ]
                },
                {
                    "x": "Apple A7 GPU|Apple A8 GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A12 GPU|Apple A13 GPU|Apple A14 GPU",
                    "m": function(n){return height(n);},
                    "n": [
                        15,
                        10,
                        11,
                        12,
                        14,
                        6,
                        7,
                        13,
                        8,
                        9,
                        5
                    ],
                    "v": [
                        "iPhone"
                    ]
                },
                {
                    "x": "Apple A7 GPU|Apple A8 GPU|Apple A9X GPU|Apple A10X GPU|Apple A9 GPU|Apple A12X GPU|Apple A10 GPU|Apple A12 GPU|Apple A8X GPU",
                    "m": function(n){return height(n);},
                    "n": [
                        19,
                        20,
                        18,
                        17,
                        16
                    ],
                    "v": [
                        "iPad"
                    ]
                },
                {
                    "x": "Apple A9X GPU|Apple A10X GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A12X GPU|Apple A12 GPU|Apple A8 GPU|Apple A8X GPU|Apple A13 GPU|Apple A14 GPU",
                    "m": function(n){return height(n);},
                    "n": [
                        19,
                        15,
                        20,
                        18,
                        10,
                        11,
                        12,
                        14,
                        17,
                        22,
                        25,
                        23,
                        13,
                        24,
                        9,
                        21
                    ],
                    "v": [
                        "Macintosh"
                    ]
                },
                {
                    "x": "Apple A10 GPU",
                    "v": [
                        "iPod Touch"
                    ]
                },
                {
                    "x": "Apple A7 GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A8 GPU|Apple A13 GPU",
                    "m": function(n){return mediacolorgamut(n);},
                    "n": [
                        27,
                        26
                    ],
                    "v": [
                        1136
                    ]
                },
                {
                    "x": "Apple A8 GPU|Apple A10 GPU|Apple A11 GPU|Apple A9 GPU",
                    "m": function(n){return mediacolorgamut(n);},
                    "n": [
                        28,
                        29
                    ],
                    "v": [
                        2001
                    ]
                },
                {
                    "x": "Apple A8 GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU",
                    "m": function(n){return mediacolorgamut(n);},
                    "n": [
                        30,
                        31
                    ],
                    "v": [
                        2208
                    ]
                },
                {
                    "x": "Apple A8 GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
                    "m": function(n){return mediacolorgamut(n);},
                    "n": [
                        32,
                        33
                    ],
                    "v": [
                        1334
                    ]
                },
                {
                    "x": "Apple A11 GPU|Apple A12 GPU|Apple A13 GPU|Apple A14 GPU",
                    "m": function(n){return hash3d(n);},
                    "n": [
                        38,
                        35,
                        36,
                        37,
                        34
                    ],
                    "v": [
                        2436
                    ]
                },
                {
                    "x": "Apple A12 GPU|Apple A13 GPU",
                    "m": function(n){return hash3d(n);},
                    "n": [
                        36,
                        34
                    ],
                    "v": [
                        2688
                    ]
                },
                {
                    "x": "Apple A12 GPU|Apple A13 GPU",
                    "m": function(n){return hash3d(n);},
                    "n": [
                        40,
                        39
                    ],
                    "v": [
                        1624
                    ]
                },
                {
                    "x": "Apple A12 GPU|Apple A13 GPU",
                    "m": function(n){return hash3d(n);},
                    "n": [
                        40,
                        39
                    ],
                    "v": [
                        1792
                    ]
                },
                {
                    "x": "Apple A11 GPU|Apple A12 GPU|Apple A14 GPU",
                    "m": function(n){return hash3d(n);},
                    "n": [
                        41,
                        34,
                        37
                    ],
                    "v": [
                        2079
                    ]
                },
                {
                    "x": "Apple A14 GPU",
                    "v": [
                        2532
                    ]
                },
                {
                    "x": "Apple A14 GPU",
                    "v": [
                        2778
                    ]
                },
                {
                    "x": "Apple A7 GPU|Apple A8 GPU|Apple A9X GPU|Apple A10X GPU|Apple A9 GPU|Apple A12X GPU|Apple A10 GPU|Apple A12 GPU|Apple A8X GPU",
                    "m": function(n){return mediacolorgamut(n);},
                    "n": [
                        43,
                        42
                    ],
                    "v": [
                        2048
                    ]
                },
                {
                    "x": "Apple A9X GPU|Apple A10X GPU|Apple A12X GPU",
                    "m": function(n){return mediacolorgamut(n);},
                    "n": [
                        44,
                        45
                    ],
                    "v": [
                        2732
                    ]
                },
                {
                    "x": "Apple A10X GPU|Apple A12 GPU",
                    "m": function(n){return hash(n);},
                    "n": [
                        47,
                        46
                    ],
                    "v": [
                        2224
                    ]
                },
                {
                    "x": "Apple A12X GPU",
                    "v": [
                        2388
                    ]
                },
                {
                    "x": "Apple A10 GPU|Apple A12 GPU",
                    "m": function(n){return hash(n);},
                    "n": [
                        48,
                        49
                    ],
                    "v": [
                        2160
                    ]
                },
                {
                    "x": "Apple A9X GPU|Apple A10X GPU|Apple A9 GPU|Apple A12X GPU|Apple A10 GPU|Apple A12 GPU|Apple A8 GPU|Apple A8X GPU",
                    "m": function(n){return mediacolorgamut(n);},
                    "n": [
                        43,
                        50
                    ],
                    "v": [
                        2048
                    ]
                },
                {
                    "x": "Apple A9 GPU|Apple A10 GPU|Apple A11 GPU",
                    "m": function(n){return mediacolorgamut(n);},
                    "n": [
                        51,
                        31
                    ],
                    "v": [
                        2208
                    ]
                },
                {
                    "x": "Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
                    "m": function(n){return mediacolorgamut(n);},
                    "n": [
                        51,
                        33
                    ],
                    "v": [
                        1334
                    ]
                },
                {
                    "x": "Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
                    "m": function(n){return mediacolorgamut(n);},
                    "n": [
                        52,
                        27
                    ],
                    "v": [
                        1136
                    ]
                },
                {
                    "x": "Apple A10 GPU|Apple A11 GPU|Apple A9 GPU",
                    "m": function(n){return mediacolorgamut(n);},
                    "n": [
                        51,
                        29
                    ],
                    "v": [
                        2001
                    ]
                },
                {
                    "x": "Apple A7 GPU|Apple A9 GPU|Apple A8 GPU",
                    "m": function(n){return hash(n);},
                    "n": [
                        53,
                        55,
                        54,
                        56
                    ],
                    "v": [
                        "srgb"
                    ]
                },
                {
                    "x": "Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
                    "m": function(n){return hash3d(n);},
                    "n": [
                        57,
                        35,
                        58
                    ],
                    "v": [
                        "p3"
                    ]
                },
                {
                    "x": "Apple A8 GPU|Apple A9 GPU",
                    "m": function(n){return hash(n);},
                    "n": [
                        59,
                        60
                    ],
                    "v": [
                        "srgb"
                    ]
                },
                {
                    "x": "Apple A10 GPU|Apple A11 GPU",
                    "m": function(n){return hash(n);},
                    "n": [
                        61,
                        62
                    ],
                    "v": [
                        "p3"
                    ]
                },
                {
                    "x": "Apple A8 GPU|Apple A9 GPU",
                    "m": function(n){return hash(n);},
                    "n": [
                        63,
                        64
                    ],
                    "v": [
                        "srgb"
                    ]
                },
                {
                    "x": "Apple A10 GPU|Apple A11 GPU",
                    "m": function(n){return hash(n);},
                    "n": [
                        61,
                        65
                    ],
                    "v": [
                        "p3"
                    ]
                },
                {
                    "x": "Apple A8 GPU|Apple A9 GPU",
                    "m": function(n){return hash(n);},
                    "n": [
                        66,
                        64
                    ],
                    "v": [
                        "srgb"
                    ]
                },
                {
                    "x": "Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
                    "m": function(n){return hash3d(n);},
                    "n": [
                        57,
                        35,
                        40
                    ],
                    "v": [
                        "p3"
                    ]
                },
                {
                    "x": "Apple A12 GPU",
                    "v": [
                        958581112,
                        4085158452
                    ]
                },
                {
                    "x": "Apple A11 GPU",
                    "v": [
                        411650080,
                        1220644697
                    ]
                },
                {
                    "x": "Apple A13 GPU",
                    "v": [
                        4193218782
                    ]
                },
                {
                    "x": "Apple A14 GPU",
                    "v": [
                        105985484
                    ]
                },
                {
                    "x": "Apple A14 GPU",
                    "v": [
                        3403189785
                    ]
                },
                {
                    "x": "Apple A12 GPU",
                    "v": [
                        4085158452
                    ]
                },
                {
                    "x": "Apple A13 GPU",
                    "v": [
                        352823931,
                        4193218782
                    ]
                },
                {
                    "x": "Apple A11 GPU",
                    "v": [
                        411650080
                    ]
                },
                {
                    "x": "Apple A7 GPU|Apple A8 GPU|Apple A9X GPU|Apple A9 GPU|Apple A10 GPU|Apple A8X GPU",
                    "m": function(n){return hash(n);},
                    "n": [
                        70,
                        67,
                        71,
                        72,
                        73,
                        68,
                        69,
                        53
                    ],
                    "v": [
                        "srgb"
                    ]
                },
                {
                    "x": "Apple A10X GPU|Apple A9X GPU|Apple A12X GPU|Apple A12 GPU",
                    "m": function(n){return hash(n);},
                    "n": [
                        76,
                        74,
                        75
                    ],
                    "v": [
                        "p3"
                    ]
                },
                {
                    "x": "Apple A9X GPU",
                    "v": [
                        "srgb"
                    ]
                },
                {
                    "x": "Apple A10X GPU|Apple A12X GPU",
                    "m": function(n){return hash(n);},
                    "n": [
                        46,
                        77
                    ],
                    "v": [
                        "p3"
                    ]
                },
                {
                    "x": "Apple A10X GPU",
                    "v": [
                        2114570256,
                        3129316290
                    ]
                },
                {
                    "x": "Apple A12 GPU",
                    "v": [
                        1349146759,
                        2917249763
                    ]
                },
                {
                    "x": "Apple A10 GPU",
                    "v": [
                        2114570256
                    ]
                },
                {
                    "x": "Apple A12 GPU",
                    "v": [
                        1349146759
                    ]
                },
                {
                    "x": "Apple A9X GPU|Apple A9 GPU|Apple A10 GPU|Apple A8 GPU|Apple A8X GPU",
                    "m": function(n){return hash(n);},
                    "n": [
                        70,
                        80,
                        78,
                        79,
                        68,
                        69
                    ],
                    "v": [
                        "srgb"
                    ]
                },
                {
                    "x": "Apple A9 GPU",
                    "v": [
                        "srgb"
                    ]
                },
                {
                    "x": "Apple A9 GPU|Apple A10 GPU",
                    "m": function(n){return hash(n);},
                    "n": [
                        81,
                        56
                    ],
                    "v": [
                        "srgb"
                    ]
                },
                {
                    "x": "Apple A7 GPU",
                    "v": [
                        857422828,
                        1915583345
                    ]
                },
                {
                    "x": "Apple A9 GPU",
                    "v": [
                        46663968,
                        3129316290
                    ]
                },
                {
                    "x": "Apple A8 GPU",
                    "v": [
                        839732043,
                        3816812018,
                        4125234388
                    ]
                },
                {
                    "x": "Apple A9 GPU",
                    "v": [
                        2114570256
                    ]
                },
                {
                    "x": "Apple A10 GPU",
                    "v": [
                        583354101,
                        3458129248
                    ]
                },
                {
                    "x": "Apple A13 GPU",
                    "v": [
                        352823931,
                        3403189785,
                        4193218782
                    ]
                },
                {
                    "x": "Apple A8 GPU",
                    "v": [
                        1411440593,
                        1924197914,
                        4125234388
                    ]
                },
                {
                    "x": "Apple A9 GPU",
                    "v": [
                        2114570256,
                        3129316290
                    ]
                },
                {
                    "x": "Apple A10 GPU",
                    "v": [
                        2114570256,
                        3129316290
                    ]
                },
                {
                    "x": "Apple A11 GPU",
                    "v": [
                        1349146759,
                        2917249763
                    ]
                },
                {
                    "x": "Apple A8 GPU",
                    "v": [
                        1411440593,
                        1913250432,
                        3074367344,
                        4125234388
                    ]
                },
                {
                    "x": "Apple A9 GPU",
                    "v": [
                        46663968,
                        2114570256,
                        3129316290
                    ]
                },
                {
                    "x": "Apple A11 GPU",
                    "v": [
                        2917249763,
                        3237505312
                    ]
                },
                {
                    "x": "Apple A8 GPU",
                    "v": [
                        3128296539,
                        3816812018,
                        4125234388
                    ]
                },
                {
                    "x": "Apple A8 GPU",
                    "v": [
                        2656686317,
                        3710391565
                    ]
                },
                {
                    "x": "Apple A9X GPU|Apple A9 GPU|Apple A10 GPU",
                    "n": [
                        84,
                        85,
                        82,
                        83
                    ],
                    "v": [
                        3129316290
                    ]
                },
                {
                    "x": "Apple A9 GPU|Apple A9X GPU|Apple A10 GPU",
                    "n": [
                        88,
                        86,
                        89,
                        87
                    ],
                    "v": [
                        2114570256
                    ]
                },
                {
                    "x": "Apple A10 GPU",
                    "v": [
                        46663968
                    ]
                },
                {
                    "x": "Apple A8 GPU|Apple A8X GPU",
                    "n": [
                        91,
                        90
                    ],
                    "v": [
                        4125234388
                    ]
                },
                {
                    "x": "Apple A8 GPU|Apple A8X GPU",
                    "m": function(n){return hash3d(n);},
                    "n": [
                        92,
                        93,
                        94
                    ],
                    "v": [
                        4005673483
                    ]
                },
                {
                    "x": "Apple A8 GPU|Apple A8X GPU",
                    "v": [
                        1350183384,
                        1361285941,
                        3816812018
                    ]
                },
                {
                    "x": "Apple A10X GPU|Apple A9X GPU",
                    "n": [
                        95,
                        96
                    ],
                    "v": [
                        3129316290
                    ]
                },
                {
                    "x": "Apple A9X GPU|Apple A10X GPU",
                    "n": [
                        97,
                        98
                    ],
                    "v": [
                        2114570256
                    ]
                },
                {
                    "x": "Apple A12X GPU|Apple A12 GPU",
                    "v": [
                        1349146759,
                        2917249763
                    ]
                },
                {
                    "x": "Apple A12X GPU",
                    "v": [
                        1349146759,
                        2917249763
                    ]
                },
                {
                    "x": "Apple A8 GPU|Apple A8X GPU",
                    "m": function(n){return hash3d(n);},
                    "n": [
                        99,
                        93
                    ],
                    "v": [
                        4005673483
                    ]
                },
                {
                    "x": "Apple A8 GPU|Apple A8X GPU",
                    "v": [
                        1361285941
                    ]
                },
                {
                    "x": "Apple A8X GPU",
                    "v": [
                        1350183384,
                        3816812018,
                        4125234388
                    ]
                },
                {
                    "x": "Apple A9 GPU",
                    "v": [
                        46663968
                    ]
                },
                {
                    "x": "Apple A10 GPU",
                    "r": [
                        {
                            "a": 13.66,
                            "b": 16.36
                        }
                    ]
                },
                {
                    "x": "Apple A9 GPU|Apple A9X GPU",
                    "n": [
                        100
                    ],
                    "r": [
                        {
                            "a": 19.06,
                            "b": 21.29
                        }
                    ]
                },
                {
                    "x": "Apple A9 GPU",
                    "r": [
                        {
                            "a": 22.45,
                            "b": 25.26
                        }
                    ]
                },
                {
                    "x": "Apple A9 GPU",
                    "r": [
                        {
                            "a": 21.59,
                            "b": 22.44
                        }
                    ]
                },
                {
                    "x": "Apple A10 GPU",
                    "r": [
                        {
                            "a": 13.78,
                            "b": 16.67
                        }
                    ]
                },
                {
                    "x": "Apple A9X GPU|Apple A10 GPU",
                    "r": [
                        {
                            "a": 16.68,
                            "b": 18.55
                        }
                    ]
                },
                {
                    "x": "Apple A9 GPU",
                    "r": [
                        {
                            "a": 21.35,
                            "b": 34.09
                        }
                    ]
                },
                {
                    "x": "Apple A9 GPU|Apple A9X GPU",
                    "n": [
                        101
                    ],
                    "r": [
                        {
                            "a": 19.54,
                            "b": 21.34
                        }
                    ]
                },
                {
                    "x": "Apple A8 GPU|Apple A8X GPU",
                    "n": [
                        102,
                        103
                    ],
                    "r": [
                        {
                            "a": 27.91,
                            "b": 30.91
                        }
                    ]
                },
                {
                    "x": "Apple A8 GPU",
                    "r": [
                        {
                            "a": 30.92,
                            "b": 31.88
                        }
                    ]
                },
                {
                    "x": "Apple A8X GPU",
                    "v": [
                        1783160115
                    ]
                },
                {
                    "x": "Apple A8 GPU",
                    "v": [
                        3928382683
                    ]
                },
                {
                    "x": "Apple A8 GPU|Apple A8X GPU",
                    "n": [
                        104,
                        105,
                        106
                    ],
                    "v": [
                        3403189785
                    ]
                },
                {
                    "x": "Apple A10X GPU",
                    "r": [
                        {
                            "a": 14.49,
                            "b": 15.29
                        }
                    ]
                },
                {
                    "x": "Apple A9X GPU",
                    "r": [
                        {
                            "a": 16.34,
                            "b": 387.31
                        }
                    ]
                },
                {
                    "x": "Apple A10X GPU",
                    "r": [
                        {
                            "a": 13.91,
                            "b": 15.11
                        }
                    ]
                },
                {
                    "x": "Apple A9X GPU",
                    "r": [
                        {
                            "a": 16.64,
                            "b": 36.84
                        }
                    ]
                },
                {
                    "x": "Apple A8X GPU",
                    "v": [
                        1783160115,
                        3403189785
                    ]
                },
                {
                    "x": "Apple A9X GPU|Apple A9 GPU",
                    "r": [
                        {
                            "a": 0.26,
                            "b": 115.16
                        }
                    ]
                },
                {
                    "x": "Apple A9X GPU|Apple A9 GPU",
                    "r": [
                        {
                            "a": 0.79,
                            "b": 331.46
                        }
                    ]
                },
                {
                    "x": "Apple A8X GPU",
                    "r": [
                        {
                            "a": 0.26,
                            "b": 5.67
                        }
                    ]
                },
                {
                    "x": "Apple A8 GPU",
                    "r": [
                        {
                            "a": 6.13,
                            "b": 177.99
                        }
                    ]
                },
                {
                    "x": "Apple A8X GPU",
                    "r": [
                        {
                            "a": 0.53,
                            "b": 13.31
                        }
                    ]
                },
                {
                    "x": "Apple A8 GPU",
                    "r": [
                        {
                            "a": 46.91,
                            "b": 82.82
                        }
                    ]
                },
                {
                    "x": "Apple A8 GPU",
                    "r": [
                        {
                            "a": 83.08,
                            "b": 2952.42
                        }
                    ]
                }
            ];

        function hash() {

            // Draws an image that changes very subtly based on the GPU model used
            // to render it.
            // @param a canvas instance that has not be drawn to.
            // @return a base 64 encoded string containing the image.
            function drawImage(canvas) {

                // Configure the canvas and get context.
                canvas.width = 67;
                canvas.height = 67;
                var ctx = canvas.getContext('2d', { alpha: true });

                if (ctx != null) {

                    // Configure the canvas context.
                    ctx.imageSmoothingQuality = "low";
                    ctx.imageSmoothingEnabled = true;
                    ctx.globalCompositeOperation = "source-over";
                    ctx.globalAlpha = 1;
                    ctx.miterLimit = Infinity;
                    ctx.filter = "none";
                    ctx.lineCap = "butt";
                    ctx.lineDashOffset = 0;
                    ctx.lineJoin = "miter";
                    ctx.font = "10pt Arial";
                    ctx.lineWidth = 2;
                    // setLineDash not supported on iPhone 3G / iOS 4.2
                    if (ctx.setLineDash !== undefined) {
                        ctx.setLineDash([10, 20]);
                    }
                    ctx.shadowColor = "black";
                    ctx.shadowOffsetX = -3;
                    ctx.shadowOffsetY = -5;

                    // Rotate the canvas and add some text.
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate(0.8901179);
                    ctx.fillStyle = "green";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText("*51Degrees*", 0, 0);

                    // Draw a transparent circle or elipse over the text. A circle
                    // is used if the ellipse feature is not supported by the GPU.
                    ctx.beginPath();
                    ctx.shadowColor = "yellow";
                    ctx.shadowBlur = 1;
                    ctx.shadowOffsetX = 1;
                    ctx.shadowOffsetY = 1;
                    ctx.strokeStyle = "red";
                    ctx.fillStyle = "rgba(0, 0, 255, 0.6)";
                    if (ctx.ellipse === undefined) {
                        ctx.arc(0, 0, 25, 0, 2 * Math.PI);
                    }
                    else {
                        ctx.ellipse(0, 0, 25, 15, Math.PI / 4, 0, 2 * Math.PI);
                    }
                    ctx.fill();
                    ctx.stroke();

                    // Return the image as a base 64 encoded string.
                    return canvas.toDataURL();
                }
            }

            var imageHash = 0;

            var canvas = document.createElement("canvas");
            if (canvas != null) {

                // Get the image data as a string.
                var imageData = drawImage(canvas);
                if (imageData) {

                    // Hash the image data.
                    imageHash = fnvHash(imageData);
                }
            }

            return imageHash;
        }

        function hash3d() {
            // This function is based on this article: https://bl.ocks.org/camargo/649e5903c4584a21a568972d4a2c16d3
            // The 'mat4' object is created from code in the gl-matrix library: https://github.com/toji/gl-matrix
            var gl, program, canvas;

            // The non-minified versions of these shaders are available in
            // WebSite/partials/fragment-shader.glsl and
            // WebSite/partials/vertex-shader.glsl
            var VERTEX_SHADER = 'attribute vec3 c,d; uniform vec4 e; uniform vec3 f,g;uniform mat4 h,i;varying vec3 j;void main(){vec3 a=normalize(d);vec4 b=h*vec4(c,1.);vec3 k=normalize(vec3(e-b));j=g*f*max(dot(k,a),0.),gl_Position=i*vec4(c,1.);}';
            var FRAGMENT_SHADER = '#ifdef GL_ES\n' +
                'precision mediump float;\n' +
                '#endif\n' +
                'varying vec3 j;void main(){gl_FragColor = vec4(j, 1.0);}';

            // This object uses code from the gl-matrix library: https://github.com/toji/gl-matrix
            var mat4 = {
                create: function () {
                    var result = new Array(16);
                    for (var i = 0; i < 16; i++) {
                        result[i] = (i % 5 == 0 ? 1 : 0);
                    }
                    return result;
                },
                perspective: function (out, fovy, aspect, near, far) {
                    var f = 1.0 / Math.tan(fovy / 2), nf;
                    out[0] = f / aspect;
                    out[1] = 0;
                    out[2] = 0;
                    out[3] = 0;
                    out[4] = 0;
                    out[5] = f;
                    out[6] = 0;
                    out[7] = 0;
                    out[8] = 0;
                    out[9] = 0;
                    out[11] = -1;
                    out[12] = 0;
                    out[13] = 0;
                    out[15] = 0;
                    if (far != null && far !== Infinity) {
                        nf = 1 / (near - far);
                        out[10] = (far + near) * nf;
                        out[14] = (2 * far * near) * nf;
                    } else {
                        out[10] = -1;
                        out[14] = -2 * near;
                    }
                    return out;
                },
                lookAt: function (out, eye, center, up) {
                    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
                    var eyex = eye[0];
                    var eyey = eye[1];
                    var eyez = eye[2];
                    var upx = up[0];
                    var upy = up[1];
                    var upz = up[2];
                    var centerx = center[0];
                    var centery = center[1];
                    var centerz = center[2];

                    if (Math.abs(eyex - centerx) < 0.000001 &&
                        Math.abs(eyey - centery) < 0.000001 &&
                        Math.abs(eyez - centerz) < 0.000001) {
                        return mat4.identity(out);
                    }

                    z0 = eyex - centerx;
                    z1 = eyey - centery;
                    z2 = eyez - centerz;

                    len = 1 / Math.hypot(z0, z1, z2);
                    z0 *= len;
                    z1 *= len;
                    z2 *= len;

                    x0 = upy * z2 - upz * z1;
                    x1 = upz * z0 - upx * z2;
                    x2 = upx * z1 - upy * z0;
                    len = Math.hypot(x0, x1, x2);
                    if (!len) {
                        x0 = 0;
                        x1 = 0;
                        x2 = 0;
                    } else {
                        len = 1 / len;
                        x0 *= len;
                        x1 *= len;
                        x2 *= len;
                    }

                    y0 = z1 * x2 - z2 * x1;
                    y1 = z2 * x0 - z0 * x2;
                    y2 = z0 * x1 - z1 * x0;

                    len = Math.hypot(y0, y1, y2);
                    if (!len) {
                        y0 = 0;
                        y1 = 0;
                        y2 = 0;
                    } else {
                        len = 1 / len;
                        y0 *= len;
                        y1 *= len;
                        y2 *= len;
                    }

                    out[0] = x0;
                    out[1] = y0;
                    out[2] = z0;
                    out[3] = 0;
                    out[4] = x1;
                    out[5] = y1;
                    out[6] = z1;
                    out[7] = 0;
                    out[8] = x2;
                    out[9] = y2;
                    out[10] = z2;
                    out[11] = 0;
                    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
                    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
                    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
                    out[15] = 1;

                    return out;
                },
                multiply: function (out, a, b) {
                    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

                    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
                    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

                    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
                    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

                    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
                    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

                    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
                    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                    return out;
                },
                identity: function (out) {
                    out[0] = 1;
                    out[1] = 0;
                    out[2] = 0;
                    out[3] = 0;
                    out[4] = 0;
                    out[5] = 1;
                    out[6] = 0;
                    out[7] = 0;
                    out[8] = 0;
                    out[9] = 0;
                    out[10] = 1;
                    out[11] = 0;
                    out[12] = 0;
                    out[13] = 0;
                    out[14] = 0;
                    out[15] = 1;
                    return out;
                }
            };

            function initVertexBuffers(gl) {
                var latitudeBands = 50;
                var longitudeBands = 50;
                var radius = 2;

                var vertexPositionData = [];
                var normalData = [];
                var textureCoordData = [];
                var indexData = [];

                var latNumber, longNumber;

                // Calculate sphere vertex positions, normals, and texture coordinates.
                for (latNumber = 0; latNumber <= latitudeBands; ++latNumber) {
                    var theta = latNumber * Math.PI / latitudeBands;
                    var sinTheta = Math.sin(theta);
                    var cosTheta = Math.cos(theta);

                    for (longNumber = 0; longNumber <= longitudeBands; ++longNumber) {
                        var phi = longNumber * 2 * Math.PI / longitudeBands;
                        var sinPhi = Math.sin(phi);
                        var cosPhi = Math.cos(phi);

                        var x = cosPhi * sinTheta;
                        var y = cosTheta;
                        var z = sinPhi * sinTheta;

                        var u = 1 - (longNumber / longitudeBands);
                        var v = 1 - (latNumber / latitudeBands);

                        vertexPositionData.push(radius * x);
                        vertexPositionData.push(radius * y);
                        vertexPositionData.push(radius * z);

                        normalData.push(x);
                        normalData.push(y);
                        normalData.push(z);

                        textureCoordData.push(u);
                        textureCoordData.push(v);
                    }
                }

                // Calculate sphere indices.
                for (latNumber = 0; latNumber < latitudeBands; ++latNumber) {
                    for (longNumber = 0; longNumber < longitudeBands; ++longNumber) {
                        var first = (latNumber * (longitudeBands + 1)) + longNumber;
                        var second = first + longitudeBands + 1;

                        indexData.push(first);
                        indexData.push(second);
                        indexData.push(first + 1);

                        indexData.push(second);
                        indexData.push(second + 1);
                        indexData.push(first + 1);
                    }
                }

                vertexPositionData = new Float32Array(vertexPositionData);
                normalData = new Float32Array(normalData);
                textureCoordData = new Float32Array(textureCoordData);
                indexData = new Uint16Array(indexData);

                // Create buffer objects.
                var vertexPositionBuffer = gl.createBuffer();
                var vertexNormalBuffer = gl.createBuffer();
                var indexBuffer = gl.createBuffer();

                // Write the vertex positions to their buffer object.
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertexPositionData, gl.STATIC_DRAW);

                // Assign position coords to attrib and enable it.
                var VertexPosition = gl.getAttribLocation(program, 'c');
                gl.vertexAttribPointer(VertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(VertexPosition);

                // Write the normals to their buffer object.
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, normalData, gl.STATIC_DRAW);

                // Assign normal to attrib and enable it.
                var VertexNormal = gl.getAttribLocation(program, 'd');
                gl.vertexAttribPointer(VertexNormal, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(VertexNormal);

                // Pass index buffer data to element array buffer.
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexData, gl.STATIC_DRAW);

                return indexData.length;
            }

            function generate() {
                if (!(gl = getRenderingContext()))
                    return;

                var vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, VERTEX_SHADER);
                gl.compileShader(vertexShader);
                var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, FRAGMENT_SHADER);
                gl.compileShader(fragmentShader);
                program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                gl.detachShader(program, vertexShader);
                gl.detachShader(program, fragmentShader);
                gl.deleteShader(vertexShader);
                gl.deleteShader(fragmentShader);
                gl.useProgram(program);

                // Init vertex buffers (position, color, and index data).
                var n = initVertexBuffers(gl);

                // Set up clear color and enable depth testing.
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.enable(gl.DEPTH_TEST);

                // Create projection matrix.
                var projection = mat4.create();
                mat4.perspective(projection, Math.PI / 6, 1.0, 0.1, 100.0);

                // Create model-view matrix.
                var modelView = mat4.create();
                mat4.lookAt(modelView, [0.0, 0.0, 10.0], [0.0, 0.0, 0.0], [0.0, 1.0, 0.0]);

                // Multiply the projection matrix by the model-view matrix to create the mvpMatrix.
                var mvpMatrix = mat4.create();
                mat4.multiply(mvpMatrix, projection, modelView);

                // Pass the modelView matrix into the shader.
                var ModelViewMatrix = gl.getUniformLocation(program, 'h');
                gl.uniformMatrix4fv(ModelViewMatrix, false, modelView);

                // Pass the mvp matrix into the shader.
                var MVP = gl.getUniformLocation(program, 'i');
                gl.uniformMatrix4fv(MVP, false, mvpMatrix);

                // Pass the light position into the shader.
                var LightPosition = gl.getUniformLocation(program, 'e');
                gl.uniform4fv(LightPosition, [10.0, 10.0, 10.0, 1.0]);

                // Pass the material diffuse color into the shader.
                var Kd = gl.getUniformLocation(program, 'f');
                gl.uniform3fv(Kd, [0.9, 0.5, 0.3]);

                // Pass the light diffuse color into the shader.
                var Ld = gl.getUniformLocation(program, 'g');
                gl.uniform3fv(Ld, [1.0, 1.0, 1.0]);

                // Clear & draw.
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_SHORT, 0);

                cleanup();
                return canvas.toDataURL();
            }

            function cleanup() {
                gl.useProgram(null);
                if (program)
                    gl.deleteProgram(program);
            }

            function getRenderingContext() {
                canvas.width = 67;
                canvas.height = 67;
                var gl = canvas.getContext("webgl")
                    || canvas.getContext("experimental-webgl");
                if (gl) {
                    gl.viewport(0, 0, 67, 67);
                    gl.clearColor(0.0, 0.0, 0.0, 1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                }
                return gl;
            }

            var imageHash = 0;

            canvas = document.createElement("canvas");
            if (canvas != null) {
                // Get the image data as a string.
                var imageData = generate();
                if (imageData) {
                    // Hash the image data.
                    imageHash = fnvHash(imageData);
                }
            }

            return imageHash;
        }

        // Performs an FNV hash on the string provided.
        // @param str the string to be hashed.
        // @return the hash value as a 32 bit integer.
        function fnvHash(str) {
            var h = 0x811c9dc5;
            for (var i = 0; i < str.length; ++i) {
                h ^= str.charCodeAt(i);
                h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
            }
            return h >>> 0;
        }

        // Try getting the renderer string via the conventional debug extension.
        // @return the UNMASKED_RENDERER_WEBGL parameter value.
        function reportedrenderer() {
            var canvas = document.createElement("canvas");
            if (canvas != null) {
                var context = canvas.getContext("webgl") ||
                    canvas.getContext("experimental-webgl");
                if (context) {
                    var info = context.getExtension("WEBGL_debug_renderer_info");
                    if (info) {
                        return context.getParameter(info.UNMASKED_RENDERER_WEBGL);
                    }
                }
            }
            return '';
        }

        // Width of the screen in pixels.
        function width() {
            return window.screen.width * window.devicePixelRatio;
        }

        // Height of the screen in pixels.
        function height() {
            return window.screen.height * window.devicePixelRatio;
        }

        // Pixel ratio of the screen.
        function ratio() {
            return window.devicePixelRatio;
        }

        // Determines if the query is supported by the device.
        // @param query the media query to check
        // @return true if the query is supported, otherwise false
        function hasMediaSupport(query) {
            return window.matchMedia(query).matches;
        }

        // Takes a list of values for a media query name and returns
        // the one that is supported, or undefined if none are supported.
        // @param name of the media query
        // @param possibleValues possible values for the media query name
        // @return the first value from the list that matches, otherwise "n/a"
        function getMediaSingleValue(name, possibleValues) {
            for (var i = 0; i < possibleValues.length; i++) {
                if (hasMediaSupport('(' + name + ': ' + possibleValues[i] + ')')) {
                    return possibleValues[i];
                }
            }
            return 'n/a';
        }

        // Returns the color gamut value from the media queries.
        // @return p2 or srgb or undefined
        function mediacolorgamut() {
            return getMediaSingleValue('color-gamut', ['p3', 'srgb']);
        }

        // Returns the portion of the User-Agent which represents the family of
        // Apple products the device belongs.
        // @return iPhone, iPad or Macintosh otherwise empty string
        function family() {
            var segments = /iPhone|iPad|Macintosh/.exec(navigator.userAgent);
            if (segments && segments.length > 0) {
                return segments[0];
            }
            return '';
        }

        function resolveNode(node, value, iterations) {

            // For all the children of the node being evaluated.
            for (var i = 0; i < node.n.length; i++) {

                // Get the values for the child.
                var child = nodes[node.n[i]];

                // If the child is a range of values.
                if (child.r) {

                    for (var c = 0; c < child.r.length; c++) {
                        var range = child.r[c];

                        // If the value is between the two values as a range.
                        if ((range.a === null || value >= range.a) &&
                            (range.b === null || value <= range.b)) {
                            evaluateNode(child, 0);
                            return;
                        }
                    }
                }

                // If the child has a specific list of values.
                else if (child.v) {

                    // Compare for equality with the value found.
                    if (child.v.indexOf(value) != -1) {
                        evaluateNode(child, 0);
                        return;
                    }
                }
            }

            // If this node has children then wait 10ms and then retry the
            // evaluation of this function if we've tried it less than 10 times.
            if (node.n.length > 0 && iterations < 10) {
                evaluateNode(node, iterations + 1)
            }

            // There child that have matched. Therefore return the Profile
            // Id of the node passed.
            complete(node.x);
        }

        // Evaluates the children of the node until a Profile Id is found.
        // @param node to be evaluated.
        // @return the profile Id of the best node found.
        function evaluateNode(node, iterations) {

            // If there is a function then execute it, get the result and
            // then find the matching item in the list.
            if (node.m) {

                // Get the value from the function.
                var result = node.m(node);

                // If this isn't a promise then resolve the value returned. If it
                // is a promise it's up to the evaluation method to handle
                // processing the promise once it's resolved.
                if (result || result === '') {
                    if (!result.then) {
                        resolveNode(node, result, iterations);
                    }
                }
                else if (node.x) {
                    complete(node.x);
                }
            }

            // There is no method so return the Profile Id.
            else {
                complete(node.x);
            }
        }

        // Evaluate the root node of the tree.
        evaluateNode(nodes[0], 0);
        complete('done');
    }

    function test() {
        let results = [];
        function getPrime() {
            return largest_prime_factor(100000000000);
        }
        function factors(n) {
            var i;
            var out = [];
            var sqrt_n = Math.sqrt(n);
            for (i = 2; i <= sqrt_n; i++) {
                if (n % i === 0) {
                    out.push(i);
                }
            }
            return out;
        }
        function primep(n) {
            return factors(n).length === 0;
        }
        function largest_prime_factor(n) {
            return factors(n).filter(primep).pop();
        }

        for (let i = 0; i < 3; i++) {
            let time = performance.now();
            getPrime();
            results.push((performance.now() - time) * 10);
        }

        results.sort((a, b) => a - b);
        return results[0];
    }

    function fallbackTest() {
        let res = Math.min(screen.width, screen.height) + 'x' + Math.max(screen.width, screen.height);
        let time = test();
        switch (res) {
            case '320x480': //old
                Device.graphics.webgl.gpu = 'legacy';
                break;

            case '320x568': //iphone 5/5s/6se
                if (time <= 400) Device.graphics.webgl.gpu = 'apple a8';
                else if (time <= 500) Device.graphics.webgl.gpu = 'apple a7';
                else Device.graphics.webgl.gpu = 'legacy';
                break;

            case '375x812': //iphone x / 11 pro
            case '414x896': //iphone xs plus // iphone 11 / 11 pro max
                if (time <= 150) Device.graphics.webgl.gpu = 'apple a13';
                else if (time <= 180) Device.graphics.webgl.gpu = 'apple a12';
                else Device.graphics.webgl.gpu = 'apple a11';
                break;

            case '414x736': //iphone 6/7/8+
            case '375x667': //iphone 6/6s/7/8
                if (time <= 220) Device.graphics.webgl.gpu = 'apple a11';
                else if (time <= 250) Device.graphics.webgl.gpu = 'apple a10';
                else if (time <= 360) Device.graphics.webgl.gpu = 'apple a9';
                else if (time <= 400) Device.graphics.webgl.gpu = 'apple a8';
                else if (time <= 600) Device.graphics.webgl.gpu = 'apple a7';
                else Device.graphics.webgl.gpu = 'legacy';
                break;

            default: //catchall
            case '768x1024': //ipad mini of all gens, ipad 9.7"
                if (time <= 160) Device.graphics.webgl.gpu = 'apple a13';
                else if (time <= 180) Device.graphics.webgl.gpu = 'apple a12';
                else if (time <= 220) Device.graphics.webgl.gpu = 'apple a11';
                else if (time <= 250) Device.graphics.webgl.gpu = 'apple a10';
                else if (time <= 360) Device.graphics.webgl.gpu = 'apple a9';
                else if (time <= 400) Device.graphics.webgl.gpu = 'apple a8';
                else if (time <= 600) Device.graphics.webgl.gpu = 'apple a7';
                else Device.graphics.webgl.gpu = 'legacy';
                break;

            case '834x1112': //ipad 2019
                if (time <= 160) Device.graphics.webgl.gpu = 'apple a13';
                else if (time <= 180) Device.graphics.webgl.gpu = 'apple a12';
                else if (time <= 220) Device.graphics.webgl.gpu = 'apple a11';
                else Device.graphics.webgl.gpu = 'apple a10';
                break;

            case '834x1194': //ipad pro 11" 2018
                if (time <= 160) Device.graphics.webgl.gpu = 'apple a13';
                else if (time <= 180) Device.graphics.webgl.gpu = 'apple a12';
                break;

            case '810x1080': //ipad 10.2" 2019
                if (time <= 160) Device.graphics.webgl.gpu = 'apple a13';
                else if (time <= 220) Device.graphics.webgl.gpu = 'apple a11';
                else if (time <= 250) Device.graphics.webgl.gpu = 'apple a10';
                break;

            case '820x1180': //ipad air 4
                Device.graphics.webgl.gpu = 'apple a14';
                break;

            case '1024x1366': //ipad pro
                if (time <= 160) Device.graphics.webgl.gpu = 'apple a13';
                else if (time <= 180) Device.graphics.webgl.gpu = 'apple a12';
                else if (time <= 220) Device.graphics.webgl.gpu = 'apple a11';
                else if (time <= 250) Device.graphics.webgl.gpu = 'apple a10';
                else Device.graphics.webgl.gpu = 'apple a9';
                break;
        }
    }

    this.exports = function() {
        let promise = Promise.create();
        let _value;
        getRenderer(value => {
            if (value == 'done') {
                if (_value.includes('|')) {
                    let split = _value.split('|');
                    let output = split.map(v => Number(v.replace('Apple', '').replace('X', '').split('A')[1].split(' ')[0]));
                    if (output[output.length-1] - output[0] > 2) fallbackTest();
                    else Device.graphics.webgl.gpu = split[0];
                } else {
                    Device.graphics.webgl.gpu = _value.toLowerCase();
                }
                promise.resolve();
            } else {
                _value = value;
            }
        });
        return promise;
    }
});
Module(function GPUBlacklist() {
    this.exports = {
        match: function() {
            if (!Device.graphics.gpu) return true;

            return Device.graphics.gpu.detect([
                'radeon hd 6970m',
                'radeon hd 6770m',
                'radeon hd 6490m',
                'radeon hd 6630m',
                'radeon hd 6750m',
                'radeon hd 5750',
                'radeon hd 5670',
                'radeon hd 4850',
                'radeon hd 4870',
                'radeon hd 4670',
                'geforce 9400m',
                'geforce 320m',
                'geforce 330m',
                'geforce gt 130',
                'geforce gt 120',
                'geforce gtx 285',
                'geforce 8600',
                'geforce 9600m',
                'geforce 9400m',
                'geforce 8800 gs',
                'geforce 8800 gt',
                'quadro fx 5',
                'quadro fx 4',
                'radeon hd 2600',
                'radeon hd 2400',
                'radeon hd 2600',
                'radeon r9 200',
                'mali-4',
                'mali-3',
                'mali-2',
                'google swiftshader',
                'sgx543',
                'legacy',
                'sgx 543'
            ]);
        }
    }
});
Class(function Initializer3D() {
    Inherit(this, Component);
    const _this = this;
    let _loader, _working;

    let _promises = [];
    let _queue = [];

    this.READY = 'initializer_ready';

    async function resolve() {
        await Promise.all(_promises);
        clearTimeout(_this.fire);
        _this.fire = _this.delayedCall(_ => {
            _this.events.fire(_this.READY);
            _this.resolved = true;
            Utils3D.onTextureCreated = null;
            if (_loader) _loader.trigger(50);
        }, 100);
    }

    async function workQueue() {
        clearTimeout(_this.warningTimer);
        _working = true;
        let promise = _queue.shift();
        if (!promise) return _working = false;
        promise.resolve(workQueue);

        if (Hydra.LOCAL) {
            _this.warningTimer = _this.delayedCall(_ => {
                console.warn('Long running queue has taken more than 5 seconds.');
            }, 5000);
        }
    }

    function incCompleted() {
        if (_loader) _loader.trigger(1);
    }

    //*** Event handlers

    //*** Public methods
    this.bundle = function() {
        function PromiseBundler() {
            const promises = [];
            const ready = Promise.create();
            let timer;

            function run(){
                clearTimeout(timer);
                timer = _this.delayedCall(_ => {
                    Promise.all(promises).then(_ => ready.resolve());
                }, 100);
            }

            this.capture = function(promise) {
                promises.push(promise);
                run();
            };

            this.ready = function() {
                run();
                return ready;
            };
        }

        return new PromiseBundler();
    };

    this.promise = this.capture = function(promise) {
        if (_loader) _loader.add(1);
        promise.then(incCompleted);
        _promises.push(promise);
        clearTimeout(_this.timer);
        _this.timer = _this.delayedCall(resolve, 100);
        return promise;
    };

    this.ready = this.loaded = function() {
        return _this.wait(_this, 'resolved');
    };

    this.createWorld = async function() {
        await Promise.all([
            AssetLoader.waitForLib('zUtils3D'),
            Shaders.ready(),
            GPU.ready(),
            UILStorage.ready()
        ]);
        World.instance();
    };

    this.linkSceneLayout = function(loader) {
        _this.captureTextures();
        SceneLayout.initializer = _this.capture;
        _loader = loader;
    };

    this.queue = function(immediate) {
        if (immediate) return Promise.resolve(_ => {});

        let promise = Promise.create();
        _queue.push(promise);
        if (!_working) workQueue();
        return promise;
    };

    this.captureTextures = function() {
        Utils3D.onTextureCreated = texture => {
            _this.promise(texture.promise);
        };
    };

    this.uploadAll = async function(group) {
        if (!group) throw 'Undefined passed to uploadAll';

        let sceneLayout;
        if (group instanceof SceneLayout || (window.StageLayout && group instanceof StageLayout)) {
            sceneLayout = group;
            if (sceneLayout.uploaded) return;
            sceneLayout.uploaded = true;
            await sceneLayout.loadedAllLayers();
            group = group.group;
        }

        let promises = [];
        let layouts = [];
        let textures = [];
        if (sceneLayout) {
            sceneLayout.textures = textures;
            for (let key in sceneLayout.layers) {
                let layer = sceneLayout.layers[key];
                if (layer.uploadSync) layer.uploadSync();
            }
        }

        group.traverse(obj => {
            if (obj.sceneLayout && obj != group) layouts.push(obj.sceneLayout);
            if (obj.stageLayout && obj != group) layouts.push(obj.stageLayout);
            if (obj.uploadIgnore || obj.visible == false) return;
            if (obj.shader) {
                for (let key in obj.shader.uniforms) {
                    let uniform = obj.shader.uniforms[key];
                    if (uniform && uniform.value && uniform.value.promise) {
                        textures.push(uniform.value);
                        promises.push( uniform.value.promise.then(_ => uniform.value.upload.bind(uniform.value)).catch(e => {}) );
                    }
                }
            }

            if (obj.asyncPromise) promises.push(obj.asyncPromise.then(_ => obj.upload.bind(obj)));
            else if (obj.upload) obj.upload();
        });

        await Promise.catchAll(promises);

        textures.forEach(t => t.upload());

        for (let i = 0; i < layouts.length; i++) {
            await _this.uploadAll(layouts[i]);
        }

        if (sceneLayout && sceneLayout._completeInitialization) sceneLayout._completeInitialization(true);
    };

    this.uploadAllDistributed = this.uploadAllAsync = async function(group, releaseQueue) {
        if (!group) throw 'Undefined passed to uploadAllDistributed';

        if(!releaseQueue && typeof releaseQueue != 'boolean') releaseQueue = await _this.queue();

        let sceneLayout;
        if (group instanceof SceneLayout || (window.StageLayout && group instanceof StageLayout)) {
            sceneLayout = group;
            if (sceneLayout.uploaded && typeof releaseQueue == 'function') return releaseQueue();
            sceneLayout.uploaded = true;
            await sceneLayout.loadedAllLayers();
            group = group.group;
        }

        let uploads = [];
        let _async = [];
        let promises = [];
        let layouts = [];
        let textures = [];
        if (sceneLayout) {
            sceneLayout.textures = textures;
            for (let key in sceneLayout.layers) {
                let layer = sceneLayout.layers[key];
                if (layer.upload) layer.upload();
            }
        }

        group.traverse(obj => {
            if (obj.sceneLayout && obj != group) layouts.push(obj.sceneLayout);
            if (obj.stageLayout && obj != group) layouts.push(obj.stageLayout);
            if (obj.uploadIgnore || obj.visible == false) return;
            if (obj.shader) {
                for (let key in obj.shader.uniforms) {
                    let uniform = obj.shader.uniforms[key];
                    if (uniform && uniform.value && uniform.value.promise) {
                        textures.push(uniform.value);
                        promises.push( uniform.value.promise.then(_ => uploads.push(uniform.value.upload.bind(uniform.value))).catch(e => {}) );
                    }
                }
            }

            if (obj.asyncPromise) {
                promises.push(obj.asyncPromise.then(_ => {
                    if (obj.geometry) obj.geometry.distributeBufferData = true;
                    uploads.push(obj.upload.bind(obj));
                    if (obj.geometry) _async.push(obj.geometry.uploadBuffersAsync.bind(obj.geometry));
                }));
            } else if (obj.upload) {
                if (obj.geometry) {
                    if (obj.geometry.uploaded) return;
                    obj.geometry.distributeBufferData = true;
                }
                uploads.push(obj.upload.bind(obj));
                if (obj.geometry) _async.push(obj.geometry.uploadBuffersAsync.bind(obj.geometry));
            }
        });

        let canFinish = false;
        let promise = Promise.create();

        let cleanUp = async _ => {
            for (let i = 0; i < _async.length; i++) {
                await _async[i]();
            }
            for (let i = 0; i < layouts.length; i++) {
                await _this.uploadAllAsync(layouts[i], !!releaseQueue);
            }
            if(typeof releaseQueue == 'function') releaseQueue();
            promise.resolve();
        };

        let worker = new Render.Worker(_ => {
            let upload = uploads.shift();
            if (upload) upload();
            else {
                if (!canFinish) worker.pause();
                else {
                    cleanUp();
                    worker.stop();
                }
            }
        }, 1);

        Promise.catchAll(promises).then(_ => {
            worker.resume();
            canFinish = true;
        });

        if (sceneLayout && sceneLayout._completeInitialization) sceneLayout._completeInitialization(false);

        return promise;
    };

    this.detectUploadAll = function(group, sync, releaseQueue) {
        return sync ? _this.uploadAll(group) : _this.uploadAllDistributed(group, releaseQueue);
    };

    this.detectUploadNuke = function(nuke, sync) {
        return sync ? _this.uploadNukeAsync(nuke) : _this.uploadNuke(nuke);
    }

    this.uploadNuke = async function(nuke) {
        for (let i = 0; i < nuke.passes.length; i++) {
            let pass = nuke.passes[i];
            let uniforms = pass.uniforms;
            for (let key in uniforms) {
                if (uniforms[key].promise) await uniforms[key].promise;
                if (uniforms[key].upload) uniforms[key].upload();
            }
            pass.upload();
        }
    }

    this.uploadNukeAsync = function(nuke) {
        return this.uploadNuke(nuke);
    }

    this.destroyAll = function(scene) {
        scene.traverse(obj => {
            if (obj.geometry && obj.shader) {
                for (let key in obj.shader.uniforms) {
                    let uniform = obj.shader.uniforms[key];
                    if (uniform && uniform.value instanceof Texture) uniform.destroy();
                }
                obj.destroy();
            }
        });
    }

    this.set('loader', loader => {
        _loader = loader;
    });

}, 'static');
Class(function Webcam(_width, _height, _audio) {
    Inherit(this, Component);
    var _this = this;

    let _stream, _cameras = {}, _config = {};
    let _back = false, _attempts = 0;

    _this.facing = 'back';

    //*** Constructor
    (function() {
        createVideo();
        initNavigator();
    })();

    function createVideo() {
        _this.div = window.AURA ? document.createElement() : document.createElement('video');
        _this.div.width = _width;
        _this.div.height = _height;
        _this.div.autoplay = true;
        _this.div.controls = true;
        _this.div.playsinline = true;
        _this.div.setAttribute("playsinline", true);
        _this.div.setAttribute("controls", true);

        Stage.add(_this.div);

        _this.element = $(_this.div);
        _this.element.transformPoint(0,0).transform({ scaleX: !Device.mobile ? -1 : 1, scale: 0.25 }).setZ(-1);
    }

    function initNavigator() {
        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
    }

    function establishWebcam() {
        if (_attempts >= 2 || !navigator.mediaDevices) return error();

        lookupDevices().then( () => {
            if (_stream && _config.back) _stream.getTracks()[0].stop();
            if (Device.mobile.phone) {
                if (_cameras && _cameras.back) _cameras.back.frameRate = { ideal: 60 };
                if (_cameras && _cameras.front) _cameras.front.frameRate = { ideal: 60 };
            }

            navigator.mediaDevices.getUserMedia({video: _config.back ? _cameras.back : _cameras.front || true, audio: _audio }).then(success).catch(error);
        });
        _attempts += 1;
    }

    function lookupDevices() {
        let promise = Promise.create();
        if (!Device.mobile) return Promise.resolve();

        navigator.mediaDevices.enumerateDevices().then(devices => {

            devices.forEach(device => {
                if (device.label.includes('front')) _cameras.front = {deviceId: {exact: device.deviceId} };
                if (device.label.includes('back')) {
                    _cameras.back = {deviceId: { exact: device.deviceId} };
                    _back = true;
                }
            });

            if (!_cameras.front) _cameras.front = { facingMode: "user" };
            if (!_cameras.back) {
                _cameras.back = { facingMode:  "environment" };
                _back = false;
            }

            promise.resolve();
        });

        return promise;
    }


    //*** Event handlers
    function success(stream) {
        _this.denied = false;
        _stream = stream;

        if (_config.back && !_back) {
            establishWebcam();
        } else {
            _this.div.srcObject = stream;
            _this.events.fire(Events.READY, null, true);
        }
    }

    function error() {
        _this.denied = true;
        _this.events.fire(Events.ERROR, null, true);
    }

    //*** Public Methods
    this.createStream = function(config = {}) {
        _attempts = 0;
        _config = config;
        establishWebcam();
    }

    this.flip = function() {
        if (!_back) return;
        let direction;

        if (_this.facing === 'front') {
            _this.facing = 'back';
            direction = _cameras.back;
        } else {
            _this.facing = 'front';
            direction = _cameras.front;
        }

        _stream.getTracks()[0].stop();
        navigator.getUserMedia({video: direction || true, audio: _audio}, success, error);
    }

    this.get('width', function() {
        return _width;
    });

    this.get('height', function() {
        return _height;
    });

    this.size = function(w, h) {
        _this.div.width = _width = w;
        _this.div.height = _height = h;
        _this.element.size(w, h);
    }

    this.getPixels = function(width = _width, height = _height) {
        if (!_this.canvas) {
            _this.canvas = document.createElement('canvas');
            _this.canvas.width = width;
            _this.canvas.height = height;
            _this.canvas.context = _this.canvas.getContext('2d');
        }

        _this.canvas.context.drawImage(_this.div, 0, 0, width, height);
        return _this.canvas.context.getImageData(0, 0, width, height);
    }

    this.getCanvas = function() {
        if (!_this.canvas) {
            _this.canvas = document.createElement('canvas');
            _this.canvas.width = _width;
            _this.canvas.height = _height;
            _this.canvas.context = _this.canvas.getContext('2d');
        }

        _this.canvas.context.drawImage(_this.div, 0, 0, _width, _height);
        return _this.canvas;
    }

    this.ready = function() {
        return _this.div.readyState > 0;
    }

    this.end = function() {
        _this.active = false;
        _this.div.pause();
        if (_stream) _stream.getTracks()[0].enabled = false;
    }

    this.restart = function() {
        _this.div.play();
        if (_stream) _stream.getTracks()[0].enabled = true;
        _this.active = true;
    }

    this.deviceCount = async function(kind) {
        if (!navigator.mediaDevices) return 0;

        let devices = await navigator.mediaDevices.enumerateDevices();
        let count = 0;
        devices.forEach(d => {
            if (d.kind.includes(kind)) count++;
        });
        return count;
    }

});
Class(function Performance() {
    Inherit(this, Component);
    const _this = this;

    var _overrides = Storage.get('performance_override') || {};

    (async function() {
        if ((Utils.query('performance') && Utils.query('edit')) || Utils.query('custom')) {
            await Hydra.ready();
            for (let key in _overrides) {
                Tests[key] = _ => _overrides[key];
            }
        }
    })();

    function save(key, value) {
        _overrides[key] = value;
        Storage.set('performance_override', _overrides);
    }

    function convert(tier) {
        if (GPU.BLACKLIST) return 'F';
        switch (tier) {
            case 5: return 'A++'; break;
            case 4: return 'A+'; break;
            case 3: return 'A'; break;
            case 2: return 'B'; break;
            case 1: return 'C'; break;
            case 0: return 'D'; break;
        }
    }

    //*** Event handlers

    //*** Public methods
    this.displayResults = async function() {
        let editing = Utils.query('edit');

        await GPU.ready();
        __body.bg('#000');

        let $results = __body.create('PerformanceResults');
        __body.css({overflowY: 'scroll'})
        $results.fontStyle('Arial', 18, '#fff').css({marginLeft: 50, marginRight: 50, 'user-select': 'auto'});

        Mobile.allowNativeScroll();

        HydraCSS.style('.PerformanceResults *', {position: 'relative', 'user-select': 'auto'});

        let code = Tests.constructor.toString();
        let tests = '';
        for (let key in Tests) {
            let result = Tests[key]();
            tests += `<p><b>${key}:</b> `;

            if (editing) {
                if (typeof result === 'number') {
                    tests += `<input class="${key}" value="${result.toString()}" /></p>`;
                }

                if (typeof result === 'boolean') {
                    tests += `<input class="${key}" type="checkbox" ${result ? 'checked' : ''}/></p>`;
                }
            } else {
                tests += result + '</p>';
            }
        }

        let html = `<h1>Performance Results</h1>
                    <p><b>GPU:</b> ${Device.graphics.webgl ? Device.graphics.webgl.gpu : 'WEBGL UNAVAILABLE'}</p>
                    <p><b>WebGL Version:</b> ${Device.graphics.webgl ? Device.graphics.webgl.version : 'WEBGL UNAVAILABLE'}</p>
                    <p><b>GPU Tier:</b> ${Device.mobile ? convert(GPU.M_TIER) : convert(GPU.TIER)} [${Device.mobile ? GPU.M_TIER : GPU.TIER}]</p>
                    <p><b>Mobile:</b> ${Device.mobile}</p>
                    <p><b>User Agent:</b> ${Device.agent}</p>
                    <p><b>DPR:</b> ${Device.pixelRatio}</p>
                    <p><b>Screen Size:</b> ${screen.width} x ${screen.height}</p>
                    <p><b>Stage Size:</b> ${Stage.width} x ${Stage.height}</p>
                    
                    <h2>Project-Specific Tests</h2>
                    ${editing ? '<button class="resetBtn">Reset All</button>' : ''}
                    ${tests}
        `;

        $results.html(html);

        if (editing) {
            await defer();

            let btn = document.querySelector('.resetBtn');
            btn.onclick = _ => {
                Storage.set('performance_override', null);
                location.reload();
            };

            for (let key in Tests) {
                let div = document.querySelector(`.${key}`);
                (function(div, key) {
                    div.onchange = _ => {
                        let value = div.value;
                        if (isNaN(value)) {
                            value = div.checked;
                        } else {
                            value = Number(value);
                        }

                        save(key, value);
                    }
                })(div, key);
            }
        }
    }
}, 'static');
Class(function RenderManager() {
    Inherit(this, Component);
    const _this = this;
    const _evt = {stage: null, camera: null};
    var _hasGLUI, _hasMetal;

    var _dpr = null;
    var _schedules = new Map();

    this.NORMAL = 'normal';
    this.MAGIC_WINDOW = 'magic_window';
    this.VR = this.WEBVR = 'webvr';
    this.AR = this.WEBAR = 'webar';

    this.RENDER = 'RenderManager_render';
    this.BEFORE_RENDER = 'RenderManager_before_render';
    this.POST_RENDER = this.FRAME_END = 'RenderManager_post_render';
    this.EYE_RENDER = 'RenderManager_eye_render';
    this.FRAME_BEGIN = 'RenderManager_frame_begin';
    this.AFTER_LOOPS = 'RenderManager_after_loops';
    this.READY = 'render_gl_ready';

    this.initialized = Promise.create();

    //*** Constructor
    (function() {
        _this.events.sub(Events.RESIZE, resizeHandler);
        Render.startFrame = startFrame;

        Hydra.ready(_ => {
            _hasGLUI = !!window.GLUI;
            _hasMetal = !!window.Metal;
        });
    })();

    function fire(evt, data) {
        let array = _schedules.get(evt);
        if (array) {
            let len = array.length;
            for (let i = 0; i < len; i++) {
                let cb = array[i];
                if (data) cb(data);
                else cb(Render.TIME, Render.DELTA);
            }
        }
    }

    function startFrame() {
        fire(_this.FRAME_BEGIN);
    }

    //*** Event handlers

    function resizeHandler() {
        _this.renderer && _this.renderer.setSize(Stage.width, Stage.height);
    }

    function getDPR() {
        if (window.AURA) return Device.pixelRatio;
        if (GPU.OVERSIZED) return 1;
        if (GPU.lt(0)) return Math.min(1.3, Device.pixelRatio);
        if (GPU.lt(1)) return Math.min(1.8, Device.pixelRatio);
        if (GPU.mobileLT(2)) return Math.min(2, Device.pixelRatio);
        if (GPU.gt(4)) return Math.max(1.5, Device.pixelRatio);
        return Math.max(1.25, Device.pixelRatio);
    }

    function directRenderCallback(render) {
        if (_hasGLUI && _hasMetal) GLUI.renderDirect(render);
    }

    //*** Public methods
    this.get('DPR', v => {
        return getDPR();
    });

    this.initialize = function(type, params = {}) {
        if (_this.camera) _this.camera.destroy();
        if (_this.renderer) _this.renderer.destroy();

        if (type == _this.WEBVR || type == _this.WEBAR) {
            params.xrCompatible = true;
            params.alpha = false;
        }

        if (!_this.gl) {
            let camera = new PerspectiveCamera(45, Stage.width / Stage.height, 0.01, 200);

            _this.gl = (function() {
                if (Device.system.browser == 'safari' && Device.system.browserVersion < 13) delete params.powerPreference;
                if (Utils.query('compat')) params.forceWebGL1 = true;
                const RendererClass = window.Metal ? MetalRenderer : Renderer;
                let renderer = new RendererClass(params);
                renderer.setSize(Stage.width, Stage.height);
                renderer.setPixelRatio(getDPR());
                return renderer;
            })();

            _this.scene = new Scene();

            _this.nuke = _this.initClass(Nuke, Stage, Object.assign({renderer: _this.gl, scene: _this.scene, camera: camera, dpr: World.DPR}, params));
        }

        _dpr = _dpr || World.DPR || 1;
        switch (type) {
            case _this.WEBVR:
                _this.renderer = _this.initClass(VRRenderer, _this.gl, _this.nuke);
                _this.camera = _this.initClass(VRCamera);
                break;

            case _this.WEBAR:
                _this.renderer = _this.initClass(window.Metal ? MetalARRenderer : ARRenderer, _this.gl, _this.nuke);
                _this.camera = _this.initClass(ARCamera);
                break;

            case _this.MAGIC_WINDOW:
                _this.renderer = _this.initClass(MagicWindowRenderer, _this.gl, _this.nuke);
                _this.camera = _this.initClass(VRCamera);
                break;

            case _this.NORMAL:
                _this.renderer = _this.initClass(RenderManagerRenderer, _this.gl, _this.nuke);
                _this.camera = _this.initClass(RenderManagerCamera);
                break;
        }

        _this.type = type;
        _this.nuke.camera = _this.camera.worldCamera;

        _this.initialized.resolve();
    }

    this.render = function(scene, camera, renderTarget, forceClear) {
        fire(_this.AFTER_LOOPS);
        if (_this.type == _this.VR) fire(World.NUKE);
        fire(_this.BEFORE_RENDER);
        _this.renderer.render(scene || _this.scene, camera || _this.camera.worldCamera, renderTarget, forceClear, directRenderCallback);
        _this.events.fire(_this.POST_RENDER);
        fire(_this.POST_RENDER);
    }

    this.schedule = function(callback, slot) {
        if (!_schedules.has(slot)) _schedules.set(slot, []);
        let array = _schedules.get(slot);
        array.push(callback);
    }

    this.scheduleOne = function(callback, slot) {
        let result;
        if (typeof callback !== 'function') {
            slot = callback;
            result = Promise.create();
            callback = result.resolve;
        }
        let handler = function() {
            _this.unschedule(handler, slot);
            return callback.apply(this, arguments);
        };
        _this.schedule(handler, slot);
        return result;
    }

    this.unschedule = function(callback, slot) {
        if (!_schedules.has(slot)) _schedules.set(slot, []);
        let array = _schedules.get(slot);
        array.remove(callback);
    }

    this.setSize = function(width, height) {
        _this.events.unsub(Events.RESIZE, resizeHandler);
        _this.renderer.setSize(width, height);
    }

    this.fire = fire;
}, 'static');

Class(function RenderManagerCamera() {
    Inherit(this, Component);
    const _this = this;

    this.worldCamera = window.THREE ? new THREE.PerspectiveCamera(30, Stage.width / Stage.height, 0.1, 1000) : new PerspectiveCamera(30, Stage.width / Stage.height, 0.1, 1000);

    _this.events.sub(Events.RESIZE, () => {
        _this.worldCamera.aspect = Stage.width / Stage.height;
        _this.worldCamera.updateProjectionMatrix();
    });
});
Class(function RenderManagerRenderer(_renderer, _nuke) {
    Inherit(this, Component);
    const _this = this;
    var _evt = {};

    _nuke.onBeforeProcess = _ => {
        _evt.stage = Stage;
        _evt.camera = _nuke.camera;
        _this.events.fire(RenderManager.RENDER, _evt);
    };

    //*** Event handlers

    //*** Public methods
    this.render = function(scene, camera, _1, _2, directRender) {
        _nuke.camera = camera;

        if (_nuke) {
            _nuke.render(directRender);
        } else {
            _renderer.render(scene, camera, null, null, directRender);
        }
    };

    this.setSize = function(width, height) {
        _renderer.setSize(width, height);
    };
});
/**
 * @name Shaders
 * */

Class(function Shaders() {
    Inherit(this, Component);
    var _this = this;

    //*** Constructor
    (function () {

    })();

    function parseSingleShader(code, fileName) {
        let uniforms = code.split('#!UNIFORMS')[1].split('#!')[0];
        let varyings = code.split('#!VARYINGS')[1].split('#!')[0];
        let attributes = code.split('#!ATTRIBUTES')[1].split('#!')[0];

        while (code.includes('#!SHADER')) {
            code = code.slice(code.indexOf('#!SHADER'));
            let split = code.split('#!SHADER')[1];
            let br = split.indexOf('\n');
            let name = split.slice(0, br).split(': ')[1];

            if (name.slice(0, 6).includes('Vertex')) name = fileName.split('.')[0] + '.vs';
            if (name.slice(0, 8).includes('Fragment')) name = fileName.split('.')[0] + '.fs';

            let glsl = split.slice(br);
            if (name.includes('.vs')) glsl = attributes + uniforms + varyings + glsl;
            else glsl = uniforms + varyings + glsl;

            // Have to do this weird thing for chrome on windows in dev mode
            let splitName = name.split('.');
            _this[splitName[0] + (splitName[1].includes('vs') ? '.vs' : '.fs')] = glsl;

            code = code.replace('#!SHADER', '$');
        }
    }

    function parseCompiled(shaders) {
        var split = shaders.split('{@}');
        split.shift();

        for (var i = 0; i < split.length; i += 2) {
            var name = split[i];
            var text = split[i+1];
            if (text.includes('#!UNIFORMS')) {
                parseSingleShader(text, name);
            } else {
                _this[name] = text;
            }
        }
    }

    function parseRequirements() {
        for (var key in _this) {
            var obj = _this[key];
            if (typeof obj === 'string') {
                _this[key] = require(obj);
            }
        }
    }

    function require(shader) {
        if (!shader.includes('require')) return shader;

        shader = shader.replace(/# require/g, '#require');
        while (shader.includes('#require')) {
            var split = shader.split('#require(');
            var name = split[1].split(')')[0];
            name = name.replace(/ /g, '');

            if (!_this[name]) throw 'Shader required '+name+', but not found in compiled shaders.\n'+shader;

            shader = shader.replace('#require('+name+')', _this[name]);
        }

        return shader;
    }

    //*** Event handlers

    //*** Public methods
    this.parse = function(code, file) {
        if (!code.includes('{@}')) {
            file = file.split('/');
            file = file[file.length-1]; 

            _this[file] = code;
        } else {
            parseCompiled(code);
            parseRequirements();
        }


        _this.shadersParsed = true;
    }

    this.onReady = this.ready = function(callback) {
        let promise = Promise.create();
        if (callback) promise.then(callback);
        _this.wait(() => promise.resolve(), _this, 'shadersParsed');
        return promise;
    }

    this.getShader = function(string) {
        if (_this.FALLBACKS) {
            if (_this.FALLBACKS[string]) {
                string = _this.FALLBACKS[string];
            }
        }

        var code = _this[string];

        if (code) {
            while (code.includes('#test ')) {
                try {
                    var test = code.split('#test ')[1];
                    var name = test.split('\n')[0];
                    var glsl = code.split('#test ' + name + '\n')[1].split('#endtest')[0];

                    if (!eval(name)) {
                        code = code.replace(glsl, '');
                    }

                    code = code.replace('#test ' + name + '\n', '');
                    code = code.replace('#endtest', '');
                } catch (e) {
                    throw 'Error parsing test :: ' + string;
                }
            }
        } else {
            throw `No shader ${string} found`;
        }

        return code;
    }
}, 'static');
Class(function Sprite(_id, _css = {}, _title = '', _viewBox = false, _useChildren = false) {
    Inherit(this, Element, 'svg', 'Sprite');
    const _this = this;
    const $this = _this.element;

    //*** Constructor
    (async function () {
        const html = $(Spritesheet.element.div);
        const symbol = html.div.querySelector(`#sprite-${_id}`);

        if (symbol && _viewBox) {
            let viewBox = symbol.getAttribute('viewBox');
            $this.attr('viewBox', viewBox);
        }

        $this.attr('role', 'img');
        $this.css(_css);

        let inner = '';

        if (_title) {
            inner += `<title>${_title}</title>`;
        }

        if (symbol && _useChildren) {
            inner += `${symbol.innerHTML}`;
        } else {
            inner += `<use xlink:href="#sprite-${_id}">`;
        }

        $this.html(inner);
    })();
});

Class(function Spritesheet() {
    Inherit(this, Component);
    const _this = this;

    _this.url = 'assets/images/sprite.svg';

    //*** Constructor
    (async function () {
        await Hydra.ready();

        const request = await fetch(_this.url);
        const response = await request.text();

        _this.element = Stage.create('Sprites');
        _this.element.size(0, 0).setZ(-1).html(response);

        Stage.add(_this.element);

        _this.flag('isReady', true);
    })();

    //*** Public methods
    _this.ready = function () {
        return _this.wait('isReady');
    };
}, 'static');

Class(function UI3D(_name = '') {
    Inherit(this, Component);
    const _this = this;

    const _rtSize = new Vector2();
    const _captureUnitSize = new Vector2();
    //*** Public methods

    this.create = function(width = 512, height = 512, dpr, data) {
        _rtSize.set(width, height);
        _captureUnitSize.set(width > height ? 1 : width / height, width > height ? height / width : 1);

        if (typeof dpr !== 'number') {
            data = dpr;
            dpr = undefined;
        }

        if (data) {
            _this.layout = _this.initClass(StageLayout, Utils.getConstructorName(_this) + _name, {glui: true, data, noGraph: !_this.isPlayground()});
            _this.root = _this.layout.element;
            _this.capture = _this.initClass(StageLayoutCapture, _this.layout, width, height, UI3D.getRTPool(width, height, dpr));
        } else {
            _this.capture = _this.initClass(StageLayoutCapture, width, height, UI3D.getRTPool(width, height, dpr));
            _this.root = _this.capture.root;
        }

        _this.root.capture = _this.capture;

        _this.$gluiObject = $gl(_captureUnitSize.x, _captureUnitSize.y, _this.capture);
        _this.capture.object3d = _this.$gluiObject;
    }


    this.setSize = function(size) {
        const fillRatio = new Vector2().copy(size).divide(_rtSize);
        _captureUnitSize.set(size.x > size.y ? 1 : size.x / size.y, size.x > size.y ? size.y / size.x : 1);
        _captureUnitSize.multiplyScalar(Math.max(fillRatio.x, fillRatio.y));

        _this.capture.setSize(size.x, size.y);
        _this.$gluiObject.size(_captureUnitSize.x, _captureUnitSize.y);
    }

    this.useShader = function(shader) {
        _this.$gluiObject.useShader(shader);
    }

    this.ready = function() {
        return _this.wait(_this, 'isReady')
    }

    this.hide = function() {
        _this.$gluiObject.hide();
    }

    this.show = function() {
        _this.$gluiObject.show();
    }

}, _ => {
    var _pools = {};
    UI3D.getRTPool = function(width, height, dpr = World.DPR) {
        let key = width+' '+height;
        if (!_pools[key]) {
            _pools[key] = RTPool.instance().clone(Texture.UNSIGNED_BYTE, 3, Texture.RGBAFormat);
            _pools[key].setSize(width * dpr, height * dpr);
        }
        return _pools[key];
    }
});
Class(function UI3DLayer(_input, _group, _id) {
    Inherit(this, Object3D);
    const _this = this;
    var _config, _obj;

    //*** Constructor
    (function() {
        _config = InputUIL.create(_input.prefix + 'ui3d', _group);
        _config.add('class');
        _config.addToggle('retina');
        _config.setLabel('Config');

        let className = _config.get('class');
        if (!className || _input.get('visible') == false) return;

        let wildcard = _input.get('wildcard');
        if (!window[className]) throw `UI3DLayer :: ${className} doesn't exist!`;

        let obj = _this.initClass(window[className], {data: wildcard, uil: {input: _input, group: _group, id: _id}});
        if (!obj.$gluiObject) throw `UI3DLayer :: ${className} not instance of UI3D (or create() hasn't been called)`;

        completeShader(obj.$gluiObject.shader);

        GLUIUtils.setRetinaMode(obj.$gluiObject, _config.get('retina') || UI3DLayer.overrideRetina, _this);
        if (GLUIUtils.isRetinaMode(obj.$gluiObject)) {
            _this.flag('retina', true);
        } else {
            obj.$gluiObject.enable3D();
            obj.$gluiObject.depthTest = false;
        }

        _obj = obj;
    })();

    function completeShader(shader) {
        let transparent = _input.get('transparent');
        let depthWrite = _input.get('depthWrite');
        let depthTest = _input.get('depthTest');
        let blending = _input.get('blending');
        let castShadow = _input.get('castShadow');
        let receiveShadow = _input.get('receiveShadow');
        let renderOrder = _input.getNumber('renderOrder');
        if (typeof depthWrite === 'boolean') shader.depthWrite = shader.mesh.depthWrite = depthWrite;
        if (typeof depthTest === 'boolean') shader.depthTest = shader.mesh.depthTest = depthTest;
        if (typeof transparent === 'boolean') shader.transparent = transparent;
        if (typeof castShadow === 'boolean') shader.mesh.castShadow = castShadow;
        if (typeof receiveShadow === 'boolean') shader.receiveShadow = receiveShadow;
        if (typeof renderOrder === 'number') shader.mesh.renderOrder = renderOrder;
        if (blending) shader.blending = blending;
    }

    //*** Event handlers

    //*** Public methods
    _this.getObject = function() {
        return _obj;
    }

    this.onDestroy = function() {
        if (_this.flag('retina')) GLUI.Scene.remove(_obj.$gluiObject);
    }
});
/**
 * UIL GUI
 * Exposes UILPanel and UILWindow instances
 */
Class(function UIL() {
    Inherit(this, Component);
    const _this = this;
    let _style;
    let _ui = {};
    let $el;

    //*** Constructor
    Hydra.ready(async _ => {
        if (!Utils.query('editMode') &&
            !(Hydra.LOCAL && window.Platform && window.Platform.isDreamPlatform && Utils.query('uil')) &&
            (!Hydra.LOCAL || Device.mobile || window._BUILT_ || !(Utils.query('uil') || Device.detect('hydra')))) return doNotLoad();
        init();
        _this.loaded = true;
    });

    function doNotLoad() {
        if (Hydra.LOCAL && Utils.query('remoteUIL')) _this.sidebar = _this.global = new UILPanel('null');
    }

    function init() {
        initContainer();
        initStyle();
        initSidebar();
        initGraph();
    }

    function initContainer() {
        $el = $('UIL');
        $el.css({position:'fixed', contain:'strict'}).size('100%', '100%').mouseEnabled(false);
        document.body.insertAdjacentElement('beforeend', $el.div);
        $el.setZ(100000);
    }

    function initStyle() {
         let initial = `
            .UIL ::-webkit-scrollbar { width:2px; }
            .UIL ::-webkit-scrollbar-track { background:#161616; }
            .UIL ::-webkit-scrollbar-thumb { background:#37A1EF; }
        `;
        let style = document.head.appendChild(document.createElement('style'));
        style.type = `text/css`;
        style.id = `uil-style`;
        style.appendChild(document.createTextNode(initial));
        _style = style;
    }

    function initGraph() {
        if (!_this.sidebar) return;

        let parent = _ui.sidebar.element.div;
        parent.insertBefore(UILGraph.instance().element.div, parent.firstChild);

    }

    function initSidebar() {
        _this.add(new UILPanel('sidebar'));
        _this.add(new UILPanel('global', {
            side: 'left'
        }));
    }

    //*** Event handlers

    //*** Public methods

    this.ready = function() {
        return _this.wait(_this, 'loaded');
    }

    /**
     * Add a new panel.
     * @param {(UILControl|UILFolder)} panel
     */
    this.add = function(panel) {
        _ui[panel.id] = panel;
        _this[panel.id] = panel;
        $el.add(panel);
        return _this;
    }

    /**
     * Remove panel.
     * @param {(UILControl|UILFolder)} id
     */
    this.remove = function(id) {
        let $panel = _ui[id];
        $panel.eliminate && $panel.eliminate();
        $panel.destroy();
        delete _ui[id];
        delete _this[id];
        return _this;
    }

    /**
     * Get a nested child by searching all UI panels requrisvely.
     * Find a control no matter where it's added.
     * @param {String} id ID of child.
     * @returns {[(UILControl|UILFolder)]} array of matching children.
     */
    this.find = function(id) {
        return Object.values(_ui).reduce((acc, el) => acc.concat(el.find(id)), []);
    }

    /**
     * Make child of ID sortable.
     * @param {String} id ID of child.
     * @param {Boolean} enable turn sorting on/off.
     * @returns {Object} this.
     */
    this.enableSorting = function(id, enable) {
        let el = _this.find(id)[0];
        el && el.enableSorting && el.enableSorting(enable);
        return _this;
    }

    /**
     * Append Style to UIL style tag.
     * @param {(UILControl|UILFolder)} control Element you're styling.
     * @param {String} style Style as CSS String.
     */
    this.addCSS = function(control, style) {
        if (control.styled) return;
        let node = document.createTextNode(style);
        if ( _style ) _style.appendChild(node);
        control.styled = true;
        return _this;
    }

    this.REORDER = `uil_reorder`;

}, 'static');
Class(function CameraUIL() {
    const _this = this;

    this.UPDATE = 'camera_uil_update';

    //*** Public methods
    this.add = function(light, group) {
        return new CameraUILConfig(light, group === null ? null : group || UIL.global);
    }
}, 'static');
Class(function CameraUILConfig(_camera, _uil) {
    const _this = this;

    if (!_camera.prefix) throw 'camera.prefix required when using MeshUIL';

    var prefix = 'CAMERA_'+_camera.prefix;
    var _group = _uil ? createFolder() : null;
    var _dynamicFOVCallback = null;

    //*** Constructor
    (function () {
        if (_camera.position) initVec('position');
        if (_camera.group) {
            _camera.groupPos = _camera.group.position;
            initVec('groupPos');
            initRotation();
        }
        initFOV('fov');
        if (_camera.moveXY) {
            initVec('moveXY');
            initVec('lookAt');
            initNumber('lerpSpeed');
            initNumber('lerpSpeed2');
            initNumber('deltaRotate');
            initNumber('deltaLerp');
            initNumber('wobbleSpeed');
            initNumber('wobbleStrength');
            initNumber('wobbleZ');
        }
        initDynamicFOV('dynamicFOV');
        if ( _group ) addListeners();
    })();

    function createFolder() {
        if (!UIL.sidebar) return null;
        let folder = new UILFolder(prefix, {label: _camera.prefix, closed:true});
        _uil.add(folder);
        return folder;
    }

    function initFOV(key) {
        let initValue = UILStorage.get(`${prefix}${key}`) || _camera.camera.fov || 9999;
        if (_group) {
            let number = new UILControlNumber(`${prefix}${key}`, {label: key, value: initValue, step: 0.05});
            number.onFinishChange(e => {
                if (_group) Events.emitter._fireEvent(CameraUIL.UPDATE, {prefix, key, val: e, fov: true, group: _this});
                _camera.setFOV(e);
                UILStorage.set(`${prefix}${key}`, e);
            });
            _group.add(number);
        }

        defer(_ => {
            _camera.setFOV(initValue);
        });
    }

    function initVec(key) {
        let initValue = UILStorage.get(`${prefix}${key}`) || _camera[key].toArray();
        if (_group) {
            let vector = new UILControlVector(`${prefix}${key}`, {label: key, value: initValue, step: 0.05});
            vector.onChange(e => {
                if (_group) Events.emitter._fireEvent(CameraUIL.UPDATE, {prefix, key, val: e, vec: true, group: _this});
                _camera[key].fromArray(e);
            });
            vector.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
            _group.add(vector);
        }

        _camera[key].fromArray(initValue);
    }

    function initNumber(key) {
        let initValue = UILStorage.get(`${prefix}${key}`) || (_camera[key] === undefined ? 9999 : _camera[key]);
        if (_group) {
            let number = new UILControlNumber(`${prefix}${key}`, {label: key, value: initValue, step: 0.05});
            number.onChange(e => {
                _camera[key] = e;
                if (_group) Events.emitter._fireEvent(CameraUIL.UPDATE, {prefix, key, val: e, number: true, group: _this});
            });
            number.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
            _group.add(number);
        }

        _camera[key] = initValue;
    }

    function initRotation() {
        let key = 'rotation';
        let toRadians = array => {
            if (!array) return [0, 0, 0];
            array.length = 3;
            return array.map(x => Math.radians(x));
        };

        let toDegrees = array => {
            if (!array) return [0, 0, 0];
            array.length = 3;
            return array.map(x => Math.degrees(x));
        };

        let initValue = toRadians(UILStorage.get(`${prefix}${key}`));

        if (_group) {
            let vector = new UILControlVector(`${prefix}${key}`, {label: key, value: toDegrees(initValue)});
            vector.onChange(e => {
                if (_group) Events.emitter._fireEvent(CameraUIL.UPDATE, {prefix, key, val: toRadians(e), rotation: true, group: _this});
                _camera.group[key].fromArray(toRadians(e));
            });
            vector.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
            _group.add(vector);
        }

        _camera.group[key].fromArray(initValue);
    }

    function initDynamicFOV(key) {
        let defaultCode = ``;
        let code = UILStorage.get(`${prefix}${key}Code`) || defaultCode;

        let evalCode = value => {
            let method = value.includes('return') ?
                `(function(){ return function getFOV() { ${value}}})()`:
                `(function(){ return function getFOV() { return ${value}}})()`;
            _camera._getDynamicFOV = eval(method);
        }

        let editCode = _ => {
            let editor = new UILExternalEditor( `${prefix}${key}`, 400, 900);
            editor.setCode( code, 'c' );
            editor.onSave = value => {
                UILStorage.set(`${prefix}${key}Code`, value );
                evalCode( value );
                code = value;
                _camera.dynamicFOV();
            }
        }

        let btn = new UILControlButton( 'btn', {
            actions: [{ title: 'Dynamic FOV', callback: editCode }],
            hideLabel: true
        });

        if ( _group ) _group.add( btn );
        defer( _ => {
            evalCode( code );
            _camera.dynamicFOV = _ => {
                let fov = _camera._getDynamicFOV?.() || _camera.camera.fov;
                if ( isNaN( fov )) return console.warn(`${prefix} Dynamic FOV requires a float value`);
                _camera.setFOV( fov );
            };
            _camera.onResize( _ => _camera.dynamicFOV());
        });

    }

    //*** Event handlers
    function addListeners() {
        Events.emitter._addEvent(CameraUIL.UPDATE, update, _this);
    }

    function update(e) {
        if (e.prefix != prefix || e.group == _this) return;
        if (e.fov) _camera.setFOV(e.val);
        if (e.number) _camera[e.key] = e.val;
        if (e.rotation) _camera.group[e.key].fromArray(e.val);
        if (e.vec) _camera[e.key].fromArray(e.val);
    }

    //*** Public methods
    this.setLabel = function(name) {
        if (_group) _group.setLabel(name);
    }
});
Class(function InputUIL() {

    this.UPDATE = 'inputUil_Update';

    this.create = function(name, group, decoupled) {
        return new InputUILConfig(name, group === null ? null : group || UIL.global, decoupled);
    }
}, 'static');
Class(function InputUILConfig(_name, _uil, _decoupled, _slim) {
    var _this = this;
    var _cache;

    const prefix = 'INPUT_'+_name;

    var _group = _uil ? createFolder() : null;
    var _fields = _uil ? {} : null;
    _this.group = _group;

    if (_uil) addListeners();

    function createFolder() {
        if (!UIL.sidebar) return null;
        let folder = new UILFolder(_name, {closed:true});
        if (!_decoupled) {
            _uil.add(folder);
            if (_uil == UIL.sidebar) folder.hide();
        }
        return folder;
    }

    function addListeners() {
        Events.emitter._addEvent(InputUIL.UPDATE, externalUpdate, _this);
    }

    function externalUpdate(e) {
        if (e.prefix != prefix || e.group == _this) return;
        UILStorage.set(`${prefix}_${e.key}`, e.value);
        _this.onUpdate && _this.onUpdate(e.key);
    }

    //*** Event handlers

    //*** Public methods
    this.get = function(key) {
        if (_cache && _cache[key] !== undefined) return _cache[key];

        let val = UILStorage.get(`${prefix}_${key}`);
        if (typeof val === 'boolean') return val;
        if (!val || val == '') return undefined;
        if (val === 'true') return true;
        if (val === 'false') return false;
        if (val.charAt && val.charAt(0) == '[') return JSON.parse(val);

        if (!UIL.global) {
            if (!_cache) _cache = {};
            if (!_cache[key]) _cache[key] = val;
        }

        return val;
    }

    this.getNumber = function(key) {
        return Number(this.get(key));
    }

    if (_slim) return;

    this.add = function(key, initValue, uil = window.UILControlText, options, params = {}) {
        if (!_group || initValue == 'hidden' || !UIL.sidebar) return this;

        let value = UILStorage.get(`${prefix}_${key}`);
        if (value === 'true') value = true;
        if (value === 'false') value = false;
        if (uil == UILControlVector && typeof value === 'string') value = JSON.parse(value);

        if (value === undefined) value = initValue;
        if (typeof value === 'string' && uil == UILControlImage) value = JSON.parse(value);

        let change = (val, fromInit) => {
            val = typeof val === 'string' ? val : JSON.stringify(val);
            UILStorage.set(`${prefix}_${key}`, val);
            if (_this.onUpdate) _this.onUpdate(key, val);
            if (!fromInit) {
                Events.emitter._fireEvent(InputUIL.UPDATE, {prefix, key, value: val, group: _this});
            }

        };

        if ((typeof initValue === 'string' || typeof initValue === 'number' || uil == UILControlVector) && !UILStorage.get(`${prefix}_${key}`)) {
            change(initValue, true);
        }

        let opts = Utils.mergeObject(params, {label: key, value, options});
        if (uil == window.UILControlButton) opts = options;

        let config = new uil(`${prefix}_${key}`, opts);
        config.onFinishChange(change);
        if (uil == UILControlVector || uil == UILControlRange) config.onChange(change);
        _group.add(config);
        _fields[key] = config;

        return this;
    }

    this.addToggle = function(key, initValue) {
        if (!UIL.sidebar) return this;
        return this.add(key, initValue, UILControlCheckbox);
    }

    this.addSelect = function(key, options) {
        if (!UIL.sidebar) return this;
        return this.add(key, null, UILControlSelect, options);
    }

    this.addImage = function(key, options) {
        if (!UIL.sidebar) return this;
        return this.add(key, null, UILControlImage, null, options);
    }

    this.addRange = function(key, initValue, options) {
        if (!UIL.sidebar) return this;
        return this.add(key, initValue, UILControlRange, null, options);
    }

    this.addNumber = function(key, initValue, step) {
        if (!UIL.sidebar) return this;
        return this.add(key, initValue, UILControlNumber, null, {step});
    }

    this.addColor = function(key, initValue = new Color()) {
        if (!UIL.sidebar) return this;
        return this.add(key, initValue.getHexString(), UILControlColor);
    }

    this.addTextarea = function(key, initValue) {
        if (!UIL.sidebar) return this;
        return this.add(key, initValue, UILControlTextarea, null, {monospace: true, rows: 4});
    }

    this.addButton = function(key, options) {
        if (!UIL.sidebar) return this;
        return this.add(key, null, UILControlButton, options);
    }

    this.addVector = function(key, initValue, options) {
        if (!UIL.sidebar) return this;
        if (!options) options = {step: 0.05};
        return this.add(key, initValue, UILControlVector, null, options);
    }

    this.getImage = function(key) {
        let data = this.get(key);
        if (!data) return;
        return JSON.parse(data).src;
    }

    this.setValue = function(key, value) {
        UILStorage.set(`${prefix}_${key}`, value);
        if (_this.onUpdate) _this.onUpdate(key);

        if (_fields) {
            let field = _fields[key];
            if (field) {
                field.value = value;
                field.update && field.update();
            }
        }

        return this;
    }

    this.copyFrom = function(input, fields) {
        fields.forEach(key => {
            let val = input.get(key);
            if (val !== undefined) {
                if (typeof val !== 'string') val = JSON.stringify(val);
                _this.setValue(key, val);
            }
        });
    }

    this.setLabel = function(name) {
        if (_group) _group.setLabel(name);
    }

    this.getField = function(key) {
        if (_fields) return _fields[key];
    }
});
Class(function ListUIL() {
    Inherit(this, Component);
    const _this = this;
    var _panel;

    var _data = {};
    var _created = {};

    //*** Constructor
    (function () {

    })();

    //*** Event handlers

    function removePanel() {
        if ( !_panel || !_panel.destroy ) return;
        _this.events.unsub(_panel, Events.COMPLETE, removePanel);
        _panel = _panel.destroy();
    }

    //*** Public methods

    this.create = function ( id, version = 1, group ) {
        if (typeof version != 'number') {
            group = version;
            version = 1;
        }

        group = group === null ? null : group || UIL.global;

        let config = new ListUILConfig( id, version, UIL.global && !_created[id]);

        if (UIL.global) {
            if (!_created[id]) {
                _created[id] = config;
                if (group != null) config.appendUILGroup(group || UIL.global);
            }
        }

        return config;
    }

    this.openPanel = function( id, name, template  ) {
        removePanel();
        _panel = new ListUILEditor( id, name, template );
        _this.events.sub(_panel, Events.COMPLETE, removePanel);
        return _panel;
    }

    this.set = function () {

    }

    this.get = function () {

    }

    this.getPanel = function() {
        return _panel;
    }

}, 'static');
Class(function ListUILConfig(_id, _version = 1, _store) {
    Inherit(this, Component);
    const _this = this;
    var _items, _folder;
    var _config, _template = {onSort: _ => {}, onAdd: _ => {}, onRemove: _ => {}};
    var _name = '';

    //*** Constructor
    (function () {
        if (_store) _items = [];
        initConfig();
    })();

    function initConfig() {
        _config = UILStorage.get( name());
        if (_config) {
            if (_config.version != _version) {
                updateConfig();
                UILStorage.clearMatch( name().split('_config')[0]);
            }
        } else {
            _config = {};
            updateConfig();
        }
    }

    function name() {
        return `LIST_${_id}_config`;
    }

    function updateConfig() {
        _config.version = _version;
        UILStorage.setWrite( name(), _config);
    }

    function edit() {
        let panel = ListUIL.openPanel( _id, _name, _this.template );
        _this.events.bubble( panel, Events.UPDATE );
        _this.events.fire(ListUIL.OPEN);
    }

    //*** Event handlers

    //*** Public methods

    this.add = function ( item ) {
        _items && _items.push( item );
        return item;
    }

    this.template = function ( config ) {
        if ( typeof config === 'function' ) _template = config;
        return _template;
    }

    this.appendUILGroup = function(uil) {
        let folder = new UILFolder('LIST_'+_id, {closed: true});
        let button = new UILControlButton('button', {actions: [
                {title: 'Edit List', callback: edit},
            ], hideLabel:true});

        folder.add(button);
        uil.add(folder);
        _folder = folder;
    }

    this.setLabel = function(name) {
        if (_folder) _folder.setLabel(name);
        _name = name;
    }

    this.onAdd = function(cb) {
        _template.onAdd = cb;
    }

    this.onRemove = function(cb) {
        _template.onRemove = cb;
    }

    this.onSort = function(cb) {
        _template.onSort = cb;
    }

    this.internalAddItems = function(count) {
        if (!count) return;

        let array = [];
        for (let i = 0; i < count; i++) {
            let id = `${_id}_${Utils.timestamp()}`;
            array.push(id);
        }

        UILStorage.set(`${_id}_list_items`, JSON.stringify(array));
    }
}, _ => {
    ListUIL.OPEN = 'list_uil_open';
});
Class(function ListUILEditor( _id,_name, _template ) {
    Inherit(this, Component);
    const _this = this;
    const PANEL_CONFIG = { label: _name ? _name : 'List', width: '400px', height: 'auto', drag: true };
    var _gui, _static, _list, _add;
    var _tabs = [];
    var _items;
    var _index = 0;

    //*** Constructor
    (function () {
        initPanel();
        refresh();
    })();

    function initPanel() {
        _this.gui = _gui = new UILWindow( _id, PANEL_CONFIG );
        _this.gui.onClose = close;
        UIL.add(_gui);
    }

    function initList() {
        read();

        _list = new UILFolder( `${_id}_list`, { hideTitle: true });
        _list.enableSorting( _id );
        _gui.add(_list);

        for ( let id of _items ) {
            let view = new ListUILItem( id, _list, _template, _index++ );
            _this.events.sub( view, Events.UPDATE, reorder );
            _this.events.sub( view, Events.END, remove );
            _tabs.push( view );
        }
    }

    function initAdd() {
        initButton( 'Add Item', add );
    }

    function initButton( title, callback ) {
        let hideLabel = true;
        let actions = [{ title, callback }];
        _add = new UILControlButton( 'button', { actions, hideLabel });
        _gui.add(_add);
    }

    //*** Event handlers

    function add() {
        let id = `${_id}_${Utils.timestamp()}`;
        let view = new ListUILItem( id, _list, _template, _index++ );
        _this.events.sub( view, Events.UPDATE, reorder );
        _this.events.sub( view, Events.END, remove );
        _tabs.push( view );
        _items.push( id );
        write();
    }

    function reorder( e ) {
        let order = [];
        for ( let item of e.order ) order.push( item.split('_folder')[0] );
        _items = order;
        _template().onSort(_items);
        write();
        _this.events.fire(Events.UPDATE, { order });
    }

    function close() {
        _this.events.fire(Events.COMPLETE);
    }

    function remove( e ) {
        _items.remove( e.id );
        write();
        refresh();
    }
    
    function read() {
        let data = UILStorage.get(`${_id}_list_items`);
        if ( typeof data === 'undefined' ) data = '[]';
        _items = JSON.parse( data );
    }
    
    function write() {
        let data = JSON.stringify( _items );
        UILStorage.set(`${_id}_list_items`, data );
    }

    function refresh() {
        _index = 0;
        if ( _list && _list.destroy ) _list = _list.destroy();
        if ( _add && _add.destroy ) _add = _add.destroy();
        initList();
        initAdd();
    }

    //*** Public methods

    this.onDestroy = function() {
        _gui.destroy();
    }

    this.add = function() {
        add();
    }

});
Class(function ListUILItem( _id, _parent, _template, _index ) {
    Inherit(this, Component);
    const _this = this;
    var $this;
    var _folder;

    //*** Constructor
    (function () {
        initFolder();
        initTemplate();
        initUI();
    })();

    async function initFolder() {
        _folder = InputUIL.create( `${_id}_folder`, _parent );
        _folder.setLabel( 'Item' );
        _folder.group.draggable( true );
        _this.events.sub( _folder.group, UIL.REORDER, onReorder );
        _folder.listUILItem = _this;
    }

    function initTemplate() {
        let id = _id;
        let init = _template().onAdd;
        init( id, _folder, _index );
    }

    function initUI() {
        let title = 'Delete';
        let callback = onDelete;
        let actions = [{ title, callback }]
        let hideLabel = true;
        _folder.addButton( 'delete', { actions, hideLabel });
    }

    //*** Event handlers

    function onDelete() {
        if (!confirm('You sure you want to delete this?')) return;
        let id = _id;
        _template().onRemove(id);
        _this.events.fire( Events.END, { id });
    }

    function onReorder( e ) {
        _this.events.fire( Events.UPDATE, e );
    }

    //*** Public methods
    this.setLabel = function(label) {
        _folder.setLabel(label);
    }

    this.forceSort = function(index) {
        _folder.group.forceSort(index);
    }

    this.open = function() {
        _folder.group.open();
        _folder.group.openChildren();
    }

    this.close = function() {
        _folder.group.close();
    }
});
Class(function MeshUIL() {
    Inherit(this, Component);
    const _this = this;

    this.exists = {};

    this.UPDATE = 'mesh_uil_update';

    //*** Public methods
    this.add = function(mesh, group) {
        return new MeshUILConfig(mesh, group === null ? null : group || UIL.global);
    }
}, 'static');
Class(function MeshUILConfig(_mesh, _uil) {
    const _this = this;

    if (!_mesh.prefix) throw 'mesh.prefix required when using MeshUIL';

    var prefix = 'MESH_'+_mesh.prefix;
    var _group = _uil && !MeshUIL.exists[prefix] ? createFolder() : null;
    var _controls = _group ? {} : null;

    this.group = _group;

    //*** Constructor
    (function () {
        MeshUIL.exists[prefix] = true;
        initVec('position');
        initVec('scale');
        initRotation();
        if (_group) addListeners();
    })();

    function createFolder() {
        if (!UIL.sidebar) return null;
        let folder = new UILFolder(prefix, {label: _mesh.prefix, closed:true});
        _uil.add(folder);
        return folder;
    }

    function initVec(key) {
        let initValue = UILStorage.get(`${prefix}${key}`) || _mesh[key].toArray();
        if (_group) {
            let vector = new UILControlVector(`${prefix}${key}`, {label: key, value: initValue, step: 0.05});
            vector.onChange(e => {
                _mesh[key].fromArray(e);
                if (_group) Events.emitter._fireEvent(MeshUIL.UPDATE, {prefix, key, val: e, group: _this});
            });
            vector.onFinishChange(save);
            _group.add(vector);

            _controls[key] = vector;
        }

        _mesh[key].fromArray(initValue);
    }

    function initRotation() {
        let key = 'rotation';
        let toRadians = array => {
            if (!array) return [0, 0, 0];
            array.length = 3;
            return array.map(x => Math.radians(x));
        };

        let toDegrees = array => {
            if (!array) return [0, 0, 0];
            array.length = 3;
            return array.map(x => Math.degrees(x));
        };

        let initValue = toRadians(UILStorage.get(`${prefix}${key}`));

        if (_group) {
            let vector = new UILControlVector(`${prefix}${key}`, {label: key, value: toDegrees(initValue)});
            vector.onChange(e => {
                _mesh[key].fromArray(toRadians(e));
                if (_group) Events.emitter._fireEvent(MeshUIL.UPDATE, {prefix, key, val: toRadians(e), group: _this});
            });
            vector.onFinishChange(save);
            _group.add(vector);

            _controls[key] = vector;
        }

        _mesh[key].fromArray(initValue);
        let rotationEuler = new Euler().fromArray(initValue);
        _mesh.customRotation = new Quaternion().setFromEuler(rotationEuler);
    }

    function save() {
        for (let key in _controls) {
            let value = _controls[key].value;
            UILStorage.set(`${prefix}${key}`, value);
        }
    }

    //*** Event handlers
    function addListeners() {
        Events.emitter._addEvent(MeshUIL.UPDATE, update, _this);
    }

    function update(e) {
        if (e.prefix != prefix || e.group == _this) return;
        _mesh[e.key].fromArray(e.val);
    }

    //*** Public methods
    this.setLabel = function(name) {
        if (_group) _group.setLabel(name);
    }
});
Class(function ShaderUIL() {
    this.exists = {};
    this.UPDATE = 'shader_update';
    this.TEXTURE_UPDATE = 'shader_texture_update';
    this.SHADER_UPDATE = 'shader_shader_update';

    //*** Public methods
    this.add = function(shader, group) {
        return new ShaderUILConfig(shader.shader || shader, group === null ? null : group || UIL.global);
    }

    this.createOverride = function(prefix, obj, group, shaderOnly) {
        let uniforms = {};
        if (Array.isArray(obj)) {
            obj.forEach(o => {
                o = o.uniforms || o;
                for (let key in o) uniforms[key] = o[key];
            });
        } else {
            uniforms = obj.uniforms || obj;
        }
        let shader = Utils3D.getTestShader();
        for (let key in uniforms) shader.uniforms[key] = uniforms[key];
        shader.UILPrefix = prefix;
        if (shaderOnly === null) return shader;
        else return this.add(shader, group);
    }

    this.createDecorator = function(shader, prefix, obj, group) {
        let uniforms = {};
        for (let key in obj) {
            uniforms[key] = shader.uniforms[key];
        }

        let nShader = Utils3D.getTestShader();
        nShader.uniforms = uniforms;
        nShader.UILPrefix = prefix;
        return this.add(nShader, group);
    }

    this.createClone = function(prefix, obj) {
        let uniforms = obj.uniforms || obj;
        let shader = Utils3D.getTestShader();
        for (let key in uniforms) {
            let value = uniforms[key].value;
            let ignoreUIL = uniforms[key].ignoreUIL || value === null;
            if (!ignoreUIL && !!value.clone) value = value.clone();
            shader.uniforms[key] = {value, ignoreUIL};
        }
        shader.UILPrefix = prefix;
        return shader;
    }

    this.lerpShader = function(from, to, alpha) {
        from = from.uniforms || from;
        to = to.uniforms || to;

        for (let key in from) {
            let f = from[key];
            let t = to[key];
            if (!f || !t) continue;

            if (typeof t.value === 'number') {
                t.value = Math.lerp(f.value, t.value, alpha);
            } else if (t.value && t.value.lerp) {
                t.value.lerp(f.value, alpha);
            }
        }
    }
}, 'static');
Class(function ShaderUILConfig(_shader, _uil) {
    var _this = this;
    var _textures;

    const prefix = _shader.UILPrefix;

    var _group = _uil && !ShaderUIL.exists[prefix] ? createFolder() : null;

    this.group = _group;
    this.shader = _shader;

    //*** Constructor
    (function () {
        ShaderUIL.exists[_shader.UILPrefix] = true;
        initItems();
        if (_group) addListeners();
    })();

    function getName() {
        let split = _shader.UILPrefix.split('/');
        if (split.length > 2) return split[0] + '_' + split[2];
        let name = split[0];
        return name;
    }

    function createFolder() {
        if (!UIL.sidebar) return null;
        let label = getName();
        if (label.charAt(label.length-1) == '_') label = label.slice(0, -1);
        let folder = new UILFolder(prefix + label, {label, closed:true});
        _uil.add(folder);
        return folder;
    }

    function initItems() {
        for (var key in _shader.uniforms) {
            let obj = _shader.uniforms[key];
            if (!obj || obj.ignoreUIL) continue;

            if (obj.value instanceof Color) createColor(obj, key);
            if (typeof obj.value === 'number') createNumber(obj, key);
            if (obj.value === null || obj.value instanceof Texture) createTexture(obj, key);
            if (obj.value instanceof Vector2) createVector(obj, key);
            if (obj.value instanceof Vector3) createVector(obj, key);
            if (obj.value instanceof Vector4) createVector(obj, key);
        }
    }

    function createVector(obj, key) {
        let initValue = UILStorage.get(`${prefix}${key}`) || obj.value.toArray();
        if (_group) {
            let vector = new UILControlVector(`${prefix}${key}`, {label: key, value: initValue, step: 0.05});
            vector.onChange(val => {
                obj.value.fromArray(val);
                if (_shader.ubo) _shader.ubo.needsUpdate = true;
                Events.emitter._fireEvent(ShaderUIL.UPDATE, {prefix, key, val, group: _this, vector: true});
            });
            vector.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
            _group.add(vector);
        }

        obj.value.fromArray(initValue);
    }

    function createTexture(obj, key) {
        if (_group && !_textures) _textures = {};

        const getTexture = obj.getTexture || ShaderUIL.getTexture || Utils3D.getTexture;
        const set = _shader.parent && _shader.parent.setOverride ? _shader.parent.setOverride : _shader.set || _shader.setUniform;
        const get = _shader.get || _shader.getUniform;

        let prefix = _shader.UILPrefix + '_tx';
        let data = UILStorage.get(`${prefix}_${key}`);
        if (data) data = JSON.parse(data);
        let value = data ? data.src : null;

        let change = data => {
            let val = data.src;
            let cleanPath = val.includes('?') && !data.hotreload ? val.split('?')[0] : val;
            if (!!data.compressed) val += '-compressedKtx';

            if (_textures) _textures[cleanPath] = change;

            data.src = cleanPath;

            UILStorage.set(`${prefix}_${key}`, JSON.stringify(data));
            set(key, getTexture(val, {premultiplyAlpha: obj.premultiplyAlpha, scale: obj.scale}), _shader);
            if (_group) Events.emitter._fireEvent(ShaderUIL.UPDATE, {prefix: _shader.UILPrefix, key, val, texture: get(key, _shader), group: _this});
        };

        if (value && value.length) change(data);

        if (_group) {
            let img = new UILControlImage(prefix+key, {label: key, value: data});
            img.onFinishChange(change);
            _group.add(img);
        }
    }

    function createNumber(obj, key) {
        let initValue = UILStorage.get(`${prefix}${key}`);
        if (initValue === undefined) initValue = obj.value;

        if (_group) {
            let number = new UILControlNumber(`${prefix}${key}`, {label: key, value: initValue, step: 0.05});
            number.onChange(val => {
                if (_shader.ubo) _shader.ubo.needsUpdate = true;
                Events.emitter._fireEvent(ShaderUIL.UPDATE, {prefix, key, val, group: _this});
                obj.value = val;
            });
            number.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
            _group.add(number);
        }

        obj.value = initValue;
    }

    function createColor(obj, key) {
        let initValue = UILStorage.get(`${prefix}${key}`);
        if (_group) {
            let color = new UILControlColor(`${prefix}${key}`, {label: key, value: initValue});
            color.onChange(val => {
                obj.value.set(val);
                if (_shader.ubo) _shader.ubo.needsUpdate = true;
                if (_group) Events.emitter._fireEvent(ShaderUIL.UPDATE, {prefix, key, val, color: true, group: _this});
            });
            color.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
            _group.add(color);
        }

        if (initValue) obj.value.set(initValue);
    }

    //*** Event handlers
    function addListeners() {
        Events.emitter._addEvent(ShaderUIL.UPDATE, update, _this);
        Events.emitter._addEvent(ShaderUIL.TEXTURE_UPDATE, textureUpdate, _this);
    }

    function textureUpdate(e) {
        if (!_textures) return;
        let cleanPath = e.file.split('?')[0];
        for (let key in _textures) {
            let testKey = key.includes('?') ? key.split('?')[0] : key;
            if (cleanPath == testKey) {
                _textures[key]({src: e.file, hotreload: true});
            }
        }
    }

    function update(e) {
        if (e.prefix != _shader.UILPrefix || e.group == _this) return;
        if (e.color) {
            let val = e.val;
            let obj = _shader.uniforms[e.key];
            if (Array.isArray(val)) obj.value.setRGB(val[0], val[1], val[2]);
            else obj.value.set(val);
        } else if (e.texture) {
            if (e.texture != 'remote') _shader.set(e.key, e.texture);
        } else if (e.vector) {
            _shader.uniforms[e.key].value.fromArray(e.val);
        } else {
            _shader.uniforms[e.key].value = e.val;
        }
    }

    this.setLabel = function(name) {
        if (_group) _group.setLabel(name);
    }
});
Class(function ShadowUIL() {
    const _this = this;

    //*** Public methods
    this.add = function(light, group) {
        return new ShadowUILConfig(light, group === null ? null : group || UIL.global);
    }
}, 'static');
Class(function ShadowUILConfig(_light, _uil) {
    const _this = this;

    if (!_light.prefix) throw 'light.prefix required when using MeshUIL';

    var prefix = 'SHADOW_'+_light.prefix;
    var _group = _uil ? createFolder() : null;

    //*** Constructor
    (function () {
        _light.target = _light.shadow.target;
        initVec('position');
        initVec('target');
        initNumber('fov');
        initNumber('size');
        initNumber('area');
        initNumber('near');
        initNumber('far');
        initTick('static');
    })();

    function createFolder() {
        if (!UIL.sidebar) return null;
        let folder = new UILFolder(prefix, {label: _light.prefix, closed:true});
        _uil.add(folder);
        return folder;
    }

    function initNumber(key) {
        let initValue = UILStorage.get(`${prefix}${key}`) || _light.shadow[key];
        if (_group) {
            let number = new UILControlNumber(`${prefix}${key}`, {label: key, value: initValue, step: 0.05});
            number.onFinishChange(e => {
                _light.shadow[key] = e;
                UILStorage.set(`${prefix}${key}`, e);
            });
            _group.add(number);
        }

        _light.shadow[key] = initValue;
    }

    function initVec(key) {
        let initValue = UILStorage.get(`${prefix}${key}`) || _light[key].toArray();
        if (_group) {
            let vector = new UILControlVector(`${prefix}${key}`, {label: key, value: initValue, step: 0.05});
            vector.onChange(e => {
                _light[key].fromArray(e);
                if (key == 'target') _light.shadow.camera.lookAt(_light.target);
            });
            vector.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
            _group.add(vector);
        }

        _light[key].fromArray(initValue);
    }

    function initTick(key) {
        let initValue = UILStorage.get(`${prefix}${key}`);
        if (_group) {
            let tick = new UILControlCheckbox(`${prefix}${key}`, {label: key, value: initValue});
            tick.onFinishChange(e => {
                _light[key] = e;
                UILStorage.set(`${prefix}${key}`, e)
            });
            _group.add(tick);
        }

        _light[key] = initValue;
    }

    //*** Event handlers

    //*** Public methods
    this.setLabel = function(name) {
        if (_group) _group.setLabel(name);
    }
});
Class(function TimelineUIL() {
    Inherit(this, Component);
    const _this = this;
    var _panel;

    var _data = {};
    var _created = {};

    //*** Constructor
    (function () {

    })();

    //*** Event handlers

    function removePanel() {
        if ( !_panel || !_panel.destroy ) return;
        _this.events.unsub(_panel, Events.COMPLETE, removePanel);
        _panel = _panel.destroy();
    }

    //*** Public methods

    this.create = function ( id, version = 1, group ) {
        if (typeof version != 'number') {
            group = version;
            version = 1;
        }

        group = group === null ? null : group || UIL.global;

        let config = new TimelineUILConfig( id, version, UIL.global && !_created[id]);

        if (UIL.global) {
            if (!_created[id]) {
                _created[id] = config;
                if (group != null) config.appendUILGroup(group || UIL.global);
            }
        }

        return config;
    }

    this.openPanel = function( id, name, template  ) {
        removePanel();
        _panel = new TimelineUILEditor( id, name, template );
        _this.events.sub(_panel, Events.COMPLETE, removePanel);
        return _panel;
    }

    this.set = function () {

    }

    this.get = function () {

    }

}, 'static');
Class(function TimelineUILConfig(_id, _version = 1, _store) {
    Inherit(this, Component);
    const _this = this;
    var _items, _folder;
    var _config, _template = {onSort: _ => {}, onAdd: _ => {}, onRemove: _ => {}};
    var _name = '';

    this.model = new TimelineUILModel(name());

    //*** Constructor
    (function () {
        if (_store) _items = [];
        initConfig();
    })();

    function initConfig() {
        _config = UILStorage.get( name());
        if (_config) {
            if (_config.version != _version) {
                updateConfig();
                UILStorage.clearMatch( name().split('_config')[0]);
            }
        } else {
            _config = {};
            updateConfig();
        }
    }

    function name() {
        return `TL_${_id}_config`;
    }

    function updateConfig() {
        _config.version = _version;
        UILStorage.setWrite( name(), _config);
    }

    function edit() {
        let panel = TimelineUIL.openPanel( name(), _name, _this.template );
        _this.events.bubble( panel, Events.UPDATE );
        _this.events.fire(TimelineUIL.OPEN);
    }

    //*** Event handlers

    //*** Public methods

    this.add = function ( item ) {
        _items && _items.push( item );
        return item;
    }

    this.template = function ( config ) {
        if ( typeof config === 'function' ) _template = config;
        return _template;
    }

    this.appendUILGroup = function(uil) {
        let folder = new UILFolder('TL_'+_id, {closed: true});
        let button = new UILControlButton('button', {actions: [
                {title: 'Edit Timeline', callback: edit},
            ], hideLabel:true});

        folder.add(button);
        uil.add(folder);
        _folder = folder;
    }

    this.setLabel = function(name) {
        if (_folder) _folder.setLabel(name);
        _name = name;
    }

    this.onAdd = function(cb) {
        _template.onAdd = cb;
    }

    this.onRemove = function(cb) {
        _template.onRemove = cb;
    }

    this.onSort = function(cb) {
        _template.onSort = cb;
    }

    this.internalAddItems = function(count) {
        if (!count) return;

        let array = [];
        for (let i = 0; i < count; i++) {
            let id = `${_id}_${Utils.timestamp()}`;
            array.push(id);
        }

        UILStorage.set(`${_id}_list_items`, JSON.stringify(array));
    }
}, _ => {
    TimelineUIL.OPEN = 'list_uil_open';
});
Class(function TimelineUILEditor( _id, _name, _template ) {
    Inherit(this, Component);
    const _this = this;
    const PANEL_CONFIG = { label: 'Timeline Editor', width: '800px', height: 'auto', drag: true };
    var _gui, _static, _list, _add, _config;
    var _tabs = [];
    var _items;
    var _index = 0;

    //*** Constructor
    (function () {
        _this.config = _config = JSON.parse(UILStorage.get(`${_id}_config`) || '{}');
        initPanel();
        refresh();
    })();

    function initPanel() {
        _this.gui = _gui = new UILWindow( _id, PANEL_CONFIG );
        UIL.add(_gui);
    }

    function initList() {
        read();

        _list = new UILFolder( `${_id}_list`, { hideTitle: true });
        // if (!_config.lock) _list.enableSorting( _id );
        _gui.add(_list);

        for ( let id of _items ) {
            let view = _this.initClass(TimelineUILItem, id, _list, _template, _index++);
            _this.events.sub( view, Events.UPDATE, reorder );
            _this.events.sub( view, Events.END, remove );
            _tabs.push( view );
        }

        if (_config.rails) attachRails();
    }

    function attachRails() {
        _tabs.forEach((t, i) => {
            t.onUpdate = v => {
                _tabs.forEach((t2, j) =>{
                    if (t2 == t) return;
                    if (j < i && t.getValue() < t2.getValue()) {
                        t2.setValue(t.getValue());
                    }

                    if (j > i && t.getValue() > t2.getValue()) {
                        t2.setValue(t.getValue());
                    }
                });
            };
        });
    }

    function initAdd() {
        if (!_config.lock) {
            _add = initButton('Add Item', add);
            _add.element.css({width: '20%'});
        }

        let space = initButton('Space Evenly', spaceEvenly);
        space.element.css({width: '20%'});
    }

    function initButton( title, callback ) {
        let hideLabel = true;
        let actions = [{ title, callback }];
        let btn = new UILControlButton( 'button', { actions, hideLabel });
        _gui.add(btn);
        return btn;
    }

    //*** Event handlers
    function spaceEvenly() {
        _tabs.forEach((t, i) => {
            let perc = Math.range(i, 0, _tabs.length-1, 0, 1);
            t.setValue(perc);
        });
    }

    function add() {
        let id = `${_id}_${Utils.timestamp()}`;
        let view = new TimelineUILItem( id, _list, _template, _index++ );
        _this.events.sub( view, Events.UPDATE, reorder );
        _this.events.sub( view, Events.END, remove );
        _tabs.push( view );
        _items.push( id );
        write();
    }

    function reorder( e ) {
        let order = [];
        for ( let item of e.order ) order.push( item.split('_folder')[0] );
        _items = order;
        _template().onSort(_items);
        write();
        _this.events.fire(Events.UPDATE, { order });
    }

    function close() {
        _this.events.fire(Events.COMPLETE);
    }

    function remove( e ) {
        _items.remove( e.id );
        write();
        refresh();
    }

    function read() {
        let data = UILStorage.get(`${_id}_list_items`);
        if ( typeof data === 'undefined' ) data = '[]';
        _items = JSON.parse( data );
    }

    function write() {
        let data = JSON.stringify( _items );
        UILStorage.set(`${_id}_list_items`, data );
    }

    function refresh() {
        _index = 0;
        if ( _list && _list.destroy ) _list = _list.destroy();
        if ( _add && _add.destroy ) _add = _add.destroy();
        initList();
        initAdd();
    }

    //*** Public methods

    this.onDestroy = function() {
        _gui.destroy();
    }

});
Class(function TimelineUILItem( _id, _parent, _template, _index ) {
    Inherit(this, Component);
    const _this = this;
    var $this;
    var _folder;

    //*** Constructor
    (function () {
        initFolder();
        initTemplate();
        initUI();
    })();

    async function initFolder() {
        _folder = InputUIL.create( `${_id}_folder`, _parent );
        _folder.setLabel( 'Item' );
        if (!_this.parent || !_this.parent.config.lock) _folder.group.draggable( true );
        _this.events.sub( _folder.group, UIL.REORDER, onReorder );

        _folder.group.open();
    }

    function initTemplate() {
        let id = _id;
        let init = _template().onAdd;
        init( id, _folder, _index );
    }

    function initUI() {
        _folder.add('label', _this.parent && _this.parent.config.lock ? 'hidden' : undefined);
        _folder.addRange('keyframe');
        _folder.add('percent', 'hidden');

        _folder.getField('keyframe').force(Math.round(_folder.getNumber('percent') * 100) || 0);

        _folder.onUpdate = key => {
            if (key == 'keyframe') {
                let val = _folder.getNumber(key) / 100;
                _folder.setValue('percent', val);
                _this.onUpdate && _this.onUpdate(val);
            }
        };

        let label = _folder.get('label');
        if (label) _folder.setLabel(label);

        if (!_this.parent || !_this.parent.config.lock) {
            let title = 'Delete';
            let callback = onDelete;
            let actions = [{title, callback}]
            let hideLabel = true;
            let del = _folder.addButton('delete', {actions, hideLabel});

            let btn = _folder.getField('delete');
            if (btn) btn.$content.css({width: '20%'});
        }
    }

    //*** Event handlers

    function onDelete() {
        if (!confirm('You sure you want to delete this?')) return;
        let id = _id;
        _template().onRemove(id);
        _this.events.fire( Events.END, { id });
    }

    function onReorder( e ) {
        _this.events.fire( Events.UPDATE, e );
    }

    //*** Public methods
    this.setLabel = function(label) {
        _folder.setLabel(label);
    }

    this.getValue = function(value) {
        return _folder.getNumber('percent');
    }

    this.setValue = function(value) {
        _folder.setValue('percent', value);
        _folder.getField('keyframe').force(Math.round(value * 100) || 0);
    }
});
Class(function TimelineUILModel(_id) {
    const _this = this;
    var _items, _config;

    var _data = [];
    var _map = {};

    //*** Constructor
    (function () {
        initItems();
        initData();
    })();

    function initItems() {
        _config = JSON.parse(UILStorage.get(`${_id}_config`) || '{}');
        _items = JSON.parse(UILStorage.get(`${_id}_list_items`) || '[]');
    }

    function initData() {
        _items.forEach((item, i) => {
            let input = InputUIL.create(`${item}_folder`, null, null, !!UIL.global);

            let data = {};
            data.label = input.get('label') || 'Item';
            data.value = input.getNumber('percent') || 0;
            data.arbitrary = input.get('arbitrary');

            _data.push(data);
            _map[data.label] = data;

            if (UIL.global) {
                Render.start(_ => {
                    data.label = input.get('label') || 'Item';
                    data.value = input.getNumber('percent') || 0;
                }, 10);
            }
        });
    }

    //*** Event handlers

    //*** Public methods
    this.setState = function(array) {
        for (let i = 0; i < array.length; i++) {
            if (!_items[i]) _items.push(`${_id}_${Utils.timestamp()}`);
        }

        if (_items.length > array.length) _items = _items.slice(0, array.length);

        _items.forEach((item, i) => {
            let data = array[i];
            let input = InputUIL.create(`${item}_folder`, null);
            input.setValue('label', data.label);
            if (data.percent) input.setValue('percent', data.percent);
            if (data.arbitrary) input.setValue('percent', data.arbitrary);
        });

        UILStorage.set(`${_id}_list_items`, JSON.stringify(_items));
    }

    this.lock = function() {
        if (_config.lock) return this;
        _config.lock = true;
        if (UIL.global) UILStorage.set(`${_id}_config`, JSON.stringify(_config));
        return this;
    }

    this.rails = function() {
        if (_config.rails) return this;
        _config.rails = true;
        if (UIL.global) UILStorage.set(`${_id}_config`, JSON.stringify(_config));
        return this;
    }

    this.getData = function() {
        return _data;
    }

    this.get = function(key) {
        return _map[key];
    }
});
Class(function TweenUIL() {
    const _this = this;
    var _folders = {};
    var _activeFolder = 'Tweens';

    var _cache = {};

    function initFolder() {
        if (UIL.global) {
            let folder = new UILFolder(_activeFolder, { label: _activeFolder, closed: true });
            _folders[_activeFolder] = folder;
            UIL.global.add(folder);
        }
    }

    //*** Event handlers

    //*** Public methods
    this.create = function(name, config, group, silent) {
        if (typeof group === 'boolean') {
            silent = group;
            group = undefined;
        }

        let folderName = _activeFolder;
        if (typeof group === 'string') {
            folderName = group;
            group = null;
        }

        if (!_folders[folderName]) initFolder();
        if (!_cache[name]) _cache[name] = new TweenUILConfig(name, config, group || _folders[folderName]);
        if (!silent) _cache[name].play();
        return _cache[name];
    }

    this.setFolder = function(name) {
        _activeFolder = name;
    }
}, 'static');
Class(function TweenUILConfig(_name, _config, _group) {
    Inherit(this, Component);
    const _this = this;
    var _input, _layers, _promise, _exec, resolve, _objects;

    var _cache = {};

    //*** Constructor
    (async function() {
        if (UIL.global) _objects = [];

        _input = InputUIL.create(_name + '_tween', _group);
        _input.setLabel(_name);
        _input.addButton('edit', {
            label: 'Edit',
            actions: [
                { title: 'Edit Code', callback: editCode }
            ]
        });
        _input.addButton('replay', {
            label: 'Replay',
            actions: [
                { title: 'Replay', callback: replay }
            ]
        });
        _input.addButton('cache', {
            label: 'Cache Values',
            actions: [
                { title: 'Cache', callback: recache }
            ]
        });
        _input.add('code', 'hidden');
        await evaluate(_input.get('code') || '');
        _this.flag('ready', true);
    })();

    function editCode() {
        let editor = new UILExternalEditor(_name, 400, 900);
        let defaultStr = `//Keys: ${Object.keys(_config).join(', ')}`;
        if (Array.isArray(_config) || _config.loadedAllLayers) defaultStr = '';
        editor.setCode(_input.get('code') || defaultStr, 'c');
        editor.onSave = value => {
            _input.setValue('code', value);
            evaluate(_input.get('code'));
        };
        UIL.add(editor);
    }

    function replay() {
        for (let key in _cache) {
            let el = _cache[key];
            switch (el.type) {
                case 'hydra':
                    TweenManager._clearCSSTween(el.obj);
                    el.obj.css(el.css).transform(el.transform);
                    break;
                case 'mesh':
                    el.obj.position.copy(el.position);
                    el.obj.scale.copy(el.scale);
                    el.obj.quaternion.copy(el.quaternion);
                    TweenManager.clearTween(el.obj.position);
                    TweenManager.clearTween(el.obj.scale);
                    TweenManager.clearTween(el.obj.quaternion);
                    break;
                case 'camera':
                    el.obj.group.position.copy(el.position);
                    el.obj.group.scale.copy(el.scale);
                    el.obj.group.quaternion.copy(el.quaternion);
                    TweenManager.clearTween(el.obj.group.position);
                    TweenManager.clearTween(el.obj.group.scale);
                    TweenManager.clearTween(el.obj.group.quaternion);
                    break;
                case 'shader':
                    for (let key in el.uniforms) {
                        TweenManager.clearTween(el.obj.uniforms[key]);
                        if (typeof el.uniforms[key] === 'number') el.obj.set(key, el.uniforms[key]);
                        else {
                            TweenManager.clearTween(el.obj.uniforms[key].value);
                            el.obj.get(key).copy(el.uniforms[key]);
                        }
                    }
                    break;
                case 'glui':
                    TweenManager.clearTween(el.obj);
                    for (let key in el.values) {
                        el.obj[key] = el.values[key];
                    }
                    break;
            }
        }
        _this.play();
    }

    function cacheHydraObject(obj) {
        let transform = {};
        let css = {};
        transform.x = obj.x || 0;
        transform.y = obj.y || 0;
        transform.z = obj.z || 0;
        transform.scale = obj.scale || 1;
        if (typeof obj.scaleX !== 'undefined') transform.scaleX = obj.scaleX;
        if (typeof obj.scaleY !== 'undefined') transform.scaleY = obj.scaleY;
        transform.rotation = obj.rotation || 0;
        transform.rotationX = obj.rotationX || 0;
        transform.rotationY = obj.rotationY || 0;
        transform.rotationZ = obj.rotationZ || 0;

        css.opacity = obj.css('opacity') || 1;

        return { obj, transform, css, type: 'hydra' };
    }

    function cacheGLUI(obj) {
        let values = {};
        values.x = obj.x || 0;
        values.y = obj.y || 0;
        values.z = obj.z || 0;
        values.scale = obj.scale || 1;
        values.scaleX = obj.scaleX;
        values.scaleY = obj.scaleY;
        values.rotation = obj.rotation || 0;
        values.rotationX = obj.rotationX || 0;
        values.rotationY = obj.rotationY || 0;
        values.rotationZ = obj.rotationZ || 0;
        return {obj, values, type: 'glui'};
    }

    function cacheMesh(obj) {
        return {obj, position: obj.position.clone(), scale: obj.scale.clone(), quaternion: obj.quaternion.clone(), type: 'mesh'};
    }

    function cacheCamera(obj) {
        return {obj, position: obj.group.position.clone(), scale: obj.group.scale.clone(), quaternion: obj.group.quaternion.clone(), type: 'camera'};
    }

    function cacheShader(obj) {
        let uniforms = {};
        for (let key in obj.uniforms) {
            let uniform = obj.uniforms[key];
            if (uniform.value instanceof Vector2 || uniform.value instanceof Vector3 || uniform.value instanceof Vector4 ||
                uniform.value instanceof Quaternion || uniform.value instanceof Color) {
                uniforms[key] = uniform.value.clone();
            } else if (typeof uniform.value === 'number') {
                uniforms[key] = uniform.value;
            }
        }

        return {obj, uniforms, type: 'shader'};
    }

    function cache(obj, key, force) {
        if (!UIL.global || (_cache[key] && !force)) return;
        if (obj instanceof HydraObject) {
            _cache[key] = cacheHydraObject(obj);
        } else if (obj.setFOV) {
            _cache[key] = cacheCamera(obj);
        } else if (obj.position) {
            _cache[key] = cacheMesh(obj);
        } else if (obj instanceof Shader) {
            _cache[key] = cacheShader(obj);
        } else if (obj instanceof GLUIObject || obj instanceof GLUIText) {
            _cache[key] = cacheGLUI(obj);
        }
    }

    function recache() {
        _objects.forEach(object => {
            let {obj, key} = object;
            cache(obj, key, true);
        });
    }

    async function evaluate(code) {
        _layers = {};
        let single;
        if (_config.loadedAllLayers) {
            await _config.loadedAllLayers();
            _layers[_config.name] = _config;
            single = _config;
        } else if (Array.isArray(_config)) {
            _config.forEach(layout => {
                _layers[layer.name] = layout;
            });
            await Promise.all(_config.map(layout => layout.loadedAllLayers()));
        } else {
            let promises = [];
            for (let key in _config) {
                if (_config[key].loadedAllLayers) promises.push(_config[key].loadedAllLayers());
                _layers[key] = _config[key];
            }
            await Promise.all(promises);
        }

        let keys = Object.keys(_layers);
        while (code.includes('${')) {
            let matched = false;
            let match = code.match(/\${([^\}]*)}/);

            if (match[1].includes('.') && !single) {
                if (match[1].includes(keys)) {
                    let [key, name] = match[1].split('.');
                    if (_layers[key].loadedAllLayers) {
                        if (!_layers[key].exists(name)) throw `TweenUIL::${_name} has no layer ${match[1]}\n${code}`;
                    }

                    let split = match[1].split('.');
                    let lookupString = `_layers.${split[0]}.layers.${split[1]}`;
                    let lookupObj = _layers[split[0]].layers[split[1]];
                    if (!_exec && lookupObj.ready) await lookupObj.ready();
                    for (let i = 2; i < split.length; i++) {
                        if (split[i]) {
                            lookupString += '.' + split[i];
                            lookupObj = lookupObj[split[i]];
                            if (!_exec && typeof lookupObj.ready === 'function') await lookupObj.ready();
                        }
                    }

                    code = code.replace(match[0], lookupString);
                    if (!_exec) {
                        cache(lookupObj, match[1]);
                        _objects && _objects.push({obj: lookupObj, key: match[1]});
                    }
                    matched = true;
                } else {
                    throw `TweenUIL::${_name} has no top level parent ${match[1]}\n${code}`;
                }
            } else {
                if (single) {
                    let split = match[1].split('.');
                    if (!single.exists(split[0])) throw `TweenUIL::${_name} has no layer ${match[1]}\n${code}`;
                    let lookupString = `_layers.${single.name}.layers.${split[0]}`;
                    let lookupObj = _layers[single.name].layers[split[0]];
                    if (!_exec && lookupObj.ready) await lookupObj.ready();
                    for (let i = 1; i < split.length; i++) {
                        if (split[i]) {
                            lookupString += '.' + split[i];
                            lookupObj = lookupObj[split[i]];
                            if (!_exec && typeof lookupObj.ready === 'function') await lookupObj.ready();
                        }
                    }

                    code = code.replace(match[0], lookupString);
                    if (!_exec) {
                        cache(lookupObj, match[1]);
                        _objects && _objects.push({obj: lookupObj, key: match[1]});
                    }
                    matched = true;
                } else if (_layers[match[1]] != null || _layers[match[1]] != undefined) {
                    code = code.replace(match[0], `_layers.${match[1]}`);
                    if (!_exec) {
                        cache(_layers[match[1]], match[1]);
                        _objects && _objects.push({obj: _layers[match[1]], key: match[1]});
                    }
                    matched = true;
                }
            }

            if (!matched) {
                throw `TweenUIL::${_name} couldn't find object!\n${code}`;}

        }

        _exec = eval(`(function() { return function exec(e) { \n ${code} \n } })();`);
    }

    //*** Event handlers

    //*** Public methods
    this.play = async function() {
        await _this.wait('ready');
        _promise = Promise.create();
        resolve = _promise.resolve;
        _exec(_config.e);
        return _promise;
    }

    this.promise = async function() {
        await _this.wait('ready');
        return _promise;
    }

    this.setLabel = function(label) {
        if(_input) _input.setLabel(label);
    }
});
Class(function UILFile(_offline, _path) {
    Inherit(this, Component);
    const _this = this;

    this.load = async function() {
        let path = window.UIL_STATIC_PATH || 'assets/data/uil.json';
        try {
            let data = await get(path);
            return data;
        } catch(e) {
            return {};
        }
    }

    this.save = async function(sessionData, data) {
        Dev.writeFile(window.UIL_STATIC_PATH || 'assets/data/uil.json', data);
        if (_offline) {
            let partial = {};
            try {
                partial = await get('assets/data/uil-partial.json', data);
                for (let key in sessionData) {
                    partial[key] = sessionData[key];
                }
            } catch(e) {
                partial = sessionData;
            }
            Dev.writeFile('assets/data/uil-partial.json', partial);
            Storage.set('uil_update_partial', true);
        }
    }

});
Class(function UILStorage() {
    Inherit(this, Component);
    const _this = this;

    var _storeIds = [];
    var _data = {};
    var _dataSession = {};
    var _id = window.UIL_ID || 'default';
    window.UIL_ID = _id = _id.replaceAll(/[^a-zA-Z0-9 _-]/g, '');

    var _platform;

    var _fs, _keys;

    this.SAVE = 'uil_save';

    const OFFLINE_FIREBASE = Utils.query('offlineFB');

    Hydra.ready(async _ => {
        if (window.Platform && Platform.isDreamPlatform && Config.PLATFORM_CONFIG) initLocalCached();
        else if (!(Hydra.LOCAL && window.Platform && window.Platform.isPlatform)) init();
        if (!Utils.query('editMode') &&
            !(Hydra.LOCAL && window.Platform && window.Platform.isDreamPlatform && Utils.query('uil')) &&
            (!Hydra.LOCAL || Device.mobile || window._BUILT_ || !(Utils.query('uil') || Device.detect('hydra')))) return;
        __window.bind('keydown', e => {
            if ((e.ctrlKey || e.metaKey) && e.keyCode == 83) {
                e.preventDefault();
                write();
            }
        });
    });

    function clearOfflineData() {
        Storage.set('uil_update_partial', false);
        Dev.writeFile('assets/data/uil-partial.json', {});
    }

    async function init() {
        if (_fs) _fs.destroy();
        _fs = _this.initClass(uilFile() ? UILFile : UILRemote, OFFLINE_FIREBASE);
        _data[_id] = await _fs.load();
        _this.loaded = true;

        if (!OFFLINE_FIREBASE && Storage.get('uil_update_partial') && !uilFile()) {
            if (!confirm('Looks like you have UIL data captured offline, do you want to sync it to Firebase?')) return clearOfflineData();
            let data = await get('assets/data/uil-partial.json');
            for (let key in data) _this.set(key, data[key]);
            write(true, true);
            clearOfflineData();
        }
    }

    async function initLocalCached() {
        _fs = _this.initClass(UILFile);
        _data[_id] = await _fs.load();
        _this.loaded = true;
    }

    async function write(direct, silent) {
        let prevent = false;
        let e = {};
        e.prevent = _ => prevent = true;
        _this.events.fire(_this.SAVE, e);

        if (!direct) {
            if (e.wait) await e.wait();
            if (prevent) return;
        }

        _fs.save(_dataSession, _data[_id]);
        _dataSession = {};

        if (!silent) {
            __body.css({ display: 'none' });
            _this.delayedCall(() => {
                __body.css({ display: 'block' });
            }, 100);
        }
    }

    function uilFile() {
        if (Utils.query('editMode')) return false;
        if (!Hydra.LOCAL) return true;
        if (window.Config && Config.PLATFORM_CONFIG && Utils.query('uil')) return false;
        if (Device.mobile) return true;
        if (OFFLINE_FIREBASE) return true;
        if (window._BUILT_) return true;
        if (window.AURA) return true;
        if (window._UIL_FILE_) return true;
        if (!window._FIREBASE_UIL_ && !window.UIL_ID) return true;
        if (Device.detect('hydra')) return false;
        if (!Utils.query('uil')) return true;
        return false;
    }

    this.reload = function (id, path, persist) {
        _this.loaded = false;
        if (!_platform) _platform = _id; // if reloaded, then preserve original uil id as _platform;
        if (persist) _storeIds.push(id);
        _id = id;
        window.UIL_ID = id;
        window.UIL_STATIC_PATH = path;
        init();
    };

    this.set = function (key, value) {
        if (value === null) {
            delete _data[_id][key];
            delete _dataSession[key];
        } else {
            _data[_id][key] = value;
            _dataSession[key] = value;
        }
    };

    this.setWrite = function (key, value) {
        this.set(key, value);
        write(true);
    };

    this.clearMatch = function (string) {
        for (let key in _data[_id]) {
            if (key.includes(string)) delete _data[_id][key];
        }

        write(true);
    };

    this.write = function (silent) {
        write(true, silent);
    };

    this.get = function (key) {
        // load from id (child), otherwise try platform uil
        let val = _data[_id] && _data[_id][key];
        if (val === undefined && _platform) val = _data[_platform][key];
        if (val === undefined && _storeIds) {
            for (let i = 0; i < _storeIds.length; i++) {
                val = _data[_storeIds[i]][key];
            }
        }
        return val;
    };

    this.ready = function () {
        return _this.wait(_this, 'loaded');
    };

    this.getKeys = function () {
        if (!_keys) _keys = Object.keys(_data[_id]);
        return _keys;
    }

    this.hasData = function () {
        return !!_data[_id];
    }

    this.parse = function (key, hint) {
        let data = _data[_id][key];
        if (typeof data === 'undefined') return null;

        if (Array.isArray(data)) {
            if (hint instanceof Vector2) return { value: new Vector2().fromArray(data) };
            if (hint instanceof Vector3) return { value: new Vector3().fromArray(data) };
            if (hint instanceof Vector4) return { value: new Vector4().fromArray(data) };
        } else if (typeof data === 'string') {
            if (data.charAt(0) === '#') return { value: new Color(data) };
        }

        return { value: data };
    };
}, 'static');

/**
 * Control base class to inherit from.
 */
Class(function UILControl() {
    Inherit(this, Element);
    const _this = this;
    let $this;
    let $label, $content, $view;
    let _value;
    let _previous;
    let _label;
    let _opts;
    let _visible = true;

    let _onChange = () => {};
    let _onFinishChange = () => {};

    //*** Constructor
    (function() {
        initHTML();
        initLabel();
        initContent();
    })();

    function initHTML() {
        $this = _this.element;
        $this.size('100%', 'auto');
        $this.css({position:'relative', display:'inline-block', borderBottom:`1px solid #161616`, padding:`2px 0`, boxSizing:`border-box`});
        $this.attr('data-type', `UILControl`);
        $this.div._this = _this;
    }

    function initLabel() {
        $label = $this.create('label');
        $label.size('100px', 'auto').fontStyle('sans-serif', 12, `#9B9C9B`);
        $label.css({paddingLeft:4, paddingTop:2, boxSizing:`border-box`, verticalAlign:`top`, float:`left`});
        _this.$label = $label;
    }

    function initContent() {
        $content = $this.create('content');
        $content.size(`calc(100% - 100px)`, `auto`).css({float:'left'});
        _this.$content = $content;
    }
    
    function isEqual(a, b) {
        if (Array.isArray(a) || Array.isArray(b)) return a+`` === b+``;
        if (typeof a === `object` || typeof b === `object`) return JSON.stringify(a) === JSON.stringify(b);
        return a === b;
    }

    function clone(value) {
        if (Array.isArray(value)) return [...value];
        if (typeof value === `object`) return Object.assign({}, value);
        return value;
    }

    //*** Event handlers

    //*** Internal methods

    /**
     * Default init method to call from children.
     * @param {String} id Child id.
     * @param {Object} opts Child options.
     */
    this.init = function(id, opts={}) {
        _this.id = id;
        _opts = opts; 
        _this.setLabel(opts.label || id)
        _value = clone(opts.value); // get from local storage here
        _previous = clone(_value);
        $this.attr('data-id', id);
    }

    /**
     * Trigger the onFinishChange callback,
     * call this from children to tell parent that editing is done.
     * @param {Boolean} history Add action to undo/redo history.
     */
    this.finish = function(history=true) {
        _onFinishChange(_value);
        if (!isEqual(_value, _previous)) {
            if (history) UILHistory.set(_this, _previous);
            UILLocalStorage.set(_this.id, _value);
            _previous = clone(_value);
        }
    }

    /**
     * Force set value and trigger finish callback.
     * Used by Undo/Redo to programmatically set the value.
     * Overwrite if custom logic is needed.
     * @param {*} value New value
     */
    this.force = function(value) {
        _this.value = clone(value);
        _this.finish(false);
    }

    /**
     * Debounce utility function used in a few child classes.
     * @param {Function} callback called when function stops being called X ms.
     * @param {Number} [time=250] milliseconds to wait.
     */
    this.debounce = function (callback, time = 250) {
        let interval;
        return (...args) => {
            clearTimeout(interval);
            interval = setTimeout(() => {
                interval = null;
                callback(...args);
            }, time);
        };
    }

    //*** Public methods

    /**
     * Register a change callback.
     * @param {Function} cb Callback.
     * @returns {Object} this.
     */
    this.onChange = function(cb) {
        _onChange = cb;
        return _this;
    }

    /**
     * Register a complete callback.
     * @param {Function} cb Callback.
     * @returns {Object} this.
     */
    this.onFinishChange = function(cb) {
        _onFinishChange = cb;
        return _this;
    }

    /**
     * @type {*}
     */
    this.get('value', () => _value);
    this.set('value', value => {
        if (isEqual(value, _value)) return;
        _value = clone(value);
        _this.update && _this.update(_value);
        _onChange(_value);
    });

    /**
     * @type {HydraObject}
     */
    this.get('view', () => $view);
    this.set('view', view => {
        if ($view) $view.destroy();
        $view = view;
        $content.add($view);
    })
    
    /**
     * Hide control.
     * @returns {Object} this.
     */
    this.hide = function() {
        _visible = false;
        $this.css({display:'none'});
        return _this;
    }

    /**
     * Show control.
     * @returns {Object} this.
     */
    this.show = function() {
        _visible = true;
        $this.css({display:'inline-block'});
        return _this;
    }

    /**
     * Get control visibility state.
     * @returns {Boolean} visibility state.
     */
    this.isVisible = function() {
        return _visible;
    }

    /**
     * Redefine label.
     * @type {String}
     */
    this.setLabel = function(label) {
        _label = label;
        _this.label = label;
        $label.text(label);
        $label.attr('title', label);
    };

});
/**
 * Container for mutiple controls.
 * @param {String} _id unique ID.
 * @param {String} [_opts.label=id] label to display, defaults to id.
 * @param {Boolean} [_opts.closed=false] Inital open/close state.
 * @param {String} [_opts.maxHeight='none'] Max height before starting to scroll.
 * @param {Boolean} [_opts.hideTitle=false] Hide folder title and toggle functionality.
 * @param {String} [_opts.background=`#272727`] Background color.
 */
Class(function UILFolder(_id, _opts={drag:true}) {
    Inherit(this, Element);
    const _this = this;
    let $this;
    let $header, $container, $toggle, $drag, $title;
    let _children = {};
    let _open = !_opts.closed;
    let _visible = true;
    let _order = [];
    let _draggable = false;
    let _sortableChildren = false;
    let _headerDrag = false;
    var _hasClipboard = false;

    _this.id = _id;
    _this.label = `${_opts.label || _id}`;
    _this.level = -1;

    const RECURSIVE_CLOSE = true;

    //*** Constructor
    (function() {
        init();
        style();
        initHeader();
        initContainer();
        restoreFolderState();
    })();

    function init() {
        $this = _this.element;
        $this.size('100%', 'auto').bg(_opts.background || `#272727`);
        $this.css({position:'relative', border:`1px solid #161616`, boxSizing:`border-box`, maxHeight:_opts.maxHeight || 'none'});
        $this.attr('data-id', _id);
        $this.attr('data-type', `UILFolder`);
        $this.div._this = _this;
    }

    function style() {
        UIL.addCSS(UILFolder, `
            .UILFolder *:focus { outline: none; }
            .UILFolder input:focus { border-color:#37a1ef!important; }
            .UILFolder button:focus { border-color:#37a1ef!important; }
            .UILFolder .UILFolder .UILFolder .toggle {margin-left:8px; }
            .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:16px; }
            .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:24px; }
            .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:32px; }
            .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:40px; }
        `);
    }

    function initHeader() {
        if (_opts.hideTitle) return;
        $header = $this.create('title', 'a');
        $header.attr('tabindex', '0');
        $header.size('100%', 'auto').bg(`#272727`);
        $header.css({display:'block', padding:`4px 4px`, boxSizing:`border-box`, fontWeight:'bold', userSelect:'none', borderBottom:`1px solid #161616`});
        $header.fontStyle('sans-serif', 11, '#B1B1B1');
        $header.div.addEventListener('keydown', onKeydown, false);
        $header.div.addEventListener('click', onToggle, false);
        $header.div.addEventListener(`mousedown`, onMouseDown);
        $header.div.addEventListener('focus', onFocus, false);
        $header.div.addEventListener('blur', onBlur, false);
        $header.div.addEventListener('keydown', onKeyup, false);

        $toggle = $header.create('toggle');
        $toggle.text(_open ? '' : '').css({fontSize:8, display:'inline-block', verticalAlign:'middle'});

        $drag = $header.create('drag');
        $drag.text(``).css({position:`absolute`, right:7, top:3, display:'inline-block', pointerEvents:`none`});
        $drag.hide();

        $title = $header.create('title');
        $title.text(_this.label).css({display:'inline-block', marginLeft:4});
    }

    function initContainer() {
        $container = $this.create('container');
        $container.size('100%', '100%').css({display:`flex`, flexDirection:`column`, position:'relative', overflowY:'auto'});
        if (!_open) $container.css({display:'none'});
        _this.container = $container.div;
    }

    function addDragHandlers() {
        $this.div.addEventListener('dragstart', dragStart, false);
        $this.div.addEventListener('dragover', dragOver, false);
        $this.div.addEventListener('drop', drop, false);
    }

    function removeDragHandlers() {
        $this.div.removeEventListener('dragstart', dragStart, false);
        $this.div.removeEventListener('dragover', dragOver, false);
        $this.div.removeEventListener('drop', drop, false);
    }

    function matchItem(str, item) {
        return UILFuzzySearch.search(str, item.id.toLowerCase()) || (UILFuzzySearch.search(str, item.label.toLowerCase()));
    }

    function filter(str, match=false) {
        str = str.toLowerCase();
        let result = [];
        let haystack = Object.values(_children);
        for (let el of haystack) {
            if (el instanceof UILFolder) {
                let matches = el.filter(str, true);
                if (matches.length) {
                    result.concat(matches);
                    el.show();
                    // el.showChildren();
                    el.open();
                } else if (matchItem(str, el)) {
                    result.push(el);
                    el.show();
                    el.showChildren();
                    el.close();
                } else {
                    !el.getVisible().length ? el.hide() : el.show();
                }
            } else {
                if (matchItem(str, el)) {
                    result.push(el);
                    el.show();
                } else {
                    el.hide();
                }
            }
        }
        return result;
    }

    function filterSingle(str) {
        str = str.toLowerCase();
        let haystack = Object.values(_children);
        for (let el of haystack) {
            if (el instanceof UILFolder) {
                el.filterSingle(str);
                if (str == el.label.toLowerCase() || str == el.id.toLowerCase()) {
                    el.show();
                    el.showChildren();
                    el.open(true);
                } else {
                    !el.getVisible().length ? el.hide() : el.show();
                }
            } else {
                if (matchItem(str, el)) {
                    el.show();
                    if (el.open) el.open(true);
                } else {
                    el.hide();
                }
            }
        }
        // saveFolderState();
        return [];
    }

    function saveSort() {
        UILStorage.set(`UIL_${UIL.sortKey}_${_this.parent.id}_order`, JSON.stringify(_order));
    }

    function getSort() {
        let sort = UILStorage.get(`UIL_${UIL.sortKey}_${_id}_order`);
        if (sort) return JSON.parse(sort);
    }

    function restoreSort() {
        _order.forEach(id => {
            if (_children[id]) $container.add(_children[id]);
        });
    }

    //*** Event handlers

    function dragStart(e) {
        if (UILFolder.DragLock) return;
        if (!_headerDrag) {
            e.preventDefault();
            e.stopPropagation();
            return;
        }
        UILFolder.DragLock = _this.id;
        e.dataTransfer.setData(`text/plain`, _this.id);
        e.dataTransfer.effectAllowed = `move`;
        $this.css({opacity:0.5});
    }

    function dragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = `move`;
    }

    function drop(e) {
        if (!UILFolder.DragLock) return;

        // If dropped items is files, return
        // and don't prevent default (Needed for ImageUIL)
        if (e.dataTransfer.items) {
            for (var i = 0; i < e.dataTransfer.items.length; i++) {
                if (e.dataTransfer.items[i].kind === 'file') {
                    return;
                }
            }
        }

        e.preventDefault();
        _headerDrag = false;

        let el = e.currentTarget;
        let target = el._this;
        let dragging = _this.parent.get(UILFolder.DragLock); //_this.parent.get(e.dataTransfer.getData(`text/plain`));
        UILFolder.DragLock = null;

        // if now control or no parent on the control return
        if (!target || !target.parent || !dragging) return
        dragging.element.css({opacity:1});

        // Parent have "target" = sibling
        if (dragging.parent.get(target.id)) {
            e.stopPropagation();
            target.parent.container.insertBefore(dragging.element.div, target.element.div);
            _order = [...target.parent.container.childNodes].map(el => el._this.id);
            _this.events.fire(UIL.REORDER, {order:[..._order]});
            saveSort();
        }
    }

    function getUrlID() {
        let key = Global.PLAYGROUND || 'Global';
        return `${key}_folder_${_id}`;
    }

    function saveFolderState() {
        sessionStorage.setItem(getUrlID(), JSON.stringify({open:_open}));
    }

    function restoreFolderState() {
        let json = JSON.parse(sessionStorage.getItem(getUrlID()));
        if (json) {
            let state = json.open;
            state ? open() : close();
        }
    }

    function open(keepClosed = false) {
        _open = true;
        $container.css({ display: 'flex' });
        $toggle && $toggle.text('');
        if (RECURSIVE_CLOSE && keepClosed != true) forEachFolder(f => f.close());
        saveFolderState();
        _this.onOpen && _this.onOpen();
    }

    function close() {
        _open = false;
        $container.css({ display: 'none' });
        $toggle && $toggle.text('');
        saveFolderState();
    }

    function onToggle(e) {
        _open ? close() : open();
    }

    function onMouseDown(e) {
        _headerDrag = true;
        $header.div.addEventListener(`mouseup`, onMouseUp);
    }

    function onMouseUp(e) {
        _headerDrag = false;
        $header.div.removeEventListener(`mouseup`, onMouseUp);
    }

    function onKeydown(e) {
        if (e.which === 13) _open ? close() : open();
    }
    
    function onKeyup(e) {
        if (!_hasClipboard) return;
        if (e.key == 'c' && e.metaKey) onCopy();
        else if (e.key == 'v' && e.metaKey) onPaste();
    }

    function onFocus() {
        $this.css({border:`1px solid #37a1ef`});
        $this.div.classList.add(`active`);
        _hasClipboard = true;
    }

    function onBlur() {
        $this.css({border:`none`, border:`1px solid #161616`});
        $this.div.classList.remove(`active`);
        _hasClipboard = false;
    }

    function onCopy() {
        UILClipboard.copy(_children);
    }
    
    function onPaste() {
        UILClipboard.paste(_children);
    }

    function forEachFolder(cb) {
        Object.values(_children).forEach(el => {
            if (el instanceof UILFolder) {
                cb(el);
                el.forEachFolder(cb);
            }
        });
        return _this;
    }

    //*** Public methods

    /**
     * Register and add new child (UILControl or UILFolder).
     * @param {(UILControl|UILFolder)} child Instance to add.
     * @returns {Object} this.
     */
    this.add = function(child) {
        child.draggable && child.draggable(_sortableChildren);
        child.parent = _this;
        _children[child.id] = child;
        $container.add(child);
        return _this;
    }

    /**
     * Remove child (UILControl or UILFolder).
     * @param {String} x ID string or instance to remove.
     * @returns {Object} this.
     */
    this.remove = function(x) {
        let id = typeof x === 'string' ? x : x.id;
        let child = _children[id];
        if (!child) {
            for (let key in _children) {
                if (key.includes(x)) {
                    child = _children[key];
                    delete _children[key];
                    break;
                }
            }
        }

        child.eliminate && child.eliminate();
        child.destroy();
        if (_order) _order = _order.filter(child => child !== id);
        delete _children[id];
        return _this;
    }

    /**
     * Get a direct child by id.
     * @param {String} id ID of child.
     * @returns {(UILControl|UILFolder)} child.
     */
    this.get = function(id) {
        return _children[id];
    }

    /**
     * Get array of all direct children.
     * @returns {Array} children.
     */
    this.getAll = function() {
        return Object.values(_children);
    }

    /**
     * Get array of all direct children,
     * but only those that are currently visible.
     * @returns {Array} children.
     */
    this.getVisible = function() {
        return Object.values(_children).filter(x => x.isVisible());
    }

    /**
     * Get a nested child by searching requrisvely.
     * @param {String} id ID of child.
     * @returns {[(UILControl|UILFolder)]} array of children matching.
     */
    this.find = function(id) {
        if (id === _id) return _this;
        return Object.values(_children).reduce((acc, item) => {
            if (item.id === id) return acc.concat(item);
            if (item instanceof UILFolder) {
                return acc.concat(item.find(id));
            } else {
                return acc;
            }
        }, []);
    }

    /**
     * Filter children requrisvely. Show and hide
     * based on filter, and return array of matches.
     * @param {String} str Filter string.
     * @returns {Array} matches.
     */
    this.filter = function(str) {
        return filter(str);
    }

    /**
     * Like filter, but is an exact search (not fuzzy).
     * @param {String} str Filter string.
     */
    this.filterSingle = filterSingle;

    /**
     * Open folder.
     * @returns {Object} this.
     */
    this.open = function (keepClosed) {
        open(keepClosed);
        return _this;
    }

    /**
     * Close folder.
     * @returns {Object} this.
     */
    this.close = function() {
        close();
        return _this;
    }

    /**
     * Redefine label.
     * @returns {Object} this.
     */
    this.setLabel = function(label) {
        _this.label = `${label}`;
        $title.text(label);
        return _this;
    }

    /**
     * Hide folder.
     * @returns {Object} this.
     */
    this.hide = function() {
        _visible = false;
        $this.css({display:'none'});
        return _this;
    }

    /**
     * Show folder.
     * @returns {Object} this.
     */
    this.show = function() {
        _visible = true;
        $this.css({display:'block'});
        return _this;
    }

    /**
     * Show all children, recursively.
     * @returns {Object} this.
     */
    this.showChildren = function() {
        Object.values(_children).forEach(el => el instanceof UILFolder ? el.showChildren() : el.show());
        _this.show();
        return _this;
    }

    /**
     * Get folder toggle state.
     * @returns {Boolean} open state.
     */
    this.isOpen = function() {
        return _open;
    }

    /**
     * Get folder visibility state.
     * @returns {Boolean} visibility state.
     */
    this.isVisible = function() {
        return _visible;
    }

    /**
     * Utility function to iterate all sub folders recursively.
     * @param {Function} cb Callback for each folder.
     * @returns {Object} this.
     */
    this.forEachFolder = function(cb) {
        return forEachFolder(cb);
    }

    /**
     * Utility function to iterate all sub controls recursively.
     * @param {Function} cb Callback for each control.
     * @returns {Object} this.
     */
    this.forEachControl = function(cb) {
        Object.values(_children).forEach(el => {
            if (el instanceof UILFolder) {
                el.forEachControl(cb);
            } else {
                cb(el);
            }
        });
        return _this;
    }

    /**
     * Make folder sortable. Make all children draggable.
     * @param {String} key Key
     * @returns {Object} this.
     */
    this.enableSorting = function(key) {
        _sortableChildren = true;
        UIL.sortKey = key;

        Object.values(_children).forEach(el => {
            if (el instanceof UILFolder) el.draggable(true);
        });

        let order = getSort();
        if (order) {
            _order = order;
            restoreSort();
        }

        return _this;
    }

    /**
     * Make element draggale for when parent is sortable.
     * @param {Boolean} enable Enable/Disable drag.
     */
    this.draggable = function(enable) {
        _draggable = enable;
        $this.attr('draggable', enable);
        if (enable) {
            addDragHandlers();
            $drag && $drag.show();
        } else {
            removeDragHandlers();
            $drag && $drag.hide();
        }
    }

    /**
     * Copy UILFolder data to UILClipboard
     */
    this.toClipboard = function() {
        UILClipboard.copy(_children);
    };

    /**
     * Set UILFolder data from UILClipboard
     */
    this.fromClipboard = function() {
        UILClipboard.paste(_children);
    };

    /**
     * Call before destroy
     */
    this.eliminate = function() {
        if (!_opts.hideTitle) {
            $header.div.removeEventListener('keydown', onToggle, false);
            $header.div.removeEventListener('click', onToggle, false);
            $header.div.removeEventListener(`mousedown`, onMouseDown);
            $header.div.removeEventListener('focus', onFocus, false);
            $header.div.removeEventListener('blur', onBlur, false);
        }
        if (_draggable) removeDragHandlers();
    }

    this.forceSort = function(index) {
        _this.parent.container.insertBefore(_this.element.div, _this.parent.container.children[index]);
        _order = [..._this.parent.container.childNodes].map(el => el._this.id);
        _this.events.fire(UIL.REORDER, {order:[..._order]});
    }

    this.openChildren = function() {
        Object.values(_children).forEach(el => el instanceof UILFolder ? el.open() : null);
    }
});
/**
 * Create panels such as sidebars,
 * with search and filter functionality.
 * @param {String} _title Title used for panel.
 * @param {String} [_opts.width='300px'] Initial Width.
 * @param {String} [_opts.height='auto'] Initial height.
 * @param {String} [_opts.maxHeight='100%'] Max height. Defaults to 100% view height.
 * @param {String} [_opts.side='right'] Initial docking ['left' or 'right'].
 * @param {Boolean} [_opts.hide=false] Change opacity on mouse over/out.
 */
Class(function UILPanel(_title, _opts={}) {
    Inherit(this, Element);
    const _this = this;
    let $this;
    let $children;
    let $toolbar;
    let _folder;
    let _toolbar;
    let _hidden = false;

    _this.id = _title;

    //*** Constructor
    (function() {
        initHTML();
        initToolbar();
        initGroup();
        addHandlers();
    })();

    function initHTML() {
        $this = _this.element;
        $this.size(_opts.width || `300px`, _opts.height || `auto`).bg(`#161616`).mouseEnabled(true);
        _opts.side === 'left' ? $this.css({left:0}) : $this.css({right:0});
        $this.css({top:0, maxHeight:_opts.maxHeight || `100%`, position:'absolute', userSelect:'none', padding:4, overflowY:'auto', borderRadius:4});
        $this.hide();
    }

    function initToolbar() {
        _toolbar = _this.toolbar = _this.initClass(UILPanelToolbar);
    }

    function initGroup() {
        _folder = _this.initClass(UILFolder, _title, {hideTitle:true, drag:false, background:`#161616`});
        _this.folder = _folder;
    }

    function hide() {
        $this.invisible();
        _hidden = true;
    }

    function show() {
        $this.visible();
        _hidden = false;
    }

    //*** Event handlers

    function addHandlers() {
        document.addEventListener('keydown', onKeydown, false);
        if (_opts.hide) {
            $this.div.addEventListener('mouseover', undim, false);
            $this.div.addEventListener('mouseleave', dim, false);
        }
    }

    function onKeydown(e) {
        if (!e.ctrlKey && !e.metaKey) return;
        if (e.keyCode == 72 && e.shiftKey) {
			let active = `${document.activeElement.type}`;
			if ( active.includes([ 'textarea', 'input', 'number' ])) return;
            e.preventDefault();
            _hidden ? show() : hide();
        }
        if (e.keyCode == 37 && e.shiftKey) {
            e.preventDefault();
            $this.css({left:0, right:'auto'});
        }
        if (e.keyCode == 39 && e.shiftKey) {
            e.preventDefault();
            $this.css({left:'auto', right:0});
        }
        if (e.which == 67 && e.shiftKey) {
            e.preventDefault();
            _folder.forEachFolder(f => f.close());
        }
        if (e.which == 79 && e.shiftKey) {
            e.preventDefault();
            _folder.forEachFolder(f => f.open());
        }
    }

    function undim() {
        $this.css({ opacity: 1 });
    }

    function dim() {
        $this.css({ opacity: 0.3 });
    }

    //*** Public methods

    /**
     * Register and add new child (UILControl or UILFolder).
     * @param {(UILControl|UILFolder)} child Instance to add.
     * @returns {Object} this.
     */
    this.add = function(child) {
        $this.show();
        _folder.add(child);
        return _this;
    }

    /**
     * Remove child (UILControl or UILFolder).
     * @param {String} x ID string or instance to remove.
     * @returns {Object} this.
     */
    this.remove = function(x) {
        _folder.remove(x.id);
        return _this;
    }

    /**
     * Get a direct child by id.
     * @param {String} id ID of child.
     * @returns {(UILControl|UILFolder)} child.
     */
    this.get = function(id) {
        return _folder.get(id);
    }

    /**
     * Get a nested child by searching requrisvely.
     * @param {String} id ID of child.
     * @returns {(UILControl|UILFolder)} child.
     */
    this.find = function(id) {
        return _folder.find(id);
    }

    /**
     * Filter children requrisvely. Show and hide
     * based on filter, and return array of matches.
     * @param {String} str Filter string.
     * @returns {Array} matches.
     */
    this.filter = function(str) {
        return _folder.filter(str);
    }

    /**
     * Make panel sortable.
     * @param {String} key Sort key
     * @returns {Object} this.
     */
    this.enableSorting = function(key) {
        _folder.enableSorting && _folder.enableSorting(key);
        return _this;
    }

    /**
     * Call before destroy
     */
    this.eliminate = function() {
        _toolbar.eliminate();
        $this.div.removeEventListener('mouseover', undim, false);
        $this.div.removeEventListener('mouseleave', dim, false);
        document.removeEventListener('keydown', onKeydown, false);
    }

});

/**
 * Button input control
 * @param {Array|Object} actions Actions object[s].
 * @param {String} actions.title Action Title.
 * @param {Function} [actions.callback] Action Callback.
 * @param {String} [_opts.label=id] Text Label.
 * @param {Boolean} [_opts.hideLabel=false] Hide label.
 */
Class(function UILControlButton(_id, _opts={}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view;
    let _buttons = [];

    //*** Constructor
    (function() {
        init();
        initActions();
    })();

    function init() {
        _this.init(_id, _opts);
        if (_opts.hideLabel) {
            _this.$label.css({display:`none`});
            _this.$content.css({width:`100%`});
        }
    }

    function initActions() {
        $view = $('inputs');
        let config = [].concat(_opts.actions);
        _buttons = [].concat(_opts.actions).map(({title, callback}) => {
            let btn = $view.create(`btn btn-${title}`, `button`);
            btn.text(title).bg(`#1d1d1d`);
            btn.css({ width: `calc(100% / ${config.length || 1}`, border: `1px solid #2e2e2e`, color: `#37a1ef`, position:`relative`});
            btn.interact(e => hover(btn, e));
            btn.click(e => click(e, title, callback));
            return btn;
        });
       _this.view = $view;
    }

    //*** Event handlers

    function click(e, title, callback) {
        _this.value = title;
        callback && callback(title, e);
        _this.finish();
    }

    function hover(btn, e) {
        e.action === `over` ? btn.css({border:`1px solid #9b9c9b`}) : btn.css({border:`1px solid #2e2e2e`});
    }

    //*** Public methods
    this.setTitle = function(text) {
        _buttons.forEach(btn => {
            btn.text(text)
        });
    }
});
/**
 * Checkbox input control
 * @param {Boolean} [_opts.value] Initial value.
 * @param {String} [_opts.label=id] Text Label.
 */
Class(function UILControlCheckbox(_id, _opts={}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view, $label, $checkbox, $slider;
    let _buttons = [];
    let _checked;

    //*** Constructor
    (function() {
        init();
        initView();
        addHandlers();
    })();

    function init() {
        _opts.value = _opts.value || false;
        _this.init(_id, _opts);
    }

    function initView() {
        $view = $(`view`);

        $label = $view.create(`label`, `label`);
        $label.size(30, 15).css({position:`relative`, display:`inline-block`, borderRadius:15, border:`1px solid #2e2e2e`}).bg(_this.value ? `#37a1ef` : `#1d1d1d`);

        $checkbox = $label.create('checkbox', 'input');
        $checkbox.attr(`type`, `checkbox`);
        $checkbox.attr(`checked`, _this.value);
        $checkbox.css({opacity:0, width:`100%`, position:`absolute`});

        $slider = $label.create(`slider`);
        $slider.size(15, 15).css({borderRadius:15, position:`absolute`, right:_this.value ? 0 : `auto`, boxSizing:`border-box`}).bg(`#ffffff`);

       _this.view = $view;
    }

    function toggle() {
        $checkbox.attr(`checked`, _this.value);
        $slider.css({right:_this.value ? 0 : `auto`});
        $label.bg(_this.value ? `#37a1ef` : `#1d1d1d`);
    }

    //*** Event handlers

    function addHandlers() {
       $checkbox.div.addEventListener('focus', focus, false);
       $checkbox.div.addEventListener('blur', blur, false);
       $checkbox.div.addEventListener('click', click, false);
       $checkbox.div.addEventListener('keypress', click, false);
    }

    function click() {
        _this.value = !_this.value;
        toggle();
        _this.finish();
    }

    function focus() {
        $label.css({border:`1px solid #37a1ef`});
    }

    function blur() {
        $label.css({border:`1px solid #2e2e2e`});
    }

    //*** Public methods

    this.update = function() {
        toggle();
    }

    this.onDestroy = function() {
        $checkbox.div.removeEventListener('focus', focus, false);
        $checkbox.div.removeEventListener('blur', blur, false);
        $checkbox.div.removeEventListener('click', click, false);
        $checkbox.div.removeEventListener('keypress', click, false);
    }
});
/**
 * Color control
 * @param {String} [_opts.value] Initial hex value.
 * @param {String} [_opts.label=id] Text Label.
 */
Class(function UILControlColor(_id, _opts={}) {
    Inherit(this, UILControl);
    const _this = this;
    var $display;
    var _input;

    //*** Constructor
    (function() {
        init();
        initInput();
        addHandlers();
    })();

    function init() {
        _opts.value = _opts.value || `#ffffff`;
        _this.init(_id, _opts);
    }

    function initInput() {
        let $view = $('color');
        $view.css({position:'relative'}).css({padding:1});

        $display = $view.create('color');
        $display.size('100%','100%').bg(_this.value);
        $display.css({border:`1px solid #2E2E2E`, boxSizing:`border-box`});

        $display.hex = $display.create(`hex`);
        $display.hex.text(_this.value);
        $display.hex.css({color:_this.value, filter:`invert(100%)`, fontSize:12, fontFamily:`sans-serif`, padding:1});

        _this.view = $view;
    }

    //*** Event handlers

    function addHandlers() {
        $display.interact( null, onDisplayClick );
        finishChange = _this.debounce(finishChange, 250);
    }

    function onDisplayClick() {
        if ( _input ) {
            _this.events.unsub( _input, Events.UPDATE, onChange );
            _input = _input.destroy();
        }

        _input = _this.initClass( UILExternalColor, _opts.label || _id, _this.value );
        _this.events.sub( _input, Events.UPDATE, onChange );
    }

    function onChange({ value }) {
        _this.value = value;
        $display.bg(_this.value);
        $display.hex.css({color:_this.value}).text(_this.value);
        finishChange();
    }

    function finishChange() {
        _this.finish();
    };

    function focus() {
        $display.css({border:`1px solid #37a1ef`});
    }

    function blur() {
        $display.css({border:`1px solid #2E2E2E`});
    }

    //*** Animation

    //*** Public methods

    this.update = function() {
        $display.bg(_this.value);
        $display.hex.css({color:_this.value}).text(_this.value);
    }

    this.onDestroy = function() {

    }
});
/**
 * Image input control
 * @param {Object} [_opts.value] Initial value {src, relative, prefix, filename}
 * @param {String} [_opts.label=id] Text Label.
 * @param {String} [_opts.relative] Realtive path.
 * @param {String} [_opts.prefix="assets/images"] Prefix.
 */
Class(function UILControlFile(_id, _opts={value:{}}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view;
    let $picker;
    let $preview, $img, $copy, $filename, $input, $$copy;
    let _value;

    //*** Constructor
    (function() {
        init();
        initView();
        addHandlers();
    })();

    function init() {
        _opts.value = Object.assign({
            src:``,
            relative: _opts.relative || ``,
            prefix: _opts.prefix,
            filename:``,
        }, _opts.value);
        _value = Object.assign({}, _opts.value);
        _this.init(_id, _opts);
    }

    function initView() {
        $view = $(`view`);
        $view.css({position:`relative`, padding:5});

        $input = $view.create(`path`, `input`);
        $input.size('100%').bg(`#1D1D1D`);
        $input.css({boxSizing:'border-box', border:`1px solid #2E2E2E`, color:`#37A1EF`, marginBottom:5});
        if (_this.value.relative) $input.div.value = _this.value.relative;
        else $input.attr(`placeholder`, `Relative Path`);

        $preview = $view.create(`preview`);
        $preview.size(`100%`, 60);
        $preview.css({boxSizing:`border-box`, position:`relative`, display:`flex`, alignItems:`center`, justifyContent:`center`, overflow:`hidden`});

        $img = $preview.create(`img`);
        $img.size(`100%`);
        $img.css({position:`absolute`, top:0, right:0, bottom:0, left:0, backgroundSize:`cover`, backgroundRepeat:`no-repeat`, backgroundPosition:`center`, border:`1px dotted #2e2e2e`, boxSizing:`border-box` });

        $picker = $preview.create(`picker`, `input`);
        $picker.attr(`type`, `file`);
        $picker.css({opacity:0, position:`absolute`, top:0, right:0, bottom:0, left:0});

        $$copy = $preview.create(`copy`);
        $$copy.html(`Drag file here<br><small>or Click to Select</small>`);
        $$copy.fontStyle('sans-serif', 11, `#9B9C9B`).css({textAlign:`center`});

        _this.view = $view;
    }

    function getRelative() {
        if (_value.relative.includes(_value.prefix))
            return _value.relative.replace(`${_value.prefix}`, ``);
        return _value.relative;
    }

    function getSrc() {
        let p = _value.prefix ? _value.prefix+`/` : ``;
        let r = _value.relative ? _value.relative+`/` : ``;
        return `${p}${r}${_value.filename}`
    }

    function fileExists(url){
        return fetch(url).then(e => e.status != 404)
            .catch(e => console.warn(`UILControlImage image url validation failed`, e));
    }

    function makePreview(file) {
        let reader = new FileReader();
        reader.onload = e => $img.css({backgroundImage: `url(${e.target.result})`});
        reader.readAsDataURL(file);
    }

    //*** Event handlers

    function addHandlers() {
        $picker.div.addEventListener('change', change, false);
        $picker.div.addEventListener('focus', focus, false);
        $picker.div.addEventListener('blur', blur, false);
        $input.div.addEventListener(`change`, inputChange, false);
    }

    async function change(e) {
        let file = $picker.div.files[0];
        if (!file) return;
        _value.filename = file.name;
        _value.relative = getRelative();
        _value.src = getSrc();
        if (await fileExists(_value.src)) {
            _this.value = Object.assign({}, _value);
            $img.attr(`title`, _value.src);
            $$copy.text(_value.filename);
            _this.finish();
        } else {
            $picker.div.value = ``;
            console.warn(`UIL: Could not find file`, _value);
            alert(`"${_value.src}" not found!\nMake sure "relative path" is correct.`);
        }
    }

    function focus() {
        $img.css({border:`1px solid #37a1ef`});
    }

    function blur() {
        $img.css({border:`1px dotted #2e2e2e`});
    }

    function inputChange() {
        _value.relative = $input.div.value;
    }

    //*** Public methods

    this.force = function(value) {
        _value = Object.assign({}, value);
        $input.div.value = _value.relative;
        $img.attr(`title`, _value.src);
        $$copy.text(_value.filename);
    }

    this.onDestroy = function () {
        $picker.div.removeEventListener('change', change, false);
        $picker.div.removeEventListener('focus', focus, false);
        $picker.div.removeEventListener('blur', blur, false);
        $input.div.removeEventListener('change', inputChange, false);
    }
});
/**
 * Image input control
 * @param {Object} [_opts.value] Initial value {src, relative, prefix, filename}
 * @param {String} [_opts.label=id] Text Label.
 * @param {String} [_opts.relative] Realtive path.
 * @param {String} [_opts.prefix="assets/images"] Prefix.
 */
Class(function UILControlImage(_id, _opts={value:{}}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view;
    let $picker;
    let $preview, $img, $copy, $filename, $input, $check, $compress;
    let _value;

    //*** Constructor
    (function() {
        init();
        initView();
        addHandlers();
    })();

    function init() {
        _opts.value = Object.assign({
            src:``,
            relative: _opts.relative || ``,
            prefix: _opts.prefix || `assets/images`,
            filename:``,
        }, _opts.value);
        _value = Object.assign({}, _opts.value);
        _this.init(_id, _opts);
    }

    function initView() {
        $view = $(`view`);
        $view.css({position:`relative`, padding:5});

        $input = $view.create(`path`, `input`);
        $input.size('100%').bg(`#1D1D1D`);
        $input.css({boxSizing:'border-box', border:`1px solid #2E2E2E`, color:`#37A1EF`, marginBottom:5});
        if (_this.value.relative) $input.div.value = _this.value.relative;
        else $input.attr(`placeholder`, `Relative Path`);

        $compress = $view.create('compress');
        $compress.text('Compress').bg('#fff').css({top: 3, width: 70, height: 15, textAlign: 'center', borderRadius: 5, position: 'relative', 'float': 'left', paddingTop: 2}).fontStyle('sans-serif', 11, `#000`);

        $check = $view.create('#compressed', 'input');
        $check.attr('type', 'checkbox');
        $check.size(20, 20);
        $check.css({boxSizing:`border-box`, position:`relative`});
        $check.div.checked = !!_this.value.compressed;

        let $label = $view.create('compressed-label', 'label');
        $label.attr('for', 'compressed');
        $label.text('Use Compressed').fontStyle('sans-serif', 9, `#9B9C9B`).css({top: -6, position: 'relative'});

        $preview = $view.create(`preview`);
        $preview.size(`100%`, 60);
        $preview.css({boxSizing:`border-box`, position:`relative`, display:`flex`, alignItems:`center`, justifyContent:`center`, overflow:`hidden`});

        $img = $preview.create(`img`);
        $img.size(`100%`);
        $img.css({position:`absolute`, top:0, right:0, bottom:0, left:0, backgroundSize:`cover`, backgroundRepeat:`no-repeat`, backgroundPosition:`center`, border:`1px dotted #2e2e2e`, boxSizing:`border-box` });
        if (_this.value.src) $img.css({backgroundImage:`url('${Assets.getPath(_this.value.src)}')`});

        $picker = $preview.create(`picker`, `input`);
        $picker.attr(`type`, `file`);
        $picker.attr(`accept`, `image/*`);
        $picker.css({opacity:0, position:`absolute`, top:0, right:0, bottom:0, left:0});

        let copy = $preview.create(`copy`);
        copy.html(`Drag image here<br><small>or Click to Select</small>`);
        copy.fontStyle('sans-serif', 11, `#9B9C9B`).css({textAlign:`center`});

        _this.view = $view;
    }

    function getRelative() {
        if (_value.relative.includes(_value.prefix))
            return _value.relative.replace(`${_value.prefix}`, ``);
        return _value.relative;
    }

    function getSrc() {
        let p = _value.prefix ? _value.prefix+`/` : ``;
        let r = _value.relative ? _value.relative+`/` : ``;
        return `${p}${r}${_value.filename}`
    }

    function imageExists(url){
        url = Assets.getPath(url);
        return fetch(url).then(e => e.status != 404)
            .catch(e => console.warn(`UILControlImage image url validation failed`, e));
    }

    function makePreview(file) {
        let reader = new FileReader();
        reader.onload = e => $img.css({backgroundImage: `url(${e.target.result})`});
        reader.readAsDataURL(file);
    }

    //*** Event handlers

    function addHandlers() {
        $picker.div.addEventListener('change', change, false);
        $picker.div.addEventListener('focus', focus, false);
        $picker.div.addEventListener('blur', blur, false);
        $input.div.addEventListener(`change`, inputChange, false);
        $compress.div.onclick = compressClick;
        $check.div.onchange = checkChange;
    }

    async function compressClick() {
        if (!_value.src || _this.flag('compressPending')) return;
        _this.flag('compressPending', true);
        $compress.bg('#f4ee42').text('---');

        try {
            let data = await Dev.execUILScript('compressktx', {src: _value.src.split('?')[0]});
            if (data == 'Error') $compress.bg('#f44141').html('Failed');
            else $compress.bg('#46f441').html('Success');
        } catch(e) {
            $compress.bg('#f44141').html('Failed');
            console.error(e);
        }

        _this.flag('compressPending', false);
    }

    function checkChange() {
        _this.value.compressed = _value.compressed = !!$check.div.checked;
        _this.finish(false);
    }

    async function change(e) {
        let file = $picker.div.files[0];
        if (!file) return;
        _value.filename = file.name;
        _value.relative = getRelative();
        _value.src = getSrc();
        _value.compressed = !!$check.div.checked;
        if (await imageExists(_value.src)) {
            _this.value = Object.assign({}, _value);
            $img.attr(`title`, _value.src);
            $img.css({backgroundImage:`url(${Assets.getPath(_value.src)})`});
            _this.finish();
        } else {
            $picker.div.value = ``;
            console.warn(`UIL: Could not find image`, _value);
            alert(`"${_value.src}" not found!\nMake sure "relative path" is correct.`);
        }
    }

    function focus() {
        $img.css({border:`1px solid #37a1ef`});
    }

    function blur() {
        $img.css({border:`1px dotted #2e2e2e`});
    }

    function inputChange() {
        _value.relative = $input.div.value;
    }

    //*** Public methods

    this.force = function(value, isClipboard) {
        _value = Object.assign({}, value);
        if (isClipboard === true) _this.value = _value;
        $input.div.value = _value.relative;
        $img.attr(`title`, _value.src);
        $img.css({backgroundImage:`url('${Assets.getPath(_value.src)}')`});
        $check.div.checked = _value.compressed;
    }

    this.onDestroy = function () {
        $picker.div.removeEventListener('change', change, false);
        $picker.div.removeEventListener('focus', focus, false);
        $picker.div.removeEventListener('blur', blur, false);
        $input.div.removeEventListener('change', inputChange, false);
    }
});
/**
 * Number control
 * @param {Number} [_opts.value=0] Initial value.
 * @param {String} [_opts.label=id] Text Label.
 * @param {Number} [_opts.min=-Infinity] Minimum value.
 * @param {Number} [_opts.max=Infinity] Maximum value.
 * @param {Number} [_opts.step=1.0] Increase/decrease step amount.
 * @param {Number} [_opts.precision=3] Precision to display (does not change return value).
 */
Class(function UILControlNumber(_id, _opts={}) {
    Inherit(this, UILControl);
    const _this = this;
    let _input;

    //*** Constructor
    (function() {
        init()
        initInput();
    })();

    function init() {
        _opts.value = _opts.value || 0;
        _this.init(_id, _opts);
    }

    function initInput() {
        _input = _this.initClass(UILInputNumber, Object.assign(_opts, {value:_this.value}));
        _input.onInput(v => _this.value = v);
        _input.onFinish(v => _this.finish());
        _this.view = _input.input;
    }

    //*** Event handlers

    //*** Public methods

    this.update = function(value) {
        _input.value = _this.value || 0;
    }
});
/**
 * Range input control
 * @param {Number} [_opts.value] Initial number value.
 * @param {String} [_opts.label=id] Text Label.
 * @param {Number} [_opts.min=0] Minimum value.
 * @param {Number} [_opts.max=100] Maximum value.
 * @param {Number} [_opts.step=1.0] Increase/decrease step amount.
 */
Class(function UILControlRange(_id, _opts={}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view, $slider;
    let _max = _opts.max || 100;
    let _min = _opts.min || 0;
    let _step = _opts.step || 1;

    //*** Constructor
    (function() {
        init();
        style();
        initView();
        addHandlers();
    })();

    function init() {
        _opts.value = _opts.value || 0;
        _this.init(_id, _opts);
    }

    function style() {
        UIL.addCSS(UILControlRange, `
            .UILControlRange input { -webkit-appearance:none; appearance:none; }
            .UILControlRange input::-webkit-slider-thumb { -webkit-appearance: none; }
            .UILControlRange input::-webkit-slider-thumb { 
                -webkit-appearance:none; appearance:none;
                width:15px; height:15px;
                background:#FFF;
                border-radius:15px;
            }
            .UILControlRange input::-moz-slider-thumb { 
                -webkit-appearance:none; appearance:none;
                width:15px; height:15px;
                background:#FFF;
                border-radius:15px;
            }
        `);
    }

    function initView() {
        $view = $(`view`);
        $slider = $view.create('range', 'input');
        $slider.attr(`type`, `range`);
        $slider.attr(`max`, _max);
        $slider.attr(`min`, _min);
        $slider.attr(`step`, _step);
        $slider.div.value = _this.value;
        $slider.css({width:`100%`, margin:0, padding:0, background:`#1d1d1d`, height:4, borderRadius:15, border:`1px solid #2e2e2e`, boxSizing:`border-box`});
       _this.view = $view;
    }

    //*** Event handlers

    function addHandlers() {
       $slider.div.addEventListener('change', change, false);
       $slider.div.addEventListener('input', input, false);
       $slider.div.addEventListener('focus', focus, false);
       $slider.div.addEventListener('blur', blur, false);
    }

    function change() {
        _this.finish();
    }

    function input(e) {
        _this.value = Number($slider.div.value);
    }

    function focus() {
        $slider.css({border:`1px solid #37a1ef`});
    }

    function blur() {
        $slider.css({border:`1px solid #2e2e2e`});
    }

    //*** Public methods

    this.force = function(value) {
        _this.value = value;
        $slider.div.value = value;
        _this.finish(false);
    }

    this.onDestroy = function() {
       $slider.div.removeEventListener('change', change, false);
       $slider.div.removeEventListener('input', input, false);
       $slider.div.removeEventListener('focus', focus, false);
       $slider.div.removeEventListener('blur', blur, false);
    }
});
/**
 * Select input control
 * @param {Array} _opts.options Options [{label, value}...]. label is optional.
 * @param {String} [_opts.value] Initial value.
 * @param {String} [_opts.label=id] Text Label.
 */
Class(function UILControlSelect(_id, _opts={}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view, $select;
    let _options;

    //*** Constructor
    (function() {
        init();
        style();
        initView();
        initOptions();
        addHandlers();
    })();

    function init() {
        if (!_opts.options) throw `UILControlSelect is missing select options`;
        _opts.value = _opts.value || _opts.options[0].value;
        _this.init(_id, _opts);
    }

    function style() {
        UIL.addCSS(UILControlSelect, `
            .UILControlSelect select { -webkit-appearance:none; appearance:none; }
        `);
    }

    function initView() {
        $view = $(`view`);
        $view.css({position:`relative`});

        $select = $view.create('dropdown', 'select');
        $select.css({width:`100%`, margin:0, padding:0, background:`#1d1d1d`, height:15, border:`1px solid #2e2e2e`, boxSizing:`border-box`, color:`#37a1ef`, borderRadius:0, height:17});
        $select.div.value = _this.value;

        let $arrow = $view.create(`arrow`);
        $arrow.text(``).css({color:`#37a1ef`, fontSize:6, position:`absolute`, right:8, top:7, pointerEvents:`none`});

       _this.view = $view;
    }

    function initOptions() {
        _options = _opts.options.map(({value, label}) => {
            let el = document.createElement(`option`);
            el.setAttribute(`value`, value);
            if (_this.value === value) el.setAttribute(`selected`, true);
            el.text = label || value;
            el.value = value;
            $select.add(el);
            return el;
        });
    }

    //*** Event handlers

    function addHandlers() {
       $select.div.addEventListener('change', change, false);
       $select.div.addEventListener('input', input, false);
       $select.div.addEventListener('focus', focus, false);
       $select.div.addEventListener('blur', blur, false);
    }

    function change() {
        _this.finish();
    }

    function input() {
        let i = $select.div.selectedIndex;
        _this.value = _options[i].value;
    }

    function focus() {
        $select.css({border:`1px solid #37a1ef`});
    }

    function blur() {
        $select.css({border:`1px solid #2e2e2e`});
    }

    //*** Public methods

    this.force = function(value) {
        $select.div.value = value;
        _this.value = value;
    }

    this.onDestroy = function () {
        $select.div.removeEventListener('change', change, false);
        $select.div.removeEventListener('input', input, false);
        $select.div.removeEventListener('focus', focus, false);
        $select.div.removeEventListener('blur', blur, false);
    }
});
/**
 * Text input control
 * @param {String} [_opts.value] Initial value.
 * @param {String} [_opts.label=id] Text Label.
 */
Class(function UILControlText(_id, _opts={}) {
    Inherit(this, UILControl);
    const _this = this;
    let $input;
    let _timeout;

    //*** Constructor
    (function() {
        _this.init(_id, _opts); // 1) call init on parent
        initInput();
        addHandlers();
    })();

    function initInput() {
        $input = $('input', 'input');
        $input.size('100%').bg(`#1D1D1D`);
        $input.css({boxSizing:'border-box', border:`1px solid #2E2E2E`, color:`#37A1EF`});

        if (_this.value) $input.div.value = _this.value || ``;
        _this.view = $input; // 3) define control view
    }

    //*** Event handlers

    function addHandlers() {
        $input.div.addEventListener('input', onChange, false);
        $input.div.addEventListener('change', onFinishChange, false);
    }

    function onChange(v) {
        clearTimeout(_timeout);
        _timeout = setTimeout(onFinishChange, 400);
        _this.value = $input.div.value;
    }

    function onFinishChange() {
        if (_timeout === null) return;
        clearTimeout(_timeout);
        _timeout = null;
        _this.finish();
    }

    //*** Animation

    //*** Public methods

    this.update = function() {
        $input.div.value = _this.value || ``;
    }

    this.onDestroy = function() {
        $input.div.removeEventListener('input', onChange, false);
        $input.div.removeEventListener('change', onBlur, false);
    }
});
/**
 * Textarea control
 * @param {String} [_opts.value] Initial value.
 * @param {String} [_opts.label=id] Text Label.
 * @param {Boolean} [_opts.monospace=false] Use a monospace font.
 * @param {String} [_opts.minWidth=0] Minimum width.
 * @param {Number} [_opts.max=Infinity] Max length.
 * @param {Number} [_opts.min=-Infinity] Min length.
 * @param {Number} [_opts.resize='vertical'] Resize option. Valid: `none`, `both`, `horizontal` and `vertical`.
 * @param {Number} [_opts.rows=2] Height.
 * @param {Boolean} [_opts.editor=false] Behave as a tiny editor.
 * @param {Boolean} [_opts.readonly=false] Indicates that the user cannot modify the value of the control.
 */
Class(function UILControlTextarea(_id, _opts={}) {
    Inherit(this, UILControl);
    const _this = this;
    let $input;
    let _timeout;

    //*** Constructor
    (function() {
        _this.init(_id, _opts);
        initInput();
        if (_opts.editor) {
            enableTab();
            //enableHighlight();
        }
        addHandlers();
    })();

    function initInput() {
        $input = $('input', 'textarea');
        $input.attr(`maxlength`, _opts.max || Infinity);
        $input.attr(`minlength`, _opts.min || -Infinity);
        $input.attr(`rows`, _opts.rows || 2);
        $input.attr(`readonly`, _opts.readonly || false);

        $input.size('100%').bg(`#1D1D1D`);
        $input.css({boxSizing:'border-box', resize:_opts.resize || `vertical`, minWidth:_opts.minWidth || 0, border:`1px solid #2E2E2E`, color:`#37A1EF`});
        if (_opts.monospace || _opts.editor) $input.css({fontFamily:`monospace`});

        if (_this.value) $input.div.value = _this.value || ``;
        _this.view = $input;
    }

    function enableTab() {
        $input.div.onkeydown = function(e) {
            if (e.keyCode === 9) {
                // get caret position/selection
                let val = this.value;
                let start = this.selectionStart;
                let end = this.selectionEnd;
    
                // set textarea value to: text before caret + tab + text after caret
                this.value = val.substring(0, start) + '\t' + val.substring(end);
    
                // put caret at right position again
                this.selectionStart = this.selectionEnd = start + 1;
    
                // prevent the focus lose
                e.preventDefault();
            }
        };
    }

    //*** Event handlers

    function addHandlers() {
        $input.div.addEventListener('input', onChange, false);
        $input.div.addEventListener('change', onFinishChange, false);
    }

    function onChange(v) {
        clearTimeout(_timeout);
        _timeout = setTimeout(onFinishChange, 400);
        _this.value = $input.div.value;
    }

    function onFinishChange() {
        if (_timeout === null) return;
        clearTimeout(_timeout);
        _timeout = null;
        _this.finish();
    }

    //*** Animation

    //*** Public methods

    this.update = function() {
        $input.div.value = _this.value || ``;
    }

    this.onDestroy = function() {
        $input.div.removeEventListener('input', onChange, false);
        $input.div.removeEventListener('change', onBlur, false);
    }
});
/**
 * Vector control
 * @param {Array} [_opts.value] Initial value. Default to array of zeros of opts.components length.
 * @param {String} [_opts.label=id] Text Label.
 * @param {Number} [_opts.components] Type of vector. Eg. 4, 3, 2 etc. for the number of components.
 * @param {Number} [_opts.min=-Infinity] Minimum value.
 * @param {Number} [_opts.max=Infinity] Maximum value.
 * @param {Number} [_opts.step=1.0] Increase/decrease step amount.
 * @param {Number} [_opts.precision=3] Precision to display (does not change return value).
 */
Class(function UILControlVector(_id, _opts={}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view;
    let _inputs = [];
    let _vector = [];
    let _length;

    //*** Constructor
    (function() {
        init();
        initInputs();
    })();

    function init() {
        if (_opts.value) {
            _length = _vector.length;
        } else if(_opts.components) {
            _opts.value = new Array(_opts.components).fill(0);
        } else {
            throw `UILControlVector: Cannot detect vector type. Define "options.components" count or init with a initial value`;
        }
        _length = _opts.value.length;
        _this.init(_id, _opts);
        _vector = [..._this.value];
    }

    function initInputs() {
        $view = $('inputs');
        for (let i = 0; i < _length; i++) {
            let input = _this.initClass(UILInputNumber, _opts);
            input.value = _this.value[i];
            input.onInput((v, m) => onInput(v, i, m));
            input.onFinish((v, m) => onFinish(v, i, m));
            input.input.css({display:`inline-block`, width:`calc(100% / ${_length})`});
            _inputs.push(input);
            $view.add(input.input);
        }
        _this.view = $view;
    }

    //*** Event handlers

    function onInput(value, index, master) {
        if (master) _vector = _vector.map(v => value);
        else _vector[index] = value;
        _this.value = [..._vector];
    }

    function onFinish(value, index, master) {
        //if (master) onInput(value, index, master);
        _this.finish();
    }

    //*** Public methods

    this.force = function(value) {
        _vector = [...value];
        _this.value = [..._vector];
        _inputs.forEach((input, index) => input.value = _this.value[index]);
        _this.finish(false);
    }

    this.update = function() {
        _inputs.forEach((input, index) => input.value = _this.value[index]);
    }
});
/**
 * Input form field with additional features.
 * @param {Number} [_opts.value=0] Initial value.
 * @param {String} [_opts.label=id] Text Label.
 * @param {Number} [_opts.min=-Infinity] Minimum value.
 * @param {Number} [_opts.max=Infinity] Maximum value.
 * @param {Number} [_opts.step=1.0] Increase/decrease step amount.
 * @param {Number} [_opts.precision=3] Precision to display (does not change return value).
 */
Class(function UILInputNumber(_opts={}) {
    Inherit(this, Component);
    const _this = this;
    let $input;
    let _timeout;
    let _editing = false;

    let _precision = _opts.precision || 3;
    let _step = _opts.step || 1.0;
    let _min = _opts.min || -Infinity;
    let _max = _opts.max || Infinity;
    let _value = _opts.value || 0;

    let _distance;
    let _onMouseDownValue;
    let _pointer = [0, 0];
    let _prevPointer = [0, 0];

    let _onInputCB = () => {};
    let _onFinishCB = () => {};

    //*** Constructor
    (function() {
        initInput();
        addHandlers();
    })();

    function initInput() {
        $input = $('input', 'input');
        $input.attr(`type`, `number`);
        $input.attr(`step`, _step);
        $input.size('100%').bg(`#1D1D1D`);
        $input.css({boxSizing:'border-box', border:`1px solid #2E2E2E`, color:`#37A1EF`, boxShadow:`none`});
        $input.div.value = parseFloat(_value).toFixed(_precision);
        _this.input = $input;
    }

    function setValue(value) {
        value = parseFloat(value) || 0;
        if (value < _min) value = _min;
        if (value > _max) value = _max;
        _value = value;
        _onInputCB(value, _this.master);
    }

    function setValueDrag(value) {
        if (value !== undefined || value !== $input.div.value) {
            setValue(value);
            $input.div.value = _value.toFixed(_precision);
        }
    }

    function addHandlers() {
        $input.div.addEventListener('mousedown', onMouseDown, false);
        $input.div.addEventListener('keyup', onKeyUp, false);
        $input.div.addEventListener('change', onFinishChange, false);
        $input.div.addEventListener('blur', onBlur, false);
        $input.div.addEventListener('input', onInput, false);
    }

    //*** Event handlers

    function onBlur() {
        onFinishChange();
        $input.div.value = parseFloat(_value).toFixed(_precision);
    }

    function onKeyUp(e) {
        if (e.keyCode === 13 && e.altKey) {
            _this.master = true;
            onInput();
        }
    }

    function onInput(e) {
        _timeout = setTimeout(onFinishChange, 400);
        _editing = true;
        setValue(parseFloat($input.div.value));
    }

    function onFinishChange() {
        if (!_editing) return;
        _editing = false;
        clearTimeout(_timeout);
        _onFinishCB(_value, _this.master);
        //$input.div.value = parseFloat(_value).toFixed(_precision);
        _this.master = false;
    }

    function onMouseDown(e) {
        if (e.button === 1 || (e.button === 0 && e.metaKey || e.ctrlKey)) {
            e.preventDefault();
            $input.css({ cursor: 'col-resize' });
            _distance = 0;
            _onMouseDownValue = _value;
            _prevPointer = [e.screenX, e.screenY];
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mouseup', onMouseUp, false);
        }
    }

    function onMouseMove(e) {
        clearTimeout(_timeout);
        _editing = true;

        let currentValue = _value;
        _pointer = [e.screenX, e.screenY];
        _distance += (_pointer[0] - _prevPointer[0]) - (_pointer[1] - _prevPointer[1]);

        let value = _onMouseDownValue + (_distance/(e.shiftKey ? 5 : 50)) * _step;
        value = Math.min(_max, Math.max(_min, value));

        _this.master = e.altKey;

        if (currentValue !== value) setValueDrag(value);

		_prevPointer = [e.screenX, e.screenY];
    }

    function onMouseUp(e) {
        onFinishChange();
        $input.css({cursor:''});
        document.removeEventListener('mousemove', onMouseMove, false);
		document.removeEventListener('mouseup', onMouseUp, false);
    }

    //*** Public methods

    this.set('value', value => {
        _value = value;
        if (!_editing) $input.div.value = parseFloat(value).toFixed(_precision);
    });
    this.get('value', () => _value);

    this.onInput = cb => _onInputCB = cb;
    this.onFinish = cb => _onFinishCB = cb;

    this.onDestroy = function() {
        $input.div.removeEventListener('mousedown', onMouseDown, false);
        $input.div.removeEventListener('change', onFinishChange, false);
        $input.div.removeEventListener('blur', onBlur, false);
        $input.div.removeEventListener('input', onInput, false);
    }
});
Class(function UILExternalColor( _title, _value ) {
    Inherit(this, Component);
    const _this = this;

    var _window;

    //*** Constructor
    (function () {
        _window = window.open(location.protocol + '//localhost/hydra/editor/color/index.html', `hydra_color_${_title}`, `width=480,height=220,left=200,top=100,location=no`);
        _window.window.onload = _ => {
            _window.window.initPicker(_title, _value, _this);
        };

        window.addEventListener( 'beforeunload', onReload );
    })();

    function onReload() {
        _this.onDestroy();
    }

    //*** Event handlers

    //*** Public methods

    this.update = function ( value ) {
        _this.events.fire( Events.UPDATE, { value });
    }

    this.onDestroy = function () {
        window.removeEventListener( 'beforeunload', onReload );
        _window && _window.window && _window.window.close();
    }

});
Class(function UILExternalEditor(_title, _height=500, _width=700) {
    Inherit(this, Component);
    const _this = this;
    var _window, _code, _language;

    //*** Constructor
    (function () {
        _window = window.open(location.protocol + '//localhost/hydra/editor/code/index.html', '_blank', `width=${_width},height=${_height},left=200,top=100`);
        _this.events.sub(Events.UNLOAD, _ => _window.close());
        _window.window.onload = _ => {
            _window.window.initEditor(_title, _code, _language, _this);
        };
    })();

    //*** Event handlers

    //*** Public methods
    this.setCode = function(code, language) {
        _code = code;
        _language = language;
    }

    this.saved = async function(code) {
        _this.onSave && _this.onSave(code);
        await defer();
        UILStorage.write();
    }
});
Class(function UILPanelToolbar() {
    Inherit(this, Element);
    const _this = this;
    let $this;
    let $filter;
    let _state = new Map();

    //*** Constructor
    (function() {
        initHTML();
        initFilter();
    })();

    function initHTML() {
        $this = _this.element;
        $this.size('100%', 'auto').bg(`#272727`);
        $this.css({padding:4, boxSizing:'border-box', marginBottom:4});
    }

    function initFilter() {
        $filter = $this.create('filter', 'input');
        $filter.div.addEventListener('input', onInput, false);
        $filter.div.addEventListener('keydown', onKeyPressed, false);
        $filter.div.addEventListener('focus', onFocus, false);
        $filter.div.addEventListener('blur', onBlur, false);

        $filter.size('100%', 'auto').bg(`#161616`);
        $filter.css({color:`#B1B1B1`, border:`1px solid #2e2e2e`, outline:`none`, padding:2, boxSizing:`border-box`});
    }

    function saveFolderState() {
       _this.parent.folder.forEachFolder(folder => {
            _state.set(folder, folder.isOpen());
        });
    }

    function restoreFolderState() {
       _this.parent.folder.forEachFolder(folder => {
            _state.get(folder) ? folder.open() : folder.close();
        });
        _state.clear();
    }

    //*** Event handlers

    function onInput(e) {
        if (!$filter.div.value.length) {
            restoreFolderState();
            return _this.parent.folder.showChildren();
        }
        _this.parent.folder.filter($filter.div.value);
    }

    function onFocus() {
        saveFolderState();
        $filter.css({border:`1px solid #37a1ef`});
    }

    function onBlur() {
        $filter.css({border:`1px solid #2e2e2e`});
    }

    function onKeyPressed(e) {
        if (e.keyCode === 27) {
            $filter.div.value = '';
            restoreFolderState();
            return _this.parent.folder.showChildren();
        }
    }

    //*** Animation

    //*** Public methods

    this.eliminate = function() {
        $filter.div.removeEventListener('input', onInput, false);
        $filter.div.removeEventListener('keydown', onKeyPressed, false);
        $filter.div.removeEventListener('focus', onFocus, false);
        $filter.div.removeEventListener('blur', onBlur, false);
    }

    this.filter = function(text) {
        $filter.div.value = text;
        onInput();
    }

    this.filterSingle = function(text) {
        $filter.div.value = text;
        _this.parent.folder.filterSingle($filter.div.value);
    }

    this.hideAll = function() {
        if (_this.flag('init')) return;
        _this.flag('init', true);
        this.filterSingle('xxxxxx');
    }
});
Class(function Video(_params) {
    Inherit(this, Component);
    const _this = this;
    let $video;
    let _video;
    let _ready = Promise.create();
    let _loaded = Promise.create();
    let _loadingState;
    let _handlers;
    let _initialPlay = true;

    (function() {
        initParam();
        init();
        addHandlers();
    })();

    function initParam() {
        let defaults = {
            muted: true,
            loop: false,
            autoplay: false,
            inline: true,
            controls: false,
            currentTime: 0,
            playback: 1,
            preload: false,
            width: 640,
            height: 360,
            events: []
        };
        _params = Object.assign(defaults, _params);
    }

    function init() {
        _video = document.createElement('video');
        _video.src = getSource(_params.src);
        _video.setAttribute('crossorigin', 'anonymous');
        _video.autoplay = _params.autoplay;
        _video.loop = _params.loop;
        _video.controls = _params.controls;
        _video.height = _params.height;
        _video.width = _params.width;
        _video.defaultMuted = _params.muted;
        _video.defaultPlaybackRate = _params.playback;
        _video.preload = _params.preload;
        _video.muted = _params.autoplay || _params.muted;
        _video.setAttribute('webkit-playsinline', _params.inline);
        _video.setAttribute('playsinline', _params.inline);
        _video.setAttribute('autoplay', _params.autoplay);
        _video.setAttribute('muted', _params.muted);
        if (_params.loop) _video.setAttribute('loop', _params.loop);

        _this.div = _video;
        $video = $(_video);

        if (_params.autoplay) return startPlayback();
        if (_params.preload) return startPreload();
    }

    function addHandlers() {
        _params.events.push('loadeddata');
        _handlers = { play, pause, ended, playing, progress, waiting, timeupdate, loadeddata, canplay };
        _params.events.forEach(ev => _video.addEventListener(ev, _handlers[ev], true));
    }

    function startPreload() {
        _loadingState = true;
        return _ready;
    }

    async function startPlayback() {
        if (_this.playing) return;
        _loadingState = false;
        await _ready;
        if (_this.playing) return;
        if (_initialPlay) {
            _initialPlay = false;
            _video.currentTime = _params.currentTime; // start from timecode given as param
        }
        _this.playing = true;
        _video.play();
    }

    //*** Utils

    function getSource(src = '') {
        if (!src.includes(['webm', 'mp4', 'ogv'])) src += '.' + Device.media.video;
        return src;
    }

    function removeListeners() {
        _params.events.forEach(ev => _video.removeEventListener(ev, _handlers[ev], true));
    }

    //*** Event Handlers

    function progress(e) {
        _this.events.fire(Video.PROGRESS, e);
    }

    function timeupdate(e) {
        _this.events.fire(Video.UPDATE, e);
    }

    function play(e) {
        // don't fire event if we trigger play() to init the load
        if (_loadingState) return _loadingState = false;
        _this.events.fire(Video.PLAY, e);
    }

    function pause(e) {
        _this.events.fire(Video.PAUSE, e);
    }

    function playing(e) {
        _this.events.fire(Video.PLAYING, e);
    }

    function ended(e) {
        _this.events.fire(Video.ENDED, e);
    }

    function waiting(e) {
        _this.events.fire(Video.WAITING, e);
    }

    function canplay(e) {
        loadeddata();
        _this.events.fire(Video.CANPLAY, e);
    }

    function loadeddata(e) {
        if (_video.readyState >= 2) {
            _ready.resolve();
        }
        if (_video.readyState >= 4) {
            _loaded.resolve();
        }
    }

    //*** Getter/Setters

    this.set('loop', bool => _video.loop = bool);
    this.get('loop', () => _video.loop);

    this.set('src', src => {
        if (src === _video.src) return;
        _video.src = getSource(src);
    });
    this.get('src', () => _video.currentSrc);

    this.set('volume', v => {
        _video.muted = v === 0;
        _video.volume = v;
    });
    this.get('volume', () => _video.volume);

    this.set('muted', bool => _video.muted = bool);
    this.get('muted', () => _video.muted);

    this.set('controls', bool => _video.controls = bool);
    this.get('controls', () => _video.controls);

    this.get('duration', () => _video.duration);
    this.get('ended', () => _video.ended);
    this.get('playback', () => _video.playbackRate);
    this.get('time', () => _video.currentTime);

    this.get('canRender', () => _video.readyState >= 2);
    this.get('canPlayThrough', () => _video.readyState >= 4);
    this.get('paused', () => _video.paused);

    this.get('element', () => $video);
    this.get('object', () => $video);
    this.get('video', () => _video);

    this.get('bufferedSeconds', _ => {
        if (_video.readyState < 2) return 0;
        return _video.buffered.end(0) - _video.buffered.start(0);
    });

    //*** Public Methods

    this.load = async function() {
        return startPreload();
    }

    this.play = async function() {
        return startPlayback();
    };

    this.pause = function() {
        _this.playing = false;
        _video.pause();
    };

    this.stop = function() {
        _this.playing = false;
        _video.pause();
        _this.seek(0);
    };

    this.seek = function(t) {
        if (_video.fastSeek) return _video.fastSeek(t);
        _video.currentTime = t;
    };

    this.seekExact = function(t) {
        _video.currentTime = t;
    }

    // As soon as media can play (You want this!)
    this.ready = function() {
        //return _this.wait(_this, 'readyEvent');
        return _ready;
    }

    // can be played through to the end without interruption
    this.loaded = function() {
        return _loaded;
    }

    this.onDestroy = function() {
        _this.stop();
        _video.src = '';
        removeListeners();
        _video = null;
    };

}, () => {
    Video.PLAY = 'hydra_video_play';
    Video.CANPLAY = 'hydra_video_can_play';
    Video.PAUSE = 'hydra_video_pause';
    Video.PROGRESS = 'hydra_video_progress';
    Video.UPDATE = 'hydra_video_update';
    Video.PLAYING = 'hydra_video_playing';
    Video.ENDED = 'hydra_video_ended';
    Video.WAITING = 'hydra_video_waiting';
});
Class(function VideoTexture(_path, {loop = true, preload = true, autoplay = true, muted = true, firstFrame = false, parseColor = false} = {}) {
    Inherit(this, Component);
    const _this = this;
    let _video, _hasRequestCallback = false;

    //*** Constructor
    (function () {
        let src = _path.includes('blob') ? _path : Assets.getPath(_path);
        if (_path.includes(['jpg', 'png'])) {
            let noop = _ => {};
            _this.texture = Utils3D.getTexture(src);
            _this.video = {play: noop, pause: noop};
            if (parseColor) _this.colorParser = _this.initClass(VideoTextureColorParser, src, true);
        } else {
            _video = _this.initClass(Video, {src, loop, preload, autoplay, muted, events: ['timeupdate', 'playing', 'ended']});
            _this.texture = new Texture();
            _this.texture.format = Texture.RGBFormat;
            _this.texture.minFilter = _this.texture.magFilter = Texture.LINEAR;
            _this.texture.generateMipmaps = false;
            _this.texture.loaded = false;
            _this.video = _video;
            _this.events.bubble(_video, Video.PLAYING);
            if (parseColor) _this.colorParser = _this.initClass(VideoTextureColorParser, src, false);

            if (firstFrame) {
                _this.videoTexture = _this.texture;
                _this.texture = Utils3D.getTexture(firstFrame);
            }
        }

        _hasRequestCallback = ('requestVideoFrameCallback' in HTMLVideoElement.prototype);
        if (!_hasRequestCallback) _this.startRender(update, 30);
    })();

    function update() {
        if (_video.canRender) {
            if (_this.videoTexture) {
                _this.texture.destroy();
                _this.texture = _this.videoTexture;
                delete _this.videoTexture;
            }

            if (!_this.texture.image) {
                _this.texture.image = _video.video;
                _this.texture.upload();
            }

            if (_this.colorParser) _this.colorParser.update(_video.time);

            _this.texture.loaded = _this.texture.needsUpdate = true;

            if(_hasRequestCallback) {
                _video.element.div.requestVideoFrameCallback(update);
            }
        }
    }

    //*** Event handlers

    //*** Public methods
    this.set('loop', loop => _video.loop = loop);
    this.set('muted', muted => _video.muted = muted);
    this.set('src', src => _video.src = Assets.getPath(src));

    this.start = async function() {
        if (_video) {
            _this.active = true;
            await _video.play();

            if(_hasRequestCallback) {
                _video.element.div.requestVideoFrameCallback(update);
            }else{
                _this.startRender(update, 30);
            }
        }
    }

    this.stop = function() {
        if (_video) {
            _this.active = false;
            _video.pause();

            if(_hasRequestCallback) {
                _video.element.div.cancelVideoFrameCallback(update)
            }else{
                _this.stopRender(update);
            }
        }
    }

    this.seek = function(time) {
        if (_video) _video.seek(time);
    }

    this.onInvisible = function() {
        if (_this.active) _video.pause();
        VideoTexture.element().removeChild(_this.video.object, true);
    }

    this.onVisible = function() {
        if (_this.active) _video.play();
        VideoTexture.element().add(_this.video.object);
    }

    this.onDestroy = function() {
        _this.texture.destroy();
        VideoTexture.element().removeChild(_this.video.object, true);
    }
}, _ => {
    var $element;
    VideoTexture.element = function() {
        if (!$element) {
            $element = Stage.create('VideoTextures');
            $element.size(0,0).setZ(-1);
            Stage.add($element);
        }

        return $element;
    }
});
Class(function VideoTextureColorParser(_path, _static) {
    Inherit(this, Component);
    const _this = this;
    var _colorData, _lumData;

    var _color = new Color();

    this.color = new Color();
    this.lerp = 1;

    //*** Constructor
    (async function () {
        let split = _path.split('.')[0];
        let path = split + '.json';

        _colorData = await get(path);
    })();

    //*** Event handlers

    //*** Public methods
    this.update = function(time) {
        if (!_colorData) return;

        for (let key in _colorData) {
            if (time <= key) {
                _color.set('#' + _colorData[key]);
                _this.color.lerp(_color, _this.lerp);
                break;
            }
        }
    }
});
/**
 * Really simple, really fast socket with minimal abstraction.
 * @name SocketConnection
 * @constructor
 * @example
 * let ws = new SocketConnection('ws://localhost:7189', Device.mobile ? 'mobile' : 'screen');
 * setInterval(_ => ws.send('message', {arbitraryData: Math.random()}), 1000);
 * _this.events.sub(ws, 'message', e => console.log(e));
 **/
Class(function SocketConnection(_server, _channel) {
    Inherit(this, Component);
    var _this = this;
    var _socket, _pingPong;

    var _fail = 0;
    var _binary = {};
    var _time = Render.TIME;

    const PING = 'ping';
    const PONG = 'pong';
    const BINARY = 'binary:';

    this.connected = false;

    //*** Constructor
    (async function () {
        try {
            connect();
        } catch(e) {
            await defer();
            _this.events.fire(SocketConnection.ERROR, {socket: _this});
            _this.timer = _this.delayedCall(connect, 250);
        }
    })();

    function connect() {
        _this.pending = false;
        _socket = new WebSocket(_server, ['permessage-deflate']);
        _socket.binaryType = 'arraybuffer';
        _socket.onopen = open;
        _socket.onmessage = message;
        _socket.onclose = close;
        _socket.onerror = close;
    }

    function sendPing() {
        if (_socket && _socket.readyState == WebSocket.OPEN) {
            _socket.send(PING);
        }
    }

    //*** Event handlers
    function open(e) {
        _fail = 0;
        _this.connected = true;
        _this.events.fire(SocketConnection.OPEN, {socket: _this}, true);
        if (_channel) _this.send('register', {channel: _channel});
        _pingPong = setInterval(sendPing, 5000);
    }

    function message(e)  {
        if (e.data == PONG || e.data == PING) return;
        if (typeof e.data === 'string') {
            try {
                let data = JSON.parse(e.data);
                let evt = data._evt;
                if (evt) {
                    delete data._evt;
                    _this.events.fire(evt, data, true);
                } else {
                    _binary.data = data;
                    _this.events.fire(SocketConnection.BINARY, _binary);
                }
            } catch(er) {

            }
        } else {
            _binary.data = e.data;
            _this.events.fire(SocketConnection.BINARY, _binary);
        }
    }

    function close(e) {
        if (Render.TIME - _time < 50 && !_this.blocked) {
            _this.blocked = true;
            return _this.events.fire(SocketConnection.BLOCKED);
        }
        if (_this.pending) return;
        if (_fail++ > 250) return;
        _this.connected = false;
        _this.pending = true;
        _this.events.fire(SocketConnection.CLOSE, {socket: _this}, true);
        _this.timer = _this.delayedCall(connect, 250);
        clearTimeout(_pingPong);
    }

    //*** Public methods
    this.send = function(evt, data = {}) {
        if (!_this.connected) return _this.delayedCall(_ => _this.send(evt, data), 100);
        data._evt = evt;
        if (_socket && _socket.readyState == WebSocket.OPEN) {
            _socket.send(data.length != undefined ? data : JSON.stringify(data));
        }
    }

    this.sendBinary = function(data) {
        if (_socket && _socket.readyState == WebSocket.OPEN && _socket.bufferedAmount < 1024) {
            _socket.send(BINARY + (data.length != undefined ? data : JSON.stringify(data)));
        }
    }

    this.close = function() {
        _socket.onclose = null;
        _socket.onerror = null;
        clearTimeout(_this.timer);
        _socket.close();
    }

}, _ => {
    SocketConnection.OPEN = 'socket_connection_open';
    SocketConnection.CLOSE = 'socket_connection_close';
    SocketConnection.ERROR = 'socket_connection_error';
    SocketConnection.BINARY = 'socket_connection_binary';
    SocketConnection.BLOCKED = 'socket_connection_blocked';
});
Class(function AvatarProfileGrid(_config = {count: 256, resolution: 2048}) {
    Inherit(this, Component);
    const _this = this;
    var _capture, $root, _connectedUniform, _chatActiveUniform, _speakingUniform;
    var _grid = [];

    //*** Constructor
    (function () {
        initCapture();
        initGrid();
        addListeners();

        // let $display = $gl(512, 512, _capture);
        // GLUI.Stage.add($display);

        _this.startRender(loop);
    })();

    function initCapture() {
        _capture = _this.initClass(StageLayoutCapture, _config.resolution, _config.resolution, null, true);
        $root = _capture.root;
        _capture.disableClear = true;
        _capture.scene.disableAutoSort = true;
        _this.rt = _capture.rt;
    }

    function initGrid() {
        let x = 0;
        let y = 0;
        let size = _config.resolution / Math.sqrt(_config.count);
        for (let i = 0; i < _config.count; i++) {
            let $obj = $root.create(size, size, '#000000');
            $obj.x = x;
            $obj.y = y;
            $obj.hide();
            _grid.push($obj);
            x += size;
            if (x >= _config.resolution) {
                x = 0;
                y += size;
            }
        }
    }

    function loop() {
        for (let i = _grid.length-1; i > -1; i--) {
            let obj = _grid[i];
            if (obj.needsUpdate) {
                obj.needsUpdate = false;
                obj.show();
                defer(_ => obj.hide());
            }
        }
    }

    //*** Event handlers
    function addListeners() {
        _this.events.sub(Player.JOIN, playerJoin);
        _this.events.sub(Player.LEAVE, playerLeave);
    }

    async function playerJoin({player}) {
        if (_this._invisible) return;

        if (!player.view) return;
        await player.view.ready();
        if (!player.view) return;

        if (player.gcPlayer && !player.gcPlayer.me) {
            if (!_this.parent.multiplayerConfig?.roomKey) return;
        }

        let mesh = player.view.mesh;
        let index = mesh.batchIndex;

        const setTexture = async player => {
            if (!player || !player.state) return;
            let photo = player.state.get('profileImage') || player.state.get('profile_photo') || '~assets/images/avatar/placeholder.png';
            // console.log('PLAYER', index, photo, player.state.get('profileImage'));
            let obj = _grid[index];
            obj.bg(photo);
            obj.show();
            obj.staticTexture = obj.shader.get('tMap');
            await obj.staticTexture.promise;
            obj.needsUpdate = true;
        };
        setTexture(player);

        player.bindProfileImage = player.state.bind('profileImage', async _ => {
            setTexture(player);
        });

        player.bindSpeaking = player.state.bind('gcmedia_speaking', speaking => {
            if (_speakingUniform) mesh.shader?.set(_speakingUniform, speaking ? 1 : 0);
        });

        player.bindMuteAudio = player.state.bind('gcmedia_mute_audio', speaking => {
            if (_speakingUniform) mesh.shader?.set(_speakingUniform, 0);
        });
    }

    function playerLeave({player}) {
        if (_this._invisible) return;

        player.bindProfileImage?.destroy?.();
        player.bindSpeaking?.destroy?.();
        player.bindMuteAudio?.destroy?.();

        let mesh = player.view.mesh;
        if (!mesh) return;
        let index = mesh.batchIndex;
        let obj = _grid[index];
        if (obj.usingVideo) {
            // obj.bg('assets/images/_scenelayout/uv.jpg');
            obj.hide();
        }
    }

    //*** Public methods
    this.addVideo = function(videoObj) {
        let player = videoObj.player;
        if (!player.view) return;
        let mesh = player.view.mesh;
        let index = mesh.batchIndex;
        let obj = _grid[index];

        if (videoObj.gcPlayer.me) {
            if (_chatActiveUniform) {
                mesh.batch?.mesh.shader.set(_chatActiveUniform, 1);
            }
        }
        if (_connectedUniform) mesh.shader?.set(_connectedUniform, 1);

        if (!videoObj.media?.videoTexture) return;

        obj.usingVideo = true;
        obj.bg(videoObj.media.videoTexture);
        obj.show();

        player.bindMuteVideo = player.state.bind('gcmedia_mute_video', muted => {
            if (muted) {
                obj.bg(obj.staticTexture);
                obj.usingVideo = false;
                obj.needsUpdate = true;
            } else {
                obj.usingVideo = true;
                obj.bg(videoObj.media.videoTexture);
                obj.show();
            }
        });
    }

    this.removeVideo = function(videoObj) {
        let player = videoObj.player;
        if (!player.view) return;
        let mesh = player.view.mesh;
        if (_connectedUniform) mesh.shader?.set(_connectedUniform, 0);
        let index = mesh.batchIndex;
        let obj = _grid[index];

        if (videoObj.gcPlayer.me) {
            if (_chatActiveUniform) {
                mesh.batch?.mesh.shader.set(_chatActiveUniform, 0);
            }
        }

        if (!videoObj.media?.videoTexture) return;

        obj.usingVideo = false;
        obj.bg(obj.staticTexture);
        obj.needsUpdate = true;

        player.bindMuteVideo?.destroy?.();
    }

    this.removeAllVideo = function() {
        for (let i = 0; i < _grid.length; i++) {
            let obj = _grid[i];
            if (obj.usingVideo) {
                obj.usingVideo = false;
                obj.bg(obj.staticTexture);
                obj.needsUpdate = true;
            }
        }
    }

    this.setConnectedUniform = function(key) {
        _connectedUniform = key;
        return this;
    }

    this.setChatActiveUniform = function(key) {
        _chatActiveUniform = key;
        return this;
    }

    this.setSpeakingUniform = function(key) {
        _speakingUniform = key;
        return this;
    }

    this.reset = function() {
        _grid[0].bg(PlayerModel.get('profileImage') || PlayerModel.get('profile_image') || 'assets/images/_scenelayout/uv.jpg');
        _grid[0].show();

        for (let i = 1; i < _grid.length; i++) {
            let image = _grid[i].shader.get('tMap');
            if (image) image.destroy();
            _grid[i].hide();
        }
    }

    this.handleKickParticipant = function(playerId) {

    }

    this.hide = function() {

    }
});
Class(function GlobalConfig() {
    Inherit(this, Component);
    const _this = this;
    var _3rdPersonCamera, _1stPersonCamera, _controls;

    var _uil = _this.isPlayground() ? undefined : null;
    var _map = {};

    //*** Constructor
    (function () {
        if ( Utils.query('noGlobalConfig')) return;
        create('controls', {moveStep: 1, playerLerp: 1, wrapperLerp: 1, jumpStrength: 1, jumpReturnLerp: 1, jumpGravity: 0.1});
        create('1st_person', {position: [0, 0, 0], groupPos: [0, 0, 0], fov: 40, moveXY: [-0.8, 0.8]});
        create('3rd_person', {position: [0, 0, 0], groupPos: [0, 0, 0], fov: 40, moveXY: [0.8, 0.8]});
    })();

    function create(name, obj) {
        let uil = InputUIL.create(name, _uil);
        uil.cache = {};
        _map[name] = uil.cache;

        for (let key in obj) {
            if (typeof obj[key] === 'number') {
                uil.add(key, obj[key]);
                uil.cache[key] = uil.getNumber(key);
            } else {
                uil.addVector(key, obj[key]);
                uil.cache[key] = uil.get(key);
            }
        }
    }

    //*** Event handlers

    //*** Public methods
    this.getConfig = function(key) {
        return _map[key];
    }
}, 'singleton');
Class(function Breakpoints() {
    Inherit(this, Component);
    const _this = this;
    // 0 - 600px:      Phone
    // 600 - 960px:    Tablet portrait
    // 960 - 1200px:   Tablet landscape
    // [1200 - 1600] is where our normal styles apply
    // 1600px + :      Big desktop
    Object.assign(this, {
        desktop:1500,
        tabLand:1200,
        tabPort:960,
        phone:600
    });

    this.getSize = function(checkPhoneOrientation = false, checkTabletOrientation = false) {
        const height = window.innerHeight;
        const width = window.innerWidth;
        if(checkPhoneOrientation && Device.mobile.phone && width < height) {
            return "phone-portrait";
        }
        if(checkPhoneOrientation && Device.mobile.phone && width > height) {
            return "phone-landscape";
        }
        if(checkTabletOrientation && Device.mobile.tablet && width < height) {
            return "tab-portrait";
        }
        if(checkTabletOrientation && Device.mobile.tablet && width > height) {
            return "tab-landscape";
        }
        if(width <= this.phone){
            return "phone"
        }
        else if(width <= this.tabPort){
            return "tab-port"
        }
        else if(width <= this.tabLand){
            return "tab-land"
        }
        else if(width <= this.desktop){
            return "desktop"
        }else{
            return "big-desktop"
        }
    };
}, 'static');
Class(function Colors() {
    Inherit(this, Component);
    const _this = this;

    Object.assign(this, {
        white: '#ffffff',
        black: '#000000',
        on: '#55b750',
        off: '#D9310B',
        monochrome: ['#EEEEEE', '#e5e5e5', '#d3d3d3', '#aaaaaa', '#838383', '#747474', '#5e5e5e', '#e8e8e8', '#2e2e2e'],
        primary: ['#6D7278', '#C2C0C0', '#A7A7A7', '#4E596D', '#354253'],
        secondary: ['#6D7278', '#C2C0C0', '#A7A7A7', '#4E596D', '#354253'],
        tertiary: ['#6D7278', '#C2C0C0', '#A7A7A7', '#4E596D', '#354253'],
        red: ['#FF3F02'],
        blue: ['#1B81F9'],
        yellow: ['#FFC539']
    });

    // _this.gl = {
    //     red: new Color('#ffe1e1'),
    //     white: new Color('#e8e8e8')
    // };

    this.inverse = function (color) {
        switch (color) {
            case _this.white:
                return _this.black;
            case _this.black:
                return _this.white;
            case _this.blue:
                return _this.orange;
        }
    };
}, 'static');

Class(function DateUtil() {
  Inherit(this, Component);

  const _this = this;

  var _token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g;
  var _timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
  var _timezoneClip = /[^-+\dA-Z]/g;

  const MASKS = {
    default: "ddd mmm dd yyyy HH:MM:ss",
    shortDate: "m/d/yy",
    mediumDate: "mmm d, yyyy",
    longDate: "mmmm d, yyyy",
    fullDate: "dddd, mmmm d, yyyy",
    shortTime: "h:MM TT",
    mediumTime: "h:MM:ss TT",
    longTime: "h:MM:ss TT Z",
    isoDate: "yyyy-mm-dd",
    isoTime: "HH:MM:ss",
    isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
    isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'",
  };

  const i18n = {
    dayNames: [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat",
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
    ],
    monthNames: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December",
    ],
  };

  //*** Constructor
  (function () {})();

  function pad(val, len) {
    val = String(val);
    len = len || 2;
    while (val.length < len) val = "0" + val;
    return val;
  }

  //*** Event handlers

  //*** Public methods
  this.format = function (date, mask, utc, local = false) {
    // You can't provide utc if you skip other args (use the "UTC:" mask prefix)
    if (
      arguments.length == 1 &&
      Object.prototype.toString.call(date) == "[object String]" &&
      !/\d/.test(date)
    ) {
      mask = date;
      date = undefined;
    }

    // Passing date through Date applies Date.parse, if necessary
    date = date ? new Date(date) : new Date();

    if (local) {
      date = new Date(_this.getLocalTime(date));
    }

    if (isNaN(date)) throw SyntaxError("invalid date");

    mask = String(MASKS[mask] || mask || MASKS["default"]);

    // Allow setting the utc argument via the mask
    if (mask.slice(0, 4) == "UTC:") {
      mask = mask.slice(4);
      utc = true;
    }

    var _ = utc ? "getUTC" : "get",
      d = date[_ + "Date"](),
      D = date[_ + "Day"](),
      m = date[_ + "Month"](),
      y = date[_ + "FullYear"](),
      H = date[_ + "Hours"](),
      M = date[_ + "Minutes"](),
      s = date[_ + "Seconds"](),
      L = date[_ + "Milliseconds"](),
      o = utc ? 0 : date.getTimezoneOffset(),
      flags = {
        d: d,
        dd: pad(d),
        ddd: i18n.dayNames[D],
        dddd: i18n.dayNames[D + 7],
        m: m + 1,
        mm: pad(m + 1),
        mmm: i18n.monthNames[m],
        mmmm: i18n.monthNames[m + 12],
        yy: String(y).slice(2),
        yyyy: y,
        h: H % 12 || 12,
        hh: pad(H % 12 || 12),
        H: H,
        HH: pad(H),
        M: M,
        MM: pad(M),
        s: s,
        ss: pad(s),
        l: pad(L, 3),
        L: pad(L > 99 ? Math.round(L / 10) : L),
        t: H < 12 ? "a" : "p",
        tt: H < 12 ? "am" : "pm",
        T: H < 12 ? "A" : "P",
        TT: H < 12 ? "AM" : "PM",
        Z: utc
          ? "UTC"
          : (String(date).match(_timezone) || [""])
              .pop()
              .replace(_timezoneClip, ""),
        o:
          (o > 0 ? "-" : "+") +
          pad(Math.floor(Math.abs(o) / 60) * 100 + (Math.abs(o) % 60), 4),
        S: ["th", "st", "nd", "rd"][
          d % 10 > 3 ? 0 : (((d % 100) - (d % 10) != 10) * d) % 10
        ],
      };

    return mask.replace(_token, function ($0) {
      return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
    });
  };

  this.simpleFormat = function (date) {
    let newDate = new Date(date);

    return newDate.toLocaleTimeString(navigator.language, {
      hour: "2-digit",
      minute: "2-digit",
    });
  };

  this.convertToFullDate = function (time, options) {
    let format = options || {
      weekday: "long",
      year: "numeric",
      month: "long",
      day: "numeric",
    };

    let date = typeof time.getMonth === "function" ? time : new Date(time);

    return date.toLocaleDateString("en-us", format);
  };

  this.addMinutes = function (date, minutes) {
    let time = typeof date.getMonth === "function" ? date : new Date(date);

    return new Date(time.getTime() + minutes * 60000);
  };

  this.differenceInMinutes = function (start, end, abs = true) {
    let value = abs ? Math.abs(start - end) : start - end;
    
    return Math.floor(value / 1000 / 60);
  };

  this.getLocalTime = function (date) {
    let newDate = new Date(date);

    let offset = date.getTimezoneOffset() / 60;
    let hours = date.getHours();

    newDate.setHours(hours - offset);

    return newDate;
  };
}, "static");

Class(function Fonts() {
    Inherit(this, Component);
    const _this = this;

    Object.assign(this, {
        css: {
            nimbus: 'nimbus-sans, sans-serif',
        }
    });
}, 'static');
Class(function RWD() {
    Inherit(this, Component);
    const _this = this;
    var _androidSize = {};

    //*** Constructor
    //*** Constructor
    (async function () {
        await Hydra.ready();

        defer(()=>{
            _this.onResize(resize);
        });

    })();

    function isMobile() {
        let isPhone = Device.mobile && Device.mobile.phone;
        let isTablet = Device.mobile && Device.mobile.tablet;

        if (isPhone) return true;

        let width, height;
        if (typeof Stage === 'undefined') { // weird stuff
            width = window.innerWidth;
            height = window.innerHeight;
        } else {
            width = Stage.width;
            height = Stage.height;
        }


        if(isTablet) {
            let isLandscape = (window.orientation === 90 || window.orientation === -90);
            return !isLandscape;
        }

        return height > width || width <= 900;

    }

    //*** Event handlers
    function resize() {
        if (isMobile()) {
            document.body.classList.add('rwd-isMobile');
            document.body.classList.remove('rwd-isDesktop');
        } else {
            document.body.classList.add('rwd-isDesktop');
            document.body.classList.remove('rwd-isMobile');
        }

        if (Device.mobile.phone && Device.system.os == 'android') {
            if (_androidSize.height) {
                if (_this.isLandscape()) {
                    __body.size('100%');
                } else {
                    __body.size(_androidSize.width, _androidSize.height);
                }
            } else {
                if (!_this.isLandscape()) {
                    let viewport = document.querySelector('meta[name=viewport]');
                    let content = viewport.getAttribute('content');
                    content = content.replace('width=device-width', `width=${Stage.width}, height=${Stage.height}`);
                    viewport.setAttribute('content', content);
                    _androidSize.width = Stage.width;
                    _androidSize.height = Stage.height;
                    __body.size(Stage.width, Stage.height);
                }
            }
        }
    }

    //*** Public methods
    this.get('isMobile', () => {
        return isMobile();
    });

    this.isLandscape = function() {
        if (Device.system.os == 'android') {
            return window.orientation != 0;
        } else {
            let width = window.innerWidth;
            let height = window.innerHeight;
            return width > height;
        }
    };

}, 'static');
Class(function Styleguide() {
    Inherit(this, Component);
    const _this = this;

    function sg(fontName, fontSize, lineHeight,letterSpacing = "0") {
        return {
            position: 'relative',
            fontFamily: Fonts.css[fontName],
            fontSize,
            lineHeight,
            letterSpacing,
            fontStyle: 'normal',
            fontWeight: 'normal'
        };
    }

    // Add method to HydraObject
    $.fn.style = function(name, color = 'black') {
        let style = _this[name];
        style.color = Colors[color];

        if (this.div.classList) {
            if (!this.div.classList.contains(name)) this.div.classList.add(name);
        } else {
            this.div.className += ' ' + name;
        }
        this._styleName = name;
        this.css(style);

        return this;
    };

    $.fn.bold = function() {
        this.css({ fontWeight: '700' });
        return this;
    };

    $.fn.black = function() {
        this.css({
            fontWeight: '900'
        });

        return this;
    };

    this.get('h1', () => {
        let style = sg('nimbus', 53, '120%',"-.5px");
        if (RWD.isMobile) {
            Object.assign(style, {
                fontSize: 46
            });
        }

        return style;
    });

    this.get('h2', () => {
        let style = sg('nimbus', 40, '120%',"-.5px");
        if (RWD.isMobile) {
            Object.assign(style, {
                fontSize: 36
            });
        }
        return style;
    });
    this.get('h3', () => {
        let style = sg('nimbus', 34, '120%');
        if (RWD.isMobile) {
            Object.assign(style, {
                fontSize: 28
            });
        }
        return style;
    });
    this.get('h4', () => {
        let style = sg('nimbus', 24, '120%',"-.5px");
        return style;
    });
    this.get('h5', () => {
        let style = sg('nimbus', 20, '120%',"-.3px");
        return style;
    });

    this.get('p1', () => {
        let style = sg('nimbus', 16, '120%');
        return style;
    });
    this.get('p2', () => {
        let style = sg('nimbus', 15, '120%',"-.3px");
        return style;
    });
    this.get('label1', (isBold=false) => {
        let style = sg('nimbus', 13, '120%',".5px");
        if(isBold){
            Object.assign(style, {
                fontWeight: '700'
            });
        }
        return style;
    });
    this.get('label2', () => {
        let style = sg('nimbus', 14, '120%');
        return style;
    });
    this.get('label3', (isBold=false) => {
        let style = sg('nimbus', 15, '120%',"-.1px");
        if(isBold){
            Object.assign(style, {
                fontWeight: '700'
            });        }
        return style;
    });
    this.get('label4', () => {
        let style = sg('nimbus', 16, '120%');
        return style;
    });
    this.get('label5', () => {
        let style = sg('nimbus', 18, '120%',"-.2px");
        return style;
    });
    this.get('button', () => {
        let style = sg('nimbus', 15, '120%',".5px");
        Object.assign(style, {
            fontWeight: '700',
            textTransform:'uppercase'
        });
        return style;
    });

    this.get('icon', ()=>{
        let style = {
            width:'2.5rem',
            height:'2.5rem',
            position:'relative'
        }
        if (RWD.isMobile) {
            Object.assign(style, {
                width:'2rem',
                height:'2rem'
            });
        }
        return style;

    })
}, 'static');
Class(function EnvironmentCollisionThread() {
    Inherit(this, Component);
    const _this = this;
    var _geom, _mesh, _ray, _dir, _camera, _geomVR, _meshVR;

    function testHit(ignoreVR){

        let [hit] = _ray.intersectObject(_mesh);

        let obj = {miss:false};

        obj.success = true;

        if(_meshVR && !ignoreVR) {

            let [hitVR] = _ray.intersectObject(_meshVR);

            if(hitVR) {
                obj.miss = true;
            } else {
                if (hit) {
                    obj.normal = hit.face.normal;
                    obj.point = hit.point;
                } else {
                    obj.miss = true;
                }
            }

        } else {
            if (hit) {
                obj.normal = hit.face.normal;
                obj.point = hit.point;
            } else {
                obj.miss = true;
            }
        }

        return obj;
    }
    //*** Event handlers

    //*** Public methods
    this.mount = function({position, normal, scale}) {
        _geom = new Geometry();
        _geom.addAttribute('position', new GeometryAttribute(position, 3));
        _geom.addAttribute('normal', new GeometryAttribute(normal, 3));
        _geom.addAttribute('uv', new GeometryAttribute(new Float32Array((position.length/3) * 2), 2));
        _geom.computeBoundingSphere();
        _geom.computeBoundingBox();

        _mesh = new Mesh(_geom, {side: Shader.FRONT_SIDE});
        _ray = new RayManager();
        _dir = new Vector3(0, -1, 0);
        _camera = new PerspectiveCamera();
        _mesh.scale.fromArray(scale);
        _mesh.updateMatrixWorld(true);
    }

    this.mountVR = function({position, normal, scaleVR}) {
        _geomVR = new Geometry();
        _geomVR.addAttribute('position', new GeometryAttribute(position, 3));
        _geomVR.addAttribute('normal', new GeometryAttribute(normal, 3));
        _geomVR.addAttribute('uv', new GeometryAttribute(new Float32Array((position.length/3) * 2), 2));
        _geomVR.computeBoundingSphere();
        _geomVR.computeBoundingBox();

        _meshVR = new Mesh(_geomVR, {side: Shader.FRONT_SIDE});
        _meshVR.scale.fromArray(scaleVR);
        _meshVR.updateMatrixWorld(true);
    }


    this.test2D = function({pos}, id) {
        if (!_geom) return resolve({success: false}, id);
        _ray.setFromCamera(pos,_camera);
        let obj = testHit(true);
        resolve(obj, id);
    }

    this.updateCamera = function({fov,near,far,aspect,position,quaternion}) {
        if (_camera) {
            _camera.fov = fov;
            _camera.near = near;
            _camera.far = far;
            _camera.aspect = aspect;
            _camera.position.fromArray(position);
            _camera.quaternion.fromArray(quaternion);
            _camera.updateProjectionMatrix();
            _camera.updateMatrixWorld(true);
        }
    }

    this.test = function({pos}, id) {
        if (!_geom) return resolve({success: false}, id);
        _ray.set(pos, _dir, 0, Number.POSITIVE_INFINITY);
        let obj = testHit();
        resolve(obj, id);
    }

    this.testBox = function({pos,bounding},id){
        if (!_geom) return resolve({success: false}, id);
        _ray.set(pos, _dir, 0, Number.POSITIVE_INFINITY);
        let obj = testHit();
        let hits = [];
        if(obj.point){
            hits.push(obj)
        }
        for(let bound of bounding){
            _ray.set(bound, _dir, 0, Number.POSITIVE_INFINITY);
            let result = testHit();
            if (result.point){
               hits.push(result);
            }
        }
        if(hits.length > 0){
            let sorted = hits.sort((a,b)=>{
                return b.point.y - a.point.y
            });
            obj.point = sorted[0].point;
        }

        resolve(obj, id);
    }

    this.clear = function() {
        _geom = null;
        _geomVR = null;
    }
});
Class(function AvatarInteraction(_controller) {
    Inherit(this, Component);
    const _this = this;
    var _thread, _geom, _over, _needsTest, _localPlayer, _vrDown, _hoverTime;

    var _camera = {projectionMatrix: [], p: [], q: []};
    var _players = [];
    var _playerMap = {};
    var _transfer = {camera: _camera, array: [], mouse: {}, localPlayer: []};

    const PROXIMITY = 'proximity';
    const VR = Platform.usingVR();
    const RADIUS = 3;

    //*** Constructor
    (function () {
        initThread();
        addListeners();
    })();

    function initThread() {
        if (!AvatarInteraction.THREAD) {
            let thread = new Thread(AvatarInteractionThread);
            Utils3D.loadEngineOnThread(thread);
            thread.importClass(Raycaster);
            AvatarInteraction.THREAD = thread;
        }

        _thread = AvatarInteraction.THREAD;
    }

    function loop() {
        if ((!_players.length || !_needsTest) && !_this.flag(PROXIMITY)) return;
        _needsTest = false;

        _transfer.array.length = 0;
        for (let i = _players.length-1; i > -1; i--) {
            let obj = _players[i];
            obj.p.toArray(obj.transfer.p);
            obj.q.toArray(obj.transfer.q);
            _transfer.array.push(obj.transfer);
        }

        _camera.fov = World.CAMERA.fov;
        _camera.aspect = World.CAMERA.aspect;
        _camera.near = World.CAMERA.near;
        _camera.far = World.CAMERA.far;
        World.CAMERA.position.toArray(_camera.p);
        World.CAMERA.quaternion.toArray(_camera.q);
        World.CAMERA.projectionMatrix.toArray(_camera.projectionMatrix);
        _camera.width = Stage.width;
        _camera.height = Stage.height;

        _transfer.mouse.x = Mouse.x;
        _transfer.mouse.y = Mouse.y;

        if (VR) {
            let input = Interaction3D.find(World.CAMERA).input;
            if (!_transfer.vrControls) _transfer.vrControls = {pos: [], quat: []};
            if (input.obj && input.obj.group) {
                input.obj.group.getWorldPosition().toArray(_transfer.vrControls.pos);
                input.obj.group.getWorldQuaternion().toArray(_transfer.vrControls.quat);
            }
        }

        if (_localPlayer) _localPlayer.position.toArray(_transfer.localPlayer);

        _thread.hitTest(_transfer, hitTestResult);
    }

    function hitTestResult({hit}) {
        if (PlayerControlsOrbit.DRAGGING) return;
        try {
            if (hit) {
                if (!_over && _playerMap[hit]) {
                    let otherPlayer = _playerMap[hit].player;
                    if (_localPlayer && _localPlayer.position.distanceTo(otherPlayer.group.position) > RADIUS) return;
                    // if (!Device.mobile) {
                    //     if (PlayerControls.shouldPrevent()) return;
                    // }
                    Stage.cursor('pointer');
                    _over = otherPlayer;
                    AvatarInteraction.intersecting = true;
                    _hoverTime = Render.TIME;
                    _over.events.fire(AvatarInteraction.HOVER, {action: 'over', object: _over});
                    if (_controller && _controller.onOver) _controller.onOver(_over);
                }
            } else {
                if (_over) {
                    Stage.cursor('auto');
                    AvatarInteraction.intersecting = false;
                    _over.events.fire(AvatarInteraction.HOVER, {action: 'out', object: _over});
                    if (_controller && _controller.onOut) _controller.onOut(_over);
                    _over = null;
                }
            }

            // if (_over && !Device.mobile) {
            //     if (PlayerControls.shouldPrevent()) {
            //         Stage.cursor('auto');
            //         _over.events.fire(AvatarInteraction.HOVER, {action: 'out', object: _over});
            //         if (_controller && _controller.onOut) _controller.onOut(_over);
            //         _over = null;
            //     }
            // }
        } catch(e) {
            _over = null;
            if (Hydra.LOCAL) console.error(e);
        }
    }

    //*** Event handlers
    function addListeners() {
        if (Device.mobile) _this.events.sub(Mouse.input, Interaction.START, start);
        else _this.events.sub(Mouse.input, Interaction.MOVE, move);
        _this.events.sub(Mouse.input, Interaction.CLICK, click);

        if (VR) {
            VRInput.controllers.forEach(c => {
                _this.events.sub(c, VRInput.BUTTON, vrInputButton);
            });
        }
    }

    function vrInputButton(e) {
        if (e.controller == Interaction3D.find(World.CAMERA).input.obj) {
            if (e.label == 'trigger') {
                if (e.pressed) _vrDown = Render.TIME;
                else {
                    let delta = Render.TIME - _vrDown;
                    if (delta < 200) {
                        click();
                    }
                }
            }
        }
    }

    function start(e) {
        _needsTest = true;
        loop();
    }

    function move(e) {
        _needsTest = true;
    }

    async function click(e) {
        if (e?.isLeaveEvent) return;

        if (_over) {
            try {
                if (Render.TIME - _hoverTime > 100) {
                    if (_controller && _controller.onClick) _controller.onClick(_over);
                    _over.events?.fire(AvatarInteraction.CLICK, {action: 'click', object: _over});
                }
            } catch(e) {
                _over = null;
                if (Hydra.LOCAL) console.error(e);
            }
        }
    }

    function onProximity({player}) {
        if (_playerMap[player] && _this.onProximityEvent) _this.onProximityEvent(_playerMap[player].player);
    }

    //*** Public methods
    this.activate = function() {
        _thread.activate();
        _geom = null;
        _this.startRender(loop, 24);
    }

    this.addLocalPlayer = function(player) {
        if (player) _localPlayer = _this.localPlayer = player.group;
    }

    this.addPlayer = async function(player) {
        if (!_geom) {
            await defer();

            if (player.boundingBox) {
                _geom = true;
                _thread.uploadBoundingBox({boundingBox: player.boundingBox});
            } else {
                if (!player.group) return;
                player.group.traverse(m => {
                    if (m.geometry && !_geom) {
                        if (!m.geometry.boundingBox) {
                            m.geometry.computeBoundingSphere();
                            m.geometry.computeBoundingBox();
                        }
                        _geom = true;
                        _thread.uploadBoundingBox({boundingBox: m.geometry.boundingBox});
                    }
                });
            }

            _this.delayedCall(_ => {
                _this.addPlayer(player);
            }, 100);
            return;
        }

        let obj = {player, p: player.group.position, q: player.group.quaternion, transfer: {p : [], q: [], id: player.gcPlayer.id}};
        _players.push(obj);
        _playerMap[player.gcPlayer.id] = obj;
        _thread.addPlayer({player: player.gcPlayer.id});
    }

    this.removePlayer = function(player) {
        let obj = _playerMap[player.gcPlayer.id];
        if (obj) {
            _this.onRemovePlayer?.(player);
            _thread.removePlayer({player: player.gcPlayer.id});
            _players.remove(obj);
            delete _playerMap[player.gcPlayer.id];
        }
    }

    this.bindPlayerProximity = function(distance = 1) {
        _thread.bindPlayerProximity({distance});
        _thread.on('proximity', onProximity);
        _this.flag('proximity', true);
    }

    this.isPlayerInside = function(pos, radius) {
        let radiusSq = radius * radius;
        for (let i = _players.length-1; i > -1; i--) {
            let player = _players[i];
            if (player.p.distanceToSquared(pos) < radiusSq) return true;
        }

        if (_localPlayer.position.distanceToSquared(pos) < radiusSq) return true;

        return false;
    }
}, _ => {
    AvatarInteraction.HOVER = 'avatar_hover';
    AvatarInteraction.CLICK = 'avatar_click';
});
Class(function AvatarInteractionThread() {
    Inherit(this, Component);
    const _this = this;
    var _players, _playerMap, _mesh, _camera, _ray, _stage, _playerProximity, _v3, _v32, _q;

    //*** Event handlers

    //*** Public methods
    this.activate = function() {
        _players = [];
        _playerMap = {};
        _camera = new PerspectiveCamera();
        _stage = {};
        _ray = new Raycaster(_camera);
        _mesh = null;
    }

    this.addPlayer = function({player}) {
        if (!_mesh) return;
        let mesh = _mesh.clone();
        mesh.playerId = player;
        _players.push(mesh);
        _playerMap[player] = mesh;
    }

    this.removePlayer = function({player}) {
        let mesh = _playerMap[player];
        delete _playerMap[player];
        _players.remove(mesh);
    }

    this.uploadBoundingBox = function({boundingBox}) {
        let geom = new BoxGeometry(1, 1, 1);
        geom.applyMatrix(new Matrix4().makeTranslation(0, 0.5, 0));
        let mesh = new Mesh(geom, {});
        mesh.scale.x = boundingBox.max.x * 2
        mesh.scale.z = boundingBox.max.z * 2;
        mesh.scale.y = boundingBox.max.y * 1;
        _mesh = mesh;
    }

    this.hitTest = function({camera, array, mouse, localPlayer, vrControls}, id) {
        _camera.aspect = camera.aspect;
        _camera.fov = camera.fov;
        _camera.near = camera.near;
        _camera.far = camera.far;
        _camera.position.fromArray(camera.p);
        _camera.quaternion.fromArray(camera.q);
        _camera.projectionMatrix.fromArray(camera.projectionMatrix);
        _camera.updateProjectionMatrix();
        _camera.updateMatrixWorld(true);

        if (!_v3) _v3 = new Vector3();
        if (!_v32) _v32 = new Vector3();
        if (!_q) _q = new Quaternion();
        _v3.fromArray(localPlayer);

        _stage.width = camera.width;
        _stage.height = camera.height;

        for (let i = array.length-1; i > -1; i--) {
            let obj = array[i];
            let player = _playerMap[obj.id];
            if (player) {
                player.position.fromArray(obj.p);
                player.quaternion.fromArray(obj.q);
                player.updateMatrixWorld(true);

                if (_playerProximity) {
                    let dist = player.position.distanceTo(_v3);
                    if (dist < _playerProximity) {
                        emit('proximity', {player: obj.id});
                    }
                }
            }
        }

        let hit;
        if (vrControls) {
            _v3.fromArray(vrControls.pos);
            _q.fromArray(vrControls.quat);
            _v32.set(0, 0, -1).applyQuaternion(_q);
            [hit] = _ray.checkFromValues(_players, _v3, _v32);
        } else {
            [hit] = _ray.checkHit(_players, mouse, _stage);
        }

        if (hit) {
            resolve({hit: hit.object.playerId}, id);
        } else {
            resolve({hit: false}, id);
        }
    }

    this.bindPlayerProximity = function({distance}) {
        _playerProximity = distance;
    }

});
Class(function ClickZone(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    var _mesh;

    var _id = _input.get('wildcard');

    //*** Constructor
    (function () {
        _mesh = new Mesh(World.BOX, Utils3D.getTestShader());
        if (!Utils.query('clickZone')) _mesh.shader.neverRender = true;
        _this.add(_mesh);
        Interaction3D.find(World.CAMERA).add(_mesh, hover, click);
    })();

    //*** Event handlers
    function hover(e) {
        _this.events.fire(ClickZone.HOVER, {action: e.action, id: _id});
    }

    function click(e) {
        _this.events.fire(ClickZone.CLICK, {id: _id});
    }

    //*** Public methods
    this.onDestroy = function() {
        Interaction3D.find(World.CAMERA).remove(_mesh, hover, click);
    }
}, _ => {
    ClickZone.HOVER = 'clickzone_hover';
    ClickZone.CLICK = 'clickzone_click';
});
Class(function TriggerZone(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    var _mesh, _box;
    var _dialog, _id, _auto, _confirm, _radius;

    var _env = _this.findParent('GroupEnvironment');
    var _wrapper = new Group();
    var _target = new Group();
    var _v3 = new Vector3();

    const VR = Platform.usingVR();

    //*** Constructor
    (function () {
        if (!_this.parent.parent.configureSpace) return;
        _id = _input.get('wildcard') || '';

        initConfig();
        _wrapper.rotation.x = Math.radians(-60);
        _wrapper.add(_target);
        initMesh();
        initDialog();
        addListeners();

        _dialog.target = new Group();

        defer(_ => {
            _this.group.updateMatrixWorld(true);
            _box.setFromObject(_mesh);
            _radius = _box.getBoundingSphere().radius;
        });

    })();

    function initConfig() {
        let config = InputUIL.create(_input.prefix + 'triggerzone', _group);
        config.setLabel('Zone');
        config.addToggle('visible', true);
        _confirm = true;

        config.onUpdate = _ => {
            let visible = config.get('visible') === true;
            _this.group.visible = visible;
        };
        config.onUpdate();
    }

    function initMesh() {
        _mesh = new Mesh(World.BOX, Utils3D.getTestShader());
        _this.add(_mesh);
        _box = new Box3();
        if (!Utils.query('orbit')) _mesh.visible = false;
    }

    function initDialog() {
        if (!_confirm) return;
        let view = TriggerZone.getDialogClass(_id.split('/')[0]);
        if ( typeof view === 'undefined' ) throw 'TriggerZone view class is undefined';
        _dialog = _this.initClass( view.class, {...{game: _id},...view.extras});
        if ( !Global.PLAYGROUND ) _this.findParent('GroupEnvironment').add(_dialog.group);
        else _dialog.group.visible = false;
    }

    function loop() {
        if (VR) return;

        if (PlayerControls.getViewState() == '1st') {
            _dialog.target.position.copy(World.CAMERA.position);
            _dialog.target.position.add(_v3.set(0, 0, -4).applyQuaternion(World.CAMERA.quaternion));
            _dialog.target.lookAt(World.CAMERA.position);
            _dialog.group.position.lerp(_dialog.target.position, 0.1);
            _dialog.group.quaternion.slerp(_dialog.target.quaternion, 0.1);
        } else {
            _dialog.group.position.copy(_this.group.position);
            _dialog.group.position.y += (_box.max.y - _box.min.y) * 0.5;

            let player = _env.player;
            if (player) {
                let worldCamera = World.CAMERA.getWorldPosition();
                let worldMesh = _dialog.group.getWorldPosition();
                _target.quaternion.copy(World.CAMERA.quaternion);
                _dialog.group.quaternion.slerp(_target.getWorldQuaternion(), 0.1);
            }
        }
    }

    function collideLoop() {
        let player = _env.player;
        if (player && player.group) {
            if (_box.containsPoint(player.group.position)) {
                if (!_this.flag('on')) {
                    TriggerZone.IS_INSIDE = true;
                    _this.flag('on', true);
                    let test = TriggerZone.lookupTest(_id);
                    if (test && !test(_id)) return;

                    _this.events.fire(TriggerZone.INSIDE, {id:_id});
                    if (_dialog) showDialog();
                }
            } else {
                if (_this.flag('on')) {
                    TriggerZone.IS_INSIDE = false;
                    _this.flag('on', false);
                    let test = TriggerZone.lookupTest(_id);
                    if (test && !test(_id)) return;

                    if (_dialog) hideDialog();
                    _this.events.fire(TriggerZone.OUTSIDE, {id:_id});
                }
            }

            TriggerZone.reportNearby(player.group.position.distanceTo(_this.group.position) < _radius*2);
        }
    }

    //*** Event handlers
    function addListeners() {
        if (_env) {
            if (_dialog) _this.startRender(loop);
            _this.startRender(collideLoop, 24);
        }
        if (_dialog) _this.events.sub(_dialog, Events.COMPLETE, onChoice);
    }

    async function onChoice({shouldStart}) {
        await hideDialog();
        if (shouldStart) _this.events.fire(TriggerZone.TRIGGERED, {id: _id});
    }

    async function showDialog() {
        await _this.wait(50);

        if (VR) {
            _dialog.scale = 0.4;
            _dialog.group.position.copy(World.CAMERA.position);
            _dialog.group.position.y -= 0.25;
            _dialog.group.position.add(new Vector3(0, 0, -1).applyQuaternion(World.CAMERA.quaternion));
            _dialog.group.lookAt(World.CAMERA.position);
        }

        if (PlayerControls.getViewState() == '1st') {
            _dialog.group.position.copy(World.CAMERA.position);
            _dialog.group.position.add(new Vector3(0, 0, -2).applyQuaternion(World.CAMERA.quaternion));
            _dialog.group.lookAt(World.CAMERA.position);
        }

        if (Device.mobile) _dialog.scale = 2;

        await _dialog.animateIn();
    }

    function hideDialog() {
        _dialog.animateOut();
    }

    //*** Public methods

    this.get('dialog', _ =>  _dialog );

    this.onInvisible = this.onDestroy = this.onVisible = function() {
        TriggerZone.IS_INSIDE = false;
        TriggerZone.IS_NEARBY = false;
        _dialog.animateOut();
    }

}, _ => {
    TriggerZone.TRIGGERED = 'triggerzone_triggered';
    TriggerZone.INSIDE = 'triggerzone_inside';
    TriggerZone.OUTSIDE = 'triggerzone_outside';

    Render.start(_ => {
        TriggerZone.IS_NEARBY = false;
    }, 24);

    var _map = {};
    var _tests = {};
    TriggerZone.registerDialogClass = function(key, DialogClass, extras, test) {
        if (typeof extras === 'function') {
            test = extras;
            extras = null;
        }

        _map[key] = {class:DialogClass, extras};
        if (test) _tests[key] = test;
    };

    TriggerZone.lookupTest = function(key) {
        return _tests[key];
    }

    TriggerZone.getDialogClass = function(key) {
        return _map[key] || {class: UI3DPrompt};
    };

    TriggerZone.reportNearby = function(bool) {
        if (bool === true) TriggerZone.IS_NEARBY = true;
    }
});

Class(function ProfileSnapshot(_key = '') {
    Inherit(this, Object3D);
    const _this = this;
    let _mesh;
    let cache = {};

    const consoleSecurity = require('ConsoleSecurity');

    //*** Constructor
    (async function () {
        await User.ready();

        _mesh = new Mesh(World.BOX, Utils3D.getTestShader());
        _this.add(_mesh);

        _mesh.prefix = 'profile_snapshot' + _key;
        MeshUIL.add(_mesh).setLabel('Profile Snapshot');
        if (!Utils.query('snapshotBox')) _mesh.visible = false;
    })();

    //*** Event handlers

    //*** Public methods
    _this.capture = async function () {
        let bb = new Box3();
        bb.setFromObject(_mesh);

        let points = [
            new Vector3(bb.min.x, bb.max.y, bb.min.z),
            new Vector3(bb.min.x, bb.max.y, bb.max.z),
            new Vector3(bb.min.x, bb.min.y, bb.min.z),
            new Vector3(bb.min.x, bb.min.y, bb.max.z),
            new Vector3(bb.max.x, bb.max.y, bb.min.z),
            new Vector3(bb.max.x, bb.max.y, bb.max.z),
            new Vector3(bb.max.x, bb.min.y, bb.min.z),
            new Vector3(bb.max.x, bb.min.y, bb.max.z)
        ];

        points = points.map(p => new Vector2().copy(ScreenProjection.find(World.CAMERA).project(p)));

        let minX = 9999;
        let minY = 9999;
        let maxX = 0;
        let maxY = 0;
        points.forEach(p => {
            minX = Math.min(minX, p.x);
            minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x);
            maxY = Math.max(maxY, p.y);
        });

        let x = Math.round(minX);
        let y = Math.round(minY);
        let width = Math.round(maxX - minX);
        let height = Math.round(maxY - minY);

        let canvas = DreamWorld.active.capturePixels(x, y, width, height);
        if (Utils.query('debugProfile')) Stage.add(canvas);

        _this.events.fire(ProfileSnapshot.UPDATE, { canvas });

        //post the canvas to the API here
        return await _this.upload(canvas.toDataURL('image/jpeg'));
    };

    _this.upload = async function (base64profile) {
        if (!Hydra.LOCAL && consoleSecurity()) return false;
        if (cache['upload'] && cache['upload'] === base64profile) return;
        if (!cache['upload']) cache['upload'] = base64profile;

        let token = await User.getIdToken();
        if (!token) return;

        Track.event('profile', 'upload');
        return await post(`${Config.API}-upload`, {
            profile: base64profile,
            token
        });
    }
}, _ => {
    ProfileSnapshot.UPDATE = 'profile_snap_update';
});

Class(function CSSAppState() {
    const _this = this;

    var _map = new Map();
    var _bindings = new Map();

    //internal class
    //Values is an array of possible values of length 1 or 2. If length is 2, then the flipVarible is used in a ternary operation to decide which to use
    /*
        Cases: 
            1. Property name is background
                 Property name is just set to the passed value

            2. Values has more than one value
                 The _flipVariable is used to perform a ternary operation to pick between the two
            
            3. Values has just one member
                 This is used in the case that you're not setting to the raw value i.e 2px solid ${VARIABLE}
    */
    function StateBinding(_keys, _obj, _propertyName, _values, _flipVariable) {
        var _oldValue;
        this.update = function(key, value) {
            let newValue = value;
            if (newValue == _oldValue) return;
            let newStyle = {};
            if(_values.length > 1){
                newStyle[_propertyName] = _flipVariable ? _values[0] + ` ${value}` : _values[1];
                _obj.css(newStyle);
            }else if(_values.length == 1){
                newStyle[_propertyName] = _values[0] + ` ${value}`;
                _obj.css(newStyle);
            }else{
                newStyle[_propertyName] = value;
                _obj.css(newStyle);
            }
          
            _oldValue = newValue;
        }
    }

    //*** Public methods
    this.set = function(key, value) {
        _map.set(key, value);
        let array = _bindings.get(key);
        if (array) array.forEach(b => b.update(key, value));
    }

    this.get = function(key) {
        return _map.get(key);
    }

    this.bind = function(keys, obj, propertyName, values = [], flipVariable = null) {
        if (!Array.isArray(keys)) keys = [keys];

        let binding = new StateBinding(keys, obj,propertyName,values,flipVariable);
        keys.forEach(key => {
            if (_bindings.has(key)) _bindings.get(key).push(binding);
            else _bindings.set(key, [binding]);

            let value = _map.get(key);
            if (value) binding.update(value)
        });
    }

    this.createLocal = function() {
        return new CSSAppState();
    }
}, 'static');
function DeferredPromise() {

    let resolve, reject;

    const promise = new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    });

    return { promise, resolve, reject };
}
Class(function StreamVideoTexture(_video) {
    Inherit(this, Component);
    const _this = this;

    this.texture = new Texture(_video);

    //*** Constructor
    (function () {
        _this.texture.format = Texture.RGBFormat;
        _this.texture.minFilter = _this.texture.magFilter = Texture.LINEAR;
        _this.texture.generateMipmaps = false;

        playVideo();

        _this.startRender(loop, 30);
    })();

    async function playVideo() {
        try {
            await _video.play();
        } catch(e) {
            _this.delayedCall && _this.delayedCall(playVideo, 100);
        }
    }

    function loop() {
        _this.texture.needsUpdate = true;
    }

    //*** Event handlers

    //*** Public methods
    this.onDestroy = function() {
        _this.texture.destroy();
    }
});
Class(function Tests() {
    const _this = this;

    (async function() {

    })();

    this.getDPR = function() {
        //Bad GPU plugged into an external screen
        if (GPU.OVERSIZED) return 0.9;

        //Desktop
        if (GPU.lt(0)) return 1;
        if (GPU.lt(1)) return Math.min(Device.pixelRatio, 1.15);
        if (GPU.lt(2)) return Math.min(Device.pixelRatio, 1.3);
        if (GPU.lt(3)) return Math.min(Device.pixelRatio, 1.4);
        if (GPU.lt(5)) return 1.5;//Math.min(Device.pixelRatio, 2);

        //Mobile
        if (GPU.mobileLT(0)) return 1;
        if (GPU.mobileLT(1)) return Math.min(Device.pixelRatio, 1.2);
        if (GPU.mobileLT(2)) return Math.min(Device.pixelRatio, 1.35);
        if (GPU.mobileLT(3)) return Math.min(Device.pixelRatio, 1.5);
        if (GPU.mobileLT(4)) return Math.min(Device.pixelRatio, 2);

        return 1;
    }

    this.capFPS = function() {
        if (GPU.lt(1)) return 30.001;
        if (GPU.mobileLT(2)) return 30.001;
        if (GPU.lt(3) && Math.max(Stage.width, Stage.height) > 1600) return 30.001;
        if (GPU.lt(3)) return Render.REFRESH_RATE > 60 ? 60.001 : null;
        if (Device.mobile) return Render.REFRESH_RATE > 100 ? 100.001 : null;
        return null;
    }

    this.renderShadows = function() {
        return GPU.gt(2);
    }

    this.mobilePhone = function() {
        return Device.mobile && Device.mobile.phone;
    }

}, 'static');

Class(function VideoManager(_view, _previewConfig) {
    Inherit(this, Component);
    const _this = this;
    var _preview, _loader;
    var _videos = new Map();
    var _objects = [];
    var _players = [];

    //*** Constructor
    (function () {
        _this.parent.getDOMElement();
        if (_previewConfig) initPreview();
        if (!_view.addVideo || !_view.removeVideo) throw `VideoManager :: videoLayout requires .addVideo .removeVideo`;
        if (_view.element) _this.parent.getDOMElement().add(_view.element);
        _this.startRender(_ => {});
        PhysicalSync.createGlobalEvent('muteParticipant', handleMuteParticipant);
        PhysicalSync.createGlobalEvent('kickParticipant', handleKickParticipant);
        addHandlers();
    })();

    function initPreview() {
        // eslint-disable-next-line no-multi-assign
        _this.preview = _preview = _this.initClass(VideoPreview, _previewConfig);
        _this.events.sub(_preview, Events.READY, previewComplete);
        _this.parent.getDOMElement().add(_preview.element);
        _view.hide && _view.hide();
    }

    async function previewComplete() {
        _this.events.fire(VideoManager.PREVIEW_COMPLETE);
        _view.show && _view.show();
        await _preview.animateOut();
        _preview = _preview.destroy();
        _this.parent.enterVideoChat();
        _loader = _this.initClass(VideoLoader, { message: "CONNECTING" });
        _this.parent.getDOMElement().add(_loader.element);
        _loader.appear();
    }

    //*** Event handlers
    function updateVideo(e) {
        if (_this._invisible) return;
        if (_loader && _loader.destroy) _loader = _loader.destroy();
        if (e.type == 'add') {
            let obj = { video: e.media.video, screenShare: !!e.media.isScreenShare, data: e.media.player.data, gcPlayer: e.media.player, media: e.media, player: e.media.player.dreamPlayer };
            obj.me = obj.gcPlayer.me;
            _videos.set(e.media, obj);
            _view.addVideo(obj, obj.gcPlayer.me);
            if (!e.media.isScreenShare) e.media.player._videoObject = obj;
            _objects.push(obj);
        } else {
            let obj = _videos.get(e.media);
            if (obj && _view && _view.removeVideo) _view.removeVideo(obj);
            _videos.delete(e.media);
            if (!e.media.isScreenShare) e.media.player._videoObject = null;
            if (obj && obj.view && obj.view.destroy) obj.view.destroy();
            _objects.remove(obj);
        }
    }

    function handleVideoMute(player, value) {
        try {
            player._videoObject && player._videoObject.onVideoMute(value);
        } catch (e) { }
    }

    function handleAudioMute(player, value) {
        try {
            player._videoObject && player._videoObject.onAudioMute(value);
        } catch (e) { }
    }

    function handleSpeaking(player, value) {
        try {
            player._videoObject && player._videoObject.onSpeaking(value);
        } catch (e) { }
    }

    function handleMuteParticipant({ playerId }) {
        if (_this._invisible) return;
        if (playerId == Multiplayer.room.me.id) {
            GameCenterMedia.userStream.disableAudio();
            AVSettingsController.instance().audioEnabled = false;
        }
    }

    function handleKickParticipant({ playerId }) {
        if (_this._invisible) return;
        if (playerId == Multiplayer.room.me.id) {
            DreamModeration.removeUser(playerId, `Removed from ${Multiplayer.room.id}`);
            _this.parent.disconnectMultiplayer();
            _view.handleKickParticipant?.(playerId);
        }
    }

    //*** Event handlers
    function addHandlers() {
        _this.events.sub(VideoAdminControls.MUTE, (gcPLayer) => _this.muteParticipant(gcPLayer));
        _this.events.sub(VideoAdminControls.REMOVE, (gcPLayer) => _this.kickParticipant(gcPLayer));
    }

    //*** Public methods
    this.addPlayer = async function(player) {
        if (!player || !_this.events) return;
        await player.wait('gcPlayer');
        if (_players.includes(player.gcPlayer)) return;
        _players.push(player.gcPlayer);

        _this.events.sub(player.gcPlayer, GameCenterMedia.UPDATE_PLAYER_VIDEO, updateVideo);

        player.state.bind('gcmedia_mute_video', value => handleVideoMute(player.gcPlayer, value));
        player.state.bind('gcmedia_mute_audio', value => handleAudioMute(player.gcPlayer, value));
        player.state.bind('gcmedia_speaking', value => handleSpeaking(player.gcPlayer, value));

        player.gcPlayer.wait('_videoObject').then(_ => {
            _this.wait(player.gcPlayer._videoObject, 'onAudioMute').then(_ => {
                if (player.state.get('gcmedia_mute_video')) handleVideoMute(player.gcPlayer, true);
                if (player.state.get('gcmedia_mute_audio')) handleAudioMute(player.gcPlayer, true);
                if (player.state.get('gcmedia_speaking')) handleSpeaking(player.gcPlayer, true);
            });
        });

        try {
            player.gcPlayer?.videos?.forEach(media => {
                updateVideo({ media, type: 'add' });
            });
        } catch (e) { }
    };

    this.removePlayer = function(player) {
        try {
            _players.remove(player.gcPlayer);
            player.gcPlayer.videos.forEach(media => {
                updateVideo({ media, type: 'remove' });
            });
        } catch (e) { }
    };

    // eslint-disable-next-line no-multi-assign
    this.deactivate = this.clearPlayers = function() {
        _objects.forEach(obj => {
            _view.removeVideo(obj);
            if (obj.view && obj.view.destroy) obj.view.destroy();
        });
        _view.hide();
        _preview?.destroy?.();
        _preview = null;
        _objects.length = 0;
        _videos.clear();
        _players.length = 0;
    };

    this.reset = function() {
        this.deactivate();
        if (_previewConfig && !_preview) initPreview();
    };

    this.getViewFor = async function(gcPlayer) {
        await _this.wait(gcPlayer, 'videos');
        await defer();
        for (let i = 0; i < _objects.length; i++) {
            let obj = _objects[i];
            if (obj.gcPlayer == gcPlayer) {
                await _this.wait(obj, 'view');
                return obj.view;
            }
        }
    };

    this.getMyView = async function() {
        await _this.wait(_objects, 'length');
        for (let i = 0; i < _objects.length; i++) {
            let obj = _objects[i];
            if (obj.gcPlayer.me) {
                await _this.wait(obj, 'view');
                return obj.view;
            }
        }
    };

    this.hasVideo = function() {
        return _this.wait(_objects, 'length');
    };

    this.muteParticipant = function(gcPlayer) {
        PhysicalSync.fireLocalEvent('muteParticipant', { playerId: gcPlayer.id });
        handleMuteParticipant({ playerId: gcPlayer.id });
    };

    this.kickParticipant = function(gcPlayer) {
        PhysicalSync.fireLocalEvent('kickParticipant', { playerId: gcPlayer.id });
        handleKickParticipant({ playerId: gcPlayer.id });
    };

    this.onDestroy = function() {
        PhysicalSync.deleteGlobalEvent('muteParticipant', handleMuteParticipant);
        PhysicalSync.deleteGlobalEvent('kickParticipant', handleKickParticipant);
    };
}, _ => {
    VideoManager.PREVIEW_COMPLETE = 'VideoManager.PREVIEW_COMPLETE';
});

Class(function PlayerModel() {
    Inherit(this, Model);
    const _this = this;

    const consoleSecurity = require('ConsoleSecurity');

    let _room;
    let _pending = {};
    let _timeout;

    _this.data = {};
    _this.UPDATE = 'playermodel_update';
    _this.state = AppState.createLocal();
    _this.state._set = _this.state.set;
    _this.state.set = _this.set;

    const DEFAULT_UID = `uid_${Date.now().toString()}`;
    const DEFAULT_NAME = `Player ${DEFAULT_UID}`;
    const DEFAULT_IMAGE = 'assets/images/avatar/placeholder.png';

    const DB_EXCLUDE = [
        'gcmedia_speaking',
        'gcmedia_mute_audio',
        'gcmedia_mute_video'
    ];
    const DB_SAVE_DELAY = 100;

    (async function () {
        await Hydra.ready();
        await Config.ready();

        AssetLoader.waitForLib('GameCenter').then(_ => {
            GameCenter.userData = _this.data;
        });

        if (Config.SERVICES.auth && !Device.detect('aura desktop')) {
            await User.ready();
            const isLoggedIn = await User.checkLoginStatusOnce();

            if (isLoggedIn) {
                let _player = await getFromDb();

                let data = {
                    name: User.profile && User.profile.displayName || 'Player',
                    image: User.state.get(User.PROFILE_IMAGE) || DEFAULT_IMAGE,
                    uid: User.uid,
                    ..._player
                };

                for (let key in data) _this.data[key] = data[key];
            } else {
                let data = {
                    name: DEFAULT_NAME,
                    image: DEFAULT_IMAGE,
                    uid: DEFAULT_UID
                };
                for (let key in data) _this.data[key] = data[key];
                _this.dataReady = true;
            }

            addAuthHandlers();
        } else {
            let data = Storage.get('playerModel') || {};
            for (let key in data) _this.data[key] = data[key];

            if (!_this.get('name')) _this.set('name', await window.DreamName?.generate() || 'Attendee');
            if (!_this.get('uid')) _this.set('uid', Utils.uuid());
            if (!_this.get('image')) _this.set('image', DEFAULT_IMAGE);
        }

        for (let key in _this.data) _this.state._set(key, _this.data[key]);

        _room && _room.updateUserData && _room.updateUserData(_this.data);
        _this.dataReady = true;
    })();

    function addAuthHandlers() {
        User.loggedIn(loggedIn);
        User.loggedOut(loggedOut);
        User.state.bind(User.PROFILE_IMAGE, updatedImage);
    }

    function updatedImage(image) {
        _this.data['image'] = image;
        _room && _room.updateUserData && _room.updateUserData(_this.data);
        _this.events.fire(_this.UPDATE);
    }

    function loggedIn(e) {
        _this.data['uid'] = User.uid;
        _this.data['name'] = User.profile && User.profile.displayName || 'Player';
        _this.data['image'] = User.state.get(User.PROFILE_IMAGE) || DEFAULT_IMAGE;

        _room && _room.updateUserData && _room.updateUserData(_this.data);
        _this.events.fire(_this.UPDATE);
    }

    function loggedOut() {
        let data = {
            name: DEFAULT_NAME,
            uid: DEFAULT_UID,
            image: DEFAULT_IMAGE
        };
        for (let key in data) _this.data[key] = data[key];
        _room && _room.updateUserData && _room.updateUserData(_this.data);
        _this.events.fire(_this.UPDATE);
    }

    function saveToDb() {
        if (!User.uid) return;
        PlatformFirestore.collection('players').doc(User.uid).set(_pending, { merge: true });
        _pending = {};
    }

    async function getFromDb() {
        if (!User.uid) return;
        let players = await PlatformFirestore.collection('players').doc(User.uid).get();
        if (!players.exists) return {};
        return players.data();
    }

    //*** Public methods
    this.set = function (key, value, bypassDatabase = false) {
        if (key === 'data') throw `PlayerModel :: Do NOT set a key called data`;
        if (!Hydra.LOCAL && consoleSecurity()) return false;

        if (Array.isArray(value)) value = value.slice();
        if (_this.data && _this.data[key] && _this.data[key] === value) return;

        _this.data[key] = value;
        _this.state._set(key, value);

        if (Config.SERVICES.auth) {
            if (_timeout) clearTimeout(_timeout);
            if (!bypassDatabase && !DB_EXCLUDE.includes(key)) {
                _pending[key] = value;
                _timeout = _this.delayedCall(saveToDb, DB_SAVE_DELAY);
            }
        } else {
            Storage.set('playerModel', _this.data);
        }

        _room && _room.updateUserData && _room.updateUserData(_this.data);
        _this.events.fire(_this.UPDATE);
    };

    this.get = function (key) {
        return _this.data[key];
    };

    this.useRoom = function (room) {
        _room = room;
    };
}, 'static');

Class(function Router() {
    Inherit(this, Component);
    Inherit(this, PushState);
    const _this = this;
    var _data = {};

    _this.BEFORE_UPDATE = 'router_before_update';
    _this.UPDATE = 'router_update';

    //*** Constructor
    (function () {
        _this.fireChangeWhenSet = true;
        if (!Hydra.LOCAL) _this.setRoot(getBasePath());
        let state = (_this.getState() || '').split('/');
        let end = state[state.length-1];
        if (end.includes('?')) {
            _this.virtualQuery = true;
            end.replace('?', '').split('&').forEach(pair => {
                let [key, value] = pair.split('=');
                if (value === undefined) value = true;
                Utils.query(key, value);
            });
        }

        _this.events.sub(_this, Events.UPDATE, onUpdate);
    })();

    //*** Event handlers
    async function onUpdate(e) {
        let guards = [];
        let addGuard = function(promise) {
            guards.push(promise);
        };

        _this.events.fire(_this.BEFORE_UPDATE, {addGuard});

        await Promise.all(guards);

        _this.events.fire(_this.UPDATE, e);
    }

    function getBasePath() {
        var bases = document.getElementsByTagName('base');
        if (bases.length > 0) {
            let url = new URL(bases[0].href);
            return url.pathname;
        }
        return '/';
    }

    //*** Public methods
    this.getState = function() {
        return (this._getState() || '').split('?')[0].split('/').filter(Boolean);
    }

    this.getStateString = function() {
        return this.getState().join('/');
    }

    this.getData = function () {
        return _data;
    }

    this.setData =function (data) {
        _data = data;
    }

}, 'static');
/**
 * Get list of bookings for the logged in User
 * @name User
 *
 * @example
 * // wait for User to load
 * await User.ready()
 *
 * // check if user is logged in or not
 * let isLoggedIn = await User.checkLoginStatusOnce();
 *
 * // listen for changes to logged in state
 * User.loggedIn(showAdminPage)
 * User.loggedOut(showHomePage)
 *
 * // check for changes to user profile
 * User.state.bind(User.PROFILE_UPDATED, updateProfileViewInfo)
 *
 */
Class(function User() {
    Inherit(this, Model);
    const _this = this;
    const prototype = User.prototype;

    let _uid;
    let _user;
    let _claims;
    let _profile;
    let _unsubscribe;

    let _statusPromise;
    let _loggedInPromise;
    let _loggedOutPromise;

    let _callback = null;
    let _metadataRef = null;
    let _initialState = true;
    let _initialClaims = true


    let _isLoggedIn;
    let _isNew;
    let _wait;
    let _waitForLoggedInEvent;

    _this.LOGGED_IN_EVENT = 'dream_fire_login';

    _this.INIT_STATE = 'dream_init_state';
    _this.LOGGED_IN = 'dream_user_logged_in';
    _this.LOGGED_OUT = 'dream_user_logged_out';

    _this.PROFILE = 'dream_user_profile';
    _this.PROFILE_IMAGE = 'dream_user_profile_image';
    _this.CLAIMS = 'dream_user_claims';
    _this.STATUS = 'dream_user_status';
    _this.DEFAULT_IMAGE = 'assets/images/avatar/placeholder.png';

    _this.state = AppState.createLocal();

    //*** Public Methods
    (async function () {
        await Hydra.ready();
        await PlatformDB.ready();
        await PlatformAuth.ready();

        addHandlers();
        _this.dataReady = true;
    }());

    function addHandlers() {
        PlatformAuth.AUTH.onAuthStateChanged((user) => {
            if (_wait && !user) {
                _wait = false;
                return;
            }

            if (_callback) _metadataRef.off('value', _callback);
            if (!user) return onLoggedOut();

            // check if refresh of claims
            _metadataRef = PlatformDB.ref(`claims/${user.uid}/refreshTime`);

            _callback = () => {
                // Force refresh to pick up the latest custom claims changes.
                if (!_initialClaims) onUpdateClaims(user);
                _initialClaims = false
            };

            // Subscribe new listener to changes on that node.
            if (_metadataRef) _metadataRef.on('value', _callback);

            // User is signed in
            if (_waitForLoggedInEvent) _this.state.bind(_this.LOGGED_IN_EVENT, onLoggedIn(user));
            else onLoggedIn(user);
        });
    }

    function onProfileUpdated(user) {
        _unsubscribe && _unsubscribe();

        _unsubscribe = PlatformFirestore.collection('users').doc(user.uid)
            .onSnapshot(function (snapshot) {
                if (_initialState) { _initialState = false; } else {
                    _profile = snapshot.data();
                    _this.state.set(_this.PROFILE, _profile);
                    _this.state.set(_this.PROFILE_IMAGE, _profile?.image || _claims?.picture || _this.DEFAULT_IMAGE);
                }
            }, (error) => {
                console.log('FIRESTORE UPDATED ERROR', error);
            });
    }

    function onUpdateClaims(firebaseUser) {
        firebaseUser.getIdTokenResult(true).then((idTokenResults) => {
            _claims = idTokenResults.claims;
            _this.state.set(_this.CLAIMS, _claims);
        });
    }

    function onLoggedIn(firebaseUser) {
        _user = firebaseUser;
        _uid = firebaseUser && firebaseUser.uid;

        if (!_uid) return null;
        if (_waitForLoggedInEvent) _waitForLoggedInEvent = false;

        // check if admin
        firebaseUser.getIdTokenResult().then((idTokenResults) => {
            _claims = idTokenResults.claims;
            _this.state.set(_this.CLAIMS, _claims);

            PlatformFirestore.collection('users').doc(_uid).get()
                .then((snapshot) => {
                    if (!snapshot.exists) {
                        onProfileUpdated(firebaseUser);
                        _isLoggedIn = true;
                        _isNew = true;

                        if (_initialState) {
                            _this.events.fire(PlatformAuth.INIT_STATE);
                            _this.state.set(_this.STATUS, _this.INIT_STATE);
                            _initialState = false;
                        } else {
                            _this.state.set(_this.STATUS, _this.LOGGED_IN);
                        }

                        _this.events.fire(PlatformAuth.LOGGED_IN, firebaseUser);
                        Track.event('auth', 'loggedIn');
                    } else {
                        _isNew = false;
                        _profile = snapshot.data();

                        _this.state.set(_this.PROFILE, _profile);
                        _this.state.set(_this.PROFILE_IMAGE, _profile?.image || _claims?.picture || _this.DEFAULT_IMAGE);

                        onProfileUpdated(firebaseUser);
                        if (Config.SERVICES.auth && Config.SERVICES.auth.checkClaims) {
                            // check claims endpoint;
                            firebaseUser.getIdToken().then((token) => {
                                get(`${Config.API}-auth/claims?token=${token}`).then(() => {
                                    _isLoggedIn = true;

                                    if (_initialState) {
                                        _this.events.fire(PlatformAuth.INIT_STATE);
                                        _this.state.set(_this.STATUS, _this.INIT_STATE);
                                        _initialState = false;
                                    } else {
                                        _this.state.set(_this.STATUS, _this.LOGGED_IN);
                                    }

                                    _this.events.fire(PlatformAuth.LOGGED_IN, firebaseUser);
                                    Track.event('auth', 'loggedIn');
                                });
                            }).catch(_ => {
                                console.log(`Claims endpoint is not responding`);
                            });
                        } else {
                            _isLoggedIn = true;

                            if (_initialState) {
                                _this.events.fire(PlatformAuth.INIT_STATE);
                                _this.state.set(_this.STATUS, _this.INIT_STATE);
                                _initialState = false;
                            } else {
                                _this.state.set(_this.STATUS, _this.LOGGED_IN);
                            }

                            _this.events.fire(PlatformAuth.LOGGED_IN, firebaseUser);
                            Track.event('auth', 'loggedIn');
                        }
                    }
                })
                .catch((err) => {
                    PlatformAuth.loginError(err);
                });
        });
    }

    function onLoggedOut() {
        _uid = null;
        _profile = null;
        _claims = null;
        _user = null;
        _isLoggedIn = false;
        _unsubscribe && _unsubscribe();

        if (_initialState) {
            _this.events.fire(PlatformAuth.INIT_STATE);
            _this.state.set(_this.STATUS, _this.INIT_STATE);
            _initialState = false;
        } else {
            _this.events.fire(PlatformAuth.LOGGED_OUT);
            _this.state.set(_this.STATUS, _this.LOGGED_OUT);
            Track.event('auth', 'loggedOut');
        }
    }

    prototype.getIdToken = function () {
        return _user.getIdToken();
    };

    prototype.updateProfile = async function (data) {
        if (!_uid) return;

        delete data['email'];
        delete data['claims']

        await PlatformFirestore.collection('users').doc(_uid).set(data, { merge: true });
        await _user.updateProfile(data);

        _profile = { ..._profile, ...data };
        return _profile;
    };

    prototype.uploadProfileImage = async function (base64) {
        if (!_uid) return;
        if (!base64) return;

        let token = await _user.getIdToken();
        if (!token) return;

        let response = await post(`${Config.API}-users/upload`, { profileImage: base64 }, { headers: { token, 'Content-Type': 'application/json' } });
        _this.state.set(_this.PROFILE_IMAGE, response.permalink);
        return response;
    };

    prototype.deleteProfile = function () {
        if (!_uid) return null;
        return PlatformFirestore.collection('users').doc(_uid).delete();
    };

    prototype.isAdmin = function () {
        return _claims && _claims.admin;
    };

    prototype.loggedIn = function (callback) {
        if (!callback) {
            if (_loggedInPromise) return _loggedInPromise;
            _loggedInPromise = Promise.create();
        }

        _this.state.bind(_this.STATUS, (info) => {
            switch (info) {
                case _this.LOGGED_IN:
                    if (!callback) _loggedInPromise.resolve(_profile);
                    else callback(_profile);
            }
        });

        return _loggedInPromise;
    };

    prototype.loggedOut = function (callback) {
        if (!callback) {
            if (_loggedOutPromise) return _loggedOutPromise;
            _loggedOutPromise = Promise.create();
        }

        _this.state.bind(_this.STATUS, (info) => {
            switch (info) {
                case _this.LOGGED_OUT:
                    if (!callback) _loggedOutPromise.resolve();
                    else callback();
            }
        });

        return _loggedOutPromise;
    };

    prototype.checkLoginStatusOnce = function () {
        if (_statusPromise) return _statusPromise;
        _statusPromise = Promise.create();

        _this.state.bind(_this.STATUS, (info) => {
            switch (info) {
                case _this.INIT_STATE:
                    if (_isLoggedIn) _statusPromise.resolve(_isLoggedIn);
                    else _statusPromise.resolve(false);
                    break;
            }
        });

        return _statusPromise;
    };

    prototype.logout = async function () {
        if (PlatformAuth.AUTH) {
            Track.event('auth', 'logout');
            await window.DreamPresence?.beforeLogout();
            return PlatformAuth.AUTH.signOut();
        }
        console.error('Auth not ready');
    };

    _this.get('uid', () => _uid);
    _this.get('profile', () => _profile);
    _this.get('claims', () => _claims);
    _this.get('isDataEmpty', () => _isNew);
    _this.set('waitForQuery', (val) => { _wait = val; });
    _this.set('waitForLoggedInEvent', (val) => { _waitForLoggedInEvent = val; });
}, 'static');

User.Class(function Storage() {
    Inherit(this, Model);
    const _this = this;

    const PATH = 'storage';

    var _data = {};
    var _isLoggedIn = false;

    //*** Constructor
    !(async function () {
        await Hydra.ready();
        await User.ready();
        addHandlers();
        let loggedInInit = await User.checkLoginStatusOnce();
        if (loggedInInit) await loggedIn();
    })();

    function addHandlers() {
        User.loggedIn(loggedIn);
        User.loggedOut(loggedOut);
    }

    async function loggedIn() {
        _isLoggedIn = true;
        let snapshot = await PlatformFirestore.collection(PATH).doc(User.uid).get();
        _data = snapshot.data() || {};
        _this.dataReady = true;
    }

    function loggedOut() {
        _data = {};
        _isLoggedIn = false;
        _this.dataReady = false;
    }

    _this.set = function (key, value) {
        if (!_isLoggedIn) return console.error('must be logged in to set data');
        _data[key] = value;
        PlatformFirestore.collection(PATH).doc(User.uid).set({
            [key]: value
        }, { merge: true });
    };

    _this.get = function (key) {
        if (!_isLoggedIn) return console.error('must be logged in to get data');
        return _data[key];
    };

    _this.clear = function() {
        if (!_isLoggedIn) return console.error('must be logged in to clear data');
        _data = {};
        PlatformFirestore.collection(PATH).doc(User.uid).set({});
    };
}, 'static');

Class(function Container() {
    Inherit(this, Element);
    const _this = this;
    const $this = this.element;

    const USING_XR = Platform.usingVR();

    //*** Constructor
    (async function () {
        initHTML();
        loadView();
    })();

    function initHTML() {
        Stage.add($this);
        $this.css({
            width: '100%',
            height: '100%'
        });
    }

    async function loadView() {
        let loaderView = _this.initClass(LoaderView);
        let loader = _this.initClass(AssetLoader, Assets.list().filter(['shaders', 'uil']));

        _this.events.sub(loader, Events.PROGRESS, loaderView.progress);
        _this.events.sub(loader, Events.COMPLETE, async () => {
            if (Global.PLAYGROUND) {
                loaderView.destroy();
            } else {
                loaderView.animateOut(() => {
                    loaderView = loaderView.destroy();

                    _this.events.fire(Container.LOADED);
                });
            }
        });

        loader.add(3);

        await loader.loadModules();

        loader.trigger(1);

        await Initializer3D.createWorld();
        await loadComplete();

        if (!Platform.usingVR()) await Worlds.instance().canDisplayFirstWorld();
        else await Platform.prefetchVRWorld();
        loader.trigger(2);
    }

    async function loadComplete() {
        if (USING_XR) {
            waitForInteraction();
        } else {
            await World.instance().init();
            Worlds.instance();
            $this.add(World.ELEMENT);
        }
    }

    async function waitForInteraction() {
        if (Platform.vrEntryOverride) return;

        let click = async e => {
            if (!Platform.vrEntryOverride) {
                await World.instance().initXR(RenderManager.WEBVR);
                Worlds.instance();
            }
            _this.events.unsub(Mouse.input, Interaction.CLICK, click);
        };

        if (window.AURA) click();
        else _this.events.sub(Mouse.input, Interaction.CLICK, click);
    }


    //*** Event handlers

    //*** Public methods
}, 'singleton', _ => {
    Container.LOADED = 'Container.LOADED';
});

Class(function ActivityEnvironment() {
    var _instance;

    //*** Public methods
    this.instance = function() {
        // if (!_instance) _instance = GroupEnvironment.instance().clone();
        // return _instance;
    }
}, 'static');
Class(function BaseEnvironment() {
    Inherit(this, Object3D);
    const _this = this;

    var _activeName;

    //*** Constructor
    (function () {

    })();

    //*** Event handlers

    //*** Public methods
    this.mount = function(ref, scene) {
        _activeName = ref.name;
        Lighting.createScene(_activeName, scene.scene || scene).useScene(_activeName);
    }

    this.unmount = function() {
        Lighting.destroyScene(_activeName);
    }

    this.activate = function() {
        Lighting.useScene(_activeName);
        GameCenterMedia.videoStream = false;
        GameCenterMedia.audioStream = false;
        GameCenterMedia.p2p = false;
    }

    this.deactivate = function() {
    }
});
Class(function GlobalEnvironment() {
    Inherit(this, BaseEnvironment);
    const _this = this;
    var _view;

    var PlayerClass;

    //*** Constructor
    (function () {

    })();

    //*** Event handlers

    //*** Public methods
    this.mount = async function(ref, scene, params) {
        this._mount(ref, scene.scene);

        let view = _this.initClass(ref, scene, params);
        view._type = 'global';
        scene.scene.add(_this.group);

        await view.loaded();

        return view;
    }

    this.unmount = function() {
        if (_this.group._parent) _this.group._parent.remove(_this.group);
        if (_view) _this.group.remove(_view.group);
        this._unmount();
    }

    this.activate = function(view) {
        _view = view;
        _this.group.add(_view.group);
        this._activate();
        GroupEnvironment.instance().deactivate();
    }

    this.deactivate = function() {
        this._deactivate();
    }

    this.registerPlayerClass = function(ref) {
        PlayerClass = ref;
        return this;
    }

    this.getPlayerClass = function() {
        return PlayerClass || DefaultCrowdAvatar;
    }

    this.get('view', _ => _view);
}, 'singleton');
Class(function GroupEnvironment(_clone) {
    Inherit(this, BaseEnvironment);
    const _this = this;
    var _view, _thread, _camera;

    var PlayerClass;

    var _player;

    //*** Constructor
    (function () {
        initThread();
        _this.startRender(loop);
        _camera = {position:[],quaternion:[]};
    })();

    function initThread() {
        _thread = _this.initClass(Thread, EnvironmentCollisionThread);
        Utils3D.loadEngineOnThread(_thread);
    }

    function loop() {
        _camera.fov = World.CAMERA.fov;
        _camera.near = World.CAMERA.near;
        _camera.far = World.CAMERA.far;
        _camera.aspect = World.CAMERA.aspect;
        World.CAMERA.getWorldPosition().toArray(_camera.position);
        World.CAMERA.getWorldQuaternion().toArray(_camera.quaternion)
        _thread.updateCamera(_camera);
    }

    //*** Event handlers
    function addListeners() {
        _view.events.sub(PhysicalSync.CONNECTION, onConnection);
        _view.events.sub(Multiplayer.ROOM, onRoomConnected);
    }

    function removeListeners() {
        if (_view && _view.events) {
            _view.events.unsub(PhysicalSync.CONNECTION, onConnection);
            _view.events.unsub(Multiplayer.ROOM, onRoomConnected);
        }
    }

    function onConnection(e) {
        let player = _this.initClass(Player, PlayerClass, _view, e.id, e.player);
        _view.group.add(player.group);
    }

    function onRoomConnected({room}) {
        // _this.events.sub(room, GameCenterRoom.PIN, handlePin);
    }

    //*** Public methods
    this.mount = async function(ref, scene, params) {
        this._mount(ref, scene.scene);

        let view = _this.initClass(ref, scene, params);
        view._type = 'clone' ? 'activity' : 'group';
        scene.scene.add(_this.group);

        await view.loaded();

        return view;
    }

    this.unmount = function() {
        if (_player && _player.destroy) _player.destroy();
        if (_this.group._parent) _this.group._parent.remove(_this.group);
        if (_view) _this.group.remove(_view.group);
        this._unmount();
    }

    this.activate = function(view, scene) {
        if (view == _view) return;

        GlobalEnvironment.instance().deactivate();
        if (_view && _view.isActive) _view.deactivate();

        (async function() {
            let hit = await view.getHitMesh();
            if (hit) {
                let {position, normal} = hit.geometry.attributes;
                let pos = new Float32Array(position.array);
                let n = new Float32Array(normal.array);
                let scale = hit.scale.toArray();
                _thread.mount({position: pos, normal: n, scale}, [pos.buffer, n.buffer]);

                //This is to check collisions for elements that avoid the user to be able to transport.
                let hitVR = await view.getHitMeshVR();
                if (hitVR) {
                    let {position, normal} = hitVR.geometry.attributes;
                    let posVR = new Float32Array(position.array);
                    let nVR = new Float32Array(normal.array);
                    let scaleVR = hitVR.scale.toArray();
                    _thread.mountVR({position: posVR, normal: nVR, scaleVR}, [posVR.buffer, nVR.buffer]);
                }
            } else {
                _thread.clear();
            }
        })();

        scene?.scene?.add?.(_this.group);
        _view = view;

        this._activate();

        addListeners();

        _this.group.add(_view.group);

        let player = _this.initClass(Player, PlayerClass, _view);
        _view.group.add(player.group);
        _player = player;
    }

    this.deactivate = function() {
        try {
            if (_player) {
                if (_view.group) _view.group.remove(_player.group);
                if (_player && _player.destroy) _player.destroy();
            }
        } catch(e) { }
        removeListeners();
        this._deactivate();
        if (_view) {
            _view.deactivate && _view.deactivate();
            _this.group.remove(_view.group);
            _view = null;
        }
    }

    this.registerPlayerClass = function(ref) {
        PlayerClass = ref;
        return this;
    }

    this.clone = function() {
        return new GroupEnvironment(true);
    }

    this.get('collision', _ => _thread);
    this.get('player', _ => _player);
    this.get('view', _ => _view);
}, 'singleton');

Class(function VideoChatZones(_config, _interaction) {
    Inherit(this, Object3D);
    const _this = this;
    var _connect, _disconnect, _prompt, _promptPromise, _block, _pendingUser, _view, _speaking, _speakingUniform, _joinedZone, _mediaAccessToast, _visibleTime;
    var _zones = [];
    var _zoneMap = {};
    var _debounce = {};
    var _target = new Group();
    var _v3 = new Vector3();

    const VR = Platform.usingVR();
    const JOIN_TEXT = formatText(_config.joinText || 'Would you like to join this video chat zone?');
    const DEBUG = false;
    const USER_MODEL = !!window.User?.profile;
    const DREAM_DND = !!window.DreamDND;
    const TOAST_TITLE = 'Your device does not allow media access.';
    const TOAST_DESC = 'Please fix your device settings and try again.';

    if (!_config.radius) _config.radius = 5;
    if (!_config.maxUsers) _config.maxUsers = 10;
    if (!_config.playerDistance) _config.playerDistance = 1;

    //*** Constructor
    (function () {
        _config.playerDistance *= VR ? 1.5 : 1;
        if(!_config.customPrompt) {
            _prompt = _this.initClass(UI3DPrompt, _config.prompt || {});
        }else{
            _prompt = _this.initClass(_config.customPrompt, _config.prompt || {});
        }
        _prompt.group.scale.setScalar(0);
        _prompt.scale = 1.25;
        _this.events.sub(_prompt, Events.COMPLETE, handlePromptEnd);

        _interaction.bindPlayerProximity(_config.playerDistance);
        _interaction.onProximityEvent = proximityEvent;
        _interaction.onRemovePlayer = playerDisconnect;
        _this.events.sub(Multiplayer.PIN, handlePin);
        // _this.events.sub(Multiplayer.ERROR, handleError);

        _this.events.sub(PlayerControls.SWITCH_VIEW, switchPlayerView);
        _this.events.sub(Router.BEFORE_UPDATE, onBeforeStateChange);

        _this.events.sub(Player.JOIN, playerJoin);
        _this.events.sub(Player.LEAVE, playerLeave);
        _this.events.sub(Events.VISIBILITY, visibilityEvent);

        _this.startRender(loop, 24);
        _this.parent.player?.state.bind('gcmedia_mute_video', localMuteVideo);
        _this.parent.player?.state.bind('gcmedia_mute_audio', localMuteAudio);
        _mediaAccessToast = _this.initClass(MediaAccessToast, {
            titleText: TOAST_TITLE,
            descText: TOAST_DESC
        },[_this.parent.getDOMElement()])
        GameCenterMedia.state.bind('hasMediaAccess', handleMediaAccess)

        _this.parent.player?.state.bind('gcmedia_mute_audio', localMuteAudio);
        _this.flag('visibility', true);

        Dev.expose('zones', _zones);
        Dev.expose('zoneMap', _zoneMap);
        Dev.expose('joinedZone', _ => {
            return _joinedZone;
        });
        setTimeout(prune, 1000);

        if (!VR) {
            _view = _this.initClass(DreamUI.VideoChatZonesUI, _config, [_this.parent.getDOMElement()]);
            _this.startRender(_ => {
                if (PlayerControls.getViewState() == '1st') {
                    _target.position.copy(World.CAMERA.position);
                    _target.position.add(_v3.set(0, 0, -1.5).applyQuaternion(World.CAMERA.quaternion));
                    _target.lookAt(World.CAMERA.position);
                    _prompt.group.position.lerp(_target.position, 0.1);
                    _prompt.group.quaternion.slerp(_target.quaternion, 0.1);
                } else {
                    let worldMesh = _prompt.group.getWorldPosition();
                    _target.quaternion.copy(World.CAMERA.quaternion);
                    _prompt.group.quaternion.slerp(_target.getWorldQuaternion(), 0.1);
                }
            });
        }
    })();

    function formatText(text) {
        if (_config.audioOnly) {
            if (text.includes('a video')) return text.replace('a video', 'an audio');
            return text.replace('video', 'audio');
        }
        return text;
    }

    function prune() {
        if (!_this.popAllZones) return;

        try {
            let uid = PlayerModel.get('uid') || Multiplayer.room.me.id;
            for (let i = _zones.length - 1; i > -1; i--) {
                let zone = _zones[i];
                if (zone.users.includes(uid) && (_joinedZone != zone || zone.position.distanceTo(_interaction.localPlayer.position) > _config.radius*1.01)) {
                    zone.forceLeave();
                }
            }
        } catch(e) {
            console.log(e);
        }
        setTimeout(prune, 1000);
    }

    async function createZone(pos) {
        if (_this.flag('pendingZone')) return;
        _this.flag('pendingZone', true, 1000);
        if (_this.flag('inZone')) return;

        for (let i = 0; i < _zones.length; i++) {
            let zone = _zones[i];
            if (zone.position.distanceTo(_interaction.localPlayer.position) < _config.radius*0.5) {
                if (DEBUG) console.log('bail on createZone because one already exists');
                return;
            }
        }

        if (DEBUG) console.log('createZone');
        Multiplayer.room.pin({chatZone: true, unique: Utils.uuid(), pos: pos.toArray(), radius: _config.radius}, 10800);
    }

    function joinZone(zone) {
        if (DEBUG) console.log('joinZone');
        if (_this.flag('inZone') || !zone.join) return;
        zone.join();
        _this.flag('inZone', true);
        Multiplayer.room.mediaId = zone.id;
        _joinedZone = zone;
        connect();
    }

    function canUseZones() {
        if (!GameCenterMedia.hasMediaAccess) return false;
        if (USER_MODEL) {
            if ((User.profile && User.profile.dnd) || DreamModeration?.isBanned()) return false
        }
        if (DREAM_DND && DreamDND.state.get('dnd')) return false;
        if (PlayerModel.get('localDND')) return false;
        if (_this.disabled) return false;

        return true;
    }

    async function handleError() {
        await _this.wait(1000);
        _zones.forEach(z => z.forceEnd());
    }

    function loop() {
        if (_prompt.zone && _prompt.zone.events == null) _prompt.zone = null;
        if (_joinedZone && _joinedZone.events == null) _joinedZone = null;

        if (!_joinedZone && _this.flag('connected')) {
            disconnect();
        }

        if (!canUseZones()) return;

        _this.interacting = _prompt.capture.isHitting;

        if (_block) {
            if (_interaction.localPlayer.position.distanceTo(_block) <= _config.radius*1.05) {
                return;
            } else {
                _this.flag('blockPrompts', false);
                _block = null;
            }
        }

        if (_pendingUser) {
            if (_interaction.localPlayer.position.distanceTo(_pendingUser) > _config.playerDistance*1.2) {
                _pendingUser = null;
                clearPrompt();
                _this.flag('swapPrompt', true, 100);
                return;
            }
        }

        for (let i = _zones.length-1; i > -1; i--) {
            let zone = _zones[i];
            if (zone.position.distanceTo(_interaction.localPlayer.position) < _config.radius) {
                // if (DEBUG) console.log('Outside of zone', _this.flag('inZone'), _joinedZone == zone);
                if (!_this.flag('inZone') && !_this.flag('openPrompt')) {
                    if (_this.flag('granted')) joinZone(zone);
                    else {
                        if (zone.canJoin()) {
                            if (DEBUG) console.log('near a zone, prompting to join it');
                            prompt(JOIN_TEXT, zone.position, zone.users).then(confirm => {
                                if (confirm == 'disappear' || confirm === undefined) return;
                                if (confirm) joinZone(zone);
                                else block(zone.position);
                            });
                            _prompt.zone = zone;
                        }
                    }
                }
            } else {
                // if (DEBUG) console.log('Outside of zone', _this.flag('inZone'), _joinedZone == zone);
                if (_this.flag('inZone') && _joinedZone == zone) {
                    if (DEBUG) console.log('went outside the zone');
                    zone.leave();
                    _joinedZone = null;
                    _this.flag('inZone', false);
                    disconnect();
                }

                if (_prompt.showing && (!!_prompt.zone && _prompt.zone == zone) && _this.flag('openPrompt')) {
                    if (DEBUG) console.log('Hide prompt because moved far away');
                    clearPrompt();
                }
            }
        }
    }

    async function connect() {
        if (_this.flag('connecting')) return;
        _this.flag('connecting', true);
        if (DEBUG) console.log('Connecting');
        await _connect;
        await _disconnect;
        _connect = await GameCenterMedia.useRoom(Multiplayer.room);
        _view?.connect();
        _this.delayedCall(_ => {
            if (VideoChatZones.localVideoMuted) GameCenterMedia.userStream.disableVideo();
            if (VideoChatZones.localAudioMuted) GameCenterMedia.userStream.disableAudio();
            AVSettingsController.instance().audioEnabled = !VideoChatZones.localAudioMuted;
            AVSettingsController.instance().videoEnabled = !VideoChatZones.localVideoMuted;
        }, 100);
        _this.flag('connecting', false);
        _this.flag('connected', true);
        if (DEBUG) console.log('Connected');
        _this.events.fire(VideoChatZones.CONNECTED);
    }

    async function disconnect() {
        _joinedZone = null;
        _this.flag('inZone', false);
        _this.flag('connected', false);
        _this.parent.avatarProfileGrid?.removeAllVideo();
        if (DEBUG) console.log('Disconnecting');
        await _connect;
        await _disconnect;
        _this.flag('disconnecting', true);
        _disconnect = await GameCenterMedia.useRoom(false);
        _view?.disconnect();
        if (DEBUG) console.log('Disconnected');
        _this.flag('disconnecting', false);
        PlayerModel.set('gcmedia_speaking', false);
        _this.events.fire(VideoChatZones.DISCONNECTED);
    }

    function block(pos) {
        if (DEBUG) console.log('said no, block zone');
        _block = pos;
        _this.flag('blockPrompts', true);
    }

    function clearPrompt() {
        if (!_promptPromise) return;
        _promptPromise.resolve('disappear');
        _prompt.animateOut();
        _this.flag('openPrompt', false);
        _this.flag('debouncePrompt', true, 1000);
        _prompt.showing = false;
    }

    //*** Event handlers
    function proximityEvent(player) {
        if (_this._invisible) return;
        if (!player.group) return;
        if (!_this.flag('swapPrompt')) {
            if (_this.flag('inZone') || _this.flag('openPrompt') || _this.flag('blockPrompts') || _this.flag('debouncePrompt')) return;
        }

        if (!canUseZones()) return;

        if (_joinedZone || TriggerZone.IS_INSIDE || TriggerZone.IS_NEARBY) return;

        if (_interaction.localPlayer.position.distanceTo(player.group.position) > _config.radius || player.hidden) return;

        if (_config.blockSpawnArea) {
            if (_interaction.localPlayer.position.distanceTo(_config.blockSpawnArea.pos) < _config.blockSpawnArea.radius) return;
        }

        if (_config.blockMoreArea) {
            for (let i = _config.blockMoreArea.length-1; i > -1; i--) {
                let area = _config.blockMoreArea[i];
                if (area && area.pos && area.radius) {
                    if (_interaction.localPlayer.position.distanceTo(area.pos) < area.radius) return;
                }
            }
        }

        for (let i = _zones.length-1; i > -1; i--) {
            let zone = _zones[i];
            if (zone.position.distanceTo(player.group.position) < _config.radius*1.85) return;
        }

        _pendingUser = player.group.position;
        if (_debounce.player != player) {
            _debounce.player = player;
            _debounce.count = 0;
            return;
        }

        if (_debounce.count++ < 10) return;

        if (DEBUG) console.log('Got the proximity event near another player, showing prompt');

        _prompt.zone = null;
        prompt(JOIN_TEXT, player.group.position, [player.state.get('uid')]).then(confirm => {
            if (DEBUG && confirm == 'disappear') console.log('Bailing on prompt because disappear');
            if (confirm == 'disappear' || confirm === undefined) return;
            if (confirm) createZone(_pendingUser);
            else block(_pendingUser);
        });
    }

    function visibilityEvent(e) {
        _this.flag('visibility', e.type == 'focus')
    }

    function playerDisconnect(player) {
        // if (_this._invisible || Multiplayer.leaving) return;
        // for (let i = 0; i < _zones.length; i++) {
        //     _zones[i].onDisconnect(player);
        // }
    }

    async function playerJoin({player}) {
        if (_this._invisible) return;

        if (!player.view) return;
        await player.view.ready();
        if (!player.view) return;

        if (player.gcPlayer && !player.gcPlayer.me) {
            if (!_this.parent.multiplayerConfig?.roomKey) return;
        }

        let mesh = player.view.mesh;
        player.bindSpeakingVZ = player.state.bind('gcmedia_speaking', speaking => {
            if (_speakingUniform) mesh.shader?.set(_speakingUniform, speaking ? 1 : 0);
        });

        player.bindMuteAudioVZ = player.state.bind('gcmedia_mute_audio', speaking => {
            if (_speakingUniform) mesh.shader?.set(_speakingUniform, 0);
        });
    }

    function playerLeave({player}) {
        if (_this._invisible) return;

        player.bindSpeakingVZ?.destroy?.();
        player.bindMuteAudioVZ?.destroy?.();
    }

    function onBeforeStateChange(e) {
        if (_this.flag('connected')) {
            _this.flag('blockPromptsDisconnecting', true, 2000);
            e.addGuard(disconnect());
        }
    }

    function localMuteVideo(muted) {
        if (_this.flag('disconnecting')) return;
        VideoChatZones.localVideoMuted = muted;
    }

    function localMuteAudio(muted) {
        if (_this.flag('disconnecting')) return;
        VideoChatZones.localAudioMuted = muted;
    }

    function handleMediaAccess(state) {
        switch (state) {
            case 'success':
                _mediaAccessToast?.hide?.()
                break;
            case 'fail':
                _mediaAccessToast?.show?.();
                break;
            default:
               break;
        }
    }

    function switchPlayerView() {
        clearPrompt();
    }

    function isInvalid(array) {
        let a = [];
        for (let i = 0; i < array.length; i++) {
            let id = array[i];
            if (a.includes(id)) return true;
            a.push(id);
        }
        return false;
    }

    function handlePin({message}) {
        if (_this._invisible) return;

        if (message.chatZone) {
            let id = message.unique;
            if (_zoneMap[id]) {
                _zoneMap[id].update(message);
                return;
            }

            if (_this.disabled) return;

            if (Array.isArray(message.users) && (!message.users.length || isInvalid(message.users))) return;

            let testPos = new Vector3().fromArray(message.pos);
            for (let i = 0; i < _zones.length; i++) {
                if (id != _zones[i].id && _zones[i].position.distanceTo(testPos) < _config.radius*0.8) {
                    if (!_this.flag('kill_zone_'+id)) {
                        _this.flag('kill_zone_'+id, true, 5000);
                        if (DEBUG) console.log(`Kill zone ${id} because one already exists`);
                        let pushArray = {key: 'users', value: '0'};
                        let popArray = {key: 'users', value: '0'};
                        Multiplayer.room.pin({chatZone: true, unique: id, pushArray, popArray}, 99999);
                    }
                    return;
                }
            }

            // if (!_this.flag('visibility')) return;

            if (DEBUG) console.log(`initClass VideoChatZone ${id}`, message);
            let zone = _this.initClass(VideoChatZone, message.pos, id, _config, message.users);
            _this.events.sub(zone, Events.END, _ => {
                _zones.remove(zone);
                _this.group.remove(zone.group);
                delete _zoneMap[id];
                if (_prompt.zone == zone) clearPrompt();
                zone.destroy();
                if (DEBUG) console.log(`destroy VideoChatZone ${id}`);
            });
            _zones.push(zone);
            _zoneMap[id] = zone;

            if (zone.position.distanceTo(_interaction.localPlayer.position) < _config.radius) {
                _prompt.zone = zone;
            }
        }
    }

    async function prompt(text, pos, otherUserIds) {
        if (_this.flag('blockPromptsDisconnecting')) return;
        if (_this.flag('debouncePrompt') && !_this.flag('swapPrompt')) return;

        if (window.User && DreamModeration?.isBlockedByUsers?.(otherUserIds)) {
            if (!Config.PROD) console.log('BLOCKED! blocked by one of the other users, dont show prompt');
            return false;
        }

        if (otherUserIds.length == 1) {
            if (window.User && DreamModeration?.isBlocked?.(otherUserIds[0])) {
                if (!Config.PROD) console.log('BLOCKED! i have blocked this other user, dont show prompt')
                _this.flag('openPrompt', false);
                return false;
            }
        } else if (otherUserIds.length > 1) {
            for (let i = 0; i < otherUserIds.length; i++) {
                if (window.User && DreamModeration?.isBlocked?.(otherUserIds[i])) {
                    if (!Config.PROD) console.log('BLOCKED! i have blocked one of the users in this chat zone, dont show prompt')
                    _this.flag('openPrompt', false);
                    return false;
                }
            }
        }

        _this.flag('openPrompt', true);

        _prompt.group.position.copy(pos);
        _prompt.setText(text);
        if (VR || PlayerControls.getViewState() == '1st') {
            await _this.wait(100);
            _prompt.scale = 0.4;
            let worldPos = World.CAMERA.getWorldPosition();
            _prompt.group.position.copy(worldPos);
            _prompt.group.position.y -= 0.25;
            _prompt.group.position.add(new Vector3(0, 0, -1).applyQuaternion(World.CAMERA.getWorldQuaternion()));
            _prompt.group.lookAt(worldPos);
        } else {
            _prompt.scale = 1;
        }
        _this.events.fire(VideoChatZones.PROMPT);
        _prompt.animateIn();
        _prompt.showing = true;
        _promptPromise = Promise.create();
        await _promptPromise;
        _prompt.animateOut();
        _this.flag('openPrompt', false);
        _this.flag('debouncePrompt', true, 1000);
        _prompt.showing = false;
        return _promptPromise;
    }

    function handlePromptEnd(e) {
        _promptPromise.resolve(e.shouldStart);
        if (e.shouldStart) _this.flag('granted', true, 1000);
    }


    //*** Public methods
    this.get('dialog', _ => _prompt);

    this.onDestroy = function() {
        _this.parent.group.remove(_this.group);
    }

    this.onVisible = function() {
        _visibleTime = Render.TIME;
    }

    this.onInvisible = function() {
        disconnect();
    }

    this.popAllZones = function() {
        if (_this.disabled) return;
        _this.disabled = true;
        if (_this.flag('connected')) {
            _joinedZone?.leave();
            disconnect();
        }
    }

    this.setSpeakingUniform = function(key) {
        _speakingUniform = key;
        return this;
    }

    this.addBlockedArea = function(obj) {
        if (!_config.blockMoreArea) _config.blockMoreArea = [];
        if (Array.isArray(obj)) {
            obj.forEach(o => {
                if (!o.pos || !o.radius) throw `addBlockedArea requires .pos && .radius`;
                _config.blockMoreArea.push(o)
            });
        } else {
            if (!obj.pos || !obj.radius) throw `addBlockedArea requires .pos && .radius`;
            _config.blockMoreArea.push(obj);
        }
    }
}, _ => {
    VideoChatZones.PROMPT = 'video_chat_zones_prompt';
    VideoChatZones.CONNECTED = 'video_chat_zones_connected';
    VideoChatZones.DISCONNECTED = 'video_chat_zones_disconnected';
});
Class(function GlobalViewCamera(_env) {
    Inherit(this, Component);
    const _this = this;
    var _input, _config, _camera, _scroll, _disabled;

    var _v2 = new Vector2();
    var _holdPos = new Vector3();
    var _target = new Vector3();
    var _move = new Vector3();
    var _bounding = new Vector2();
    var _zoomIn = new Vector3();
    var _zoomOut = new Vector3();
    var _dragScale = 1;

    var _v3 = new Vector3();
    var _v31 = new Vector3();

    var _targetZoom = 0;
    var _zoom = 0;

    const PROHIBITED_ELEMENTS = ['hit', 'prevent_interaction'];

    //*** Constructor
    (async function () {
        _camera = new GazeCamera();
        _camera.prefix = 'global_cam';
        _camera.lock();

        initScroll();
        initInput();
        addListeners();
        _this.startRender(loop);
        
        CameraUIL.add(_camera);

        Stage.cursor('grab', _this);
        _this.flag('cursor', 'grab');
    })();

    function checkIfProhibited(e) {
        let element = document.elementFromPoint(Math.clamp(e.x || 0, 0, Stage.width), Math.clamp(e.y || 0, 0, Stage.height));
        if (element) {
            let el = element;
            while (el) {
                if (el.classList && el.classList.contains(PROHIBITED_ELEMENTS)) {
                    if (_this.flag('cursor') != 'auto') {
                        Stage.cursor('auto', _this);
                        _this.flag('cursor', 'auto');
                    }
                    return true;
                }
                el = el.parentNode;
            }
        } else {
            if (_this.flag('cursor') != 'grab') {
                Stage.cursor('grab', _this);
                _this.flag('cursor', 'grab');
            }
        }
        return false;
    }

    function initInput() {
        _config = InputUIL.create(`camera_${Utils.getConstructorName(_env)}`);
        _config.setLabel('Global Camera');
        _config.addVector('positionIn', [0, 13, 16]);
        _config.addVector('positionOut', [0, 13, 16]);
        _config.addVector('rotation', [0, 0, 0]);
        _config.addVector('lookAt', [0, 0, 0]);
        _config.addVector('bounding', [15, 15]);
        _config.addNumber('dragScale', 1);
        _config.addNumber('orbitAmount', 1);
        _config.addNumber('startZoom', 0.1);

        _config.onUpdate = _ => {
            _zoomIn.fromArray(_config.get('positionIn') || []);
            _zoomOut.fromArray(_config.get('positionOut') || []);
            _camera.position.fromArray(_config.get('positionOut') || []);
            _camera.lookAt.fromArray(_config.get('lookAt') || [0, 0, 0]);
            _camera.group.rotation.fromArray(radians(_config.get('rotation') || [0, 0, 0]));
            _bounding.fromArray(_config.get('bounding') || [15, 15]);
            _dragScale = _config.getNumber('dragScale') || 1;
            _camera.moveXY.setScalar(_config.getNumber('orbitAmount') || 1);
            _targetZoom = _zoom = _config.getNumber('startZoom');
        };

        _config.onUpdate();
    }

    function initScroll() {
        _scroll = _this.initClass(Scroll, {limit: false, lockMouseX: true});
        _scroll.enabled = !Global.PLAYGROUND;
    }

    function radians(array) {
        return [...array.map(v => Math.radians(v))];
    }

    function loop() {
        _targetZoom -= _scroll.delta.y * 0.008;
        _targetZoom = Math.clamp(_targetZoom, 0, 1);
        _zoom = Math.lerp(_targetZoom, _zoom, 0.1);
        _v3.copy(_zoomOut).lerp(_zoomIn, _zoom);
        _camera.position.set(_v3.x, _v3.y, _v3.z, true);
        _camera.group.position.lerp(_target, 0.07);
    }

    //*** Event handlers
    function addListeners() {
        _input = _this.initClass(Interaction, Stage);
        _input.ignoreLeave = true;
        _this.events.sub(_input, Interaction.START, touchStart);
        _this.events.sub(_input, Interaction.MOVE, touchMove);
        _this.events.sub(_input, Interaction.END, touchEnd);
    }

    function touchStart(e) {
        if (checkIfProhibited(e)) return;
        if (_disabled) return;
        _this.flag('dragging', true);
        _holdPos.copy(_camera.group.position);
        Stage.cursor('grabbing', _this);
    }

    function touchMove(e) {
        if (checkIfProhibited(e)) return;
        if (_disabled) return;
        if (!_this.flag('dragging')) return;
        _v2.copy(e).sub(_input.hold);

        _move.x = _holdPos.x + -_v2.x * 0.03 * _dragScale;
        _move.z = _holdPos.z + -_v2.y * 0.03 * _dragScale;
        _move.applyQuaternion(_camera.group.quaternion);

        _target.copy(_move);

        if (_target.x > _bounding.x) _target.x = _bounding.x;
        if (_target.x < -_bounding.x) _target.x = -_bounding.x;
        if (_target.z > _bounding.y) _target.z = _bounding.y;
        if (_target.z < -_bounding.y) _target.z = -_bounding.y;
        _target.y = 0;
    }

    function touchEnd(e) {
        if (checkIfProhibited(e)) return;
        if (_disabled) return;
        _this.flag('dragging', false);
        Stage.cursor('grab', _this);
    }

    //*** Public methods
    this.setFOV = function(fov) {
        _camera.setFOV(fov);
    };

    this.onDestroy = function() {
        Stage.cursor('auto', _this);
    }

    this.disable = function() {
        Stage.cursor('auto', _this);
        _disabled = true;
    }

    this.enable = function() {
        Stage.cursor('grab', _this);
        _disabled = false;

    }
});
Class(function Multiplayer() {
    Inherit(this, Component);
    const _this = this;
    var _room, _serverId, _leaving, _joining;

    const DEBUG = Utils.query('localsocket');
    const consoleSecurity = require('ConsoleSecurity');

    this.ROOM = 'multiplayer_room';
    this.PIN = 'multiplayer_pin';
    this.UNPIN = 'multiplayer_unpin';
    this.ERROR = 'multiplayer_error';

    //*** Constructor
    (async function () {
        await Hydra.ready();
        await AssetLoader.waitForLib('GameCenter');
        addListeners();
        connect();
    })();

    function connect() {
        if (Config.DISABLE_SOCKET === true) return;

        GameCenter.ports = Config.GAMECENTER_PORTS;
        GameCenter.connect(Config.GAMECENTER_SOCKET);

        if (Config.FM_DISTRIBUTOR || Config.FM_GATEWAY) {
            if (Config.FM_MAX_BITRATE) GameCenterMedia.maxBitrate = Config.FM_MAX_BITRATE;
            if (Config.FM_DISTRIBUTOR) GameCenterMedia.fmLoadBalancer = Config.FM_DISTRIBUTOR;
            GameCenterMedia.connect(Config.FM_GATEWAY, Config.FM_APP_ID, Config.FM_SHARED_SECRET);
        }

        _this.events.sub(GameCenter.BLOCKED_ERROR, gameCenterBlocked);
    }

    async function leave() {
        _this.leaving = true;
        if (_joining) await _joining;
        if (_leaving) await _leaving;
        if (!_room) return;
        _leaving = Promise.create();
        PhysicalSync.useRoom(null);
        if (_room && _room.leave) _room.leave();
        _room = null;
        PlayerModel.useRoom(null);
        await GameCenterMedia.useRoom(null);
        _leaving.resolve();
        _leaving = null;
        _this.leaving = false;
    }

    //*** Event handlers
    function handlePin(e) {
        _this.events.fire(_this.PIN, e);
    }

    function handleUnpin(e) {
        _this.events.fire(_this.UNPIN, e);
    }

    function gameCenterBlocked() {
        //display error screen
    }

    function addListeners() {
        _this.events.sub(GameCenter.BLOCKED_ERROR, blocked);
        _this.events.sub(GameCenter.LOST_CONNECTION, leave);
    }

    function handleError() {
        if (_room) {
            _this.events.fire(_this.ERROR);
            leave();
        }
    }

    function blocked() {
        let timer = _this.delayedCall(_ => {
            alert(`Looks like you may be experiencing networking issues preventing access to some services required for the virtual event.
Please try to visit on another computer or network, or contact your IT administrator.
If the issue persists, please fill out the help form with as much detail as you can for us to assist you.`);
        }, 10000);
        _this.events.sub(Worlds.LOADED, _ => clearTimeout(timer));
    }

    //*** Public methods
    this.establish = async function (obj) {
        if (_room) leave();
        if (_leaving) await _leaving;
        if (_joining) await _joining;

        _joining = Promise.create();

        await _this.wait(100);
        if (obj.serverId && _serverId != obj.serverId) {
            _serverId = obj.serverId;
            await GameCenter.connect(`${Config.GAMECENTER_SOCKET}/${obj.serverId}`);
        } else if (_serverId) {
            _serverId = null;
            await GameCenter.connect(Config.GAMECENTER_SOCKET);
        }

        try {
            if (obj.roomId) {
                let fn = obj.watcher ? GameCenter.watchRoom : GameCenter.joinRoom;
                obj.type = `${obj.roomKey}/${obj.roomId}`;
                _room = await fn(`${obj.community ? 'community_' : ''}${obj.type}${obj.silent ? '_silent' : ''}`, obj);
            } else {
                _room = await GameCenter.findRoom(`${obj.community ? 'community_' : ''}${obj.roomKey}${obj.silent ? '_silent' : ''}`, obj);
            }
        } catch (e) {

        }

        Dev.expose('room', _room);

        _this.events.sub(_room, GameCenterRoom.PIN, handlePin);
        _this.events.sub(_room, GameCenterRoom.ERROR, handleError);
        _this.events.sub(_room, GameCenterRoom.UNPIN, handleUnpin);
        _this.events.fire(_this.ROOM, { room: _room });

        PhysicalSync.useRoom(_room);
        PlayerModel.useRoom(_room);
        if (!obj.chatZones) await GameCenterMedia.useRoom(_room);

        _this.delayedCall(_ => _joining.resolve(), 100);
        return _room;
    };

    this.failed = function () {
        _joining?.resolve();
        _leaving?.resolve();
    };

    this.reset = function () {
        return leave();
    };

    this.pin = function (data, timeInSeconds) {
        if (_room) _room.pin(data, timeInSeconds);
    };

    this.unpin = function (data) {
        if (_room) _room.unpin(data);
    };

    this.get('room', _ => {
        if (!Hydra.LOCAL && consoleSecurity()) return false;
        return _room;
    });

    this.getRoomCount = async function (roomId) {
        roomId = `community_${roomId}`;
        let result = await GameCenter.getRoomCount(roomId);
        return result.count;
    };
}, 'static');

Class(function DreamColors() {
    Inherit(this, Component);

    const _this = this;

    //*** Constructor
    (function () {
        _this.black = '#000';
        _this.primary = '#9b66d3';
        _this.gray = '#ccc';
        _this.red = '#f00';
        _this.yellow = '#ffcf00';
        _this.steel = '#6d7278';
        _this.white = '#fff';
        _this.green = '#55b750';
        _this.blue = '#1B81F9';
        _this.accessibility = hexToRgba(_this.primary, 0.8);

        //*** Default.
        _this.online = '#00E532';
        
        _this.gray800 = '#3C4043';
        _this.gray600 = '#80868B';
        _this.gray500 = '#959CA5';
        _this.gray300 = '#DADCE0';
        _this.gray200 = '#F1F3F4';
        _this.gray50 = '#FAFAFA';

        _this.blue600 = '#1A73E8';
        _this.blue500 = '#4285F4';
        _this.blue200 = '#72ABF1';
        _this.blue100 = '#E7F5F7';
        _this.blue50 = '#F6F9FE';

        _this.yellow600 = '#F9AB00';
        _this.yellow500 = '#FBBC04';
        _this.yellow200 = '#F5C64B';
        _this.yellow100 = '#F4EDE6';

        _this.green600 = '#1E8E3E';
        _this.green500 = '#34A853';
        _this.green200 = '#73C16B';
        _this.green100 = '#E4EFE6';

        _this.red600 = '#D93025';
        _this.red500 = '#EA4335';
        _this.red200 = '#F7BBBE';
        _this.red100 = '#F9EDED';
    })();

    function hexToRgba(hex, opacity) {
        let c;
        if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
            c = hex.substring(1).split('');
            if (c.length === 3) {
                c = [c[0], c[0], c[1], c[1], c[2], c[2]];
            }
            c = `0x${c.join('')}`;
            return `rgba(${[(c >> 16) & 255, (c >> 8) & 255, c & 255].join(',')},${opacity})`;
        }
        throw new Error('Bad Hex');
    }

    //*** Public methods
    /**
     * @name hexToRgba
     * @memberOf DreamColors
     * @type {function(*=, *): (string|undefined)}
     */
    this.hexToRgba = hexToRgba;

    this.setColors = colors => {
        if (colors) {
            Object.keys(colors).forEach(key => {
                _this[key] = colors[key];
            });
        }

        _this.flag('isReady', true);
    };

    this.ready = function() {
        return _this.wait('isReady');
    };
}, 'singleton');

/**
 * @name DreamComponentConfig
 *
 *  A class to store components and/or their config, to override core components/config
 *
 * A core component can enhance sub-component instatiation using this class with something like the following
 * _this.initClass(DreamComponentConfig.instance().coreComponent || CoreComponent)
 *
 * You can also store config/props used within a core component instead of the entire component itself. From within a project you can update those props
 *
 * Where <CoreComponent> is some exisiting component in Dream that exists outside of Modules
 *
 * A Dream project should call setComponents() from within its global file, though it's probably not necessary to do so
 * if you're not overriding any components:
 *
 * If the core compoenent calling this class is lazy-loaded (i.e. not the first thing a user sees) then probably no await DreamComponentConfig.instance().ready()
 * is necessary in the core component calling this class
 *
 * But if not lazy loaded, probably best to await DreamComponentConfig.instance().ready()
 */
Class(function DreamComponentConfig() {
    Inherit(this, Component);

    const _this = this;

    //*** Constructor
    (function () {
    })();



    this.setComponents = component => {
        if (component) {
            Object.keys(component).forEach(key => {
                _this[key] = component[key];
            });
        }

        _this.flag('isReady', true);
    };

    this.ready = function() {
        return _this.wait('isReady');
    };
}, 'singleton');

Class(function DreamStyleguide() {
    Inherit(this, Component);

    const _this = this;


    //*** Public methods
    this.setStyles = styles => {
        if (styles) {
            Object.keys(styles).forEach(key => {
                _this[key] = styles[key];
            });
        }
    };

    this.init = ({ fonts = { primary: 'Manrope' }, styles } = {}) => {
        _this.fonts = fonts;

        //*** Titles.
        _this.h1 = {
            font: `400 5.6rem/120% ${_this.fonts.primary}`
        };

        _this.h2 = {
            font: `400 4rem/135% ${_this.fonts.primary}`
        };

        _this.h3 = {
            font: `400 3.4rem/140% ${_this.fonts.primary}`
        };

        _this.h4 = {
            font: `400 2.8rem/140% ${_this.fonts.primary}`
        };

        _this.h5 = {
            font: `400 2.4rem/130% ${_this.fonts.primary}`
        };

        //*** Copy.
        _this.bodyLarge = {
            font: `400 1.6rem/150% ${_this.fonts.primary}`
        };

        _this.bodyMedium = {
            font: `400 1.5rem/150% ${_this.fonts.primary}`
        };

        _this.bodySmall = {
            font: `400 1.3rem/140% ${_this.fonts.primary}`
        };

        //*** Labels.
        _this.label0 = {
            font: `500 1.2rem/110% ${_this.fonts.primary}`,
        };

        _this.label1 = {
            font: `500 1.3rem/120% ${_this.fonts.primary}`,
        };
        
        _this.label2 = {
            font: `500 1.4rem/130% ${_this.fonts.primary}`,
        };
        
        _this.label3 = {
            font: `500 1.5rem/130% ${_this.fonts.primary}`,
        };
        
        _this.label4 = {
            font: `500 1.7rem/150% ${_this.fonts.primary}`,
        };
        
        _this.label5 = {
            font: `500 2rem/145% ${_this.fonts.primary}`,
        };

        //*** Button.
        _this.buttonSmall = {
            font: `400 1.35rem/100% ${_this.fonts.primary}`
        };

        _this.buttonMedium = {
            font: `400 1.4rem/100% ${_this.fonts.primary}`
        };

        _this.buttonLarge = {
            font: `400 1.7rem/100% ${_this.fonts.primary}`
        };

        //*** Misc.
        _this.p1 = {
            fontFamily: _this.fonts.primary,
            fontSize: '1.6rem',
            lineHeight: '1.4'
        };

        _this.p2 = {
            fontFamily: _this.fonts.primary,
            fontSize: '1.5rem',
            lineHeight: '1.4'
        };

        _this.p3 = {
            fontFamily: _this.fonts.primary,
            fontSize: '1.4rem',
            lineHeight: '1.3'
        };

        _this.button = {
            fontFamily: _this.fonts.primary,
            fontSize: '1.5rem'
        };

        _this.l1 = {
            fontFamily: _this.fonts.primary,
            fontSize: '1rem'
        };

        _this.withAccessibility = {
            boxShadow: `0 0 0 0.25rem ${DreamColors.instance().accessibility}`
        };

        _this.withoutAccessibility = {
            boxShadow: 'none'
        };

        _this.visuallyHidden = {
            border: 0,
            clip: 'rect(0 0 0 0)',
            height: '1px',
            margin: '-1px',
            overflow: 'hidden',
            padding: 0,
            position: 'absolute',
            width: '1px'
        };

        if (styles) this.setStyles(styles);

        _this.flag('isReady', true);
    };

    this.ready = function() {
        return _this.wait('isReady');
    };
}, 'singleton');

Class(function Platform() {
    Inherit(this, Component);
    var _this = this;
    var _focusPromise;

    var _required = {};
    var _proxies = [];
    var _static = {};

    this.isDreamPlatform = true;
    this.PATH = Hydra.LOCAL ? (`${location.protocol}//${location.host}${location.pathname}`).toLowerCase() : `${location.protocol}//${location.host}/`;

    // check if base href exists on page, use as base path if so
    var bases = document.getElementsByTagName('base');
    if (bases.length > 0) this.PATH = bases[0].href;

    this.visibility = 'visible';

    //*** Constructor
    (function () {
        if (_this.PATH.slice(-2) == '//') _this.PATH = `${_this.PATH.slice(0, -2)}/`;
        Assets.BASE_PATH = _this.PATH;
        Assets.registerPath(_this.PATH, window.ASSETS);
        addListeners();
    })();

    //*** Event handlers
    function addListeners() {
        _this.events.sub(Events.VISIBILITY, onVisibility);
    }

    function onVisibility(e) {
        if (e.type == 'focus') {
            _this.visibility = 'visible';
            _focusPromise && _focusPromise.resolve();
        } else {
            _this.visibility = 'blur';
            _focusPromise = null;
        }
    }

    //*** Public methods
    this.waitForFocus = function () {
        if (!_focusPromise) _focusPromise = Promise.create();
        return _focusPromise;
    };

    this.mount = function () {
        if (window.Config) {
            if (Config.MOUNTS) return Promise.all(Config.MOUNTS.map(name => _this.require(name, true, true)));
        }
    };

    this.usingVR = function () {
        if (!Hydra.LOCAL && window.CustomWebXRPolyfill) return false;

        if (Device.system.xr.vr) {
            // if (window.CustomWebXRPolyfill) return true;
            if (Device.mobile || Device.detect('oculus')) return true;

            return Storage.get('using_desktop_vr');
        }

        return false;
    };

    this.desktopVRAvailable = function () {
        if (Device.mobile || Device.detect('oculus')) return false;
        return Device.system.xr.vr;
    };

    this.toggleDesktopVR = function (bool) {
        Storage.set('using_desktop_vr', bool);
        location.reload();
    };

    this.useFXAA = function () {
        if (GPU.OVERSIZED) return false;
        if (GPU.lt(0)) return false;
        if (GPU.mobileLT(2)) return false;
        return true;
    };

    this.blurFX = function () {
        return GPU.gt(2);
    };

    this.getPath = function (path) {
        if (path.includes('http')) return path;
        return _this.PATH + path;
    };

    this.require = async function (perma, forceReload, assets) {
        if (!forceReload && _required[perma]) return;
        _required[perma] = true;
        let env = new WorldEnvironment(perma, true);
        if (assets) await env.evaluateWithAssets();
        else await env.evaluate();
    };

    this.prefetchVRWorld = async function () {
        if (Config.PLATFORM_CONFIG) {
            if (Config.VR_MOUNTS) return Promise.all(Config.VR_MOUNTS.map(name => _this.require(name, true, true)));
        }

        let key = _this.getRoute(Router.getState()[0] || Config.DEFAULT_ROUTE);

        Worlds.stash[key] = await _this.require(key, true, true);
    };

    this.preloadWorldAndLayout = function(world, layout) {
        new PreloadWorldLayout(world, layout);
    }

    this.overrideVREntry = function () {
        _this.vrEntryOverride = true;
    };

    this.enterVR = async function () {
        if (_this.flag('enterVR')) return;
        _this.flag('enterVR', true, 2000);
        await World.instance().initXR(RenderManager.WEBVR);
        Worlds.instance();
        Stage.hide();
    };

    this.get('namespace', _ => window);

    this.runtimeES5 = function (submodule) {
        let promise = Promise.create();
        let modulePath = window.location.href.split('#!')[0].replace('platform/', `sections/${submodule}/`);
        var xhr = new XMLHttpRequest();
        xhr.open('GET', `http://${window.location.hostname}/runtime/?${modulePath}`, true);
        xhr.send();
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4) promise.resolve();
        };

        return promise;
    };

    this.registerRoutes = function (routes) {
        _proxies = routes.map(({ path, world }) => {
            let regex = typeof path === 'object' ? new RegExp(path) : `^${path}\/?$`;

            return {
                regex,
                world
            };
        });
    };

    this.getRoute = function (perma) {
        if (!Global.PLAYGROUND) {
            let proxy = _proxies.find(({ regex, world }) => new RegExp(regex).test(perma));

            if (proxy) {
                let route = proxy.world;

                if (typeof proxy.world === 'function') {
                    route = proxy.world();
                }

                return route;
            }
        }

        return perma.split('/')[0];
    };
}, 'static');

Class(function AppStyleController() {
    Inherit(this, Component);
    const _this = this;
    var _styleguide, _colors;

    _this.STYLEGUIDE_CHANGE = 'app_style_controller_styleguide_change';
    _this.COLORS_CHANGE = 'app_style_controller_colors_change';

    //*** Constructor
    (function () {
        _styleguide = Styleguide;
        _colors = Colors;
    })();

    //*** Public methods

    this.get('styleguide',()=> {
        return _styleguide;
    })

    this.get('colors', ()=>{
       return _colors;
    })

     this.set('styleguide',(styleguide)=> {
         _styleguide = styleguide;
         _this.events.fire(_this.STYLEGUIDE_CHANGE,{styleguide:_styleguide})
     })

     this.set('colors', (colors)=>{
        _colors = colors;
        _this.events.fire(_this.COLORS_CHANGE,{colors:_colors})
     })

},'static');
Class(function Player(PlayerClass, _env, _id, _player) {
    Inherit(this, PhysicalLink, _id);
    Inherit(this, Object3D);
    const _this = this;
    var _view, _vrL, _vrR;

    var _isLocal = false;
    var _isLocalVR = false;

    const ENV_KEY = Utils.getConstructorName(_env);

    this.gcPlayer = _player;
    this.state = AppState.createLocal();

    var _scale = {value: 1};

    //*** Constructor
    (async function () {
        setupData();

        if (_player) _player.dreamPlayer = _this;
        _this.view = _view = _this.initClass(PlayerClass);

        if (!_id) initLocal();
        else initRemote();

        _this.startRender(loop, World.NUKE);

        defer(_ => {
            _this.events?.fire?.(Player.JOIN, {player: _this});
        });
    })();

    function loop() {
        let isZero = _this.group.position.x == 0 && _this.group.position.y == 0 && _this.group.position.z == 0;
        let hidden = !_isLocal && isZero;
        if (_isLocalVR) hidden = true;

        if (!hidden) {
            if (_this.flag('hidden')) {
                _this.flag('hidden', false);
                _scale.value = 0;
                tween(_scale, {value: 1}, 300, 'easeOutCubic', 500);
            }
        } else {
            if (!_this.flag('hidden')) _this.flag('hidden', true);
        }

        let scale = _scale.value * (hidden ? 0 : 1);

        if (_isLocalVR || (!isZero && _isLocal && PlayerControls.getViewState() == '1st')) scale = 0;

        if (DreamWorld.active) {
            let frustum = DreamWorld.active.frustum;
            let sphere = DreamWorld.active.testSphere;
            if (frustum && sphere) {
                sphere.center.copy(_this.group.position);
                if (!frustum.intersectsSphere(sphere)) scale = 0;
            }
        }

        _this.group.scale.setScalar(scale);
        _this.hidden = hidden;
    }

    function initVRObjects() {
        _vrL = new Group();
        _vrR = new Group();
        _vrL.posTarget = new Vector4();
        _vrL.pos4 = new Vector4();
        _vrR.posTarget = new Vector4();
        _vrR.pos4 = new Vector4();

        _this.isVR = true;
        _this.vrHandL = _vrL;
        _this.vrHandR = _vrR;

        _this.vrHeadPos = new Vector3();
    }

    function setupData() {
        if (!_id) {
            updateState(PlayerModel.data);
        } else {
            let data = _player.data;
            if (data.data) data = data.data;
            updateState(data);

            _this.isVR = data.isVR;
            if (_this.isVR) initVRObjects();
        }
    }

    function updateLocation() {
        if (!_this.group) return Render.stop(updateLocation);
        Player.setLocation(ENV_KEY, _this.group);
    }

    function updateState(data) {
        for (let key in data) {
            _this.state.set(key, data[key]);
        }
    }

    async function initLocal() {
        _isLocal = true;
        _isLocalVR = !!Platform.usingVR();
        PlayerModel.set('isVR', _isLocalVR);
        _view.setUserData(PlayerModel.data);
        updateState(PlayerModel.data);
        _this.events.sub(PlayerModel, PlayerModel.UPDATE, _ => {
            _view.setUserData(PlayerModel.data);
            updateState(PlayerModel.data);
        });

        let spawn;
        if (!!_env.config?.customSpawnCode) {
            spawn = _env.config.customSpawnCode();
            _this.group.position.copy(spawn.position);

            let spawnArea = await _env.getSpawn();
            if (spawnArea) spawnArea.visible = false;
        } else {
            spawn = await _env.getSpawn();
            if (spawn) {
                spawn.visible = false;
                let v3 = new Vector3();
                let bb = new Box3().setFromObject(spawn);
                v3.x = Math.random(bb.min.x, bb.max.x, 4);
                v3.z = Math.random(bb.min.z, bb.max.z, 4);
                _this.group.position.copy(v3);
                // if (!PlayerControls.FREE_MOVE && !PlayerControls.WALKING_AVATAR) _this.group.quaternion.copy(spawn.quaternion);
            }
        }

        try {
            let storedLocation = Player.getLocation(ENV_KEY);
            if (storedLocation) {
                _this.group.position.copy(storedLocation.position);
                // _this.group.quaternion.copy(storedLocation.quaternion);
                spawn.position.copy(storedLocation.position);
            }
        } catch(e) {

        }

        defer(_ => {
            if (_env.onConnectLocalPlayer) _env.onConnectLocalPlayer(_this);
            if (_env._connectLocalPlayer) _env._connectLocalPlayer(_this);
        });

        if (!_this.bindLink) return;

        if (Platform.usingVR()) {
            let nullGroup = new Group();
            nullGroup.extraData = {l: [], r: []};
            if (_env.vrHandRotation) {
                nullGroup.extraData.lq = [];
                nullGroup.extraData.rq = [];
            }
            _this.bindLink(nullGroup, 'player');
            _this.controls = _this.initClass(PlayerControlsVR, _this.group, _view, spawn, nullGroup);
        } else {
            _this.bindLink(_this.group, 'player');
            _this.controls = _this.initClass(PlayerControls, _this.group, _view, spawn);
        }
        if (_env.config?.persistAvatarLocation) Render.start(updateLocation, 5);
    }

    function initRemote() {
        let data = _player.data;
        if (data.data) data = data.data;
        _view.setUserData(data, _player);
        _this.events.sub(_player, GameCenterPlayer.UPDATE_DATA, ({data}) => {
            if (data.data) data = data.data;
            _view.setUserData(data, _player);
            updateState(data);
        });

        onTeleport(null, 800);
        // _this.bindEvent('teleport', onTeleport);
        _env.onConnectPlayer(_this);
        _env._onPlayerConnect(_this);
        _this.bindLink(_this.group, 'player');
        Render.start(handleData);
    }

    function handleData() {
        if (!_this.group) return Render.stop(handleData);
        let data = _this.group.extraData;
        if (data && data.l && data.l.length == 4 && data.r && data.r.length == 4) {
            if (!_vrL) initVRObjects();
            _vrL.posTarget.fromArray(data.l);
            _vrR.posTarget.fromArray(data.r);

            _vrL.pos4.lerp(_vrL.posTarget, PhysicalSync.baseLerp);
            _vrR.pos4.lerp(_vrR.posTarget, PhysicalSync.baseLerp);
            _vrL.position.copy(_vrL.pos4);
            _vrR.position.copy(_vrR.pos4);

            _this.vrHeadPos.copy(_this.group.position);
            _this.vrHeadPos.y = _vrL.pos4.w;

            if (data.lq) {
                if (!_vrL.targetQ) {
                    _vrL.targetQ = new Quaternion().fromArray(data.lq);
                    _vrR.targetQ = new Quaternion().fromArray(data.rq);
                }

                _vrL.quaternion.slerp(_vrL.targetQ, PhysicalSync.baseLerp);
                _vrR.quaternion.slerp(_vrR.targetQ, PhysicalSync.baseLerp);
            }
        }
    }

    //*** Event handlers
    function onTeleport(e, delay = 0) {
        // _scale.value = 0;
        // tween(_scale, {value: 1}, 300, 'easeOutCubic', delay + 200);
    }

    //*** Public methods
    this.onDisconnect = function() {
        _view.setUserData(_player.data, {videoTexture: Utils3D.getEmptyTexture()});
        _this.events.fire(Player.LEAVE, {player: _this});
        try { _env.onDisconnectPlayer(_this); } catch(e) { }
        try { _env._onPlayerDisconnect(_this); } catch(e) { }

        tween(_scale, {value: 0}, 300, 'easeOutCubic').onComplete(_ => {
            _this.parent.group.remove(_this.group);
            _this.group.traverse(mesh => {
                if (mesh.batch && mesh.batch.remove) mesh.batch.remove(mesh);
            });
            _this.destroy();
        });
    }

    this.get('isLocal', _ => _isLocal);

    this.setPosition = function(pos, euler) {
        _this.destroyLink();
        _this.group.position.copy(pos);
        if (euler) _this.group.rotation.copy(euler);
    }

    this.snapTo2dPoint = function(point2D) {
        //_this.destroyLink();
        _this.group.position.x = point2D.x;
        _this.group.position.z = point2D.y;
        if(!_isLocalVR) {
            _this.group.target.x = point2D.x;
            _this.group.target.z = point2D.y;
        }
    }

    this.teleport = function() {
        _this.fireEvent('teleport');
        onTeleport();
    }

    this.onLocalActivate = async function() {
        _this.gcPlayer = null;
        await Multiplayer.wait('room');
        try {
            _this.gcPlayer = _player = Multiplayer.room.me;
            _player.dreamPlayer = _this;
        } catch(e) {
            await _this.wait?.(100);
            _this.onLocalActivate();
        }
    }
}, _ => {
    Player.JOIN = 'player_join';
    Player.LEAVE = 'player_leave';
    Player.TELEPORT = 'player_teleport';

    var _locations = {};

    Player.clearLocation = function(key) {
        delete _locations[key];
    }

    Player.clearAllLocations = function() {
        for (let key in _locations) {
            delete _locations[key];
        }
    }

    Player.setLocation = function(key, inst) {
        if (!_locations[key]) _locations[key] = new Group();
        _locations[key].position.copy(inst.position);
        _locations[key].quaternion.copy(inst.quaternion);
    }

    Player.getLocation = function(key) {
        return _locations[key];
    }
});

Class(function PlayerControls(_player, _view, _spawn) {
    Inherit(this, Component);
    const _this = this;
    var _camera, _3rdP, _scroll, _1stP, _orbit, _config, _hitbox, _teleport, _bounding, _disabled;
    var $hit;

    const WAIT_TO_JUMP = 200;

    var _wrapper = new Group();
    var _rotation = new Group();
    var _rotation2 = new Group();

    const FWD = new Vector3(0, 0, -1);
    const BACK = new Vector3(0, 0, 1);
    const LEFT = new Vector3(-1, 0, 0);
    const RIGHT = new Vector3(1, 0, 0);
    const NONE = new Vector3(0, 0, 0);
    const START_RADIUS = Math.radians(Math.random(0, 360));
    const TEST_RADIUS = Math.random(0, 10, 4);

    var _time = Date.now();
    var _temp = new Vector3();
    var _jump = new Vector3();
    var _move = new Vector3();
    var _v3 = new Vector3();
    var _v31 = new Vector3();
    var _lastPos = new Vector3();
    var _direction = new Vector3();
    var _euler = new Euler();
    var _pressing = [];
    var _threadEvent = {};
    var _yPosition = 0;
    var _currView = '3rd';
    var _collision = _this.findParent('GroupEnvironment').collision;

    this.offset = new Vector3();
    this.lerpScale = 1;

    //*** Constructor
    (async function () {
        let hitbox = await _view.getHitBox();
        _bounding = _this.initClass(PlayerControlsBounding, hitbox, _view.group);

        _wrapper.target = new Vector3();
        _jump.target = new Vector3();

        _3rdP = _this.initClass(GazeCamera);
        _1stP = _this.initClass(GazeCamera);
        _wrapper.add(_rotation);
        _rotation.add(_rotation2);
        _rotation2.add(_3rdP.group);
        _rotation2.add(_1stP.group);

        _camera = Camera.instance().createLocal();
        _3rdP.lock(_camera);
        Camera.instance().lock(_camera.worldCamera);

        _player.target = new Vector3().copy(_player.matrixAutoUpdate ? _player.getWorldPosition() : _player.position);

        applyCameraConfig(_3rdP, '3rd_person');
        applyCameraConfig(_1stP, '1st_person');

        _config = GlobalConfig.instance().getConfig('controls');

        let orbitConfig = PlayerControls.ORBIT_CONFIG;
        if (PlayerControls.CUSTOM_CONFIG) {
            orbitConfig = Utils.cloneObject(PlayerControls.ORBIT_CONFIG);
            for (let key in PlayerControls.CUSTOM_CONFIG) orbitConfig[key] = PlayerControls.CUSTOM_CONFIG[key];
        }
        _orbit = _this.initClass(PlayerControlsOrbit, _rotation, _rotation2, orbitConfig);
        _teleport = _this.initClass(PlayerTeleportMouse, _player.position, _player.target);
        _this.startRender(loop);

        _this.orbit = _orbit;

        if (_spawn) {
            _orbit.rotationY = _spawn.rotation.y;
            if (PlayerControls.FREE_MOVE) {
                _wrapper.target.x = _player.target.x;
                _wrapper.target.z = _player.target.z;
            }
        }

        let viewState = PlayerControls.getViewState() || '3rd';
        if (viewState) handleSwitchView({view: viewState});

        addListeners();
        if (Device.mobile) initMobileControls();
        // switchView();
        _this.flag('initialized', true);
    })();

    function applyCameraConfig(camera, key) {
        let config = GlobalConfig.instance().getConfig(key);
        camera.moveXY.fromArray(config.moveXY);

        if (Device.mobile) camera.moveXY.x = camera.moveXY.y = 0;

        camera.setFOV(config.fov * (PlayerControls.FOV || 1));
        camera.position.copy(new Vector3().fromArray(config.position).multiplyScalar(key == '3rd_person' ? PlayerControls.ZOOM_MULTIPLIER || 1 : 1));
        camera.group.position.fromArray(config.groupPos);
        camera.deltaRotate = 0.0001;
    }

    function loop() {
        if (!_wrapper.target) return;

        let initialFrames = _this.flag('initialFrames');
        _wrapper.updateMatrixWorld();
        _wrapper.position.lerp(_wrapper.target, initialFrames ? 1 : 0.125 * _this.lerpScale);

        _player.rotation.y = Math.lerp(_orbit.rotationY, _player.rotation.y, 0.2);

        _move.copy(_direction).normalize().multiplyScalar(_config.moveStep * (PlayerControls.MOVE_MULTIPLIER || 1) * 0.1 * Render.HZ_MULTIPLIER).applyQuaternion(_player.quaternion);

        _temp.copy(_player.target).add(_v31.copy(_move).multiplyScalar(4));
        _temp.y += 2;
        _threadEvent.pos = _temp;
        _threadEvent.bounding = _bounding.vectors;

        if (_bounding.active) {
            _collision.testBox(_threadEvent, hitTestResult);
        } else {
            _collision.test(_threadEvent, hitTestResult);
        }

        _player.target.y = Math.lerp(_yPosition, _player.target.y, 0.1);
        _player.target.add(_jump.target.copy(_jump));
        _player.position.lerp(_player.target, initialFrames ? 1 : _config.playerLerp);
        _player.position.y = Math.lerp(_yPosition, _player.position.y, 0.3);
        if (PlayerControls.FREE_MOVE) _player.position.add(_this.offset);

        _orbit.direction = 1;//_currView == '3rd' ? 1 : -1;
        _orbit.firstP = _currView == '1st';

        if ($hit) {
            $hit.move.x = Math.clamp($hit.interaction.move.x, -50, 50);
            $hit.move.y = Math.clamp($hit.interaction.move.y, -50, 50);

            if (!_this.touching) {
                $hit.move.x = $hit.move.y = 0;
            }

            $hit.position.lerp($hit.move, 0.15);
            $hit.mover.x = $hit.position.x;
            $hit.mover.y = $hit.position.y;
            $hit.mover.transform();
        }
    }

    function initMobileControls() {
        let offset = 60;
        $hit = Stage.create('hit');

        let bottom = PlayerControls.MOBILE_CONTROLS_OFFSET ? PlayerControls.MOBILE_CONTROLS_OFFSET.y : offset;
        let left = PlayerControls.MOBILE_CONTROLS_OFFSET ? PlayerControls.MOBILE_CONTROLS_OFFSET.x : offset;
        $hit.size(50, 50).css({ position: 'fixed', top: '100%', marginTop: -bottom-50, left }).setZ(99);

        Global.MOBILE_CONTROLS_ELEMENT = $hit;

        $hit.behind = $hit.create('.behind');
        $hit.behind.size(120,120).css({ left: -35, borderRadius: '50%', bottom: -35, border: '2px solid #fff', opacity: 0 }).transform({ scale: 0.4 });

        $hit.move = new Vector2();
        $hit.position = new Vector2();

        $hit.mover = $hit.create('.wrapper');
        $hit.mover.size(50,50);

        $hit.inner = $hit.mover.create('.inner');
        $hit.inner.size(50, 50).css({ border: '4px solid #fff', boxShadow: '0 4px 15px rgba(0,0,0,0.2)', background: 'rgba(0,0,0,0.15)', opacity: 0.7, borderRadius: '50%' });

        $hit.interaction = _this.initClass(Interaction, $hit);
        _this.events.sub($hit.interaction, Interaction.START, touchStart);
        _this.events.sub($hit.interaction, Interaction.MOVE, touchMove);
        _this.events.sub($hit.interaction, Interaction.END, touchEnd);

        _this.events.sub(Mouse.input, Interaction.START, _ => {
            let delta = Date.now() - _time;
            _time = Date.now();
            if (delta < 200) jump();
        })
    }

    function toggleView(){
        if (_this.disabled) return;
        _this.disabled = true;
        _this.delayedCall(_ => { _this.disabled = false; }, 1000);


        switch(_currView){
            case '3rd':{
                _view.visible = false;
                _1stP.transition(300, 'easeOutCubic', _camera).then(()=>{
                });
                _currView = "1st"
                break;
            }
            case '1st':{
                _view.visible = true;
                _3rdP.transition(300, 'easeOutCubic', _camera).then(()=>{
                });
                _currView = "3rd"
                break;
            }
        }
        _this.events.fire(PlayerControls.SWITCH_VIEW,{view:_currView})
    }

    //*** Event handlers
    function addListeners() {
        var _input = _this.initClass(Interaction, Stage);
        _this.events.sub(Keyboard.DOWN, keyPress);
        _this.events.sub(Keyboard.UP, keyUp);
        _this.events.sub(PlayerControls.SWITCH_VIEW, handleSwitchView);
        _this.events.sub(Events.RESIZE, resize); resize();
        _this.events.sub(PlayerControls.ENABLE_STATE_CHANGE, handleEnableChange);
        _this.events.sub(PlayerControls.DISABLE_TELEPORT, disableTeleport);
        _this.events.sub(_input, Interaction.START, inputStart);
        _this.events.sub(_input, Interaction.END, inputEnd);
        // _this.events.sub(Events.VISIBILITY, visibilityEvent);
        // $(document).bind('mouseout', mouseLeave);
    }

    function mouseLeave() {
        _pressing.length = 0;
        _direction.set(0, 0, 0)
    }

    function visibilityEvent(e) {
        if (e.type == 'blur') {
            _pressing.length = 0;
            _direction.set(0, 0, 0);
        }
    }

    function disableTeleport() {
        _teleport?.disable?.();
    }

    function resize() {
        if (Device.mobile) {
            let multiplier = PlayerControls.FOV || 1;
            if (Stage.width > Stage.height) {
                _3rdP.setFOV(35 * multiplier);
            } else {
                _3rdP.setFOV(65 * multiplier);
            }
        }
    }

    function handleSwitchView(e) {
        if(e.view == _currView){
            return;
        }
        switch(e.view){
            case '1st':{
                _view.visible = false;
                _1stP.transition(300, 'easeOutCubic', _camera).then(()=>{
                });
                _currView = "1st";
                break;
            }
            case '3rd':{
                _view.visible = true;
                _3rdP.transition(300, 'easeOutCubic', _camera).then(()=>{
                });
                _currView = "3rd";
                break;
            }
        }

        PlayerControls.setViewState(_currView);
    }

    function handleEnableChange(e) {
        if (e.isEnabled || e.enabled) {
            _this.enable();
        } else {
            _this.disable();
        }
    }

    function scroll() {
        if (_this.disabled) return;
        if (_scroll.delta.y < 0 && _currView == '3rd') toggleView();
        if (_scroll.delta.y > 0 && _currView == '1st') toggleView();
    }

    function touchStart() {
        _this.events.fire(PlayerControls.MOBILE_JOYSTICK);
        $hit.inner.tween({ opacity: 1, scale: 1.15 }, 400, 'easeOutCubic');
        $hit.behind.tween({ opacity: 0.6, scale: 1 }, 400, 'easeOutCubic');
        _this.touching = true;
        // _orbit.disabled = true;
    }

    function inputStart() {
        _this.events.fire(PlayerControls.DRAGGING, {type: 'start'});
    }

    function inputEnd() {
        _this.events.fire(PlayerControls.DRAGGING, {type: 'end'});
    }

    function touchMove(e) {
        let moved = $hit.interaction.move.length();
        let angle = Math.atan2($hit.interaction.move.y, $hit.interaction.move.x) + Math.radians(90);
        _direction.copy(FWD);
        _euler.y = -angle;
        _direction.applyEuler(_euler).multiplyScalar(Math.range(moved, 0, 50, 0, 1, true));
    }

    function touchEnd(e) {
        $hit.inner.tween({ opacity: 0.7, scale: 1 }, 400, 'easeOutCubic');
        $hit.behind.tween({ opacity: 0, scale: 0.4 }, 400, 'easeOutCubic');
        _this.touching = false;
        // _orbit.disabled = false;

        _direction.set(0, 0, 0);
    }

    function hitTestResult(e) {
        if (!e.success) {
            _player.target.add(_move);
            if (PlayerControls.FREE_MOVE) _wrapper.target.add(_move);
            else _wrapper.target.copy(_player.position);
            return;
        }

        if (!e.miss) {
            _player.target.add(_move);
            if (PlayerControls.FREE_MOVE) {
                _wrapper.target.add(_move);
                _wrapper.target.y = e.point.y + PlayerControls.FREE_MOVE;
            }
            else _wrapper.target.copy(_player.position);
            _yPosition = e.point.y;
            _lastPos.copy(_player.target);
        } else {
            _player.target.copy(_lastPos);
        }
    }

    function keyPress(e) {
        if (_disabled) return;
        if (!_pressing.includes(e.key)) _pressing.push(e.key);
        switch (e.key) {
            case 'w':
            case 'W':
            case 'ArrowUp':
                _direction.z = FWD.z;
                break;

            case 'a':
            case 'A':
                _direction.x = LEFT.x;
                break;

            case 's':
            case 'S':
            case 'ArrowDown':
                _direction.z = BACK.z;
                break;

            case 'd':
            case 'D':
                _direction.x = RIGHT.x;
                break;

            case ' ':
                if (!PlayerControls.NO_JUMP) jump();
                break;

            // case 'Tab':{
            //     e.preventDefault();
            //     toggleView();
            //     break;
            // }
        }
    }

    function jump() {
        if (!_this.flag('jumping')) {
            _this.flag('jumping', true);
            tween(_jump, {y: _config.jumpStrength * 0.6}, 100, 'linear', _ => {
                tween(_jump, {y: 0}, 500, 'easeInCubic').onComplete(_ => {
                    _this.delayedCall(() => {_this.flag('jumping', false)}, WAIT_TO_JUMP);
                });
            });
        }
    }

    function keyUp(e) {
        if (_disabled) return;
        _pressing.remove(e.key);
        if (!_pressing.length) _direction.set(0, 0, 0);
        switch (e.key) {
            case 'w':
            case 'W':
            case 'z':
            case 'Z':
            case 'ArrowUp':
                _direction.z = 0;
                break;

            case 'a':
            case 'A':
            case 'ArrowLeft':
                _direction.x = 0;
                break;

            case 's':
            case 'S':
            case 'ArrowDown':
                _direction.z = 0;
                break;

            case 'd':
            case 'D':
            case 'ArrowRight':
                _direction.x = 0;
                break;
        }
    }

    //*** Public methods
    this.disable = async function() {
        _this.visible = false;
        _disabled = true;
        _direction.x = 0;
        _direction.z = 0;
        _this.stopRender(loop);
        await _this.wait('initialized');
        _orbit.disabled = true;
        if ($hit) $hit.hide();
        _this.disableTeleport();
    }

    this.resetTarget = () => {
        _player.target = _player.position.clone();
    }

    this.enableTeleport = async function() {
        await _this.wait('initialized');
        _teleport?.enable?.();
    }

    this.disableTeleport = async function() {
        await _this.wait('initialized');
        _teleport?.disable?.();
    }

    this.enable = async function(){
        _this.visible = true;
        _disabled = false;
        _this.startRender(loop);
        await _this.wait('initialized');
        _orbit.disabled = false;
        if ($hit) $hit.show();
    }

    this.setCameraView = async function(view) {
        await _this.ready();
        _this.events.fire(PlayerControls.SWITCH_VIEW, {view});
    }

    this.ready = function() {
        return _this.wait('initialized');
    }

    this.offsetZ = function(z) {
        _3rdP.group.position.z += z;
    }

    this.blockOrbit = function() {
        if (_this.flag('still')) return;
        _this.flag('still', true);
        _3rdP.still(1000);
    }

    this.allowOrbit = function() {
        if (!_this.flag('still')) return;
        _this.flag('still', false);
        _3rdP.orbit(1000);
    }

    this.onVisible = function() {
        _this.flag('initialFrames', true, 500);
        if (_3rdP) {
            applyCameraConfig(_3rdP, '3rd_person');
            applyCameraConfig(_1stP, '1st_person');
        }
    }

    this.onDestroy = function() {
        _camera?.destroy?.();
        if ($hit) $hit.remove();
    }

},()=>{
    PlayerControls.SWITCH_VIEW = "playercontrols_switchview";
    PlayerControls.DISABLE_TELEPORT = "playercontrols_teleport";
    PlayerControls.MOBILE_JOYSTICK = "playercontrols_mobile_joystick";
    PlayerControls.ENABLE_STATE_CHANGE = "playercontrols_enable_state_change";
    PlayerControls.ORBIT_CONFIG = {screenRotation: 180, xLimit: 20, zOrigin: 2, xMin: -30, xMax: 10, xAngle: 0};
    PlayerControls.FREE_MOVE = false;
    PlayerControls.BLOCK_TELEPORT = false;
    PlayerControls.MOVE_MULTIPLIER = 1;
    PlayerControls.ZOOM_MULTIPLIER = 1;
    PlayerControls.DRAGGING = 'player_controls_dragging';

    var _state;
    PlayerControls.setViewState = async function(key) {
        _state = key;
        Storage.set('player_controls_view_state', key);

        let env = await DreamWorld.getActiveEnvironment();
        env.player?.controls?.setCameraView(key);
    }

    PlayerControls.getViewState = function(key) {
        if (!_state) _state = Storage.get('player_controls_view_state');
        return _state;
    }

    PlayerControls.shouldPrevent = function() {
        let el = document.elementFromPoint(Mouse.x, Mouse.y);
        return checkIfProhibited(el);
    }

    const PROHIBITED_ELEMENTS = ['hit', 'prevent_interaction3d'];
    function checkIfProhibited(element) {
        let el = element;
        while (el) {
            if (el.classList) {
                for (let i = 0; i < PROHIBITED_ELEMENTS.length; i++) {
                    if (el.classList.contains(PROHIBITED_ELEMENTS[i])) return true;
                }
            }
            el = el.parentNode;
        }
        return false;
    }
});

Class(function PlayerControlsVR(_group, _view, _spawn, _nullGroup) {
    Inherit(this, Object3D);
    const _this = this;
    var _time, _controller, _cyl, _preventTeleport, _wristMenu, _line;

    var _canMove = true;
    var _castPos = new Vector3();
    var _hitPos = new Vector3();
    var _joyMoveDir = new Vector2();
    var _joyMoveAbsolute = new Vector3();
    var _v3 = new Vector3();
    var _qBlend = {value: 1};
    var _runningLerp = new Group();
    var _threadEvent = {};
    var _targetY = 0;
    var _collision = _this.findParent('GroupEnvironment').collision;

    const DOWN = new Vector3(0, -1, 0);
    const UP = new Vector3(0, 3, 0);
    const FWD = new Vector3(0, 0, -1);
    const REMOTE_LERP = 0.04;

    this.offset = new Vector3();

    //*** Constructor
    (async function () {
        if (_spawn) {
            RenderManager.camera.offset.copy(_spawn.position);
        }

        if (PlayerControlsVR.wristMenuObject) initWristMenu();

        [_line, _cyl] = PlayerControlsVR.getTeleportStructure();
        _cyl.position.y = _spawn ? _spawn.position.y : 0;

        _this.startRender(loop);
        captureControllers();

        _view.visible = false;
    })();

    async function captureControllers() {
        await VRInput.ready();
        VRInput.controllers.forEach((c, i) => {
            _this.events.sub(c, VRInput.BUTTON, vrButton);
            _this.events.sub(c, VRInput.JOYSTICK, vrJoystick);
        });
    }

    function initWristMenu() {
        _wristMenu = new Group();
        _wristMenu.add(PlayerControlsVR.wristMenuObject.group);
    }

    function optimize(array) {
        for (let i = 0; i < array.length; i++) {
            array[i] = Number(array[i].toFixed(3));
        }
    }

    function loop() {
        if (_controller) {
            FWD.set(0, 0, -1);
            let ranged = Math.range(Math.degrees(_controller.group.rotation.x), -45, 45, 0.1, 1, true);
            _castPos.copy(_controller.group.getWorldPosition()).add(FWD.multiplyScalar(8 * PlayerControlsVR.TELEPORT_SCALAR * ranged).applyQuaternion(_controller.group.getWorldQuaternion()));
            _cyl.position.x = _castPos.x;
            _cyl.position.z = _castPos.z;
        }

        if (_cyl.visible) {
            _hitPos.copy(_cyl.position).add(UP);
            _threadEvent.pos = _hitPos;
            _threadEvent.cylinder = true;
            _collision.test(_threadEvent, hitTestCylinder);
        }

        _runningLerp.position.lerp(_cyl.visible ? _cyl.position : _group.position, _qBlend.value);
        _runningLerp.quaternion.slerp(World.CAMERA.getWorldQuaternion(), _qBlend.value);
        _hitPos.copy(_runningLerp.position).add(UP);
        _threadEvent.pos = _hitPos;
        _threadEvent.cylinder = false;
        _collision.test(_threadEvent, hitTestRunning);

        _group.position.y = Math.lerp(_targetY, _group.position.y, 0.2);
        RenderManager.camera.offset.copy(_group.position);

        _hitPos.copy(World.CAMERA.getWorldPosition());
        _threadEvent.pos = _hitPos;
        _threadEvent.cylinder = false;
        _collision.test(_threadEvent, hitTestPlayer);

        _nullGroup.quaternion.copy(_runningLerp.quaternion);

        let l = VRInput.controllers[0];
        let r = VRInput.controllers[1];
        if (l && r) {
            if (l.handedness != 'left') {
                let r2 = r;
                r = l;
                l = r2;
            }

            l.group.getWorldPosition().sub(_hitPos).toArray(_nullGroup.extraData.l);
            r.group.getWorldPosition().sub(_hitPos).toArray(_nullGroup.extraData.r);
            _nullGroup.extraData.l[3] = _hitPos.y;
            _nullGroup.extraData.r[3] = _hitPos.y;
            if (_nullGroup.extraData.lq) {
                l.group.getWorldQuaternion().toArray(_nullGroup.extraData.lq);
                r.group.getWorldQuaternion().toArray(_nullGroup.extraData.rq);
            }

            optimize(_nullGroup.extraData.l);
            optimize(_nullGroup.extraData.r);
        }

        if (_joyMoveDir.lengthSq() > 0) {
            _joyMoveAbsolute.set(_joyMoveDir.x, 0, _joyMoveDir.y).applyQuaternion(World.CAMERA.getWorldQuaternion()).multiplyScalar(PlayerControlsVR.JOYSTICK_SPEED * 0.02 * Render.HZ_MULTIPLIER);
            _v3.copy(_group.position).add(_joyMoveAbsolute).add(UP);
            _threadEvent.pos = _v3;
            _threadEvent.cylinder = true;
            _collision.test(_threadEvent, hitTestJoystick);
        }
    }

    function hitTestPlayer(e) {
        if (e.point) {
            _targetY = e.point.y;
        }
    }

    function hitTestCylinder(e) {
        _cyl.shader.set('uVis', 1);
        if (e.miss) {
            _canMove = false;
            _cyl.shader.set('uMiss', 1);
            _line.group.visible = false;
        } else {
            _cyl.shader.set('uMiss', 0);
            if (e.point) _cyl.position.y = e.point.y;
            _canMove = true;
            TweenManager.clearTween(_qBlend);
            _qBlend.value = REMOTE_LERP;

            if (_controller) {
                _line.group.visible = true;
                let subdivisions = 30;
                _line.clear();
                _controller.group.getWorldPosition(_line.catmull.points[0]);
                _line.catmull.points[1].copy(_line.catmull.points[0]).lerp(_cyl.position, 0.5, true);
                _line.catmull.points[1].y = Math.max(_line.catmull.points[0].y, _cyl.position.y);
                _line.catmull.points[2].copy(_cyl.position);
                for (let i = 0; i < subdivisions; i++) {
                    _line.catmull.getPoint((i+1) / subdivisions, _v3);
                    _line.draw(_v3);
                }
            } else {
                _line.group.visible = false;
            }
        }
    }

    function hitTestRunning(e) {
        if (!e.miss) {
            if (!e.success) _nullGroup.position.copy(_cyl.position);
            else _nullGroup.position.copy(e.point);
            _nullGroup.position.x += RenderManager.camera.inset.x;
            _nullGroup.position.z += RenderManager.camera.inset.z;
        }
    }

    function hitTestJoystick(e) {
        if (!e.miss) _group.position.add(_joyMoveAbsolute);
    }

    //*** Event handlers
    function vrButton(e) {
        Interaction3D.useInput(e.controller);
        if (e.label == 'trigger') {
            if (e.pressed) start(e);
            else end(e);
        }

        if (_wristMenu) {
            if (e.label == 'a' || e.label == 'b' || e.label == 'side_trigger' || e.label == 'touch_pad') {
                if (e.pressed) {
                    VRInput.controllers.forEach(c => {
                        if (c != e.controller) Interaction3D.useInput(c);
                    });

                    PlayerControlsVR.wristMenuObject?.onOpen?.();
                    _wristMenu.visible = true;
                    _wristMenu.scale.setScalar(0);
                    e.controller.group.add(_wristMenu);
                    _wristMenu.position.z = -0.05;
                    tween(_wristMenu.scale, {x: 1, y: 1, z: 1}, 300, 'easeOutCubic');
                } else {
                    if (_wristMenu.visible) {
                        VRInput.controllers.forEach(c => {
                            c.hideBeam();
                        });
                        PlayerControlsVR.wristMenuObject?.onClose?.();
                        tween(_wristMenu.scale, {x: 0, y: 0, z: 0}, 300, 'easeOutCubic').onComplete(_ => {
                            _wristMenu.visible = false;
                        });
                    }
                }
            }
        }
    }

    function restoreCyl() {
        _cyl.shader.tween('uVis2', 1, 300, 'easeOutSine');
    }

    function vrJoystick(e) {
        if (e.controller.handedness == 'right') {
            if (e.x > 0.5) {
                if (!_this.flag('blockPosX')) {
                    if (_cyl.visible) {
                        _cyl.shader.set('uVis2', 0);
                        Utils.debounce(restoreCyl, 100);
                    }
                    RenderManager.camera.wrapper.rotation.y += Math.radians(-45);
                    _this.flag('blockPosX', true);
                }
            }

            if (e.x < -0.5) {
                if (!_this.flag('blockNegX')) {
                    if (_cyl.visible) {
                        _cyl.shader.set('uVis2', 0);
                        Utils.debounce(restoreCyl, 100);
                    }
                    RenderManager.camera.wrapper.rotation.y += Math.radians(45);
                    _this.flag('blockNegX', true);
                }
            }

            if (e.x <= 0) _this.flag('blockPosX', false);
            if (e.x >= 0) _this.flag('blockNegX', false);
        } else {
            _joyMoveDir.set(e.x, e.y);
        }
    }

    function start(e) {
        if (Interaction3D.find(World.CAMERA).intersecting || AvatarInteraction.intersecting) return;
        if (e.controller.handedness == 'left') return;
        _time = Date.now();
        _cyl.shader.set('uVis', 0);
        _cyl.visible = true;
        _controller = e.controller;
    }

    function end(e) {
        if (Interaction3D.find(World.CAMERA).intersecting || AvatarInteraction.intersecting || !_cyl.visible) return;
        if (e.controller.handedness == 'left') return;
        _controller = null;
        _cyl.visible = false;

        tween(_qBlend, {value: 1}, 500, 'linear');

        if (Date.now() - _time > 100 && _canMove) {
            _group.position.x = _cyl.position.x;
            _group.position.y = _targetY = _cyl.position.y;
            _group.position.z = _cyl.position.z;

            _this.events.fire(Player.TELEPORT);

            _group.position.x -= RenderManager.camera.inset.x;
            _group.position.z -= RenderManager.camera.inset.z;
        }
    }

    //*** Public methods
    this.disable = function() {
        _preventTeleport = true;
    }

    this.enable = function() {
        _preventTeleport = false;
    }
}, _ => {
    PlayerControlsVR.TELEPORT_SCALAR = 1;
    PlayerControlsVR.JOYSTICK_SPEED = 1;

    var _line, _cyl, _lineColor, _color, _missColor;
    function initLine() {
        _line = new Line3D({
            width: 7,
            color: '#0e76c5'
        });

        let shader = new Shader('TeleportLineShader', {
            uLColor: {value: _lineColor},
            uLAlpha: {value: 0.35},
            uVis: _cyl.shader.uniforms.uVis,
            uVis2: _cyl.shader.uniforms.uVis2,
            transparent: true
        });

        _line.useShader(shader);
        _line.color = new Color();
        _line.catmull = new CatmullRomCurve([new Vector3(), new Vector3(), new Vector3()]);
        World.SCENE.add(_line.group);
        _line.group.visible = false;

        _line.wait('mesh').then(_ => _line.mesh.renderOrder = 99999);
    }

    function initCylinder() {
        let geom = new CylinderGeometry(1, 1, 1, 50);
        geom.applyMatrix(new Matrix4().makeTranslation(0, 0.5, 0));
        let shader = new Shader('TeleportCylinderShader', {
            uColor: {value: _color},
            uAlpha: {value: 0.5},
            uVis: {value: 0},
            uVis2: {value: 1},
            uMiss: {value: 0},
            uMissColor: {value: _missColor},
            transparent: true
        });
        _cyl = new Mesh(geom, shader);
        _cyl.depthWrite = false;
        _cyl.renderOrder = 9999;
        _cyl.scale.set(0.2, 4, 0.2);
        World.SCENE.add(_cyl);
        _cyl.shader.depthWrite = false;
        _cyl.visible = false;
    }

    function initColors() {
        if (_color) return;
        _color = new Color('#ffffff');
        _lineColor = new Color('#ffffff');
        _missColor = new Color('#D90E0E');
    }

    PlayerControlsVR.getTeleportStructure = function() {
        if (!_line) {
            initColors();
            initCylinder();
            initLine();
        }

        return [_line, _cyl];
    }

    PlayerControlsVR.setTeleportColor = function(color) {
        initColors();
        _color.set(color);
    }

    PlayerControlsVR.setLineColor = function(color) {
        initColors();
        _lineColor.set(color);
    }

    PlayerControlsVR.setMissColor = function(color) {
        initColors();
        _missColor.set(color);
    }

    PlayerControlsVR.registerWristMenu = function(Class) {
        if (Platform.usingVR()) {
            PlayerControlsVR.wristMenuObject = new Class();
            if (!PlayerControlsVR.wristMenuObject.group) throw `PlayerControlsVR::registerWristMenu Class is missing .group`;
        }
    }
});
Class(function PlayerControlsBounding(_hitbox,_group) {
    Inherit(this, Component);
    const _this = this;
    var _nulls = [];
    this.vectors = [];

    //*** Constructor
    (function () {
        if (!_hitbox) return;
        _this.active = true;
        _hitbox.geometry.computeBoundingSphere();
        _hitbox.geometry.computeBoundingBox();
        let bb = _hitbox.geometry.boundingBox.clone();
        bb.setFromObject(_hitbox);
        for(let i =0; i< 4; i++){
            let group = new Group();
            _nulls.push(group);
            _group.add(group);
            _this.vectors.push(new Vector3());
        }
        _nulls[0].position.set(bb.max.x, 0.5, bb.max.z);
        _nulls[1].position.set(bb.min.x, 0.5, bb.max.z);
        _nulls[2].position.set(bb.max.x, 0.5, bb.min.z); 
        _nulls[3].position.set(bb.min.x, 0.5, bb.min.z);
        _this.startRender(loop);
    })();
    
    function loop(){
        for(let i =0;i<4;i++){
            _nulls[i].getWorldPosition(_this.vectors[i])
        }
    }
    //*** Event handlers
    
    //*** Public methods
    
});
Class(function PlayerControlsOrbit(_root, _wrap, _config = PlayerControls.ORBIT_CONFIG) {
    Inherit(this, Component);
    var _this = this;
    var _input, _camera, _prevent, _moving;

    var _move = new Vector2();
    var _hold = new Vector3();
    var _target = new Vector3();
    var _rotation = new Vector3();
    var _velocity = new Vector3();
    var _moveTarget = 0;
    var _moveAlpha = 0.07;
    var _enabled = true;
    var _touchStartTime = 0;
    var _touchEndTime = 0;
    this.lerp = 1;

    _this.direction = 1;
    _this.firstP = false;

    //*** Constructor
    (function () {
        _velocity.x = _target.x = _config.xAngle;
        // _config.xMax = Math.radians(_config.xMax);
        // _config.xMin = Math.radians(_config.xMin);
        defer(initInput);
        _this.startRender(loop);
    })();

    function initInput() {
        if ( !_this || !_this.initClass ) return;
        _input = _this.initClass(Interaction, Stage);
        _input.ignoreLeave = true;
        _this.events.sub(_input, Interaction.START, touchStart);
        _this.events.sub(_input, Interaction.MOVE, touchMove);
        _this.events.sub(_input, Interaction.END, touchEnd);
        _this.events.sub(Keyboard.DOWN, keyPress);
        _this.events.sub(Keyboard.UP, keyUp);
    }

    function loop() {
        if (!_enabled) return;

        // if (!_camera) _camera = _config;

        if (_this.keyLeft) _velocity.y += 1.5 * Render.HZ_MULTIPLIER;
        if (_this.keyRight) _velocity.y -= 1.5 * Render.HZ_MULTIPLIER;

        _target.lerp(_velocity, 0.1 * _this.lerp);

        // Mouse Look
        if (_this.firstP && !Device.mobile && !_moving && !_enabled) _target.y -= Mouse.tilt.x*2*Render.HZ_MULTIPLIER;

        _rotation.lerp(_target, 0.4 * _this.lerp);

        _root.rotation.y = Math.radians(_rotation.y);
        _wrap.rotation.x = Math.radians(_rotation.x);

        if (Mouse.x > Stage.width) {
            if (_this.flag('cursorSet')) {
                _this.flag('cursorSet', false);
                Stage.cursor('auto', _this);
            }
        } else {
            if (!_this.flag('cursorSet')) {
                _this.flag('cursorSet', true);
                Stage.cursor('grab', _this);
            }
        }
    }

    //*** Event handlers
    function touchStart(e) {
        if (_prevent || e.x > Stage.width) return;
        if (e.target.className == 'hit') return _moving = false;
        _moving = true;
        _velocity.y = _target.y;
        _hold.y = _target.y;
        _hold.x = _target.x;
        _moveAlpha = 0.07;
        _touchStartTime = Date.now();

        PlayerControlsOrbit.DRAGGING = true;

        Stage.cursor('grabbing', _this);
    }

    function touchMove(e) {
        if (!_moving || _prevent || !_enabled) return;
        let x = e.x;
        let y = e.y;
        _target.y = _hold.y + (-_input.move.x / Stage.width) * _config.screenRotation * _this.direction;
        _target.x = _hold.x + (-_input.move.y / Stage.height) * (_config.screenRotation * Math.radians(_config.xLimit) * _this.direction);

        if (_target.x < _config.xMin) {
            _target.x = _config.xMin;
        }

        if (_target.x > _config.xMax) {
            _target.x = _config.xMax;
        }

        if (_target.x > 10 || _target.x < -20) _this.parent.blockOrbit();
        else _this.parent.allowOrbit();

        _velocity.y = _target.y;
        _velocity.x = _target.x;
        _move.copy(_input.move);

        _moveTarget = Math.range(Math.abs(_input.velocity.x), 0, 7, 0, _config.zOrigin * 0.5);
    }

    function touchEnd(e) {
        if (!_moving || _prevent) return;
        var moveX = ((-Math.abs(_input.velocity.x) * 200) / Stage.width) * _config.screenRotation * Math.sign(_move.x) * _this.direction;
        var moveY = ((-Math.abs(_input.velocity.y) * 200) / Stage.height) * (_config.screenRotation * Math.radians(_config.xLimit)) * Math.sign(_move.y) * _this.direction;

        PlayerControlsOrbit.DRAGGING = false;

        if (_move && _move.length() > 8) {
            _velocity.y = _target.y + Math.clamp(moveX, -360, 360);
            // _velocity.x = Math.clamp(_target.x + moveY, -_config.xMax, _config.xMax);
        }

        Stage.cursor('grab', _this);

        _moveTarget = 0;
        _moveAlpha = 0.02;
        _moving = false;

        if (_move) {
            _move.x = 0;
            _move.y = 0;
        }
    }

    function keyPress(e) {
        switch (e.key) {
            case 'ArrowLeft':
                _this.keyLeft = true;
                break;
            case 'ArrowRight':
                _this.keyRight = true;
                break;
        }
    }

    function keyUp(e) {
        switch (e.key) {
            case 'ArrowLeft':
                _this.keyLeft = false;
                break;
            case 'ArrowRight':
                _this.keyRight = false;
                break;
        }
    }

    //*** Public methods
    this.center = function(x, y, snap) {
        _velocity.x = Math.degrees(x);
        _velocity.y = Math.degrees(y);
        if (snap) {
            _target.x = _velocity.x;
            _target.y = _velocity.y;
            _wrap.rotation.x = x;
            _wrap.rotation.y = y;
        }
    }

    this.set('rotationY', y => {
        _target.y = Math.degrees(y);
        _velocity.y = _target.y;
        _rotation.y = _target.y;
        // _moveTarget = Math.range(Math.abs(_input.velocity.x), 0, 7, 0, _config.zOrigin * 0.5);
    });

    this.get('rotationY', () => {
        return _root.rotation.y;
    });
    this.set('rotationX', x => {

    });

    this.get('rotationX', () => {
        return  _target.x;
    });

    this.set('xMax', v => _config.xMax = v);
    this.set('xMin', v => _config.xMin = v);
    this.set('xAngle', v => _velocity.x = _target.x = v);

    this.set('disabled', bool => {
        _prevent = bool;
        _enabled = !bool;

        if (_enabled) {
            Stage.cursor('grab', _this);
        } else {
            Stage.cursor('auto', _this);
        }
    });

    this.onDestroy = function() {
        Stage.cursor('auto', _this);
    }
});
Class(function PlayerTeleportMouse(_playerPosition, _playerTarget) {
    Inherit(this, Component);
    const _this = this;
    var _input;

    var _mouse = new Vector2();
    var _threadEvent = {};
    var _time = Date.now();
    var _collision = _this.findParent('GroupEnvironment').collision;
    var _move = new Vector3();

    //*** Constructor
    (function () {
        addListeners();
    })();

    //*** Event handlers
    function addListeners() {
        _input = _this.initClass(Interaction, Stage);
        _this.events.sub(_input, Interaction.START, touchStart);
    }

    function touchStart() {
        if (PlayerControls.BLOCK_TELEPORT) return;
        if (PlayerControls.shouldPrevent()) return;
        let delta = Date.now() - _time;
        _time = Date.now();
        if (delta < 200) teleport();
    }

    async function teleport() {
        _mouse.x = (Mouse.x/Stage.width)*2 - 1;
        _mouse.y = -(Mouse.y/Stage.height)*2 + 1;
        _threadEvent.pos = _mouse;
        let result = await _collision.test2D(_threadEvent);
        if ( !result || !result.point ) return false;

        if (_playerPosition.distanceTo(result.point) > PlayerTeleportMouse.MAX_MOVE) return;

        _move.copy(result.point);
        let distance = Math.abs(_playerPosition.length()-_move.length());
        let time = 800;//Math.range(distance, 0, 10, 400, 1000);

        if (result.point) {
            tween(_playerPosition, result.point, time, 'easeOutCubic')
            tween(_playerTarget, result.point, time, 'easeOutCubic')
            _this.findParent('Player').teleport();
            _this.events.fire(Player.TELEPORT);
        }
    }

    this.disable = function() {
        _this.events.unsub(_input, Interaction.START, touchStart);
    }
}, _ => {
    PlayerTeleportMouse.MAX_MOVE = PlayerTeleportMouse.MAX_MOVE_DEFAULT = 50;
});
Class(function AVSettingsController() {
    Inherit(this, Component);
    const _this = this;
    var _videoEnabled;
    var _audioEnabled;
    var _videoAllowed;
    var _audioAllowed;
    //*** Constructor
    (function () {
        _videoEnabled = true;
        _audioEnabled = true;
        _videoAllowed = true;
        _audioAllowed = true;
    })();

    //*** Event handlers

    //*** Public methods

    this.get('audioEnabled', () => {
        return _audioEnabled;
     });
     this.get('videoEnabled', () => {
        return _videoEnabled;
     });
     this.get('audioAllowed', () => {
        return _audioAllowed;
     });
     this.get('videoAllowed', () => {
        return _videoAllowed;
     });

    this.set('audioEnabled', (isEnabled) => {
        _this.events.fire(AVSettingsController.AUDIO_STATE_CHANGE, {isEnabled});
        _audioEnabled = isEnabled;
     });
     this.set('videoEnabled', (isEnabled) => {
        _this.events.fire(AVSettingsController.VIDEO_STATE_CHANGE, {isEnabled});
        _videoEnabled = isEnabled;
     });

     this.set('audioAllowed', (isAllowed) => {
        _this.events.fire(AVSettingsController.AUDIO_ALLOW_CHANGE, {isAllowed});
        _audioAllowed = isAllowed;
     });
     this.set('videoAllowed', (isAllowed) => {
        _this.events.fire(AVSettingsController.VIDEO_ALLOW_CHANGE, {isAllowed});
        _videoAllowed = isAllowed;
     });

},'singleton',()=>{
    AVSettingsController.AUDIO_STATE_CHANGE = 'event_audioenable_change',
    AVSettingsController.VIDEO_STATE_CHANGE = 'event_videoenable_change',
    AVSettingsController.AUDIO_ALLOW_CHANGE = 'event_audioallow_change',
    AVSettingsController.VIDEO_ALLOW_CHANGE = 'event_videoallow_change'
});
Class(function Playground() {
    Inherit(this, Component);
    const _this = this;
    let _view;

    const USING_XR = Platform.usingVR();

    //*** Constructor
    (async function () {
        await UILStorage.ready();
        Global.PLAYGROUND = Hydra.LOCAL ? (Router.virtualQuery || location.search.indexOf('p=') > 0) && Utils.query('p') : false;
        initXR();
    })();

    async function initXR() {
        if (USING_XR) {
            waitForInteraction();
        } else {
            await World.instance().init();
            initView();
            Stage.add(World.ELEMENT);
        }
    }

    async function waitForInteraction() {
        let click = async _ => {
            await World.instance().initXR(RenderManager.WEBVR);
            initView();
            _this.events.unsub(Mouse.input, Interaction.CLICK, click);
        };

        if (window.AURA) click();
        else _this.events.sub(Mouse.input, Interaction.CLICK, click);
    }

    function initView() {
        let request = Global.PLAYGROUND.split('/')[0];
        let view = window['Playground' + request] || window[request] || null;
        if (!view) throw `No Playground class ${request} found.`;

        _view = !!view.instance ? view.instance() : _this.initClass(view);
        if (_view.element) Stage.add(_view.element);

        if (_view.rt && _view.scene && _view.nuke) {
            let shader = _this.initClass(Shader, 'ScreenQuad', {
                tMap: {value: _view}
            });
            let mesh = new Mesh(World.QUAD, shader);
            World.SCENE.add(mesh);
        } else {
            World.SCENE.add(_view.group || _view.mesh || _view.object3D || new Group());
        }

        if (Global.DEBUG_CAMERA_POS) World.CAMERA.position.fromArray(Global.DEBUG_CAMERA_POS);

        Dev.expose('view', _view);
    }

    //*** Event handlers

    //*** Public methods

}, 'singleton');

Class(function PlatformAnalytics() {
    Inherit(this, Model);
    const _this = this;

    var _analytics;

    //*** Constructor
    (function () {
    })();

    this.init = async function (app) {
        await FirebaseAnalytics.ready();
        _analytics = app.analytics();
        _this.dataReady = true;
    };

    this.event = function (key, params) {
        if (!_analytics) return console.log('analytics not ready: ', key, params);
        _analytics.logEvent(key, params);
    };

    this.setUserProperties = function (data) {
        if (!_analytics) return console.log('analytics not ready: ', data);
        if (_analytics) _analytics.setUserProperties(data);
    };
}, 'Static');

Class(function PlatformAuth() {
    Inherit(this, Model);
    const _this = this;

    let _providers = {};
    let _href = window.location.href;

    _this.USER_STATE = 'dream_user_state';
    _this.INIT_STATE = 'dream_init_state';
    _this.LOGGED_IN = 'dream_logged_in';
    _this.LOGGED_OUT = 'dream_logged_out';
    _this.LOGIN_ERROR = 'dream_login_error';
    _this.CLAIMS_CHANGED = 'dream_claims_changed';

    _this.init = async function (app) {
        await Hydra.ready();
        await FirebaseAuth.ready();
        await PlatformDB.ready();

        initProviders();

        _this.AUTH = app.auth();
        _this.dataReady = true;
    };

    function initProviders() {
        if (Config.SERVICES && Config.SERVICES.auth && Config.SERVICES.auth.google) _providers['google'] = new firebase.auth.GoogleAuthProvider();
    }

    //*** Public methods
    _this.loginError = function (error) {
        loginError(error);
    };

    _this.logout = async function () {
        if (_this.AUTH) {
            Track.event('auth', 'logout');
            await window.DreamPresence?.beforeLogout();
            return _this.AUTH.signOut();
        }
        console.error('Auth not ready');
    };

    /**
     * Login Methods
     */
    _this.loginGoogle = function () {
        if (_this.AUTH && _providers['google']) return _this.AUTH.signInWithPopup(_providers['google']);
        console.log('Google login error');
    };

    function loginEmailPassword({ email, password }) {
        return _this.AUTH.signInWithEmailAndPassword(email, password);
    }

    function loginEmail({ email, continueURL = null }) {
        if (!email) email = window.prompt('Please provide your email address to login.');
        Storage.set('emailForSignIn', email);

        return _this.AUTH.sendSignInLinkToEmail(email, {
            url: continueURL || _href,
            handleCodeInApp: true
        });
    }

    function loginError(error) {
        // Some error occurred, you can inspect the code: error.code
        // Common errors could be invalid email and invalid or expired OTPs.
        let code = error.code;
        let message = 'Error logging in. Try logging in again later.';
        if (code === 'auth/invalid-action-code') message = 'Access link may have already been used or expired. Please try logging in again.';
        if (code === 'auth/invalid-user-token') message = 'Invalid token. Try logging in again.';
        if (code === 'auth/invalid-user-code') message = 'Invalid access code. Try logging in again.';
        if (code === 'auth/user-token-expired') message = 'Token expired. Try logging in again.';
        if (code === 'auth/web-storage-unsupported') message = 'Your web browser does not support web storage.';
        if (code === 'auth/too-many-requests') message = 'Too many requests. Try logging in again later.';
        if (code === 'auth/user-disabled') message = 'User has been disabled.';
        if (code === 'auth/custom') message = error.message;
        _this.events.fire(_this.LOGIN_ERROR, { code, message });
        Track.event('auth', 'loginError', code);
        console.log(error);
    }


    _this.login = function () {
        return {
            with(name, metadata) {
                if (!_this.AUTH) return;
                if (name === 'google') return _this.loginGoogle();
                if (name === 'email/password') return loginEmailPassword(metadata);
                if (name === 'email') return loginEmail(metadata);
                if (name === 'customToken') return _this.AUTH.signInWithCustomToken(metadata);
            }
        };
    };
}, 'static');

Class(function PlatformDB() {
    Inherit(this, Model);
    const _this = this;

    const consoleSecurity = require('ConsoleSecurity');

    var _database;

    //*** Constructor
    (function () {
    })();

    this.init = async function(app) {
        await FirebaseDB.ready();
        _database = app.database();
        _this.dataReady = true;
    }

    this.ref = function(path) {
        // if (!Hydra.LOCAL && consoleSecurity()) return false;
        if (_database) return _database.ref(path);
        return null;
    }

}, 'Static');
Class(function PlatformFirestore() {
    Inherit(this, Model);
    const _this = this;

    const consoleSecurity = require('ConsoleSecurity');

    let _firestore;

    //*** Constructor
    (function () {
    })();

    this.init = async function (app) {
        await Firestore.ready();
        _firestore = app.firestore();
        _this.dataReady = true;
    };

    this.doc = function (doc) {
        // if (!Hydra.LOCAL && consoleSecurity()) return false;
        if (_firestore) return _firestore.doc(doc);
        return null;
    };

    this.collection = function (collection) {
        // if (!Hydra.LOCAL && consoleSecurity()) return false;
        if (_firestore) return _firestore.collection(collection);
        return null;
    };

    this.timestamp = function () {
        return firebase.firestore.FieldValue.serverTimestamp()
    }

}, 'Static');

Class(function PlatformFunctions() {
    Inherit(this, Model);
    const _this = this;

    let _functions;

    //*** Constructor
    (function () {
    })();

    this.init = async function (app) {
        await FirebaseFunctions.ready();
        _functions = app.functions();

        if (Utils.query('localServer')) {
            _functions.useEmulator("localhost", 5000);
        }

        _this.FUNCTIONS = _functions;

        _this.dataReady = true;
    };

    this.httpsCallable = function (endpoint) {
        if (!_functions) return console.log('functions not ready: ', endpoint, data);
        return _functions.httpsCallable(endpoint);
    };
}, 'Static');

Class(function PlatformServices() {
    Inherit(this, Model);
    var _this = this;
    var _app;

    //*** Constructor
    (async function () {
        await Hydra.ready();
        await Config.ready();
        if (Config.SERVICES.firebase) Firebase.init();
        await Firebase.ready();
        if (Config.SERVICES.database) FirebaseDB.init();
        if (Config.SERVICES.firestore) Firestore.init();
        if (Config.SERVICES.auth) FirebaseAuth.init();
        if (Config.SERVICES.analytics) FirebaseAnalytics.init();
        if (Config.SERVICES.functions) FirebaseFunctions.init();
        if (Config.SERVICES.init === true) _this.init();
    })();

    //*** Event handlers

    //*** Public methods
    this.init = async function () {
        if (!Config.PLATFORM_CONFIG) return console.log('platform config missing');

        if (!_app) _app = firebase.initializeApp(Config.PLATFORM_CONFIG, 'platform');

        if (Config.SERVICES.database) {
            await FirebaseDB.ready();
            await PlatformDB.init(_app);
        }

        if (Config.SERVICES.firestore) {
            await Firestore.ready();
            await PlatformFirestore.init(_app);
        }

        if (Config.SERVICES.auth && (!Global.PLAYGROUND || Utils.query('login'))) {
            await PlatformAuth.init(_app);
            await PlatformAuth.ready();
        }

        if (Config.SERVICES.analytics) {
            await FirebaseAnalytics.ready();
            await PlatformAnalytics.init(_app);
        }

        if (Config.SERVICES.functions) {
            await FirebaseFunctions.ready();
            await PlatformFunctions.init(_app);
        }

        _this.dataReady = true;
    };
    //*** Private class
}, 'Static');

Class(function SoundFX() {
    Inherit(this, Component);
    const _this = this;

    var _audio = {};

    //*** Constructor
    (function () {

    })();

    //*** Event handlers

    //*** Public methods
    this.load = function(key, path, permanent = false) {
        _audio[key] = {
            audio3d: _this.initClass(Audio3D, {src: Assets.getPath(path), autoload: true}),
            permanent
        };

        _audio[key].audio3d.load();
    }

    this.play = function(key) {
        _audio[key].audio3d.play();
    }

    this.clear = function() {
        for (let key in _audio) {
            let audio = _audio[key];
            if (!audio.permanent) audio.destroy();
        }
    }
}, 'static');
Class(function UI3DPrompt(_config = {}) {
    Inherit(this, Object3D);
    const _this = this;
    var $root;

    _this.dimensions = {x: 1024, y:500};
    _this.padding = {x: 100, y:100};
    _this.text = 'Would you like to do the thing';
    _this.font = 'myriad';
    _this.fontSize = 50;
    _this.fontColor = '#000000';
    _this.align = 'center';
    _this.lineHeight = 1.5;
    _this.bgColor = '#FFFFFF';
    _this.yesButton = 'Yes';
    _this.noButton = 'No';
    _this.scale = _config.scale || 1;
    _this.hideButtonBuffer = _config.hideButtonBuffer || false;

    var _layout;
    var $capture, $bg, $content, $text;
    var _button1, _button2;

    //*** Constructor
    (async function () {
        GLSEO.registerPage(_this.group, 'UI3DPrompt');
        Object.assign(_this, _config);
        init();
        _this.startRender(_ => {});
        await initLayers();
        _this.flag('initialized', true);
        if (!Global.PLAYGROUND) _this.group.visible = false;
    })();

    async function initLayers() {
        $bg = $gl(_this.dimensions.x, _this.dimensions.y, _this.bgColor);
        $bg.setZ(-2);
        $root.add($bg)

        $content = $gl();
        $content.x = _this.padding.x;
        $content.y = _this.padding.y;
        $root.add($content);

        $text = $glText(_this.text, _this.font, _this.fontSize, {
            width: _this.dimensions.x * .75,
            align: _this.align,
            color: _this.fontColor,
            lineHeight: _this.lineHeight
        });
        $text.parentSeo = _this.group;
        $content.add($text);
        await $text.loaded();
        $text.x = _this.dimensions.x/2. - _this.padding.x;
        let buttonGap = 250;
        let buttonWidth = (_this.dimensions.x - (_this.padding.x) - buttonGap)/ 2;
        let buttonBuffer = 75;

        _button1 = _this.initClass(UI3DPromptButton, {
            text: _this.yesButton,
            width: buttonWidth,
            color: _this.fontColor,
            borderColor: _this.fontColor,
            bgHoverColor: _this.fontColor,
            hoverColor: _this.bgColor,
            font: _this.font
        });

        _button1.click = yesClick;
        $content.add(_button1.element);
        let button1Dimensions = await _button1.getDimensions();
        _button1.element.y = _this.dimensions.y - _this.padding.y - button1Dimensions.height;
        if (!_this.hideButtonBuffer) {
            _button1.element.y -= buttonBuffer;
        }

        if (!_config.singleOption) {
            _button2 = _this.initClass(UI3DPromptButton, {
                text: _this.noButton,
                width: buttonWidth,
                color: _this.fontColor,
                borderColor: _this.fontColor,
                bgHoverColor: _this.fontColor,
                hoverColor: _this.bgColor,
                font: _this.font
            });
            _button2.click = noClick;
            $content.add(_button2.element);
            let button2Dimensions = await _button2.getDimensions();
            _button2.element.y = _this.dimensions.y - _this.padding.y - button2Dimensions.height - buttonBuffer;
            _button2.element.x = _this.dimensions.x - _this.padding.x * 2. - button2Dimensions.width;
        } else {
            _button1.element.x = _this.dimensions.x/2 - button1Dimensions.width/2 - $content.x;
        }
    }

    function init() {
        let capture = _this.initClass(StageLayoutCapture, 1024, 1024, true);

        $root = capture.root;
        $capture = $gl(2., 2., capture);
        $capture.enable3D();
        _this.add($capture.group);
        if (!Platform.usingVR()) {
            $capture.mesh.shader.depthTest = false;
            $capture.mesh.shader.depthWrite = false;
        }
        $capture.mesh.shader.transparent = true;
        $capture.mesh.renderOrder = 999;
        capture.object3d = $capture;

        _this.capture = capture;
    }

    function yesClick() {
        _this.events.fire(Events.COMPLETE, {shouldStart: true});
    }

    function noClick() {
        _this.events.fire(Events.COMPLETE, {shouldStart: false});
    }

    //*** Public methods
    _this.animateIn = async function() {
        await _this.wait('initialized');
        _this.group.visible = true;
        _this.group.scale.setScalar(0);
        tween(_this.group.scale, {x:_this.scale, y:_this.scale, z:_this.scale}, 400, 'easeInOutCubic')
    }

    _this.animateOut = async function() {
        await _this.wait('initialized');
        tween(_this.group.scale, {x:0, y:0, z:0}, 400, 'easeInOutCubic').onComplete(_ => {
            _this.group.visible = false;
        });
    }

    _this.setText = async function(text) {
        await _this.wait('initialized');
        $text.setText(text);
    }

    _this.onInvisible = function() {

    }

    _this.onVisible = function() {

    }

    _this.onDestroy = function() {
        _this.group.deleted = true;
    }
});

Class(function UI3DPromptButton(_config = {}) {
    Inherit(this, GLUIElement);
    const _this = this;


    _this.text = '';
    _this.font = 'myriad';
    _this.fontSize = 30;
    _this.align = 'left';
    _this.padding = {x:40, y:50};
    _this.width = 150;
    _this.borderColor = _this.color = '#000000';
    _this.hoverColor = '#FFFFFF';
    _this.bgHoverColor = '#000000';

    var $text, $border;
    var _dimensions;

    //*** Constructor
    (async function () {
        Object.assign(_this, _config);
        await initText();
        addListeners();
        initBorder();
        _this.element.alpha = 1;
    })();

    async function initText() {
        _this.text = _this.text.toUpperCase();

        $text = await $glText(_this.text, _this.font, _this.fontSize, {
            align:'center',
            color: _this.color
        });
        await $text.loaded();

        let {width, height} = $text.dimensions;
        $text.x = (_this.width + _this.padding.x )/2.;
        $text.y = -(height * 1.4)/2.;

        _this.element.add($text);
    }


    async function initBorder() {
        await $text.loaded();
        let {width, height} = $text.dimensions;

        _dimensions = {
            width: _this.width + _this.padding.x,
            height: height + _this.padding.y,
        }

        $border = $gl(_dimensions.width, _dimensions.height, _this.borderColor);
        $border.parentSeo = _this.parent.group;
        $border.x = 0;
        $border.y = -_dimensions.height/2.;
        $border.z = -.01;

        let shader = _this.initClass(Shader,'UI3DPromptButtonShader',{
            uSize: { value: new Vector2(_dimensions.width, _dimensions.height) },
            uBorderColor: {value: new Color(_this.borderColor)},
            uColor: {value: new Color(_this.bgHoverColor)},
            uHover: {value: 0},
            uAlpha: {value: 1},
            transparent: true
        });
        $border.useShader(shader);

        _this.element.add($border);
        _this.flag('isReady', true)
    }

    function initDebug() {
        if (_this.isPlayground()) {
            _this.element.x = Stage.width / 2;
            _this.element.y = Stage.height / 2;
        }
    }

    //*** Event handlers
    async function addListeners() {
        await _this.wait('isReady');
        $border.interact(onHover, onClick, '#', _config.text);
    }

    function onHover(e) {
        if(e.action == 'over') {
            $border.shader.tween('uHover', 1, 400, 'easeOutCubic')
            $text.tweenColor(new Color(_this.hoverColor), 400, 'easeOutCubic', 0);
        }else{
            $border.shader.tween('uHover', 0, 400, 'easeOutCubic')
            $text.tweenColor(new Color(_this.color), 400, 'easeOutCubic', 0);
        }
    }

    function onClick() {
        if(_this.click) {
            _this.click();
        }
    }

    //*** Public methods
    _this.getDimensions = async function() {
        await _this.ready();
        return _dimensions;
    }

    _this.setText = function(text) {
        $text.setText(text);
    }

    _this.ready = async function() {
        return _this.wait(_this, 'isReady')
    }

    _this.animateIn = async function(delay) {
        await _this.ready();
        tween(_this.element, {alpha:1.}, 1000, 'easeOutCubic', delay)
    }

});

Class(function UIAVController() {
    Inherit(this, Element);
    const _this = this;
    var $this, $videoShareControl;
    var _view;

    //*** Constructor
    (function () {
        initHTML();
        initView()
    })();

    function initHTML() {
        $this = _this.element;
        $this.css({
            position:'relative'
        })
    }
    function initView() {
        _view = _this.initClass(UIAVControllerView);
    }

    this.updateSettings = function(hasVideo,hasAudio) {
        _view.updateSettings(hasVideo,hasAudio)
    }
    this.registerVideoAction = function (action) {
        _view.registerVideoAction(action)
    }
});
Class(function UIAVControllerView() {
    Inherit(this, Element);
    const _this = this;
    const $this = _this.element;
    var $audioButton,$videoWrap,$videoButton;
    const _prefix = 'UIAVControllerView';

    //*** Constructor
    (function () {
         initHTML();
         addListeners()
    })();

    function initHTML() {
        $this.css({
            position:'relative',
            display:'grid',
            gridAutoFlow:'column',
            gridAutoColumns:'max-content',
            gridGap:'1rem',
            alignItems:'end',
            justifySelf:'center',
            opacity:0
        })
        $audioButton = _this.initClass(UIAVToggleButton,"audio",[$this]);
        $videoWrap = $this.create(`${_prefix}__video`);
        $videoWrap.css({
            position:'relative',
            height:'11.5rem',
            width:'15rem'
        })
        _this.initClass(UIVideo,[$videoWrap]);
        $videoButton = _this.initClass(UIAVToggleButton,"video",[$this]);
    }

    function addListeners() {
        _this.onResize(resize);
        _this.events.sub(AVSettingsController.AUDIO_ALLOW_CHANGE,handleAudioAllowChange);
        _this.events.sub(AVSettingsController.VIDEO_ALLOW_CHANGE,handleVideoAllowChange);

    }

    function resize() {
        const size = Breakpoints.getSize();
        switch (size) {
            case 'big-desktop':
            case 'desktop':
            case 'tab-land':{
                $this.css({
                    gridAutoFlow:'column',
                    gridTemplateColumns:'unset',
                    justifyItems:'unset'
                })
                $audioButton.element.css({
                    order:"unset"
                })
                $videoButton.element.css({
                    order:"unset"
                })

                $videoWrap.css({
                    position:'relative',
                    height:'10rem',
                    width:'13rem',
                    gridColumn:'unset',
                    order:'unset'
                })
                break;
            }
            case 'tab-port':{
                $this.css({
                    gridAutoFlow:'column',
                    gridTemplateColumns:'unset',
                    justifyItems:'unset'
                })
                $audioButton.element.css({
                    order:"unset"
                })
                $videoButton.element.css({
                    order:"unset"
                })
                $videoWrap.css({
                    position:'relative',
                    height:'10rem',
                    width:'13rem',
                    gridColumn:'unset',
                    order:'unset'
                })
                break;
            }
            case 'phone':{
                $this.css({
                    gridTemplateColumns:'1fr 1fr',
                    justifyItems:'center',
                    gridAutoFlow:'unset'
                })
                $videoWrap.css({
                    height:'6rem',
                    width:'10rem',
                    gridColumn:'1/-1',
                    order:"1"
                })
                $audioButton.element.css({
                    order:"2"
                })
                $videoButton.element.css({
                    order:"3"
                })
            }
            default:
                break;
        }
    }

    function handleAudioAllowChange(e){
        if(e.isAllowed){
            $audioButton.element.css({
                display:'flex'
            })
        }else{
            $audioButton.element.css({
                display:'none'
            })
        }
        $this.css({
            opacity:1
        })
    }

    function handleVideoAllowChange(e){
        if(e.isAllowed){
            $videoWrap.css({
                display:'block'
            })
            $videoButton.element.css({
                display:'flex'
            })
        }else{
            $videoWrap.css({
                display:'none'
            })
            $videoButton.element.css({
                display:'none'
            })
        }
        $this.css({
            opacity:1
        })
    }

    function videoHover(e) {
        switch (e.action) {
            case 'over':
                $videoWrap.tween({ scale: 1.02, opacity: 0.8, y: 0 }, 200, 'easeOutCubic');
                break;
            case 'out':
                $videoWrap.tween({ scale: 1, opacity: 1, y: 0 }, 400, 'easeOutCubic');
                break;
        }
    }

    this.registerVideoAction = function (action) {
        $videoWrap.interact(videoHover,action)
    }
});
/**
 * @name UIAVAudioToggle
 */
Class(function UIAVAudioToggle({
    styles = {},
    animations = UIAVToggleAnimations,
    preset = 'default'
}) {
    Inherit(this, UIAVToggle, {
        styles,
        animations,
        preset
    });
    const _this = this;

    this.getEnabledAvSetting = _ => AVSettingsController.instance().audioEnabled;

    this.getAssets = _ => ({
        videoZoneEnabled: '~assets/images/icon/mic-video-zone.svg',
        videoZoneDisabled: '~assets/images/icon/mic-video-zone-red.svg',
        enabled: '~assets/images/icon/mic-on-grey.svg',
        disabled: '~assets/images/icon/mic-off.svg'
    });

    this.avSettingsSubscriber = _ => {
        _this.events.sub(AVSettingsController.AUDIO_STATE_CHANGE, _this.handleStateChange);
    };

    this.avSettingsUpdates = _ => {
        AVSettingsController.instance().audioEnabled = _this._enabled;
        if (_this._enabled) {
            Track.event('settings', 'enable_av_audio');
            GameCenterMedia.userStream.enableAudio();
        } else {
            Track.event('settings', 'enable_av_audio');
            GameCenterMedia.userStream.disableAudio();
        }
    };
});

/**
 * @name UIAVToggle
 *
 * A base class used for creating the audio/video toggle buttons
 *
 */
Class(function UIAVToggle({
    styles,
    animations,
    preset = 'default'
}) {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    const $this = _this.element;
    _this.isVideoChatZone = preset === 'video-chat-zone';

    _this._enabled = true;
    _this.$content = null;
    _this.$disableLine = null;

    var _clicked = false;

    //*** Constructor
    (async function () {
        await UIAVToggleStyles.ready();
        _this._enabled = _this.getEnabledAvSetting();
        initHTML();
        initStyles();
        addListeners();
        resize();
        checkState();
        _this.flag('isReady', true);
    })();

    function initHTML() {
        _this.$content = $this.create(`${_this.constructorName}content`);
        _this.$disableLine = $this.create(`${_this.constructorName}__content__disbale-line`);
    }

    function initStyles() {
        $this.css(_this.combineStyles([UIAVToggleStyles[preset].element, styles.element]));
        _this.$content.css(_this.combineStyles([UIAVToggleStyles[preset].content, styles.content]));
        if (preset === 'video-chat-zone') _this.$disableLine.css(_this.combineStyles([UIAVToggleStyles[preset].disableLine, styles.disableLine]));
        animations.setContentBg(_this);
        animations.setDisableLineVisibility(_this);
    }

    function checkState() {
        if (_this.isVideoChatZone) {
            if (_this._enabled) {
                animations.onEnabledVideoZone(_this);
            } else {
                animations.onDisabledVideoZone(_this);
            }
        } else {
            if (_this._enabled) {
                animations.onEnabled(_this, styles.element?.background || UIAVToggleStyles[preset].element.background);
            } else if (!_this.isVideoChatZone) {
                animations.onDisabled(_this, styles.disabledColor || UIAVToggleStyles[preset].disabledColor);
            }
        }
    }

    //*** Event handlers
    function addListeners() {
        $this.interact(onHover, onClick);
        _this.avSettingsSubscriber();
    }


    function onHover(e) {
        animations.onHover(e, _this);
    }

    function onClick() {
        if (!GameCenterMedia.userStream) return;
        if (_clicked) return;
        _clicked = true;

        animations.onClick(_this);

        _this._enabled = !_this._enabled;

        _this.avSettingsUpdates();

        checkState();

        _this.delayedCall(() => { if (_clicked) _clicked = false; }, 250);
    }

    function resize() {
        // if (styles.setResponsiveStyles) styles.setResponsiveStyles(_this);
    }
    //*** Public methods

    /**
     * @memberOf UIAVToggle
     * @return avsettingscontroller state
     * i.e. AVSettingsController.instance().audioEnabled;
     */
    this.getEnabledAvSetting = _ => {
        console.error(`override ${_this.constructorName}.getEnabledAvSetting()`);
    };

    /**
     * @memberOf UIAVToggle
     * @return an object containing asset paths
     * {
        videoZoneEnabled: '~assets/images/icon/mic-video-zone.svg',
        videoZoneDisabled: '~assets/images/icon/mic-video-zone-red.svg',
        enabled: '~assets/images/icon/mic-on-grey.svg',
        disabled: '~assets/images/icon/mic-off.svg'
    }
     */
    this.getAssets = _ => {
        console.error(`override ${_this.constructorName}.getAssets()`);
    };

    /**
     * @memberOf UIAVToggle
     * call any events.sub(AVSettingsController) here
     */
    this.avSettingsSubscriber = _ => {
        console.error(`override ${_this.constructorName}.avSettingsSubscriber()`);
    };

    /**
     * @memberOf UIAVToggle
     * Handle updating AVSettingsController, Track.events,
     * GameMediaCenter
     */
    this.avSettingsUpdates = _ => {
        console.error(`override ${_this.constructorName}.avSettingsUpdates()`);
    };

    /**
     * @memberOf UIAVToggle
     * @param e
     * called from avSettingsSubscriber
     */
    this.handleStateChange = function (e) {
        _this._enabled = e.isEnabled;
        checkState();
    };

    this.setStyles = async function(replacedStyles) {
        await _this.wait('isReady');
        if (replacedStyles.element) $this.css(replacedStyles.element);
        if (replacedStyles.content) _this.$content.css(replacedStyles.content);
        if (replacedStyles.disableLine) _this.$disableLine.css(replacedStyles.disableLine);
    };
});

/**
 * @name UIAVToggleAnimations
 */
Class(function UIAVToggleAnimations() {
    Inherit(this, Component);

    this.onHover = function ({ action }, component) {
        if (!component.element.tween) return;
        if (component.isVideoChatZone) {
            switch (action) {
                case 'over':
                    component.element.tween({ opacity: 0.8 }, 400, 'easeOutCubic');
                    break;
                case 'out':
                    component.element.tween({ opacity: 1 }, 300, 'easeOutCubic');
                    break;
            }
        } else {
            switch (action) {
                case 'over':
                    component.element.tween({ scale: 1.05 }, 300, 'easeOutCubic');
                    break;
                case 'out':
                    component.element.tween({ scale: 1 }, 300, 'easeOutCubic');
                    break;
            }
        }
    };

    this.onClick = (component) => {
        if (!component.isVideoChatZone) {
            component.element.tween({ scale: 0.98, opacity: 0.8 }, 100, 'easeOutCubic', (_) => {
                component.element.tween({ scale: 1, opacity: 1 }, 400, 'easeOutCubic');
            });
        }
    };

    this.setContentBg = (component) => {
        if (component.isVideoChatZone === 'video-chat-zone') component.$content.bg(component.getAssets().videoZoneEnabled, 'cover');
        else component.$content.bg(component.getAssets().enabled);
    };

    this.setDisableLineVisibility = (component) => {
        if (component.isVideoChatZone === 'video-chat-zone') component.$disableLine.show();
        else component.$disableLine.hide();
    };

    this.onEnabled = function (component, bgColor) {
        component.$content.bg(component.getAssets().enabled);

        component.element.css({
            background: bgColor
        });
    };

    this.onDisabled = function (component, bgColor) {
        component.$content.bg(component.getAssets().disabled);

        component.element.css({
            background: bgColor
        });
    };

    this.onEnabledVideoZone = async function (component) {
        component.$content.bg(component.getAssets().videoZoneEnabled);
        await component.$disableLine.tween({ opacity: 0, y: 30, x: 30, rotation: -45 }, 200, 'easeInOut').promise();
        if (!component.$disableLine.tween) return;
        component.$disableLine.css({
            transform: 'translate(-30px, -30px) rotate(-45deg)'
        });
    };

    this.onDisabledVideoZone = function (component) {
        component.$content.bg(component.getAssets().videoZoneDisabled);
        if (!component.$disableLine.tween) return;
        component.$disableLine.tween({ opacity: 0.7, y: 0, x: 0, rotation: -45 }, 200, 'easeInOut');
    };
}, 'static');

/**
 * @name UIAVToggleStyles
 */
Class(function UIAVToggleStyles() {
    Inherit(this, Component);
    const _this = this;
    (async function () {
        await DreamColors.instance().ready();

        _this.default = {
            element: {
                position: 'relative',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                borderRadius: '50%',
                cursor: 'pointer',
                padding: '1.5rem',
                height: 'fit-content',
                width: 'fit-content',
                background: DreamColors.instance().white
            },
            content: {
                height: '3rem',
                width: '3rem',
                position: 'relative',
                backgroundSize: 'contain'
            },

            disabledColor: DreamColors.instance().red
        };

        _this['video-chat-zone'] = {
            ..._this.default,
            element: {
                ..._this.default.element,
                height: '7rem',
                width: '7rem',
                padding: '0',
                borderRadius: '0%',
                background: DreamColors.instance().black,
                border: `1px solid ${DreamColors.instance().primary}`
            },
            content: {
                ..._this.default.content,
                height: '4rem',
                width: '2.3rem',
                backgroundPosition: 'center',
                backgroundSize: 'cover'
            },
            disableLine: {
                height: '80%',
                opacity: 0.7,
                transform: 'translate(-30px, -30px) rotate(-45deg)',
                borderLeft: `0.45rem solid ${DreamColors.instance().black}`,
                borderRight: `0.25rem solid ${DreamColors.instance().red}`
            }
        };

        _this.flag('isReady', true);
    })();

    _this.ready = function () {
        return _this.wait('isReady');
    };
}, 'static');

/**
 * @name UIAVVideoToggle
 */
Class(function UIAVVideoToggle({
    styles = {},
    animations = UIAVToggleAnimations,
    preset = 'default'
}) {
    Inherit(this, UIAVToggle, {
        styles,
        animations,
        preset
    });
    const _this = this;

    this.getEnabledAvSetting = _ => AVSettingsController.instance().videoEnabled;

    this.getAssets = _ => ({
        videoZoneEnabled: '~assets/images/icon/camera-video-zone.svg',
        videoZoneDisabled: '~assets/images/icon/camera-video-zone-red.svg',
        enabled: '~assets/images/icon/camera-on-grey.svg',
        disabled: '~assets/images/icon/camera-off.svg'
    });

    this.avSettingsSubscriber = _ => {
        _this.events.sub(AVSettingsController.VIDEO_STATE_CHANGE, _this.handleStateChange);
    };

    this.avSettingsUpdates = _ => {
        AVSettingsController.instance().videoEnabled = _this._enabled;
        if (_this._enabled) {
            Track.event('settings', 'enable_av_video');
            GameCenterMedia.userStream.enableVideo();
        } else {
            Track.event('settings', 'disable_av_video');
            GameCenterMedia.userStream.disableVideo();
        }
    };
});

Class(function UIVideo() {
    Inherit(this, Element);
    const _this = this;
    const $this = _this.element
    var $video, $wrapper, $overlay, $overlayIcon;
    const _prefix = 'VideoContainer';
    var _color;

    //*** Constructor
    (function () {
        initHTML();
        createVideo($wrapper);
        createOverlay($wrapper);
        addHandlers();
    })();

    function initHTML() {
        $this.size('100%')
        $this.css({
            position: 'relative'
        })
        $wrapper = $this.create(`${_prefix}__wrapper`);
        $wrapper.css({
            position: 'relative',
            width: '100%',
            height: '100%'
        })

    }

    function createOverlay(parent) {
        $overlay = parent.create(`${_prefix}__overlay`);
        $overlay.css({
            width:'100%',
            height:'100%',
            background:Colors.monochrome[6],
            top:0,
            left:0,
            display:'flex',
            justifyContent:'center',
            borderRadius: '1rem',
            alignItems:'center',
            opacity:0
        })
        $overlayIcon = $overlay.create(`${_prefix}__overlay__icon`)
        $overlayIcon.css(CoreUIState.instance().styleguide.icon);
        $overlayIcon.css({
            position:'relative',
            background: 'white',
            width:'4rem',
            height:'4rem',
            "-webkit-mask-repeat":'no-repeat',
            "-webkit-mask-size":'contain',
            maskSize:'contain',
            "-webkit-mask-image":`url(${Assets.getPath('assets/images/icon/user.svg')})`,
            maskImage:`url(${Assets.getPath('assets/images/icon/user.svg')})`,
        })
    }

    async function createVideo(parent) {
        $video = parent.create(`${_prefix}__video`, 'video')
        $video.css({
            background: 'black',
            height: '100%',
            width: '100%',
            borderRadius: '1rem',
            border: '0.5em solid '+Global.PLAYER_COLOR,
            boxShadow: '0 2px 10px rgba(0,0,0,0.2)'
        })
        $video.attr('muted', 'true')
        $video.attr('playsinline', 'true')

        let stream = await GameCenterMedia.getUserStream();
        if(stream){
            _this.delayedCall(()=>{
                $video.div.srcObject = stream.srcObject;
                $video.div.play();
                $video.div.muted = true;
            },100)
      
        }
    }

    function setBorderColor(color) {
        $video.css({
            border: `0.5em solid ${color}`,
        })
    }
    //*** Event handlers
    function addHandlers() {
        _this.events.sub(UIVideo.CHANGE_BORDER_COLOR, handleColorChange);
        _this.events.sub(GameCenterMediaUserStream.UPDATE,updateStream);
        _this.events.sub(AVSettingsController.VIDEO_STATE_CHANGE,handleVideoStateChange);
        _this.onResize(resize);
    }

    function handleVideoStateChange(e) {
        if (e.isEnabled){
            $overlay.tween({opacity:0},500,'easeOutCubic')
        }else{
            $overlay.tween({opacity:1},500,'easeOutCubic')
        }
    }
    async function updateStream() {
        let stream = await GameCenterMedia.userStream.getStream();
        _this.delayedCall(()=>{
            $video.div.srcObject = stream.srcObject;
            $video.div.play();
            $video.div.muted = true;
        },100)
    }

    function resize() {
        const size = Breakpoints.getSize();
        if(size == 'phone' || size == 'tab-port'){
            $overlayIcon.css({
                width:'2.5rem',
                height:'2.5rem',
            })
        }else{
            $overlayIcon.css({
                width:'4rem',
                height:'4rem',
            })
        }

    }


    function handleColorChange(e) {
        if (e.color) {
            _color = e.color
            setBorderColor(_color)
        }
    }
    //*** Public methods

}, _ => {
    UIVideo.CHANGE_BORDER_COLOR = 'change_border_color';
});
Class(function UIAVAudioBars({
    styles = {}
}) {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    const $this = _this.element;
    var $bars = [];
    var _audioContext, _analyser, _source, _dataArray;
    //*** Constructor
    (async function () {
        await UIAVAudioBarsStyles.ready();
        initHTML();
        initAnalyser();
        addListeners();
        _this.startRender(loop);
    })();

    function initHTML() {
        $this.css(_this.combineStyles([UIAVAudioBarsStyles.element, styles.element]));

        let numBars = 3;
        for (let i = 0; i < numBars; i++) {
            let bar = $this.create(`UIAVAudioBars__audio-bar`);
            bar.css(_this.combineStyles([UIAVAudioBarsStyles.bar, styles.bar]));
            $bars.push(bar);
        }
    }

    async function initAnalyser() {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (AudioContext) {
            _audioContext = new AudioContext();
            _analyser = _audioContext.createAnalyser();
            _analyser.minDecibels = -70;
            _analyser.maxDecibels = -10;
            _analyser.smoothingTimeConstant = 0.85;
            _analyser.fftSize = 256;
            const stream = await GameCenterMedia.userStream.getStream();
            if (stream) {
                _source = _audioContext.createMediaStreamSource(stream.srcObject);
                _source.connect(_analyser);
                const bufferLength = _analyser.frequencyBinCount;
                _dataArray = new Float32Array(bufferLength);
            }
        }
    }

    function loop() {
        if (_dataArray && _analyser) {
            _analyser.getFloatFrequencyData(_dataArray);
            let value = Math.range(_dataArray[0], -100, -30, 0.1, 1.0, true);
            for (let bar of $bars) {
                bar.css({
                    height: `${2 * value}rem`
                });
            }
        }
    }

    //*** Event handlers
    function addListeners() {
        _this.events.sub(GameCenterMediaUserStream.UPDATE, replaceStream);
    }

    async function replaceStream() {
        initAnalyser();
    }
    //*** Public methods
});

/**
 * @name UIAVAudioBarsStyles
 */
Class(function UIAVAudioBarsStyles() {
    Inherit(this, Component);
    const _this = this;

    (async function () {
        await DreamColors.instance().ready();
        _this.element = {
            display: 'grid',
            position: 'relative',
            gridAutoFlow: 'column',
            gridAutoColumns: 'min-content',
            gridGap: '3px'
        };

        _this.bar = {
            position: 'relative',
            borderRadius: 3,
            height: "2rem",
            width: 2,
            willChange: 'height',
            background: DreamColors.instance().gray800
        };

        _this.flag('isReady', true);
    })();

    _this.ready = function() {
        return _this.wait('isReady');
    };
}, 'static');

Class(function UIAudioInput(_config) {
    Inherit(this, Element);
    const _this = this;
    const $this = _this.element;
    var _audioContext;
    var _prefix = 'UIAudioInput';
    var $start, $header, $inputs, $audioTestButton, $close, $doneButton, $spinner;
    var _audioInput, _audioOutput, _parent;
    //*** Constructor
    (async function () {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (AudioContext) {
            _audioContext = new AudioContext();
        }
        parseConfig();
        initHTML();
        initStyles();
    })();

    async function initHTML() {
        initSpinner();
        $start = $this.create(`${_prefix}_start`);
        $close = $start.create(`${_prefix}__close`);
        $header = $start.create(`${_prefix}__header`, 'h4');
        $header.text('Audio Settings');

        $inputs = $this.create(`${_prefix}__inputs`);
        $doneButton = $this.create(`${_prefix}__button`);
        $doneButton.text('Done');

        let sections = [
            {
                title: 'Microphone',
                image: '~assets/images/icon/mic-on-grey.svg',
                subView: createAudioBars,
                options: await GameCenterMedia.userStream.getAudioInputs(),
            },
            {
                title: 'Speakers',
                image: '~assets/images/icon/sound-level2.svg',
                subView: createAudioTestButton,
                options: await GameCenterMedia.userStream.getAudioOutputs(),
            },
        ];
        for (let section of sections) {
            let newSection = createSubsection($inputs, section.title, section.image, section.subView);
            if (section.title == 'Microphone') {
                _audioInput = createDropdown(newSection, section.options);
            } else {
                _audioOutput = createDropdown(newSection, section.options);
            }
        }

        animateIn();
        addListeners();
    }

    function initStyles() {
        CoreUIState.instance().uiBuilder.buildTextButton($doneButton);
        CoreUIState.instance().uiBuilder.buildUIAudioInput({
            start: $start,
            container: $this,
            close: $close,
            header: $header,
            inputs: $inputs,
            done: $doneButton,
        });
        $start.css({ opacity: 0 });
        $inputs.css({ opacity: 0 });
        $doneButton.css({ opacity: 0 });
    }

    function createSubsection(parent, title, image, subView) {
        let section = parent.create(`${_prefix}__section`);

        let sectionHeader = section.create(`${_prefix}__section__header`);

        let sectionLabel = sectionHeader.create(`${_prefix}__section__label`);

        sectionLabel.text(title);
        let sectionActions = sectionHeader.create(`${_prefix}__section__actions`);

        CoreUIState.instance().uiBuilder.buildUIAVInputSubsection({
            section,
            sectionHeader,
            sectionLabel,
            sectionActions,
        });

        if (image) {
            let itemIcon = sectionActions.create(`${_prefix}__header__item__image`);
            CoreUIState.instance().uiBuilder.buildIcon(itemIcon);
            itemIcon.bg(image);
        }
        if (subView) {
            subView(sectionActions);
        }
        return section;
    }

    function createDropdown(section, options) {
        let curr = null;
        let mappedOptions = options.map((option) => {
            if (option.selected) {
                curr = option;
            }
            return { label: option.label, value: option };
        });

        return _this.initClass(UISelectView, { inputType: 'chat', label: '', options: mappedOptions, value: curr ? curr : options.length > 0 ? options[0] : null }, [
            section,
        ]);
    }

    function createAudioBars(parent) {
        _this.initClass(UIAVAudioBars, [parent]);
    }

    function createAudioTestButton(parent) {
        if (_audioContext) {
            $audioTestButton = parent.create(`${_prefix}__test-button`);
            CoreUIState.instance().uiBuilder.buildUIAVInputAudioTestButton($audioTestButton);
            $audioTestButton.text('Test');

            var myRequest = new Request(Assets.getPath('~assets/audio/message.mp3'));

            fetch(myRequest)
                .then(function (response) {
                    return response.arrayBuffer();
                })
                .then(function (buffer) {
                    if (buffer) {
                        _audioContext.decodeAudioData(buffer, function (decodedData) {
                            $audioTestButton.interact(null, () => {
                                source = _audioContext.createBufferSource();
                                source.buffer = decodedData;
                                source.connect(_audioContext.destination);
                                source.start(0, 0, 1);
                            });
                        });
                    }
                });
        }
    }

    function parseConfig() {
        for (let key in _config) {
            switch (key) {
                case 'parent':
                    _parent = _config[key];
                    break;

                default:
                    break;
            }
        }
    }

    function animateIn() {
        if ($spinner) {
            removeSpinner();
        }
        AnimationBuilder.fadeInUp($start, 0);
        AnimationBuilder.fadeInUp($inputs, 100);
        AnimationBuilder.fadeInUp($doneButton, 200);
    }

    function initSpinner() {
        let size = Device.mobile.phone ? 100 : 110;
        $spinner = $this.create('.spinner-anim');
        $spinner.size(size, size).center();
        $spinner.css({
            borderRight: '2px solid #bbb',
            borderLeft: '2px solid #f4f4f4',
            borderTop: '2px solid #bbb',
            borderBottom: '2px solid #f4f4f4',
            borderRadius: '50%',
        });
    }

    function removeSpinner() {
        $spinner.tween({ opacity: 0 }, 300, 'easeOutCubic', () => {
            $spinner.destroy();
            $spinner = null;
        });
    }

    //*** Event handlers

    function addListeners() {
        _this.events.sub(_audioInput, UISelectView.VALUE_CHANGE, handleValueChange);
        _this.events.sub(_audioOutput, UISelectView.VALUE_CHANGE, handleValueChange);
        $doneButton.interact(null, () => {
            _parent.closeSettings();
        });
        $close.interact(null, () => {
            _parent.closeSettings();
        });
    }

    function handleValueChange(e) {
        let option = e.value;
        switch (option.kind) {
            case 'audioinput': {
                GameCenterMedia.userStream.setAudioSource(option.deviceId);
                break;
            }
            case 'audiooutput': {
                GameCenterMedia.userStream.setAudioOutputSource(option.deviceId);
                break;
            }
            case 'videoinput': {
                GameCenterMedia.userStream.setVideoSource(option.deviceId);
                break;
            }
        }
    }
    //*** Public methods
});

Class(function UIAudioInputStyles() {
    Inherit(this, Component);

    this.buildUIAudioInput = function (elements) {
        let { start, container, header, inputs, close, done } = elements;

        start.css({
            display: 'flex',
            flexDirection: 'row-reverse',
            justifyContent: 'space-between',
            position: 'relative',
        });

        close.css(this.styleguide.icon);
        close.css({
            position: 'relative',
            justifySelf: 'end',
        });
        close.bg('~assets/images/icon/close.svg', 'cover');

        container.css({
            background: 'white',
            padding: '3rem',
            position: 'relative',
            display: 'grid',
            gridAutoRows: 'min-content',
            gridGap: '4rem',
        });

        header.css(this.styleguide.h4);
        header.medium();
        header.css({
            color: '#4E596D',
            fontSize: '2.4rem',
        });

        inputs.css({
            position: 'relative',
            display: 'grid',
            gridAutoRows: 'min-content',
            gridGap: '3rem',
        });

        done.css({
            padding: '1.5rem 2rem',
        });
    };
}, 'static');

Class(function UIAVInputView(_config) {
    Inherit(this, Element);
    const _this = this;
    const $this = _this.element;
    const _prefix = 'UIAVInputView';
    var $body, $audioTab, $videoTab, $header, $audioTestButton, $audioTab, $audioTabHeader, $videoTabHeader, $title, $testVideo, $button;
    var _audioContext;
    var $audioDropdowns = [];
    var $headerItems = [];
    var _activeIndex = 0;
    var $tabBodies = [];
    var _audioInputOptionsOpen = false;
    var _audioOutputOptionsOpen = false;
    //*** Constructor
    (async function () {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        _audioContext = new AudioContext();
        initHTML();
        createTitle();
        createHeader();
        createBody();
        $tabBodies.push(await createAudioTab($body));
        createButton();
        addListeners();
        handleAudioAllowChange({
            isAllowed: AVSettingsController.instance().audioAllowed,
        });
        $tabBodies.push(await createVideoTab($body));
        handleVideoAllowChange({
            isAllowed: AVSettingsController.instance().videoAllowed,
        });

        show();
    })();

    function initHTML() {
        CoreUIState.instance().uiBuilder.buildUIAVInputContainer($this);
        
    }

    function closeAllDropdowns() {
        for (let dropdown of $audioDropdowns) {
            dropdown.tween({ opacity: 0 }, 300, 'easeOutQuad');
        }
    }

    function createBody() {
        $body = $this.create(`${_prefix}__body`);
        $body.css({
            width: '100%',
            position: 'relative',
            marginTop: '4rem',
            height: 192
        });
        $body.interact(null, () => {
            closeAllDropdowns()
        });
    }

    function createTitle() {
        $title = $this.create(`${_prefix}__title`);
        let $iconWrapper = $title.create(`${_prefix}__icon-wrapper`)
        let $icon = $iconWrapper.create(`${_prefix}__title__icon`);
        let $settingsText = $iconWrapper.create(`${_prefix}__settings-text`)
        $iconWrapper.css({
            position: 'relative',
            display: 'flex',
            alignItems: 'center'
        })
        $settingsText.text('Settings')
        $iconWrapper.interact(null, () => {
            closeAllDropdowns()
            if (_config.previousComponent) {
                UIController.instance().modal.openModal(_config.previousComponent);
            } else {
                UIController.instance().modal.closeModal();
            }
        });
        let $text = $title.create(`${_prefix}__title__text`);
        $text.text('/ AUDIO + VIDEO');
        CoreUIState.instance().uiBuilder.buildUIAVInputTitle({
            title: $title,
            icon: $icon,
            text: $text,
            $settingsText
        });
    }
    function createHeader() {
        $header = $this.create(`${_prefix}__header`);
        $header.css({
            position: 'relative',
            width: '75%',
        });
        let headerContent = $header.create(`${_prefix}__header__content`);
        headerContent.css({
            position: 'relative',
            display: 'grid',
            gridAutoFlow: 'column',
            gridGap: '1rem',
            gridAutoRows: 'min-content',
        });
        let options = [
            {
                title: 'Audio',
                image: '~assets/images/icon/speaker.svg',
                altImage: '~assets/images/icon/speaker-grey.svg',
                isActive: true,
            },
            {
                title: 'Video',
                image: '~assets/images/icon/camera-on-orange.svg',
                altImage: '~assets/images/icon/camera-on-grey.svg',
                isActive: false,
            },
        ];
        let i = 0;
        for (let option of options) {
            let item = createHeaderItem(headerContent, option, i);
            if (option.title == 'Audio') {
                $audioTabHeader = item;
            } else if (option.title == 'Video') {
                $videoTabHeader = item;
            }
            i++;
        }
    }
    function createHeaderItem(parent, option, index) {
        let item = parent.create(`${_prefix}__header__item`);
        item.index = index;
        let label = item.create(`${_prefix}__header__item__text`);
        label.text(option.title);
        CoreUIState.instance().uiBuilder.buildUIAVInputHeaderItem(
            {
                item,
                label,
            },
            option
        );
        $headerItems.push({
            item,
            label,
            option,
            index,
        });
        item.interact(null, () => {
            _activeIndex = index;
            for (let headerItem of $headerItems) {
                const isActive = _activeIndex == headerItem.index;
                headerItem.item.css({
                    borderBottom: isActive ?  `2px solid ${Colors.yellow[0]}` : `2px solid  ${Colors.monochrome[4]}`,
                });
                headerItem.label.css({
                    color: isActive ? Colors.yellow[0] : Colors.monochrome[4],
                });
            }
            swapTabBody();
        });
        return item;
    }
    async function createAudioTab(parent) {
        $audioTab = createTab(parent);
        let sections = [
            {
                title: 'Microphone',
                image: '~assets/images/icon/mic-on-grey.svg',
                subView: createAudioBars,
                options: await GameCenterMedia.userStream.getAudioInputs(),
                isOpen: _audioInputOptionsOpen
            },
            {
                title: 'Speakers',
                image: '~assets/images/icon/sound-level2-grey.svg',
                subView: createAudioTestButton,
                options: await GameCenterMedia.userStream.getAudioOutputs(),
                isOpen: _audioOutputOptionsOpen
            },
        ];
        for (let section of sections) {
            let newSection = createSubsection($audioTab, section.title, section.image, section.subView);
            createDropdown(newSection, section.options);
        }
        return $audioTab;
    }

    async function createVideoTab(parent) {
        $videoTab = createTab(parent);
        $videoTab.css({
            opacity: 0,
            display: 'none',
        });
        let sections = [
            {
                title: 'Cameras',
                subView: createTestVideo,
                options: await GameCenterMedia.userStream.getVideoInputs(),
            },
        ];
        for (let section of sections) {
            let newSection = createSubsection($videoTab, section.title, section.image, section.subView);
            createDropdown(newSection, section.options);
        }
        return $videoTab;
    }

    function createTab(parent) {
        let tab = parent.create(`${_prefix}__input-section`);
        tab.css({
            height: '100%',
            width: '100%',
            top: 0,
            gridAutoRows: 'min-content',
            display: 'grid',
            gridGap: '4rem',
            position: 'relative'
        });
        return tab;
    }
    function createSubsection(parent, title, image, subView) {
        let section = parent.create(`${_prefix}__section`);

        let sectionHeader = section.create(`${_prefix}__section__header`);

        let sectionLabel = sectionHeader.create(`${_prefix}__section__label`);

        sectionLabel.text(title);
        let sectionActions = sectionHeader.create(`${_prefix}__section__actions`);

        CoreUIState.instance().uiBuilder.buildUIAVInputSubsection({
            section,
            sectionHeader,
            sectionLabel,
            sectionActions,
        });

        if (image) {
            let itemIcon = sectionActions.create(`${_prefix}__header__item__image`);
            CoreUIState.instance().uiBuilder.buildIcon(itemIcon);
            itemIcon.bg(image);
        }
        if (subView) {
            subView(sectionActions);
        }
        return section;
    }
    function createAudioBars(parent) {
        _this.initClass(UIAVAudioBars, [parent]);
    }
    function createAudioTestButton(parent) {
        $audioTestButton = parent.create(`${_prefix}__test-button`);
        CoreUIState.instance().uiBuilder.buildUIAVInputAudioTestButton($audioTestButton);
        $audioTestButton.text('Test');

        var myRequest = new Request(Assets.getPath('~assets/audio/test.mp3'));

        fetch(myRequest)
            .then(function (response) {
                return response.arrayBuffer();
            })
            .then(function (buffer) {
                _audioContext.decodeAudioData(buffer, function (decodedData) {
                    $audioTestButton.interact(null, () => {
                        source = _audioContext.createBufferSource();
                        source.buffer = decodedData;
                        source.connect(_audioContext.destination);
                        source.start();
                    });
                });
            });
    }

    async function createTestVideo(parent) {
        $testVideo = parent.create(`${_prefix}__video`, 'video');
        $testVideo.css({
            background: 'black',
            height: '3rem',
            width: '5rem',
            position: 'relative',
        });
        $testVideo.attr('autoplay', 'true');
        let stream = await GameCenterMedia.userStream.getStream();
        if (stream) {
            $testVideo.div.srcObject = stream.srcObject;
            $testVideo.div.play();
            $testVideo.div.volume = 0.001;
        }
    }

    function createDropdown(parent, options) {
        if (options && options.length > 0) {
            let curr = options.filter((option) => {
                return option.selected;
            });
            curr = curr.length > 0 ? curr[0] : options[0];
            let type = 'Input';
            let dropdown = parent.create(`${_prefix}__dropdown`);
            dropdown.css({ position: 'relative' });
            let select = dropdown.create(`${_prefix}__dropdown__select`);
            let label = select.create(`${_prefix}__dropdown__curr`);
            label.text(curr._name.length > 0 ? curr._name : type + ' ' + 1);
            let icon = select.create(`${_prefix}__dropdown__curr`);
            let optionContainer = dropdown.create(`${_prefix}__dropdown__options`);
            CoreUIState.instance().uiBuilder.buildUIAVInputDropdown({
                select,
                label,
                optionContainer,
                icon,
            });
            $audioDropdowns.push(optionContainer);
            let i = 0;
            for (let option of options) {
                i++;
                let newOption = optionContainer.create(`${_prefix}__dropdown__option`);
                newOption.text(option._name.length > 0 ? option._name : type + ' ' + i);
                CoreUIState.instance().uiBuilder.buildUIAVInputDropdownOption(newOption);
                newOption.interact(
                    (e) => {
                        switch (e.action) {
                            case 'over': {
                                newOption.tween({ backgroundColor: `rgba(0,0,0,0.2)`}, 200, 'easeOutCubic');
                                break;
                            }

                            case 'out': {
                                newOption.tween({ backgroundColor: `rgba(0,0,0,0.0)`}, 200, 'easeOutCubic');
                                break;
                            }
                        }
                    },
                    () => {
                        label.text(option._name.length > 0 ? option._name : type + ' ' + i);
                        optionContainer.tween({ opacity: 0 }, 500, 'easeOutQuad', () => {
                            optionContainer.css({ display: 'none' });
                        });
                        switch (option.kind) {
                            case 'audioinput': {
                                GameCenterMedia.userStream.setAudioSource(option);
                                break;
                            }
                            case 'audiooutput': {
                                GameCenterMedia.userStream.setAudioOutputSource(option);
                                break;
                            }
                            case 'videoinput': {
                                GameCenterMedia.userStream.setVideoSource(option);
                                break;
                            }
                        }
                    }
                );
            }
            select.interact(null, () => {
                optionContainer.tween({ opacity: 1, display: 'grid' }, 500, 'easeOutQuad');
            });
        } else {
            let dropdown = parent.create(`${_prefix}__dropdown`);
            dropdown.css({ position: 'relative' });
            let select = dropdown.create(`${_prefix}__dropdown__select`);
            let label = select.create(`${_prefix}__dropdown__curr`);
            label.text('No devices found.');
            CoreUIState.instance().uiBuilder.buildUIAVInputEmptyDropdown({
                select,
                label,
            });
        }
    }

    function createButton() {
        $button = $this.create(`${_prefix}__button`);
        $button.text('Save');
        CoreUIState.instance().uiBuilder.buildTextButton($button);
        $button.interact(hover, () => {
            UIController.instance().modal.closeModal();
        });
    }

    function hover(e) {
        switch (e.action) {
            case 'over': {
                $button.tween({ opacity: 0.5}, 400, 'easeOutCubic');
                break;
            }

            case 'out': {
                $button.tween({ opacity: 1}, 200, 'easeOutCubic');
                break;
            }
        }
    }

    function show() {
        $this.tween({ opacity: 1 }, 500, 'easeOutCubic');
    }
    //*** Event handlers
    function addListeners() {
        _this.onResize(resize);
        _this.events.sub(AVSettingsController.AUDIO_ALLOW_CHANGE, handleAudioAllowChange);
        _this.events.sub(AVSettingsController.VIDEO_ALLOW_CHANGE, handleVideoAllowChange);

        _this.events.sub(GameCenterMediaUserStream.UPDATE, replaceStream);
    }

    async function replaceStream() {
        let stream = await GameCenterMedia.userStream.getStream();
        if (!$testVideo?.div?.srcObject) return
        $testVideo.div.srcObject = stream.srcObject;
    }

    function swapTabBody() {
        for (let i = 0; i < $tabBodies.length; i++) {
            if (i != _activeIndex) {
                $tabBodies[i].hide()
            } else {
                $tabBodies[i].css({
                    display: 'grid',
                });
                $tabBodies[i].tween({ opacity: 1 }, 300, 'easeOutQuad', 0);
            }
        }
    }

    function resize() {
        const size = Breakpoints.getSize();
        switch (size) {
            case 'big-desktop': {
                $this.css({
                    width: '25vw',
                    // height: '60vh',
                });     
                break;
            }
            case 'desktop': {
                $this.css({
                    width: '30vw',
                    // height: '80vh',
                });
                break;
            }
            case 'tab-land': {
                $this.css({
                    width: '40vw',
                    // height: '60vh',
                });
                break;
            }
            case 'tab-port': {
                $this.css({
                    width: '50vw',
                    // height: '60vh',
                });
                break;
            }
            case 'phone': {
                $this.css({
                    width: '95vw',
                    // height: '70vh',
                });
                break;
            }
        }
        if (Device.mobile && Stage.width > Stage.height) {
            $this.css({
                width: '80vw',
                height: '95vh',
            });
            if ($audioTab) {
                $audioTab.css({
                    gridAutoFlow: 'column',
                    gridGap: '4rem',
                });
            }
            if ($videoTab) {
                $videoTab.css({
                    gridAutoFlow: 'column',
                    gridGap: '4rem',
                });
            }
        } 
    }
    function handleAudioAllowChange(e) {
        if (!e.isAllowed) {
            $audioTabHeader.css({
                opacity: 0,
                display: 'none',
            });
            $audioTab.css({
                opacity: 0,
                display: 'none',
            });
            if (_activeIndex == 0) {
                _activeIndex = 1;
                $videoTabHeader.css({
                    opacity: 1,
                    display: 'grid',
                });
                $videoTab.css({
                    opacity: 1,
                    display: 'grid',
                });
            }
        } else {
            $audioTabHeader.css({
                opacity: 1,
                display: 'grid',
            });
            $audioTab.css({
                opacity: 1,
                display: 'grid',
            });
        }
    }

    function handleVideoAllowChange(e) {
        if (!e.isAllowed) {
            $videoTabHeader.css({
                opacity: 0,
                display: 'none',
            });
            $videoTab.css({
                opacity: 0,
                display: 'none',
            });
            if (_activeIndex == 1) {
                _activeIndex = 0;
                $audioTabHeader.css({
                    opacity: 1,
                    display: 'grid',
                });
                $audioTab.css({
                    opacity: 1,
                    display: 'grid',
                });
            }
        }
    }
});

Class(function UIAVInputViewStyles() {
    Inherit(this, Component);

    this.buildUIAVInputContainer = function (container) {
        container.css({
            opacity: 0,
            width: '22vw',
            maxHeight: 600,
            height: 'fit-content',
            background: 'black',
            position: 'relative',
            padding: '3rem'
        });
    };

    this.buildUIAVInputTitle = function (elements) {
        let { title, text, icon, $settingsText } = elements;
        title.css({
            position: 'relative',
            display: 'grid',
            gridAutoFlow: 'column',
            gridGap: '1rem',
            paddingBottom: '2rem',
            marginBottom: '4.8rem',
            gridAutoColumns: 'min-content',
            alignItems: 'center',
            borderBottom: `0.1rem solid #7D7B7C`
        });

        this.buildMaskIcon(icon, '~assets/images/icon/arrow-left.svg', '1rem', '0.9rem', this.colors.primary[0]);
        icon.css({
            cursor: 'pointer'
        });

        $settingsText.css({
            ...this.styleguide.p1,
            fontSize: '1.5rem',
            color: "#7D7B7C",
            marginLeft: '1.2rem',
            letterSpacing: '0.08rem'
        });

        text.css(this.styleguide.h4);
        text.css({
            color: 'white',
            whiteSpace: 'nowrap',
            fontSize: '1.8rem',
            letterSpacing: '0.08rem',
            position: 'relative'
        });
    };
    this.buildUIAVInputHeaderItem = function (elements, option) {
        let { item, itemIcon, label } = elements;
        item.css({
            display: 'grid',
            gridAutoFlow: 'column',
            gridAutoColumns: 'min-content',
            gridGap: '2rem',
            paddingBottom: '0.8rem',
            pointer: 'cursor',
            position: 'relative',
            borderBottom: option.isActive ? `2px solid ${this.colors.yellow[0]}` : `2px solid  ${this.colors.monochrome[4]}`
        });

        label.css(this.styleguide.label5);
        label.css({
            color: option.isActive ? this.colors.yellow[0] : this.colors.monochrome[4],
            fontWeight: 'bold',
            textTransform: 'uppercase',
            fontSize: '1.2rem',
            letterSpacing: '0.08rem'
        });
    };

    this.buildUIAVInputSubsection = function (elements) {
        let { section, sectionHeader, sectionLabel, sectionActions } = elements;
        section.css({
            display: 'grid',
            gridGap: '1.5rem',
            position: 'relative'
        });
        sectionHeader.css({
            display: 'grid',
            position: 'relative',
            gridTemplateColumns: '1fr auto',
            alignItems: 'center'
        });
        sectionLabel.css(this.styleguide.label3);
        sectionLabel.css({
            color: "#F1F1F1",
            fontSize: '1.8rem',
            letterSpacing: '0.08rem',
            textTransform: 'uppercase',
            fontWeight: 'lighter'
        });
        sectionActions.css({
            position: 'relative',
            display: 'grid',
            gridAutoFlow: 'column',
            gridGap: '1rem',
            gridAutoColumns: 'min-content',
            alignItems: 'center'
        });
    };

    this.buildUIAVInputAudioTestButton = function (button) {
        button.css(this.styleguide.label4);
        button.css({
            color: this.colors.monochrome[4],
            fontSize: '1.5rem',
            fontWeight: '500'
        });
    };

    this.buildUIAVInputDropdown = function (elements) {
        let { select, label, icon, optionContainer } = elements;
        select.css({
            position: 'relative',
            display: 'flex',
            justifyContent: 'space-between',
            paddingBottom: '1rem',
            borderBottom: `1px solid ${this.colors.monochrome[2]}`,
            color: 'white'
        });
        label.css(this.styleguide.label3);
        label.css({ color: 'white' });
        icon.css(this.styleguide.icon);
        icon.css({
            backgroundSize: 'contain',
            backgroundRepeat: 'no-repeat',
            position: 'relative',
            width: '1.4rem'

        });
        icon.bg('~assets/images/icon/chevron-down-white.svg');
        optionContainer.css({
            display: 'none',
            opacity: 0,
            top: 0,
            width: '100%',
            background: 'white',
            boxShadow: '-1px 5px 10px 2px rgba(0,0,0,0.6)',
            left: 0,
            zIndex: 100001,
            maxHeight: '13rem',
            overflow: 'auto'
        });
    };

    this.buildUIAVInputEmptyDropdown = function (elements) {
        let { select, label } = elements;

        select.css({
            position: 'relative',
            display: 'flex',
            justifyContent: 'space-between',
            paddingBottom: '1rem',
            borderBottom: `1px solid ${this.colors.monochrome[2]}`
        });
        label.css(this.styleguide.label3);
        label.css({
            color: Colors.white
        });
    };

    this.buildUIAVInputDropdownOption = function (option) {
        option.css(this.styleguide.label3);
        option.css({
            padding: '1rem 1rem',
            color: this.colors.monochrome[6]
        });
    };
}, 'static');

/**
 * @name UIAVSettingsButton
 * @param type {string} default | video-chat-zone
 * @param animations {}
 * @param styles {}
 */

Class(function UIAVSettingsButton({
    type = 'default',
    styles = {},
    animations = UIAVSettingsButtonAnimations
}) {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    const $this = _this.element;

    //*** Constructor
    (function () {
        _this.isVideoChatZone = type === 'video-chat-zone';
        initHTML();
        addListeners();
        _this.flag('isReady', true);
    })();

    async function initHTML() {
        await UIAVSettingsButtonStyles.ready();
        console.log(styles)
        $this.css(_this.combineStyles([UIAVSettingsButtonStyles[type].element, styles.element]));
        _this.content = $this.create(`${_this.constructorName}__content`);
        _this.content.css(_this.combineStyles([UIAVSettingsButtonStyles[type].content, styles.content]));
        _this.content.bg(UIAVSettingsButtonStyles[type].settingsImage, 'cover');
    }


    //*** Event handlers
    function addListeners() {
        $this.interact(hover, onClick);
    }

    function hover(e) {
        const $hoverEl = _this.isVideoChatZone ? _this.content : $this;
        if (!$hoverEl.tween) return;
        animations.hover($hoverEl, e);
    }

    function onClick() {
        if ($this.tween) {
            animations.click($this);
        }
        // TODO: create way to toggle hideBack
        UIController.instance().modal.openModal(UIAVSettingsPanel, { hideBack: true });
    }

    this.setStyles = async function(replacedStyles) {
        await _this.wait('isReady');
        if (replacedStyles.element) $this.css(replacedStyles.element);
        if (replacedStyles.content) _this.content.css(replacedStyles.content);
    };
});

/**
 * @name UIAVSettingsButtonAnimations
 */
Class(function UIAVSettingsButtonAnimations() {
    Inherit(this, Component);
    this.click = (el) => {
        el.tween({ scale: 0.98, opacity: 0.8 }, 100, 'easeOutCubic', (_) => {
            if (!el.tween) return;
            el.tween({ scale: 1, opacity: 1 }, 400, 'easeOutCubic');
        });
    };
    this.hover = (el, e) => {
        switch (e.action) {
            case 'over':
                el.tween({ scale: 1.05, opacity: 0.8 }, 200, 'easeOutCubic');
                break;
            case 'out':
                el.tween({ scale: 1, opacity: 1 }, 300, 'easeOutCubic');
                break;
        }
    };
}, 'static');

/**
 * @name UIAVSettingsButtonStyles
 */
Class(function UIAVSettingsButtonStyles() {
    Inherit(this, Component);
    const _this = this;

    (async function () {
        await DreamColors.instance().ready();

        _this.default = {
            element: {
                position: 'relative',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                borderRadius: '50%',
                cursor: 'pointer',
                padding: '1.5rem',
                height: 'fit-content',
                width: 'fit-content',
                background: DreamColors.instance().white
            },
            content: {
                height: '3rem',
                width: '3rem',
                position: 'relative',
                backgroundSize: 'contain'
            },
            settingsImage: "~assets/images/icon/setting.svg"
        };

        _this['video-chat-zone'] = {
            element: {
                ..._this.default.element,
                marginLeft: '1.6rem',
                height: '7rem',
                width: '7rem',
                padding: '0',
                borderRadius: '0%',
                background: DreamColors.instance().black,
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
                border: `1px solid ${DreamColors.instance().primary}`
            },

            content: {
                ..._this.default.content,
                height: '3rem',
                width: '3rem'
            },

            settingsImage: '~assets/images/icon/settings-video-chat-zone.svg'
        };

        _this.flag('isReady', true);
    }());
    _this.ready = function () {
        return _this.wait('isReady');
    };
}, 'static');

Class(function UIAVSettingsPanel() {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    const $this = _this.element;

    (async function() {
        await UIAVSettingsPanelStyles.ready();
        initHTML();
        initHeader();
        initTabs();
        initFooter();
        addListeners();
    })();

    function initHTML() {
        $this.css(_this.combineStyles([UIAVSettingsPanelStyles.container]));
    }


    function initHeader() {
        _this.header = _this.initClass(DreamComponentConfig.instance().uiAVSettingsHeader || UIAVSettingsHeader);
    }

    function initFooter() {
        _this.footer = _this.initClass(DreamComponentConfig.instance().uiAVSettingsFooter || UIAVSettingsFooter);
    }


    async function initTabs() {
        _this.tabs = await _this.initClass(DreamUI.Tab, {
            preset: UIAVSettingsPanelStyles.tabPreset,
            styles: _this.combineStyles([UIAVSettingsPanelStyles.tabStyles]),
            tabs: [
                {
                    view: DreamComponentConfig.instance().uiAVSettingsAudio || UIAVSettingsAudio,
                    label: 'Audio'
                },
                {
                    view: DreamComponentConfig.instance().uiAVSettingsVideo || UIAVSettingsVideo,
                    label: 'Video'
                }
            ]
        });
    }

    function addListeners() {
        // close modal on bg click
        UIController.instance().modal.element.bind('click', e => {
            if (!_this.element || _this.element.div.contains(e.target)) return;
            UIController.instance().modal.closeModal();
        });
    }
});

/**
 * @name UIAVSettingsPanelStyles
 */
Class(function UIAVSettingsPanelStyles() {
    Inherit(this, Component);
    const _this = this;

    (function () {
        _this.container = {
            width: '90%',
            maxWidth: 440,
            background: DreamColors.instance().white,
            borderRadius: 8,
            position: 'relative',
            padding: '3rem',
            boxShadow: '0 2px 12px rgba(0,0,0,0.3)'
        };

        _this.tabPreset = 'rounded';
        // a style configuration matching DreamUITabStyles
        _this.tabStyles = {
            element: {
                
            },
            header: {
                padding: '2.8rem 0 4rem'
            }
        };

        _this.flag('isReady', true);
    })();

    _this.ready = function() {
        return _this.wait('isReady');
    };
}, 'static');

Class(function UIAVSettingsSectionHeader({
    styles = {},
    label = 'Hello',
    icon,
    preset = 'rowLayout',
    actionView
}) {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    const $this = _this.element;

    (async function() {
        await UIAVSettingsSectionHeaderStyles.ready();
        initHTML();
        initStyles();
    })();

    function initHTML() {
        _this.label = $this.create(_this.getPrefix('label'));
        _this.label.text(label);
        _this.actions = $this.create(_this.getPrefix('actions'));

        if (icon) _this.icon = _this.initClass(Sprite, icon, _this.combineStyles([UIAVSettingsSectionHeaderStyles[preset].icon, styles.icon]), [_this.actions]);

        // if (image) {
        //     // _this.icon = _this.actions.create(_this.getPrefix('item-image'));
        //     // _this.icon.css(_this.combineStyles([UIAVSettingsSectionHeaderStyles.icon, styles.icon]));
        //     // _this.icon.bg(image);
        // }
        if (actionView) _this.initClass(actionView, [_this.actions]);
    }

    function initStyles() {
        $this.css(_this.combineStyles([UIAVSettingsSectionHeaderStyles[preset].element, styles.element]));
        _this.label.css(_this.combineStyles([UIAVSettingsSectionHeaderStyles[preset].label, styles.label]));
        _this.actions.css(_this.combineStyles([UIAVSettingsSectionHeaderStyles[preset].actions, styles.actions]));
    }
});

/**
 * @name UIAVSettingsSectionHeaderStyles
 */
Class(function UIAVSettingsSectionHeaderStyles() {
    Inherit(this, Component);
    const _this = this;

    (async function () {
        await DreamColors.instance().ready();
        _this.rowLayout = {
            element: {
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                marginBottom: 16
            },
            label: {
                ...DreamStyleguide.instance().label4,
                color: DreamColors.instance().gray800
            },
            actions: {
                display: 'flex',
                width: 65,
                justifyContent: 'space-between',
                alignItems: 'center'
            },
            icon: {
                width: 24,
                height: 24,
                color: DreamColors.instance().blue,
                marginRight: 16
            }
        };

        _this.columnLayout = {
            ..._this.rowLayout,
            element: {
                ..._this.rowLayout.element,
                flexDirection: 'column',
                marginBottom: 20
            },
            actions: {
                width: 'auto',
                justifyContent: 'center'
            },
            label: {
                ..._this.rowLayout.label,
                alignSelf: 'flex-start'
            }
        };
        _this.flag('isReady', true);
    })();

    _this.ready = function() {
        return _this.wait('isReady');
    };
}, 'static');

Class(function UIAVSettings({
    previousComponent = null,
    styles = {},
    headingText = '/ AUDIO + VIDEO',
    settingsLabel = 'Settings'
}) {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    const $this = _this.element;
    const _prefix = 'UIAVInputView';
    var $audioTab, $videoTab, $header, $audioTestButton, $audioTabHeader, $videoTabHeader, $heading, $testVideo;
    var _audioContext;
    var $audioDropdowns = [];
    var _audioInputOptionsOpen = false;
    var _audioOutputOptionsOpen = false;
    _this.tabBodies = [];
    _this.tabs = [];

    const state = AppState.createLocal({ activeTabIndex: 0 });

    //*** Constructor
    (async function () {
        _this.element.mouseEnabled(true);
        await UIAVSettingsStyles.ready();
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        _audioContext = new AudioContext();

        initHTML();
        initHeading();
        initTabs();
        createBody();
        _this.tabBodies.push(await createAudioTab());
        createButton();
        addListeners();
        handleAudioAllowChange({
            isAllowed: AVSettingsController.instance().audioAllowed
        });
        _this.tabBodies.push(await createVideoTab());
        handleVideoAllowChange({
            isAllowed: AVSettingsController.instance().videoAllowed
        });

        show();
    })();

    function initHTML() {
        $this.css(_this.combineStyles([UIAVSettingsStyles.container, styles.container]));
    }

    function closeAllDropdowns() {
        for (let dropdown of $audioDropdowns) {
            dropdown.tween({ opacity: 0 }, 300, 'easeOutQuad');
        }
    }

    function createBody() {
        _this.body = $this.create(`${_prefix}__body`);
        _this.body.css(_this.combineStyles([UIAVSettingsStyles.body, styles.body]));
    }

    function initHeading() {
        $heading = $this.create(`${_prefix}__heading`);

        const button = _this.initClass(DreamUI.Button, {
            icon: 'arrow-left',
            text: settingsLabel,
            styles: _this.combineStyles([UIAVSettingsStyles.headingButton, styles.headingButton])
        }, [$heading]);

        button.element.css({ position: 'relative' });

        let $text = $heading.create(`${_prefix}__title__text`);
        $text.text(headingText);

        $heading.css(_this.combineStyles([UIAVSettingsStyles.heading, styles.heading]));
        $text.css(_this.combineStyles([UIAVSettingsStyles.headingText, styles.headingText]));

        _this.events.sub(button, DreamUI.Button.CLICK, () => {
            closeAllDropdowns();
            if (previousComponent) {
                UIController.instance().modal.openModal(previousComponent);
            } else {
                UIController.instance().modal.closeModal();
            }
        });
    }



    function initTabs() {
        $header = $this.create(`${_prefix}__tabs-heading`);
        $header.css(_this.combineStyles([UIAVSettingsStyles.tabsWrapper, styles.tabsWrapper]));

        let options = [
            {
                title: 'Audio',
                image: '~assets/images/icon/speaker.svg',
                altImage: '~assets/images/icon/speaker-grey.svg'
            },
            {
                title: 'Video',
                image: '~assets/images/icon/camera-on-orange.svg',
                altImage: '~assets/images/icon/camera-on-grey.svg'
            }
        ];

        options.forEach((option, idx) => {
            let item = initTabsItem($header, option, idx);
            _this.tabs.push(item);
            if (option.title === 'Audio') {
                $audioTabHeader = item;
            } else if (option.title === 'Video') {
                $videoTabHeader = item;
            }
        });
    }

    function initTabsItem(parent, option, index) {
        const tab = parent.create(`${_prefix}__header__item`);
        tab.css(_this.combineStyles([UIAVSettingsStyles.tab, styles.tab]));
        tab.index = index;

        const tabLabel = tab.create(`${_prefix}__header__item__text`);
        tabLabel.css(_this.combineStyles([UIAVSettingsStyles.tabLabel, styles.tabLabel]));
        tabLabel.text(option.title);
        tab.label = tabLabel;

        if (state.get('activeTabIndex') === index) styleActiveTab(tab);

        tab.interact(null, _ => state.set('activeTabIndex', index));
        return tab;
    }

    function styleActiveTab(tab) {
        tab.css({ borderColor: styles.activeTabColor || UIAVSettingsStyles.activeTabColor });
        tab.label.css({ color: styles.activeTabColor || UIAVSettingsStyles.activeTabColor });
    }

    function styleNonActiveTab(tab) {
        tab.css({ borderColor: styles.nonActiveTabColor || UIAVSettingsStyles.nonActiveTabColor });
        tab.label.css({ color: styles.nonActiveTabColor || UIAVSettingsStyles.nonActiveTabColor });
    }

    async function createAudioTab() {
        $audioTab = createTabBody();
        let sections = [
            {
                title: 'Microphone',
                image: '~assets/images/icon/mic-on-grey.svg',
                subView: createAudioBars,
                options: await GameCenterMedia.userStream.getAudioInputs(),
                isOpen: _audioInputOptionsOpen
            },
            {
                title: 'Speakers',
                image: '~assets/images/icon/sound-level2-grey.svg',
                subView: createAudioTestButton,
                options: await GameCenterMedia.userStream.getAudioOutputs(),
                isOpen: _audioOutputOptionsOpen
            }
        ];

        for (let section of sections) {
            let newSection = createSubsection($audioTab, section.title, section.image, section.subView);
            createDropdown(newSection, section.options);
        }
        return $audioTab;
    }

    async function createVideoTab() {
        $videoTab = createTabBody();
        $videoTab.css({
            opacity: 0,
            display: 'none'
        });
        let sections = [
            {
                title: 'Cameras',
                subView: createTestVideo,
                options: await GameCenterMedia.userStream.getVideoInputs()
            }
        ];
        for (let section of sections) {
            let newSection = createSubsection($videoTab, section.title, section.image, section.subView);
            createDropdown(newSection, section.options);
        }
        return $videoTab;
    }

    function createTabBody(parent = _this.body) {
        const tabBody = parent.create(`${_prefix}__tab-body`);
        tabBody.css(_this.combineStyles([UIAVSettingsStyles.tabBody, styles.tabBody]));
        return tabBody;
    }

    function createSubsection(parent, title, image, subView) {
        let section = parent.create(`${_prefix}__section`);

        let sectionHeader = section.create(`${_prefix}__section__header`);

        let sectionLabel = sectionHeader.create(`${_prefix}__section__label`);

        sectionLabel.text(title);
        let sectionActions = sectionHeader.create(`${_prefix}__section__actions`);

        section.css(_this.combineStyles([UIAVSettingsStyles.section, styles.section]));
        sectionHeader.css(_this.combineStyles([UIAVSettingsStyles.sectionHeader, styles.sectionHeader]));
        sectionLabel.css(_this.combineStyles([UIAVSettingsStyles.sectionLabel, styles.sectionLabel]));
        sectionActions.css(_this.combineStyles([UIAVSettingsStyles.sectionActions, styles.sectionActions]));

        if (image) {
            let itemIcon = sectionActions.create(`${_prefix}__header__item__image`);
            itemIcon.css(_this.combineStyles([UIAVSettingsStyles.sectionIcon, styles.sectionIcon]));
            itemIcon.bg(image);
        }

        if (subView) {
            subView(sectionActions);
        }
        return section;
    }

    function createAudioBars(parent) {
        _this.initClass(UIAVAudioBars, [parent]);
    }

    async function createAudioTestButton(parent) {
        $audioTestButton = parent.create(`${_prefix}__test-button`);

        const button = _this.initClass(DreamUI.Button, {
            text: 'Test',
            styles: _this.combineStyles([UIAVSettingsStyles.audioTestButton, styles.audioTestButton])
        }, [parent]);

        const audioReq = new Request(Assets.getPath('~assets/audio/test.mp3'));

        try {
            const response = await fetch(audioReq);
            const buffer = await response.arrayBuffer();
            const decodedData =  await _audioContext.decodeAudioData(buffer);
            _this.events.sub(button, DreamUI.Button.CLICK, _ => handleAudioTest(decodedData));
        } catch (e) {
            console.error(e);
        }
    }

    function handleAudioTest(decodedData) {
        const source = _audioContext.createBufferSource();
        source.buffer = decodedData;
        source.connect(_audioContext.destination);
        source.start();
    }

    async function createTestVideo(parent) {
        $testVideo = parent.create(`${_prefix}__video`, 'video');
        $testVideo.css({
            background: 'black',
            height: '3rem',
            width: '5rem',
            position: 'relative'
        });
        $testVideo.attr('autoplay', 'true');
        let stream = await GameCenterMedia.userStream.getStream();
        if (stream) {
            $testVideo.div.srcObject = stream.srcObject;
            $testVideo.div.play();
            $testVideo.div.volume = 0.001;
        }
    }

    async function createDropdown(parent, options) {
        if (!options || options.length === 0) {
            return;
        }

        const getOptionId = opt => (opt._id ? opt._id : opt.deviceId);

        const formatOptionsForSelect = options.map((option) => ({
            text: option._name,
            value: getOptionId(option)
        }));

        const selectedOption = options.find(option => option.selected);

        const dropdown = _this.initClass(DreamUI.Select, {
            id: '1',
            options: formatOptionsForSelect,
            value: selectedOption && getOptionId(selectedOption),
            styles: _this.combineStyles([
                UIAVSettingsStyles.selectStyles(DreamUI.SelectStyles),
                styles.selectStyles
            ])
        }, [parent]);

        _this.events.sub(dropdown, DreamUI.Select.CHANGE, ({ value }) => {
            const matchedOption = options.find(option => getOptionId(option) === value);
            switch (matchedOption.kind) {
                case 'audioinput': {
                    GameCenterMedia.userStream.setAudioSource(matchedOption);
                    break;
                }
                case 'audiooutput': {
                    GameCenterMedia.userStream.setAudioOutputSource(matchedOption);
                    break;
                }
                case 'videoinput': {
                    GameCenterMedia.userStream.setVideoSource(matchedOption);
                    break;
                }
            }
        });
    }

    function createButton() {
        const $buttonWrapper = $this.create(`${_prefix}__button`);
        $buttonWrapper.css(_this.combineStyles([UIAVSettingsStyles.saveButtonWrap, styles.saveButtonWrap]));

        const button = _this.initClass(DreamUI.Button, {
            text: 'Save',
            preset: 'stroked',
            styles: _this.combineStyles([
                UIAVSettingsStyles.saveButton,
                styles.saveButton
            ])
        }, [$buttonWrapper]);

        _this.events.sub(button, DreamUI.Button.CLICK, _ => UIController.instance().modal.closeModal());
    }

    function show() {
        $this.tween({ opacity: 1 }, 500, 'easeOutCubic');
    }

    //*** Event handlers
    function addListeners() {
        _this.onResize(resize);
        _this.events.sub(AVSettingsController.AUDIO_ALLOW_CHANGE, handleAudioAllowChange);
        _this.events.sub(AVSettingsController.VIDEO_ALLOW_CHANGE, handleVideoAllowChange);
        _this.events.sub(GameCenterMediaUserStream.UPDATE, replaceStream);

        state.bind('activeTabIndex', index => {
            handleTabChange(index);
        });

        // close modal on bg click
        UIController.instance().modal.element.bind('click', e => {
            if (!_this.element || _this.element.div.contains(e.target)) return;
            UIController.instance().modal.closeModal();
        });
    }

    function handleTabChange(index) {
        _this.tabs.forEach(t => {
            if (index === t.index) styleActiveTab(t);
            else styleNonActiveTab(t);
        });

        _this.tabBodies.forEach((tab, i) => {
            if (i !== index) {
                _this.tabBodies[i].hide();
            } else {
                _this.tabBodies[i].css({ display: 'grid' });
                _this.tabBodies[i].tween({ opacity: 1 }, 300, 'easeOutQuad', 0);
            }
        });
    }

    async function replaceStream() {
        let stream = await GameCenterMedia.userStream.getStream();
        if (!$testVideo?.div?.srcObject) return;
        $testVideo.div.srcObject = stream.srcObject;
    }

    function resize() {
        const size = Breakpoints.getSize();
        UIAVSettingsStyles.mobileStyles(size, { $this, $audioTab, $videoTab });
    }
    function handleAudioAllowChange(e) {
        UIAVSettingsStyles.handleAudioAllowChange(e, { $audioTabHeader, $audioTab, $videoTabHeader });
    }

    function handleVideoAllowChange(e) {
        const activeIndex = state.get('activeTabIndex');
        UIAVSettingsStyles.handleVideoAllowChange(e, activeIndex, { $videoTabHeader, $videoTab, $audioTab, $audioTabHeader });
        if (activeIndex === 1) state.set('activeTabIndex', 0);
    }
});

/**
 * @name UIAVSettingsStyles
 */
Class(function UIAVSettingsStyles() {
    Inherit(this, Component);
    const _this = this;

    (function () {
        _this.body = {
            width: '100%',
            position: 'relative',
            marginTop: '4rem',
            height: 192
        };

        _this.container = {
            opacity: '0.5',
            width: '22vw',
            maxHeight: 600,
            height: 'fit-content',
            background: DreamColors.instance().black,
            position: 'relative',
            padding: '3rem'
        };

        _this.heading = {
            position: 'relative',
            display: 'grid',
            gridAutoFlow: 'column',
            gridGap: '1rem',
            paddingBottom: '2rem',
            marginBottom: '4.8rem',
            gridAutoColumns: 'min-content',
            alignItems: 'center',
            borderBottom: `0.1rem solid ${DreamColors.instance().gray}`
        };

        /**
         * A DreamUI.Button styles configuration
         * This gives config gives a button with text and icon on left
         */
        _this.headingButton = {
            element: {
                position: 'relative',
                display: 'flex',
                alignItems: 'center',
                flexDirection: 'row-reverse',
                width: 'auto',
                borderRadius: 'none',
                padding: '0.25rem 1rem 0.25rem 0'
            },
            text: {
                display: 'block',
                position: 'relative',
                color: DreamColors.instance().gray,
                marginLeft: '1rem',
                fontSize: '1.5rem'
            },
            icon: {
                height: '1.5rem',
                width: '1.5rem',
                stroke: DreamColors.instance().gray
            }
        };

        _this.headingText = {
            ...DreamStyleguide.instance().p1,
            color: DreamColors.instance().white,
            whiteSpace: 'nowrap',
            fontSize: '1.8rem',
            letterSpacing: '0.08rem',
            position: 'relative'
        };

        /**
         * Tabs
         */
        _this.tabsWrapper = {
            position: 'relative',
            width: '75%',
            display: 'grid',
            gridAutoFlow: 'column',
            gridGap: '1rem',
            gridAutoRows: 'min-content'
        };

        /**
         * Single Tab
         */
        _this.activeTabColor = DreamColors.instance().primary;
        _this.nonActiveTabColor = DreamColors.instance().gray;

        _this.tab = {
            display: 'grid',
            gridAutoFlow: 'column',
            gridAutoColumns: 'min-content',
            gridGap: '2rem',
            paddingBottom: '0.8rem',
            pointer: 'cursor',
            position: 'relative',
            borderBottom: `solid 2px ${_this.nonActiveTabColor}`
            // borderBottom: option.isActive ? `2px solid ${DreamColors.instance().yellow}` : `2px solid  ${DreamColors.instance().gray}`
        };

        _this.tabLabel = {
            ...DreamStyleguide.instance().p3,
            position: 'relative',
            // color: option.isActive ? DreamColors.instance().yellow : DreamColors.instance().gray,
            color: _this.nonActiveTabColor,
            fontWeight: 'bold',
            textTransform: 'uppercase',
            fontSize: '1.2rem',
            letterSpacing: '0.08rem'
        };

        _this.tabBody = {
            display: 'grid',
            height: '100%',
            width: '100%',
            top: 0,
            gridAutoRows: 'min-content',
            gridGap: '4rem',
            position: 'relative'
        };

        /**
         * Subsection
         */
        _this.section = {
            display: 'grid',
            // gridGap: '1.5rem',
            position: 'relative'
        };

        _this.sectionHeader = {
            display: 'grid',
            position: 'relative',
            gridTemplateColumns: '1fr auto',
            alignItems: 'center'
        };

        _this.sectionLabel = {
            ...DreamStyleguide.instance().p3,
            position: 'relative',
            color: "#F1F1F1",
            fontSize: '1.8rem',
            letterSpacing: '0.08rem',
            textTransform: 'uppercase',
            fontWeight: 'lighter'
        };

        _this.sectionActions = {
            position: 'relative',
            display: 'grid',
            gridAutoFlow: 'column',
            gridGap: '1rem',
            gridAutoColumns: 'min-content',
            alignItems: 'center'
        };

        _this.sectionIcon = {
            width: RWD.isMobile ? '2rem' : '2.5rem',
            height: RWD.isMobile ? '2rem' : '2.5rem',
            position: 'relative',
            backgroundSize: 'contain',
            backgroundRepeat: 'no-repeat'
        };

        /**
         * A config matching DreamUI.Button
         */
        _this.audioTestButton = {
            element: {
                position: 'relative',
                padding: 0
            },
            text: {
                display: 'block',
                position: 'relative',
                color: DreamColors.instance().gray
            }
        };

        /**
         * A config matching DreamUI.SelectStyles
         */
        _this.selectStyles = DreamUISelectStyles => ({
            element: {
                ...DreamUISelectStyles.element,
                width: '100%',
                bacgkround: DreamColors.instance().black
            },
            input: {
                ...DreamUISelectStyles.input,
                color: DreamColors.instance().white
            },
            text: {
                color: DreamColors.instance().white
            }
        });


        /**
         * Save
         */
        _this.saveButtonWrap = {
            position: 'relative',
            display: 'flex',
            justifyContent: 'center',
            marginTop: '9rem'
        };

        _this.saveButton = {
            element: {
                borderColor: DreamColors.instance().white
            },
            text: {
                color: DreamColors.instance().gray800
            }
        };


        _this.flag('isReady', true);
    })();

    _this.ready = function() {
        return _this.wait('isReady');
    };

    _this.handleAudioAllowChange = (e, { $audioTabHeader, $audioTab, $videoTabHeader }) => {
        if (!e.isAllowed) {
            $audioTabHeader.css({
                opacity: 0,
                display: 'none'
            });
            $audioTab.css({
                opacity: 0,
                display: 'none'
            });
            if (_activeIndex == 0) {
                _activeIndex = 1;
                $videoTabHeader.css({
                    opacity: 1,
                    display: 'grid'
                });
                $videoTab.css({
                    opacity: 1,
                    display: 'grid'
                });
            }
        } else {
            $audioTabHeader.css({
                opacity: 1,
                display: 'grid'
            });
            $audioTab.css({
                opacity: 1,
                display: 'grid'
            });
        }
    };
    _this.handleVideoAllowChange = (e, activeIndex, { $videoTabHeader, $videoTab, $audioTab, $audioTabHeader }) => {
        if (!e.isAllowed) {
            $videoTabHeader.css({
                opacity: 0,
                display: 'none'
            });
            $videoTab.css({
                opacity: 0,
                display: 'none'
            });
            if (activeIndex === 1) {
                $audioTabHeader.css({
                    opacity: 1,
                    display: 'grid'
                });
                $audioTab.css({
                    opacity: 1,
                    display: 'grid'
                });
            }
        }
    };
    _this.mobileStyles = (size, { $this, $audioTab, $videoTab }) => {
        switch (size) {
            case 'big-desktop': {
                $this.css({
                    width: '25vw'
                    // height: '60vh',
                });
                break;
            }
            case 'desktop': {
                $this.css({
                    width: '30vw'
                    // height: '80vh',
                });
                break;
            }
            case 'tab-land': {
                $this.css({
                    width: '40vw'
                    // height: '60vh',
                });
                break;
            }
            case 'tab-port': {
                $this.css({
                    width: '50vw'
                    // height: '60vh',
                });
                break;
            }
            case 'phone': {
                $this.css({
                    width: '95vw'
                    // height: '70vh',
                });
                break;
            }
        }

        if (Device.mobile && Stage.width > Stage.height) {
            $this.css({
                width: '80vw',
                height: '95vh'
            });
            if ($audioTab) {
                $audioTab.css({
                    gridAutoFlow: 'column',
                    gridGap: '4rem'
                });
            }
            if ($videoTab) {
                $videoTab.css({
                    gridAutoFlow: 'column',
                    gridGap: '4rem'
                });
            }
        }
    };
}, 'static');

Class(function UIAVSettingsFooter({
    styles = {},
    buttonConfig = {}
} = {}) {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    const $this = _this.element;

    (async function() {
        await UIAVSettingsFooterStyles.ready();
        $this.css(_this.combineStyles([UIAVSettingsFooterStyles.element, styles.element]));
        initButton();
    })();

    function initButton() {
        _this.saveButton = _this.initClass(DreamUI.Button, getButtonConfig());
        _this.events.sub(_this.saveButton, DreamUI.Button.CLICK, _ => UIController.instance().modal.closeModal());
    }

    function getButtonConfig() {
        return {
            preset: 'flat',
            text: 'Save',
            ...buttonConfig,
            styles: _this.combineStyles([UIAVSettingsFooterStyles.buttonStyles, buttonConfig.styles])
        };
    }
});

/**
 * @name UIAVSettingsFooterStyles
 */
Class(function UIAVSettingsFooterStyles() {
    Inherit(this, Component);
    const _this = this;

    (async function () {
        await DreamColors.instance().ready();
        _this.element = {
            paddingTop: '2rem'
        };
        _this.buttonStyles = {
            element: {
                width: '100%',
                justifyContent: 'center',
                height: 48,
                borderRadius: 50,
                background: DreamColors.instance().blue
            }
        };
        _this.flag('isReady', true);
    })();

    _this.ready = function() {
        return _this.wait('isReady');
    };
}, 'static');

Class(function UIAVSettingsHeader({
    styles = {},
    buttonConfig = {}
} = {}) {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    const $this = _this.element;

    (async function() {
        await UIAVSettingsHeaderStyles.ready();
        initHeading();
        initButton();
        initStyles();
    })();

    function initHeading() {
        _this.heading = $this.create(_this.getPrefix('heading')).text('Settings');
    }

    function initButton() {
        _this.closeButton = _this.initClass(DreamUI.Button, getButtonConfig());
        _this.events.sub(_this.closeButton, DreamUI.Button.CLICK, _ => UIController.instance().modal.closeModal());
    }

    function getButtonConfig() {
        return {
            preset: 'icon',
            text: 'close',
            icon: 'close',
            ...buttonConfig,
            styles: _this.combineStyles([UIAVSettingsHeaderStyles.buttonStyles, buttonConfig.styles])
        };
    }

    function initStyles() {
        $this.css(_this.combineStyles([UIAVSettingsHeaderStyles.element, styles.element]));
        _this.heading.css(_this.combineStyles([UIAVSettingsHeaderStyles.heading, styles.heading]));
    }
});

/**
 * @name UIAVSettingsHeaderStyles
 */
Class(function UIAVSettingsHeaderStyles() {
    Inherit(this, Component);
    const _this = this;

    (async function () {
        await DreamColors.instance().ready();
        await DreamStyleguide.instance().ready();
        _this.element = {
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center'
        };

        _this.heading = {
            ...DreamStyleguide.instance().h3,
            fontWeight: 'bold',
            color: DreamColors.instance().gray800
        };

        _this.buttonStyles = {
            element: {
                border: `2px solid ${DreamColors.instance().gray500}`,
                color: DreamColors.instance().gray500
            }
        };

        _this.flag('isReady', true);
    })();

    _this.ready = function() {
        return _this.wait('isReady');
    };
}, 'static');

Class(function UIAVSettingsTabBase() {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    const $this = _this.element;

    (function() {
        $this.css({ width: '100%' });
    })();


    _this.getOptionId = opt => (opt._id ? opt._id : opt.deviceId);


    _this.formatOptionsForDreamUISelect = options => options.map((option) => ({
        text: option._name,
        value: _this.getOptionId(option)
    }));

    _this.getMatchingOptionOnSelectChange = (options, value) => options.find(option => _this.getOptionId(option) === value);

    _this.createDropdown = async (id, streamOptions, gameCenterCb) => {
        const options = _this.formatOptionsForDreamUISelect(streamOptions);
        const selectedOption = streamOptions.find(o => o.selected);

        const styles = await _this.getSelectStyles();
        const select = _this.initClass(DreamUI.Select, {
            id,
            options,
            styles,
            value: selectedOption && _this.getOptionId(selectedOption)
        });

        _this.events.sub(select, DreamUI.Select.CHANGE, ({ value }) => {
            const match = _this.getMatchingOptionOnSelectChange(streamOptions, value);
            if (match) gameCenterCb(match);
        });

        return select;
    };

    _this.getSelectStyles = async _ => {
        await DreamColors.instance().ready();
        await DreamStyleguide.instance().ready();

        return {
            selectedColor: DreamColors.instance().gray800,
            unselectedColor: DreamColors.instance().gray800,
            text: {
                ...DreamStyleguide.instance().label3,
                whiteSpace: 'nowrap',
                color: DreamColors.instance().gray800
            },
            input: {
                height: '4.6rem',
                border: `solid 1px ${DreamColors.instance().gray300}`,
                paddingLeft: 20,
                borderRadius: 40,
                background: DreamColors.instance().white
            },
            icon: {
                width: '2rem',
                height: '2rem',
                right: '1.5rem',
                color: DreamColors.instance().blue
            }
        };
    };

    _this.setSelectStyles = styles => {

    };
});

/**
 * @name UIAVSettingsTabBaseStyles
 */
Class(function UIAVSettingsTabBaseStyles() {
    Inherit(this, Component);
    const _this = this;

    (function () {
        _this.section = {
            marginBottom: 40
        };


        _this.flag('isReady', true);
    })();

    _this.ready = function() {
        return _this.wait('isReady');
    };
}, 'static');

Class(function UIAVSettingsAudio({ styles = {} }) {
    Inherit(this, UIAVSettingsTabBase);
    const _this = this;
    const $this = _this.element;

    (async function() {
        await UIAVSettingsTabBaseStyles.ready();
        createMicSection();
        // createSpeakerSection();
    })();

    async function createMicSection() {
        _this.micSection = $this.create(_this.getPrefix('mic-section')).css(_this.combineStyles([UIAVSettingsTabBaseStyles.section, styles.section]));

        _this.micSectionHeader = _this.initClass(UIAVSettingsSectionHeader, {
            label: 'Microphone',
            icon: 'av-mic-on',
            actionView: UIAVAudioBars
        }, [_this.micSection]);

        const streamOptions =  await GameCenterMedia.userStream.getAudioInputs();
        _this.micSectionSelect = await _this.createDropdown(`mic-select`, streamOptions, GameCenterMedia.userStream.setAudioSource);
        _this.micSection.add(_this.micSectionSelect);
    }

    async function createSpeakerSection() {
        _this.speakerSection = $this.create(_this.getPrefix('speaker-section')).css(_this.combineStyles([UIAVSettingsTabBaseStyles.section, styles.section]));
        _this.speakerSectionHeader = _this.initClass(UIAVSettingsSectionHeader, {
            label: 'Speakers',
            icon: 'av-sound-level',
            actionView: UIAVSettingsAudioTest
        }, [_this.speakerSection]);

        const streamOptions = await GameCenterMedia.userStream.getAudioOutputs();
        _this.speakerSectionSelect = await _this.createDropdown(`speaker-select`, streamOptions, GameCenterMedia.userStream.setAudioOutputSource);
        _this.speakerSection.add(_this.speakerSectionSelect);
    }


    function addSubscribers() {
        _this.events.sub(dropdown, DreamUI.Select.CHANGE, ({ value }) => {
            const matchedOption = options.find(option => getOptionId(option) === value);
            switch (matchedOption.kind) {
                case 'audioinput': {
                    GameCenterMedia.userStream.setAudioSource(matchedOption);
                    break;
                }
                case 'audiooutput': {
                    GameCenterMedia.userStream.setAudioOutputSource(matchedOption);
                    break;
                }
            }
        });
    }
});

Class(function UIAVSettingsAudioTest() {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    const $this = _this.element;
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    _this.audioContext = new AudioContext();

    (function() {
        initButton();
        audioTestSubscriber();
    })();

    async function initButton() {
        await DreamColors.instance().ready();
        await DreamStyleguide.instance().ready();
        _this.button = _this.initClass(DreamUI.Button, {
            text: 'Test',
            styles: {
                element: {
                    padding: 0
                },
                text: {
                    ...DreamStyleguide.instance().label1,
                    color: DreamColors.instance().gray800
                }
            }
        });
    }

    async function audioTestSubscriber() {
        const audioReq = new Request(Assets.getPath('~assets/audio/test.mp3'));

        try {
            const response = await fetch(audioReq);
            const buffer = await response.arrayBuffer();
            const decodedData =  await _this.audioContext.decodeAudioData(buffer);
            _this.events.sub(_this.button, DreamUI.Button.CLICK, _ => handleAudioTest(decodedData));
        } catch (e) {
            console.error(e);
        }
    }

    function handleAudioTest(decodedData) {
        const source = _this.audioContext.createBufferSource();
        source.buffer = decodedData;
        source.connect(_this.audioContext.destination);
        source.start();
    }
});


Class(function UIAVSettingsVideo({ styles = {} }) {
    Inherit(this, UIAVSettingsTabBase);
    const _this = this;
    const $this = _this.element;

    (async function() {
        await UIAVSettingsTabBaseStyles.ready();
        createVideoSection();
    })();

    async function createVideoSection() {
        _this.videoSection = $this.create(_this.getPrefix('video-section'));
        _this.videoSectionHeader = _this.initClass(UIAVSettingsSectionHeader, {
            label: 'Cameras',
            actionView: UIAVSettingsVideoTest,
            preset: 'columnLayout'
        }, [_this.videoSection]);

        const streamOptions =  await GameCenterMedia.userStream.getVideoInputs();
        _this.videoSectionSelect = _this.createDropdown(`video-select`, streamOptions, GameCenterMedia.userStream.setVideoSource);
        _this.videoSection.add(_this.videoSectionSelect);
    }
});

Class(function UIAVSettingsVideoTest({ styles = {} }) {
    Inherit(this, DreamUI.DreamElement, 'video');
    const _this = this;
    const $this = _this.element;

    (async function() {
        await UIAVSettingsVideoTestStyles.ready();
        initVideo();
    })();

    async function initVideo() {
        $this.css(_this.combineStyles([UIAVSettingsVideoTestStyles.element, styles.element]));
        $this.attr('autoplay', 'true');
        let stream = await GameCenterMedia.userStream.getStream();
        if (stream) {
            $this.div.srcObject = stream.srcObject;
            $this.div.play();
            $this.div.volume = 0.001;
        }
    }
});

/**
 * @name UIAVSettingsVideoTestStyles
 */
Class(function UIAVSettingsVideoTestStyles() {
    Inherit(this, Component);
    const _this = this;

    (function () {
        _this.element = {
            background: 'black',
            height: 120,
            width: 120,
            objectFit: 'cover',
            position: 'relative'
        };
        _this.flag('isReady', true);
    })();

    _this.ready = function() {
        return _this.wait('isReady');
    };
}, 'static');

/**
 * @name UIAVShareButton
 */
Class(function UIAVShareButton({
    styles = {},
    animations = UIAVShareButtonAnimations
}) {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    const $this = _this.element;

    //*** Constructor
    (function () {
        initHTML();
        addListeners();
        _this.flag('isReady', true);
    })();

    function initHTML() {
        $this.css(_this.combineStyles([UIAVShareButtonStyles.element, styles.element]));
        _this.content = $this.create(`${_this.constructorName}__content`);
        _this.content.css(_this.combineStyles([UIAVShareButtonStyles.content, styles.content])).bg(UIAVShareButtonStyles.screenShareImage);
    }


    //*** Event handlers
    function addListeners() {
        $this.interact(hover, onClick);
        _this.events.sub(GameCenterMedia.SCREEN_SHARE_TOGGLE, onScreenShareToggle);
    }

    function onScreenShareToggle(e) {
        _this.isSharing = e.isSharing;
    }

    function hover(e) {
        animations.hover($this, e);
    }

    function onClick() {
        animations.click($this);
        _this.isSharing = !_this.isSharing;
        if (_this.isSharing) {
            GameCenterMedia.shareScreen();
        } else {
            GameCenterMedia.stopScreenShare();
        }
    }
    //*** Public methods
    this.setStyles = async function(replacedStyles) {
        await _this.wait('isReady');
        if (replacedStyles.element) $this.css(replacedStyles.element);
        if (replacedStyles.content) _this.content.css(replacedStyles.content);
    };
});

/**
 * @name UIAVShareButtonAnimations
 */
Class(function UIAVShareButtonAnimations() {
    Inherit(this, Component);
    this.click = (el) => {
        el.tween({ scale: 0.98, opacity: 0.8 }, 100, 'easeOutCubic', (_) => {
            el.tween({ scale: 1, opacity: 1 }, 400, 'easeOutCubic');
        });
    };
    this.hover = (el, e) => {
        switch (e.action) {
            case 'over':
                el.tween({ scale: 1.05, opacity: 0.8 }, 200, 'easeOutCubic');
                break;
            case 'out':
                el.tween({ scale: 1, opacity: 1 }, 300, 'easeOutCubic');
                break;
        }
    };
}, 'static');

/**
 * @name UIAVShareButtonStyles
 */
Class(function UIAVShareButtonStyles() {
    Inherit(this, Component);
    const _this = this;

    (async function() {
        await DreamColors.instance().ready();

        _this.element = {
            position: 'relative',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            borderRadius: '50%',
            cursor: 'pointer',
            padding: '1.5rem',
            height: 'fit-content',
            width: 'fit-content',
            background: DreamColors.instance().white
        };

        _this.content = {
            height: '3rem',
            width: '3rem',
            position: 'relative',
            backgroundSize: 'contain'
        };

        _this.screenShareImage = '~assets/images/icon/screenshare.svg';

        _this.flag('isReady', true);
    }());

    _this.ready = function () {
        return _this.wait('isReady');
    };
}, 'static');


Class(function UIVideoPlayer(_config) {
    Inherit(this, AbstractUIComponent);

    const _this = this;
    const $this = _this.element;

    var $cover, $iframe, $button, $buttonIcon, $video;
    var _brightcoveElement, _brightcoveVideo;
    _this.color = null;
    _this.cover = null;
    _this.icon = null;
    _this.iframe = null;
    _this.autoPlay = null;
    _this.brightcoveConfig = null;

    //*** Constructor
    ( async function () {
        _this.parseConfig(_config);
        if (_this.brightcove) await initBrightcove()
        initCover();
        if (!_this.brightcove) initIframe();
        if (!_this.brightcove) initButton();

        CoreUIState.instance().uiBuilder.buildUIIVideoPlayer(
            {
                $container: $this,
                $cover,
                $iframe,
                $button,
                $buttonIcon,
            },
            _this.color
        );

    })();

    async function initBrightcove() {
        await AssetLoader.loadAssets(['~assets/js/lib/brightcove.js']);
        $video = $this.create(_this.getPrefix('video'));
        $video.css({ left: 0, top: 0 }).size('100%');
        let brightcovePlayer = brightcovePlayerLoader({
            accountId: _this.brightcove.account,
            embedId: 'default',
            playerId: _this.brightcove.player,
            refNode: $video.div,
            videoId: _this.brightcove.video,
            autoPlay: true
        });

        brightcovePlayer.then(({ ref }) => {
            if (_this.autoPlay) {
                ref.play()
            }
            _brightcoveElement = ref.el();
            _brightcoveVideo =  ref.children()[0];
            _brightcoveVideo.addEventListener('ended', handleEndVideo)
            _brightcoveElement.style.border = 'none';
            _brightcoveElement.style.height = '100%';
            _brightcoveElement.style.left = 0;
            _brightcoveElement.style.top = 0;
            _brightcoveElement.style.width = '100%';
        });
    }
    

    function initCover() {
        $cover = $this.create(_this.getPrefix('cover'), 'img');
        $cover.attr('src', _this.cover);
    }

    function initIframe() {
        $iframe = $this.create(_this.getPrefix('iframe'), 'iframe');
        $iframe.attr('allow', 'accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture');
        $iframe.attr('allowfullscreen', '');
        $iframe.attr('frameborder', 0);
        if (_this.autoPlay) {
            $iframe.attr('src', _this.iframe + '?autoplay=1');
            $iframe.css({ visibility: 'visible' });
            $iframe.tween({ opacity: 1 }, 400, 'easeOutCubic');
        }
    }

    function initButton() {
        $button = $this.create(_this.getPrefix('button'));
        $buttonIcon = $this.create(_this.getPrefix('button-icon'));
    }

    //*** Event handlers

    function handleEndVideo() {
        _this.events.fire(UIVideoPlayer.VIDEOENDED)
    }

    //*** Public methods
}, () => {
    UIVideoPlayer.VIDEOENDED = 'ui_v_p_video_ended'
});

Class(function UIVideoPlayerStyles() {
    Inherit(this, Component);

    this.buildUIIVideoPlayer = function ({ $container, $cover, $iframe, $button, $buttonIcon }, _color) {
        $container.css({
            paddingTop: `${(768 / 1366) * 100}%`,
            position: 'relative',

        });

        $cover.css({
            height: '100%',
            objectFit: 'cover',
            left: 0,
            top: 0,
            width: '100%',
            pointerEvents: 'none'
        });

        if ($iframe) {
            $iframe.css({
                border: 'none',
                height: '100%',
                left: 0,
                outline: 'none',
                top: 0,
                width: '100%',
                zIndex: 1,
            });
        }
        if ($button) {
            $button.css({
                background: '#fff',
                border: 'none',
                borderRadius: '50%',
                boxShadow: '0px 4px 4px rgba(0, 0, 0, 0.25)',
                height: '5rem',
                left: '50%',
                top: '50%',
                width: '5rem',
            });

            $button.transform({ x: '-50%', y: '-50%' });

            $buttonIcon.css({
                color: _color,
                height: '3rem',
                left: '50%',
                top: '50%',
                width: '3rem',
            });

            $buttonIcon.transform({ x: '-50%', y: '-50%' });
        }
    };
}, 'static');

Class(function UICameraViewToggle(_config) {
    Inherit(this, AbstractUIComponent);
    const _this = this;
    const $this = _this.element;

    var $text, $border1, $buttonWrapper, $view1, $view1Button, $view2, $view2Button, $border2;

    var _currView = PlayerControls.getViewState() || '3rd';

    //*** Constructor
    (async function () {
        _this.parseConfig(_config);

        initHTML();
        initStyles();

        addHandlers();

        await _this.wait(50);
        handleClick({ view: _currView });
    })();

    function initHTML() {
        $this.hide();

        $text = $this.create(_this.getPrefix('text'));
        $text.text('camera POV');

        $border1 = $this.create(_this.getPrefix('border'));

        $buttonWrapper = $this.create(_this.getPrefix('button-wrapper'));

        $view1 = $buttonWrapper.create(_this.getPrefix('view1'));

        $view1Button = _this.initClass(UIFilledButton, {
            text: 'VIEW 1',
            onClick: () => handleClick({ view: '1st' }),
            iconButton: _this.iconButton,
            icon: 'view-1st'
        }, [$view1]);

        $view2 = $buttonWrapper.create(_this.getPrefix('view2'));

        $view2Button = _this.initClass(UIFilledButton, {
            text: 'VIEW 2',
            onClick: () => handleClick({ view: '3rd' }),
            iconButton: _this.iconButton,
            icon: 'view-3rd'
        }, [$view2]);

        $border2 = $this.create(_this.getPrefix('border'));
    }

    function initStyles() {
        CoreUIState.instance().uiBuilder.buildUICameraViewToggle({
            $container: $this,
            $text,
            $border1,
            $buttonWrapper,
            $view1,
            $view1Button,
            $view2,
            $view2Button,
            $border2,
        }, {
            iconButton: _this.iconButton,
        });
    }

    //*** Event handlers
    function addHandlers() {
        _this.events.sub(PlayerControls.SWITCH_VIEW, handleSwitchView);
    }

    function handleSwitchView(e) {
        _currView = e.view;

        switch (_currView) {
            case '1st':
                CoreUIState.instance().uiBuilder.cameraViewToggleActive($view1Button, true);
                CoreUIState.instance().uiBuilder.cameraViewToggleActive($view2Button, false);
                break;
            case '3rd':
                CoreUIState.instance().uiBuilder.cameraViewToggleActive($view1Button, false);
                CoreUIState.instance().uiBuilder.cameraViewToggleActive($view2Button, true);
                break;
        }
    }

    function handleClick(e) {
        Track.event('settings', `switch_view_${e.view}`)
        _this.events.fire(PlayerControls.SWITCH_VIEW, e);
    }

    //*** Public methods
    this.show = function () {
        $this.show();
        $this.css({ opacity: 0 }).tween({ opacity: 1 }, 400, 'easeOutCubic');
    }

    this.hide = function () {
        $this.tween({ opacity: 0 }, 400, 'easeOutCubic').onComplete(_ => {
            $this.hide();
        });
    }

});

Class(function UICameraViewToggleStyles() {
    Inherit(this, Component);

    this.buildUICameraViewToggle = function ({
        $container,
        $text,
        $border1,
        $buttonWrapper,
        $view1,
        $view1Button,
        $view2,
        $view2Button,
        $border2,
    }, {
        iconButton,
    }) {
        $container.css({
            left: '2.3rem',
            bottom: '3rem',
            padding: '1.3rem 1.8rem',
            background: 'black',
            borderRadius: '0.5rem',
        });

        $text.css({
            ...this.styleguide.label3,
            position: 'relative',
            color: this.colors.monochrome[2],
            paddingBottom: '1rem',
        });

        $border1.css({
            position: 'relative',
            width: '100%',
            height: '1px',
            background: this.colors.monochrome[3],
        });

        $view1.css({
            position: 'relative',
            display: 'inline-block',
        });

        $buttonWrapper.css({
            position: 'relative',
            display: 'flex',
            justifyContent: 'space-between',
        });

        $view1Button.element.css({
            width: 58,
            height: 19,
            marginTop: '1rem',
            marginBottom: '1rem',
            padding: '4px 10px',
            fontSize: 10,
            fontWeight: '500',
            border: 'none',
            background: 'none',
            color: 'white',
            borderRadius: 5,
        });

        $view2.css({
            position: 'relative',
            display: 'inline-block',
        });

        $view2Button.element.css({
            width: 58,
            height: 19,
            marginTop: '1rem',
            marginBottom: '1rem',
            marginLeft: 2,
            padding: '4px 10px',
            fontSize: 10,
            fontWeight: '500',
            border: 'none',
            background: 'none',
            color: 'white',
            borderRadius: 5,
        });

        $border2.css({
            position: 'relative',
            width: '100%',
            height: '1px',
            background: this.colors.monochrome[3],
        });

        if (iconButton) {
            $view1Button.element.css({
                width: 40,
                height: 40,
            });
            $view2Button.element.css({
                width: 40,
                height: 40,
            });
        }
    };

    this.cameraViewToggleActive = function ($button, active) {
        if (active) {
            $button.element.css({
                background: this.colors.primary[0],
                color: 'black',
            });
        } else {
            $button.element.css({
                background: 'none',
                color: 'white',
            });
        }
    };

}, 'static');

Class(function UIChatController() {
    Inherit(this, Element);
    const _this = this;
    var $this;
    var $content,$wrapper;
    var _view;
    var _showing = false;

    //*** Constructor
    (function () {
        initHTML();
    })();

    function initHTML() {
        $this = _this.element;
        $this.css({
            position:'relative'
        })
        $wrapper = _this.initClass(UIButton,{
            image:'~assets/images/icon/chat.svg',
            action:click,
            toolTipText:null,
            isDisabled:true
        },[$this]);
    }

    //*** Event handlers
 
    function click() {
        
    }
    //*** Public methods
   
});
Class(function CoreUIState() {
  Inherit(this, UIState);
  
  const _this = this;

  //*** Constructor
  (function () {
    _this.uiBuilder = _this.initClass(CoreUIBuilder)
    _this.styleguide = AppStyleController.styleguide
    _this.colors = AppStyleController.colors

    _this.uiBuilder.setStyleguide(_this.styleguide)
    _this.uiBuilder.setColors(_this.colors)
    _this.addListeners()
  })();
}, 'singleton');

Class(function UIController() {
    Inherit(this, Element);

    const _this = this;
    const $this = _this.element;

    //*** Constructor
    (function () {
        _this.constructorName = Utils.getConstructorName(_this);

        initSpritesheet();
        initHTML();
        initHeader();
        initContent();
        initFooter();
        initModal();

        defer(_ => World.instance().resize());
    })();

    function initSpritesheet() {
        Spritesheet.url = Assets.getPath('~assets/images/sprite.svg');
    }

    function initHTML() {
        $this.size('100%').css({
            display: 'flex',
            flexDirection: 'column',
            position: 'fixed',
            opacity: 1,
            zIndex: 100
        });

        if (!Platform.usingVR() && !Utils.query('orbit')) Stage.add($this);
    }

    function initHeader() {
        _this.header = $this.create(`${_this.constructorName}__header`);
        _this.header.css({
            position: 'relative'
        });
    }

    function initContent() {
        _this.content = $this.create(`${_this.constructorName}__content`);
        _this.content.css({
            height: '100%',
            position: 'relative'
        });
    }

    function initFooter() {
        _this.footer = $this.create(`${_this.constructorName}__footer`);
        _this.footer.css({
            position: 'relative'
        });
    }

    function initModal() {
        _this.modal = _this.initClass(UIModalController, [$this]);
    }

    //*** Public methods

    /**
     * Initializes UIController layout with specified Class
     * @param {object} Class - class that will be instantiated
     * @param {boolean} isIgnoringHeightResize
     * @param {boolean} isIgnoringWidthResize
     */
    this.init = function({ ClassComponent = UIPanelLayout, isIgnoringHeightResize = false, isIgnoringWidthResize = false } = {}) {
        _this.flag('isIgnoringHeightResize', isIgnoringHeightResize);
        _this.flag('isIgnoringWidthResize', isIgnoringWidthResize);

        _this.layout = _this.initClass(ClassComponent, [_this.content]);

        _this.flag('isReady', true);
    };

    this.ready = function() {
        return _this.wait('isReady');
    };

    //*** Header
    this.initHeader = function(Class) {
        _this.headerInstance = _this.initClass(Class, [_this.header]);

        defer(_ => World.instance().resize());
    };

    this.hideHeader = function() {
        _this.header.css({ marginTop: -_this.sizes.top, transition: 'margin 200ms ease' });
        _this.delayedCall(_ => _this.header.invisible(), 200);
    };

    this.showHeader = function() {
        _this.header.visible();
        _this.header.css({ marginTop: 0, transition: 'margin 200ms ease' });
    };

    this.destroyHeader = function() {
        _this.headerInstance?.destroy();
        _this.headerInstance = null;
    };

    //*** Footer
    this.initFooter = function(Class) {
        _this.footerInstance = _this.initClass(Class, [_this.footer]);

        defer(_ => World.instance().resize());
    };

    this.destroyFooter = function() {
        _this.footerInstance?.destroy();
        _this.footerInstance = null;
    };

    //*** Visibility
    this.show = function(delay) {
        _this.layout.show(delay);
    };

    this.hide = function(delay) {
        _this.layout.hide(delay);
    };

    //*** Bounds
    this.get('sizes', _ => {
        let headerHeight = _this.flag('isIgnoringHeightResize') ? 0 : _this.headerInstance?.element?.div?.clientHeight || 0;
        let footerHeight = _this.flag('isIgnoringHeightResize') ? 0 : _this.footerInstance?.element?.div?.clientHeight || 0;
        let layoutWidth = _this.flag('isIgnoringWidthResize') ? 0 : _this.layout?.width || 0;

        return {
            height: window.innerHeight - headerHeight - footerHeight,
            left: 0,
            top: headerHeight,
            width: window.innerWidth - layoutWidth
        };
    });

    //*** Routes
    this.registerRoutes = function(routes) {
        _this.layout.registerRoutes(routes);
    };

    //*** AV
    this.setAVSettings = function(videoAllowed, audioAllowed) {
        AVSettingsController.instance().audioAllowed = audioAllowed;
        AVSettingsController.instance().videoAllowed = videoAllowed;
    };
}, 'singleton');

Class(function UIOverlay() {
    Inherit(this, AbstractUIComponent);

    const _this = this;
    const $this = _this.element;

    //*** Constructor
    (function () {
        $this.css({ left: '100%', top: 0, zIndex: 10000 }).transform({ x: '0%' });

        UIController.instance().layout.element.add($this);
    })();

    _this.animateIn = function() {
        $this.tween({ x: '-100%' }, 400, 'easeOutCubic');
    };

    _this.animateOut = function() {
        $this.tween({ x: '0%' }, 400, 'easeOutCubic');
    };
});
Class(function UIPageLayout() {
    Inherit(this, Element);

    const _this = this;
    const $this = _this.element;

    var _routeCurrent, _viewCurrent;
    var _filterNav, _filterContent;

    var _views = [];

    //*** Constructor
    (function () {
        _this.constructorName = Utils.getConstructorName(_this);
        _this.width = '100%';

        initHTML();
        initTransition();
        addListeners();
        resize();
    })();

    function initHTML() {
        $this.css({
            position: 'relative',
            display: 'flex',
            width: '100%',
            height: '100%'
        }).mouseEnabled(false);

        _this.page = $this.create('Page');
        _this.page.div.classList.add('prevent_interaction3d');
        _this.page.div.classList.add('prevent_interactionScroll');
        _this.page.mouseEnabled(true);

        _this.page.css({
            position: 'relative',
            height: '100%'
        });

        initWrapper();
        initHeader();
        initContent();
        initFooter();
        initModal();
    }

    function initWrapper() {
        _this.wrapper = _this.page.create(`${_this.constructorName}__wrapper`);
        _this.wrapper.css({
            display: 'flex',
            flexDirection: 'column'
        }).size('100%');
    }

    function initHeader() {
        _this.header = _this.wrapper.create(`${_this.constructorName}__header`);
        _this.header.css({
            position: 'relative',
            width: '100%',
            zIndex: 2
        });

        _this.header.setZ(10);

        _filterNav = _this.initClass(CSSFilter, _this.header);
    }

    function initContent() {
        _this.content = _this.wrapper.create(`${_this.constructorName}__content`);
        _this.content.css({
            height: '100%',
            position: 'relative',
            overflowX: 'hidden',
            zIndex: 2
        }).overflowScroll({ y: true })

        _filterContent = _this.initClass(CSSFilter, _this.content);
    }

    function initModal() {
        _this.modal = _this.initClass(UIModalController, [_this.page]);
    }

    function initFooter() {
        _this.footer = _this.wrapper.create(`${_this.constructorName}__footer`);
        _this.footer.css({
            position: 'relative',
            width: '100%',
            zIndex: 10
        });
    }

    //*** Transition
    function initTransition() {
        _this.transitionElement = _this.page.create(`${_this.constructorName}__transition`);
        _this.transitionElement.size('100%').css({
            left: 0,
            opacity: 0,
            position: 'absolute',
            top: 0,
            visibility: 'hidden'
        });

        _this.transitionElement.setZ(-1);
    }

    async function transition(view, direction = 'right') {
        if (view.color) {
            _this.transitionElement.css({ background: view.color });
        }

        if (_viewCurrent) {
            if (_viewCurrent.animateOut) {
                _this.events.fire(UIPageLayout.HIDE);

                await _viewCurrent.animateOut();
            }

            _viewCurrent.destroy();
        }

        _viewCurrent = _this.initClass(view.view, view.options, [_this.content]);

        if (_viewCurrent.animateIn) {
            _this.events.fire(UIPageLayout.SHOW);

            await _viewCurrent.animateIn();
        }

        notifyResize();
    }

    //*** Event handlers
    function addListeners() {
        _this.onResize(resize);

        _this.events.sub(Router, Router.UPDATE, handleRouteUpdate);

        _this.events.sub(UIModalView.OPEN, blurActivate);
        _this.events.sub(UIModalView.CLOSE, blurDeactivate);
    }

    function blurActivate() {
        if (!Platform.blurFX()) return;

        _filterNav.tween({ blur: 2 }, 700, 'easeInSine');
        _filterContent.tween({ blur: 2 }, 700, 'easeInSine');
    }

    function blurDeactivate() {
        if (!Platform.blurFX()) return;

        _filterNav.tween({ blur: 0 }, 400, 'easeInSine');
        _filterContent.tween({ blur: 0 }, 400, 'easeInSine');
    }

    async function handleRouteUpdate(value) {
        _this.destroyOverlay();

        handleRouteCreate(value);
    }

    async function handleRouteCreate({ value }) {
        if (!_views.length) return;

        let page = _views.find(({ regex }) => new RegExp(regex).test(value));

        if (page && page.guard) {
            let id;

            if (page.guard.constructor.name === 'AsyncFunction') id = await page.guard(value);
            else id = page.guard(value);

            page = _views.find(({ regex }) => new RegExp(regex).test(id));
        }

        _routeCurrent = value;

        if (page && page.view && _routeCurrent != page.view) {
            transition(page.view);
        }
    }

    function resize() {
        if (_this.flag('isHidden') || _this.flag('isFullscreen')) return;

        if (Utils.query('collapse')) {
            this.hide(0);
        }
    }

    function notifyResize() {
        if (_this.width === window.innerWidth) {
            World.instance().stopRender();
        } else if (!_this.flag('isFullscreen')) {
            World.instance().startRender();
        }

        World.instance().resize();
    }

    //*** Public methods
    this.addContent = function (obj) {
        if (_viewCurrent) _viewCurrent.destroy();

        if (obj.element) {
            _this.content.add(obj.element);

            _viewCurrent = obj;
        } else {
            let instance = _this.initClass(obj, { parent: _this.page, showBackdrop: true, closeOnBackdropClick: true }, [_this.content]);

            _viewCurrent = instance;
        }

        return _viewCurrent;
    };

    this.addHeader = function (Class) {
        let instance = _this.initClass(Class, { parent: _this.page }, [_this.header]);

        _this.headerInstance = instance;

        _this.flag('isHeaderVisible', true);

        return instance;
    };

    this.destroyHeader = _ => _this.headerInstance && _this.headerInstance.destroy();

    this.addFooter = function (Class) {
        let instance = _this.initClass(Class, null, [_this.footer]);

        _this.footerInstance = instance;

        _this.flag('isFooterVisible', true);

        return instance;
    };

    this.destroyFooter = _ => _this.footerInstance && _this.footerInstance.destroy();

    //*** Routes
    this.registerRoutes = function (routes) {
        _views = routes.map(({ path, color, view, guard }) => {
            let regex = typeof path === 'object' ? new RegExp(path) : `^${path}\/?$`;

            return {
                guard,
                regex,
                view: {
                    color,
                    view
                }
            };
        });
    };

    //*** Visibility
    this.hide = function (duration = 300) {
        if (_this.flag('isHidden')) return;

        _this.flag('isHidden', true);

        return new Promise((resolve, reject) => {
            _this.widthPrevious = _this.width;

            let translation = { x: 0 };
            let onComplete = _ => {
                _this.width = 0;

                _this.page.css({ opacity: 0, visibility: 'hidden' });

                resolve();
            };

            if (duration) {
                let animation = tween(translation, { x: 1 }, duration, 'easeOutCubic', onComplete);

                animation.onUpdate(_ => {
                    _this.page.transform({ x: `${translation.x * 100}%` });
                    _this.width = _this.widthPrevious * (1 - translation.x);
                });
            } else {
                onComplete();
            }
        });
    };

    this.show = function (duration = 300) {
        if (!_this.flag('isHidden')) return;

        _this.flag('isHidden', false);

        return new Promise((resolve, reject) => {
            let translation = { x: 1 };
            let onComplete = _ => {
                _this.width = _this.widthPrevious;

                resolve();
            };

            _this.page.css({ opacity: 1, visibility: 'visible' });

            if (duration) {
                let animation = tween(translation, { x: 0 }, duration, 'easeOutCubic', onComplete);

                animation.onUpdate(_ => {
                    _this.page.transform({ x: `${translation.x * 100}%` });
                    _this.width = _this.widthPrevious * (1 - translation.x);
                });
            } else {
                onComplete();
            }
        });
    };

    //*** Header visibility
    this.hideHeader = function ({ duration = 400, ease = 'easeOutCubic' } = {}) {
        _this.header.transform({ y: '0%' }).invisible().tween({ y: '-100%' }, duration, ease);

        _this.flag('isHeaderVisible', false);
    };

    this.showHeader = function ({ duration = 400, ease = 'easeOutCubic', height } = {}) {
        _this.header.transform({ y: '-100%' }).visible().tween({ y: '0%' }, duration, ease);

        _this.flag('isHeaderVisible', true);
    };

    //*** Footer visibility
    this.hideFooter = function ({ duration = 400, ease = 'easeOutCubic' } = {}) {
        _this.footer.transform({ y: '0%' }).invisible().tween({ y: '100%' }, duration, ease);

        _this.flag('isFooterVisible', false);
    };

    this.showFooter = function ({ duration = 400, ease = 'easeOutCubic', height } = {}) {
        _this.footer.transform({ y: '-100%' }).visible().tween({ y: '0%' }, duration, ease);

        _this.flag('isFooterVisible', true);
    };

    //**** Overlay visibility
    this.showOverlay = function (Class, data, direction, background) {
        _this.destroyOverlay();

        _this.overlay = _this.content.create('overlay');
        _this.overlay.size('100%').css({ left: 0, top: 0, position: 'absolute' });

        _this.transitionElement.css({ background });
    };

    this.hideOverlay = function (direction, background) {
        _this.transitionElement.css({ background });
    };

    this.destroyOverlay = function () {
        if (_this.overlay) {
            _this.overlayInstance.destroy();
            _this.overlayInstance = null;

            _this.overlay.remove();
            _this.overlay = null;

            _viewCurrent?.element.css({ opacity: 1, visibility: 'visible' });
        }
    };

    _this.transition = function (direction, background, callback) {
        _this.transitionElement.css({ background });
    };

    //*** Initialization
    this.init = function ({ width = '100%' } = {}) {
        _this.width = width;
        _this.widthPrevious = width;

        _this.page.css({
            width: _this.width
        });

        handleRouteUpdate({ value: Router.getState().join('/') });
    };

    this.get('view', _ => _viewCurrent);

    this.get('headerVisible', _ => _this.flag('isHeaderVisible'));
    this.get('footerVisible', _ => _this.flag('isFooterVisible'));

    //*** Width methods
    this.setSize = async function ({ duration = 0, ease = 'easeOutCubic', width = 500 } = {}) {
        _this.width = width;
        _this.widthPrevious = width;

        let tween = _this.page.tween({ width }, duration, ease, _ => {
            notifyResize();
        });

        return tween.promise();
    };
}, _ => {
    UIPageLayout.SHOW = 'UIPageLayout.SHOW';
    UIPageLayout.HIDE = 'UIPageLayout.HIDE';
    UIPageLayout.RESIZE = 'UIPageLayout_reize';
});

Class(function UIPanelLayout() {
    Inherit(this, Element);

    const _this = this;
    const $this = _this.element;

    var _routeCurrent, _viewCurrent;
    var _filterNav, _filterContent;

    var _views = [];

    //*** Constructor
    (function () {
        _this.flag('isSwipeTransition', true);

        _this.constructorName = 'Panel';
        _this.width = 500;

        initHTML();
        initTransition();
        addListeners();
        resize();
    })();

    function initHTML() {
        $this.css({
            position: 'relative',
            display: 'flex',
            width: '100%',
            height: '100%'
        }).mouseEnabled(false);

        _this.panel = $this.create('Panel');
        _this.panel.div.classList.add('prevent_interaction3d');
        _this.panel.div.classList.add('prevent_interactionScroll');
        _this.panel.mouseEnabled(true);

        _this.panel.css({
            position: 'absolute',
            height: '100%',
            overflow: 'hidden',
            right: 0,
            top: 0
        });

        _this.panel.setZ(100);

        initWrapper();
        initHeader();
        initContent();
        initFooter();
        initModal();
    }

    function initWrapper() {
        _this.wrapper = _this.panel.create(`${_this.constructorName}__wrapper`);
        _this.wrapper.css({
            display: 'flex',
            flexDirection: 'column',
            left: 0,
            overflow: 'hidden',
            top: 0
        }).size('100%');
    }

    function initHeader() {
        _this.header = _this.wrapper.create(`${_this.constructorName}__header`);
        _this.header.css({
            position: 'relative',
            width: '100%',
            zIndex: 2
        });

        _this.header.setZ(10);

        _filterNav = _this.initClass(CSSFilter, _this.header);
    }

    function initContent() {
        _this.content = _this.wrapper.create(`${_this.constructorName}__content`);
        _this.content.css({
            height: '100%',
            position: 'relative',
            overflowY: 'auto',
            overflowX: 'hidden',
            zIndex: 2
        });

        _filterContent = _this.initClass(CSSFilter, _this.content);
    }

    function initModal() {
        _this.modal = _this.initClass(UIModalController, [_this.panel]);
    }

    function initFooter() {
        _this.footer = _this.wrapper.create(`${_this.constructorName}__footer`);
        _this.footer.css({
            position: 'relative',
            width: '100%',
            zIndex: 10
        });
    }

    //*** Transition
    function initTransition() {
        _this.transitionElement = _this.panel.create(`${_this.constructorName}__transition`);
        _this.transitionElement.size('100%').css({
            left: 0,
            opacity: 0,
            position: 'absolute',
            top: 0,
            visibility: 'hidden'
        });

        _this.transitionElement.setZ(-1);
    }

    async function transition(view, direction = 'right') {
        if (view.color) {
            _this.transitionElement.css({ background: view.color });
        }

        if (_this.flag('isSwipeTransition')) {
            await new Promise(resolve => AnimationBuilder.swipeTransition(_this.content, _this.transitionElement, direction, _ => resolve()));
        }

        if (_viewCurrent) {
            if (_viewCurrent.animateOut) {
                await _viewCurrent.animateOut();
            }

            _viewCurrent.destroy();
        }

        _viewCurrent = _this.initClass(view.view, view.options, [_this.content]);

        if (_viewCurrent.animateIn) {
            await _viewCurrent.animateIn();
        }

        notifyResize();
    }

    //*** Event handlers
    function addListeners() {
        _this.onResize(resize);

        _this.events.sub(Router, Router.UPDATE, handleRouteUpdate);

        _this.events.sub(UIModalView.OPEN, blurActivate);
        _this.events.sub(UIModalView.CLOSE, blurDeactivate);
    }

    function blurActivate() {
        if (!Platform.blurFX()) return;

        _filterNav.tween({ blur: 2 }, 700, 'easeInSine');
        _filterContent.tween({ blur: 2 }, 700, 'easeInSine');
    }

    function blurDeactivate() {
        if (!Platform.blurFX()) return;

        _filterNav.tween({ blur: 0 }, 400, 'easeInSine');
        _filterContent.tween({ blur: 0 }, 400, 'easeInSine');
    }

    async function handleRouteUpdate(value) {
        _this.destroyOverlay();

        handleRouteCreate(value);
    }

    async function handleRouteCreate({ value }) {
        if (!_views.length) return;

        let page = _views.find(({ regex }) => new RegExp(regex).test(value));

        if (page && page.guard) {
            let id;

            if (page.guard.constructor.name === 'AsyncFunction') id = await page.guard(value);
            else id = page.guard(value);

            page = _views.find(({ regex }) => new RegExp(regex).test(id));
        }

        _routeCurrent = value;

        if (page && page.view && _routeCurrent != page.view) {
            transition(page.view);
        }
    }

    function resize() {
        if (_this.flag('isHidden') || _this.flag('isFullscreen')) return;

        if (Utils.query('collapse')) {
            this.hide(0);
        } else {
            notifyResize();
        }
    }

    function notifyResize() {
        if (_this.width === window.innerWidth) {
            World.instance().stopRender();
        } else if (!_this.flag('isFullscreen')) {
            World.instance().startRender();
        }

        World.instance().resize();
    }

    //*** Public methods
    this.addContent = function (obj) {
        if (_viewCurrent) _viewCurrent.destroy();

        if (obj.element) {
            _this.content.add(obj.element);

            _viewCurrent = obj;
        } else {
            let instance = _this.initClass(obj, { parent: _this.panel, showBackdrop: true, closeOnBackdropClick: true }, [_this.content]);

            _viewCurrent = instance;
        }

        return _viewCurrent;
    };

    this.addHeader = function (Class) {
        let instance = _this.initClass(Class, { parent: _this.panel }, [_this.header]);

        _this.headerInstance = instance;

        _this.flag('isHeaderVisible', true);

        return instance;
    };

    this.destroyHeader = _ => _this.headerInstance && _this.headerInstance.destroy();

    this.addFooter = function (Class) {
        let instance = _this.initClass(Class, null, [_this.footer]);

        _this.footerInstance = instance;

        _this.flag('isFooterVisible', true);

        return instance;
    };

    this.destroyFooter = _ => _this.footerInstance && _this.footerInstance.destroy();

    //*** Routes
    this.registerRoutes = function (routes) {
        _views = routes.map(({ path, color, view, guard }) => {
            let regex = typeof path === 'object' ? new RegExp(path) : `^${path}\/?$`;

            return {
                guard,
                regex,
                view: {
                    color,
                    view
                }
            };
        });
    };

    //*** Visibility
    this.hide = function (duration = 300) {
        if (_this.flag('isHidden')) return;

        _this.events.fire(UIPanelLayout.HIDE);

        _this.flag('isHidden', true);

        return new Promise((resolve, reject) => {
            _this.widthPrevious = _this.width;

            let translation = { x: 0 };
            let onComplete = _ => {
                _this.width = 0;

                _this.panel.css({ opacity: 0, visibility: 'hidden' });

                notifyResize();
                resolve();
            };

            if (duration) {
                let animation = tween(translation, { x: 1 }, duration, 'easeOutCubic', onComplete);

                animation.onUpdate(_ => {
                    _this.panel.transform({ x: `${translation.x * 100}%` });
                    _this.width = _this.widthPrevious * (1 - translation.x);

                    notifyResize();
                });
            } else {
                onComplete();
            }
        });
    };

    this.show = function (duration = 300) {
        if (!_this.flag('isHidden')) return;

        _this.events.fire(UIPanelLayout.SHOW);

        _this.flag('isHidden', false);

        return new Promise((resolve, reject) => {
            let translation = { x: 1 };
            let onComplete = _ => {
                _this.width = _this.widthPrevious;

                notifyResize();
                resolve();
            };

            _this.panel.css({ opacity: 1, visibility: 'visible' });

            if (duration) {
                let animation = tween(translation, { x: 0 }, duration, 'easeOutCubic', onComplete);

                animation.onUpdate(_ => {
                    _this.panel.transform({ x: `${translation.x * 100}%` });
                    _this.width = _this.widthPrevious * (1 - translation.x);

                    notifyResize();
                });
            } else {
                onComplete();
            }
        });
    };

    //*** Header visibility
    this.hideHeader = function ({ duration = 400, ease = 'easeOutCubic' } = {}) {
        _this.header.tween({ height: 0 }, duration, ease, _ => {
            _this.header.invisible();
        });

        _this.isHeaderVisible = false;
    };

    this.showHeader = function ({ duration = 400, ease = 'easeOutCubic', height } = {}) {
        _this.header.visible();
        _this.header.tween({ height: height || _this.header.children()[0].clientHeight }, duration, ease);

        _this.isHeaderVisible = true;
    };

    //*** Footer visibility
    this.hideFooter = function ({ duration = 400, ease = 'easeOutCubic' } = {}) {
        _this.footer.tween({ height: 0 }, duration, ease, _ => {
            _this.footer.invisible();
        });

        _this.flag('isFooterVisible', false);
    };

    this.showFooter = function ({ duration = 400, ease = 'easeOutCubic', height } = {}) {
        _this.footer.visible();
        _this.footer.tween({ height: height || _this.footer.children()[0].clientHeight }, duration, ease);

        _this.flag('isFooterVisible', true);
    };

    //**** Overlay visibility
    this.showOverlay = function (Class, data, direction, background) {
        _this.destroyOverlay();

        _this.overlay = _this.content.create('overlay');
        _this.overlay.size('100%').css({ left: 0, top: 0, position: 'absolute' });

        _this.transitionElement.css({ background });

        AnimationBuilder.swipeTransition(_this.content, _this.transitionElement, direction, _ => {
            _this.overlayInstance = _this.initClass(Class, data, [_this.overlay]);

            _viewCurrent?.element.css({ opacity: 0, visibility: 'hidden' });
        });
    };

    this.hideOverlay = function (direction, background) {
        _this.transitionElement.css({ background });

        AnimationBuilder.swipeTransition(_this.content, _this.transitionElement, direction, _ => {
            _this.destroyOverlay();
        });
    };

    this.destroyOverlay = function () {
        if (_this.overlay) {
            _this.overlayInstance.destroy();
            _this.overlayInstance = null;

            _this.overlay.remove();
            _this.overlay = null;

            _viewCurrent?.element.css({ opacity: 1, visibility: 'visible' });
        }
    };

    //*** Transition
    _this.setSwipeTransition = function(isEnabled) {
        _this.flag('isSwipeTransition', isEnabled);
    };

    _this.transition = function (direction, background, callback) {
        _this.transitionElement.css({ background });

        AnimationBuilder.swipeTransition(_this.content, _this.transitionElement, direction, callback);
    };

    //*** Initialization
    this.init = function ({ width = 500 } = {}) {
        _this.width = width;
        _this.widthPrevious = width;

        _this.panel.css({
            width: _this.width
        });

        handleRouteUpdate({ value: Router.getState().join('/') });
    };

    this.get('view', _ => _viewCurrent);

    this.get('headerVisible', _ => _this.flag('isHeaderVisible'));
    this.get('footerVisible', _ => _this.flag('isFooterVisible'));

    //*** Width methods
    this.setSize = async function ({ duration = 0, ease = 'easeOutCubic', width = 500 } = {}) {
        _this.width = width;
        _this.widthPrevious = width;

        let tween = _this.panel.tween({ width }, duration, ease, _ => {
            notifyResize();
        });

        return tween.promise();
    };

    this.enableFullscreen = async function ({ duration = 0, ease = 'easeOutCubic' } = {}) {
        _this.flag('isFullscreen', true);

        let tween = _this.panel.tween({ width: window.innerWidth }, duration, ease).onComplete(_ => {
            _this.panel.css({ width: '100%' });

            notifyResize();
        });

        return tween.promise();
    };

    this.disableFullscreen = async function ({ duration = 0, ease = 'easeOutCubic' } = {}) {
        _this.flag('isFullscreen', false);

        World.instance().startRender();

        let tween = _this.panel.tween({ width: _this.width }, duration, ease).onComplete(_ => {
            notifyResize();
        });

        return tween.promise();
    };
}, _ => {
    UIPanelLayout.SHOW = 'UIPanelLayout.SHOW';
    UIPanelLayout.HIDE = 'UIPanelLayout.HIDE';
    UIPanelLayout.RESIZE = 'UIPanelLayout_reize';
});

Class(function UIState() {
    Inherit(this, Component);
    const _this = this;
    
    //*** Constructor
    (function () {
    })();
    
    //*** Event handlers
    this.addListeners = function () {
        _this.events.sub(AppStyleController.STYLEGUIDE_CHANGE, onStyleguideChange);
        _this.events.sub(AppStyleController.COLORS_CHANGE, onColorsChange);
    }
    
    function onStyleguideChange(e) {
        _this.styleguide = e.styleguide;
        _this.uiBuilder.setStyleguide(_this.styleguide);
    }

    function onColorsChange(e) {
        _this.colors = e.colors;
        _this.uiBuilder.setColors(_this.colors);
    }


    this.setBuilder = function (builder) {
        if(_this.uiBuilder){
            _this.uiBuilder.destroy();
        }
        _this.uiBuilder = _this.initClass(builder);
        _this.uiBuilder.setStyleguide(_this.styleguide);
        _this.uiBuilder.setColors(_this.colors);
    }
},'singleton');
Class(function AbstractUIComponent(_element) {
    Inherit(this, Element, _element);
    const _this = this;
    //*** Event handlers

    //*** Public methods
    this.parseConfig = function(config) {
        for(let key in config) {
            _this[key] = config[key]
        }
    }

    this.getPrefix = function(className) {
        return `${Utils.getConstructorName(this)}__${className}`
    }

    this.hideLoader = () => {
        UIController.instance().layout.modal.closeModal();
    }

    this.showLoader = (view, config) => {
        UIController.instance().layout.modal.openModal(view, {
           ...config
        });
    }
});
Class(function UIBackButton(_config) {
    Inherit(this, AbstractUIComponent, 'button');
    const _this = this;
    const $this = _this.element;

    var $image, $text, $icon;

    _this.color = null;
    _this.image = null;
    _this.onClick = null;
    _this.size = 'normal';
    _this.text = null;

    //*** Constructor
    (function () {
        _this.parseConfig(_config);

        initHTML();
        initStyles();

        addHandlers();
    })();

    function initHTML() {
        $icon = _this.initClass(Sprite, 'chevron-left');

        if (_this.image) {
            $image = $this.create(_this.getPrefix('image'), 'img');
            $image.attr('src', _this.image);
        } else {
            $text = $this.create(_this.getPrefix('text'), 'span');
            $text.text(_this.text);
        }
    }

    function initStyles() {
        $this.multiTween = true;

        CoreUIState.instance().uiBuilder.buildUIBackButton({
            $container: $this,
            $icon,
            $image,
            $text,
        },
        {
            ..._config,
            size: _this.size,
        });
    }

    //*** Event handlers
    function addHandlers() {
        $this.interact(handleHover, handleClick, _this.text, _this.text);
    }

    async function handleHover(event) {
        CoreUIState.instance().uiBuilder.buildUIBackButtonHover(event, {
            $container: $this,
            $icon,
            $image,
            $text,
        },
        {
            ..._config,
            size: _this.size,
        });
    }

    function handleClick() {
        if (_this.onClick) _this.onClick();

        CoreUIState.instance().uiBuilder.buildUIBackButtonClick({
            $container: $this,
            $icon,
            $image,
            $text,
        },
        {
            ..._config,
            size: _this.size,
        });
    }
});

Class(function UIBackButtonStyles() {
    Inherit(this, Component);

    this.buildUIBackButton = function ({ $container, $image, $icon, $text }, { color, size }) {
        $container.css({
            alignItems: 'center',
            background: 'none',
            border: 'none',
            display: 'flex',
            marginLeft: '-0.7rem',
            outline: 'none',
            position: 'relative',
        });

        if ($image) {
            $image.css({
                display: 'block',
                height: '3.2rem',
                position: 'relative',
            });
        }

        $icon.element.css({
            color,
            height: '2.4rem',
            justifySelf: 'end',
            marginRight: '0.5rem',
            position: 'relative',
            width: '2.4rem',
        });

        if ($text) {
            $text.css({
                letterSpacing: '0.3px'
            });

            if (size === 'large') {
                $text.css({
                    ...this.styleguide.h4,
                    textTransform: 'uppercase',
                });

                $text.bold();
            } else if (size === 'small') {
                $text.css({
                    ...this.styleguide.label4,
                    color: this.colors.monochrome[6],
                    textTransform: 'uppercase',
                });

                $text.semibold();
            } else {
                $text.css({
                    ...this.styleguide.h5,
                });
            }
        }
    };

    this.buildUIBackButtonHover = function ({ action }, { $container }, {}) {
        switch (action) {
            case 'over':
                $container.tween({ opacity: 0.5 }, 400, 'easeOutCubic');
                break;

            case 'out':
                $container.tween({ opacity: 1 }, 400, 'easeOutCubic');
                break;
        }
    };

    this.buildUIBackButtonClick = function ({ $container }, {}) {
        $container.tween({ opacity: 1 }, 400, 'easeOutCubic');
    };
}, 'static');

/*
    Config allows for the following:

         background : string
            - color of background in normal state

         color : string
            - color of text in normal state

         disabled: string
            - set button state

         text: string
            - text to be displayed
            
         href : string
            - when using `elementType: a`, sets the desired `href`
            
         hover : string
            - color of background in hover state
            
         hoverColor : string
            - color of text in hover state
            
         rel : string
            - when using `elementType: a`, sets the desired `rel`
            
         target : string
            - when using `elementType: a`, sets the desired `target`
            
         title : string
            - sets the desired `title`
        
         value : string
            - when using `elementType: button`, sets the desired `value`

         elementType : string
            - a type of html element - defaults to 'button'

         type : string
            - a style type - `type: noBackground` could then be accessed in UIFilledButtonStyles for special styles
*/
Class(function UIFilledButton(_config) {
    Inherit(this, AbstractUIComponent, _config.elementType || 'button');
    const _this = this;
    const $this = _this.element;

    var $text, $hover, _icon;

    _this.background = null;
    _this.color = null;
    _this.disabled = null;
    _this.hover = null;
    _this.hoverColor = null;
    _this.href = null;
    _this.rel = null;
    _this.size = 'normal';
    _this.target = null;
    _this.text = null;
    _this.title = null;
    _this.type = 'fill';
    _this.icon = null;
    _this.iconButton = false;
    _this.onClick = null;
    _this.minWidth = null;

    //*** Constructor
    (function () {
        _this.parseConfig(_config);

        initHTML();
        initStyles();

        addHandlers();
    })();

    function initHTML() {
        if (_this.disabled) {
            $this.attr('disabled', 'disabled');
            $this.css({ opacity: 0.5 });
        }

        if (_this.href) $this.attr('href', _this.href);
        if (_this.rel) $this.attr('rel', _this.rel);
        if (_this.target) $this.attr('target', _this.target);
        if (_this.title) $this.attr('title', _this.title);
        if (_this.value) $this.attr('value', _this.value);

        _this.textElement = $text = $this.create(`${_this.getPrefix('text')}`, 'span');
        $text.text(_this.text);
        
        let stripped = _this.text && _this.text.replace(' ', '');
        $text.attr('id', `${stripped}_label`);
        $this.attr('aria-labeledby', `${stripped}_label`);
        $this.attr('role', 'button')

        if (_this.icon) {
            $text.text('');

            _this.iconElement = _icon = _this.initClass(Sprite, _this.icon, {
                height: '100%',
                width: '100%',
                position: 'relative',
                zIndex: '10'
            });
        }

        $hover = $this.create(`${_this.getPrefix('hover')}`);
    }

    function initStyles() {
        CoreUIState.instance().uiBuilder.buildUIFilledButton({
            $container: $this,
            $text,
            $hover,
        }, {
            background: _this.background,
            color: _this.color,
            hover: _this.hover,
            hoverColor: _this.hoverColor,
            size: _this.size,
            type: _this.type,
            minWidth: _this.minWidth,
        });
    }

    //*** Event handlers
    function addHandlers() {
        $this.interact(handleHover, handleClick, _this.text, _this.text);
    }

    function handleHover(event) {
        if (!$this || !$this.hit || !$this.attr) return;
        if (_this.isDisabled()) return;

        CoreUIState.instance().uiBuilder.buildUIFilledButtonHover(event, {
            $container: $this,
            $text,
            $hover,
        }, {
            background: _this.background,
            color: _this.color,
            hover: _this.hover,
            hoverColor: _this.hoverColor,
            size: _this.size,
            type: _this.type,
            minWidth: _this.minWidth,
        });
    }

    function handleClick() {
        if (!$this || !$this.attr) return;
        if ($this.attr('disabled')) return;

        if (_this.onClick) _this.onClick();

        CoreUIState.instance().uiBuilder.buildUIFilledButtonClick({
            $container: $this,
            $text,
            $hover,
        }, {
            background: _this.background,
            color: _this.color,
            hover: _this.hover,
            hoverColor: _this.hoverColor,
            size: _this.size,
            type: _this.type,
            minWidth: _this.minWidth,
        });
    }

    //*** Public methods
    this.isDisabled = function () {
        return $this.attr('disabled');
    };

    this.enable = function () {
        $this.attr('disabled', '');
        
        CoreUIState.instance().uiBuilder.buildUIFilledButtonEnable({
            $container: $this,
            $text,
            $hover,
        }, {
            background: _this.background,
            color: _this.color,
            hover: _this.hover,
            hoverColor: _this.hoverColor,
            size: _this.size,
            type: _this.type,
            minWidth: _this.minWidth,
        });
    };

    this.disable = function () {
        $this.attr('disabled', 'disabled');
        
        CoreUIState.instance().uiBuilder.buildUIFilledButtonDisable({
            $container: $this,
            $text,
            $hover,
        }, {
            background: _this.background,
            color: _this.color,
            hover: _this.hover,
            hoverColor: _this.hoverColor,
            size: _this.size,
            type: _this.type,
            minWidth: _this.minWidth,
        });
    };

    this.setBackground = function(background) {
        _this.background = background;

        $this.css({ background });
    };

    this.text = function (text) {
        $text.text(text);
    };
});

Class(function UIFilledButtonStyles() {
    Inherit(this, Component);

    this.buildUIFilledButton = function ({ $container, $text, $hover }, { background, color, hover, type, minWidth }) {
        $container.css({
            background: type === 'fill' ? background || this.colors.primary[0] : 'transparent',
            border: type === 'fill' ? 'none' : `0.2rem solid ${color}`,
            borderRadius: '0.3rem',
            color: color || '#fff',
            outline: 'none',
            overflow: 'hidden',
            padding: '1.5rem',
            position: 'relative',
            whiteSpace: 'nowrap',
            '-webkit-appearance': 'none',
        });

        if (minWidth) {
            $container.css({minWidth})
        }

        $text.css({
            ...this.styleguide.label1,
            fontSize: '1.5rem',
            fontWeight: '500',
            position: 'relative',
            zIndex: 1,
        });

        $hover.css({
            background: hover || '#fff',
            left: 0,
            opacity: 0,
            top: 0
        }).size('100%');
    };

    this.buildUIFilledButtonHover = function ({ action }, { $container, $text, $hover }, {}) {
        switch (action) {
            case 'over':
                $hover.tween({ opacity: 0.25 }, 400, 'easeOutCubic');
                break;

            case 'out':
                $hover.tween({ opacity: 0 }, 400, 'easeOutCubic');
                break;
        }
    };

    this.buildUIFilledButtonClick = function({ $container, $text, $hover }) {
        $hover.tween({ opacity: 0 }, 400, 'easeOutCubic');
    };

    this.buildUIFilledButtonEnable = function({ $container, $text, $hover }) {
        $container.css({ opacity: 1 });
        $container.hit.css({ cursor: 'pointer' });
    };

    this.buildUIFilledButtonDisable = function({ $container, $text, $hover }) {
        $container.css({ opacity: 0.5 });
        $container.hit.css({ cursor: 'not-allowed' });
    };
}, 'static');

Class(function UIIconButton(_config) {
    Inherit(this, AbstractUIComponent);

    const _this = this;
    const $this = _this.element;

    var $icon, $text, $tooltip;

    _this.align = 'left';
    _this.icon = null;
    _this.onClick = null;
    _this.text = null;
    _this.textStyle = null;
    _this.tooltip = null;
    _this.title = null;
    _this.iconStyle = null;

    //*** Constructor
    (function () {
        _this.flag('isEnabled', true);
        
        _this.parseConfig(_config);

        initSprite();

        if (_this.text) {
            initText();
        }

        if (_this.tooltip) {
            initTooltip();
        }

        addHandlers();
        
        CoreUIState.instance().uiBuilder.buildUIIconButton({
            $container: $this,
            $icon,
            $text,
            $tooltip,
        }, {
            ..._config,
            align: _this.align,
            iconStyle: _this.iconStyle,
            textStyle: _this.textStyle,
        });

        $this.attr('role', 'button');
        $this.attr('tabindex', '0');
    })();

    function initSprite() {
        _this.iconElement = $icon = _this.initClass(Sprite, _this.icon, {}, _this.title ? _this.title : _this.icon, [$this]);
    }

    function initText() {
        _this.textElement = $text = $this.create(_this.getPrefix('text'));

        $text.text(_this.text);
    }

    function initTooltip() {
        _this.tooltipElement = $tooltip = _this.initClass(UITooltip, {
            background: _this.tooltip.background || AppStyleController.colors.monochrome[0],
            color: _this.tooltip.color || AppStyleController.colors.primary[0],
            direction: _this.tooltip.direction || 'left',
            text: _this.tooltip.text,
        }, [$this]);
    }

    //*** Event handlers
    function addHandlers() {
        $this.interact(handleHover, handleClick);
        _this.onResize(onResize);
    }

    function onResize() {
        CoreUIState.instance().uiBuilder.buildUIIconButton({
            $container: $this,
            $icon,
            $text,
            $tooltip,
        }, {
            ..._config,
            align: _this.align,
            iconStyle: _this.iconStyle,
            textStyle: _this.textStyle,
        });
    }

    function handleHover(event) {
        if (!_this.flag('isEnabled')) return;

        CoreUIState.instance().uiBuilder.buildUIIconButtonHover(event, {
            $container: $this,
            $icon,
            $text,
            $tooltip,
        }, {
            ..._config,
            align: _this.align,
            iconStyle: _this.iconStyle,
            textStyle: _this.textStyle,
        });
    }

    function handleClick() {
        CoreUIState.instance().uiBuilder.buildUIIconButtonClick({
            $container: $this,
            $icon,
            $text,
            $tooltip,
        }, {
            ..._config,
            align: _this.align,
            iconStyle: _this.iconStyle,
            textStyle: _this.textStyle,
        });

        _this.onClick && _this.onClick();
    }

    //*** Public methods
    _this.enableInteract = function () {
        _this.flag('isEnabled', true);

        $this.hit.mouseEnabled(true);
        $this.mouseEnabled(true);
    };

    _this.disableInteract = function () {
        _this.flag('isEnabled', false);

        $this.hit.mouseEnabled(false);
        $this.mouseEnabled(false);
    };
});

Class(function UIIconButtonStyles() {
    Inherit(this, Component);

    this.buildUIIconButton = function ({ $container, $icon, $text }, { align, textStyle, iconStyle }) {
        $container.css({
            alignItems: 'center',
            display: 'flex',
            flexDirection: align === 'left' ? '' : 'row-reverse',
            justifyContent: align === 'right' ? 'flex-end' : '',
            position: 'relative',
        });

        $container.hit.css({
            zIndex: 100000,
        });

        $icon.element.css({
            color: 'currentColor',
            height: '2.4rem',
            position: 'relative',
            width: '2.4rem',
        });

        if (iconStyle) {
            $icon.element.css({ ...iconStyle })
        }

        if ($text) {
            $text.css({
                ...this.styleguide.buttonSmall,
                marginLeft: align === 'left' ? '1rem' : '',
                marginRight: align === 'right' ? '1rem' : '',
                maxWidth: 'calc(100% - 3.4rem)',
                position: 'relative',
                textTransform: 'uppercase',
            });

            if (textStyle) {
                $text.css({ ...textStyle })
            }

            $text.bold();
        }
    };

    this.buildUIIconButtonHover = function ({ action }, { $container, $icon, $text, $tooltip }, {}) {
        switch (action) {
            case 'over':
                $container.tween({ opacity: 0.5 }, 400, 'easeOutCubic');
                $tooltip && $tooltip.animateIn();
                break;

            case 'out': 
                $container.tween({ opacity: 1 }, 400, 'easeOutCubic');
                $tooltip && $tooltip.animateOut();
                break;
        }
    };
    
    this.buildUIIconButtonClick = function ({ $container, $icon, $text, $tooltip }, {}) {

    };
}, 'static');

Class(function UIButton(_config) {
    Inherit(this, Element,'button');
    const _this = this;
    const $this = _this.element;
    var $image, $background, $hover;
    const _prefix = "IconButton";
    var $pulse;
    var _shouldIgnoreHover;

    //*** Constructor
    (function () {
         initHTML();
         initStyles();
         if(!_config.isDisabled){
            addListeners()
         }
    })();

    function initHTML() {
        $this.attr('role','button');
        $this.tabIndex('0');
        
        $background = $this.create('.background');
        $pulse = $this.create(`${_prefix}__pulse`,"div");
        $image = $this.create(`${_prefix}__image`);
        $hover = $this.create(`${_prefix}__image-hover`);

        if(_config.type){
            $this.attr("type",_config.type);
        }
    }

    function initStyles() {
        CoreUIState.instance().uiBuilder.buildUIButton({
            $container:$this,
            $background,
            $hover,
            $pulse,
            $image,
        },_config)
    }

    //*** Event handlers
    function addListeners(){
        $this.interact(onHover, onClick);
        _this.onResize(resize);

    }
    function resize() {
        const size = Breakpoints.getSize();
        switch (size) {
            case 'big-desktop':
            case 'desktop':
            case 'tab-port':
            case 'tab-land':{
                $this.css({
                    padding:'1.5rem',
                })
                break;
            }
            case 'phone':{
                $this.css({
                    padding:'1rem',
                })
                break;
            }
            default:
                break;
        }
    }
    function onClick(){
        $pulse.tween({opacity:.3,x:'-50%',y:'-50%'},0,'easeOutQuad',()=>{
            $pulse.tween({scale:'1.5',x:'-50%',y:'-50%',opacity:0},500,'easeOutQuad');
            if(_config.action){
                _config.action();
            }
        })
    }
    function onHover(e) {
        if (_config.onHover) {
            _config.onHover(e);
        } else if (!_shouldIgnoreHover) {
            switch(e.action){
                case 'over':
                    $this.tween({ scale: 1.05, y: 0 }, 200, 'easeOutCubic');
                    $hover.tween({ opacity: 1 }, 200, 'easeOutSine');
                    $image.tween({ opacity: 0 }, 200, 'easeOutSine');
                    $background.tween({ opacity: 1 }, 200, 'easeOutSine');
                    break;
                case 'out':
                    $this.tween({ scale: 1.0, y: 0 }, 400, 'easeOutCubic');
                    $background.tween({ opacity: 0 }, 300, 'easeOutSine');
                    $hover.tween({ opacity: 0 }, 300, 'easeOutSine');
                    $image.tween({ opacity: 1 }, 300, 'easeOutSine');
                    break;
            }
        }
    }
    
    //*** Public methods
    this.setAppearance = function (color,imageColor,shouldIgnoreHover) {
        $this.css({
            background:color
        })
        $image.css({
            background:imageColor
        })
        _shouldIgnoreHover = shouldIgnoreHover;
    }
});
Class(function UIButtonStyles() {
    Inherit(this, Component);

    this.buildUIButton = function (elements, _config) {
        let { $container, $background, $pulse, $image, $hover } = elements;
        $container.css({
            padding: '1.5rem',
            borderRadius: '50%',
            position: 'relative',
            background: 'white',
            width: 'fit-content',
            height: 'fit-content',
            cursor: 'pointer',
            boxShadow: '0px 4px 20px rgba(0,0,0,0.1)',
            display: _config.isDisabled ? 'none' : 'flex',
            opacity: _config.isDisabled ? 0 : 1,
            border: 'none',
        });

        $background.size('100%').bg(this.colors.primary[0]).css({ opacity: 0, borderRadius: '50%', top: 0, left: 0 });

        $pulse.css({
            width: '100%',
            height: '100%',
            borderRadius: '50%',
            top: '50%',
            left: '50%',
            opacity: 0,
            background: this.colors.primary[0],
        });

        $pulse.transform({ x: '-50%', y: '-50%' });

        $image.css(this.styleguide.icon);
        $image.css({
            position: 'relative',
            background: _config.imageColor || this.colors.primary[0],
            '-webkit-mask-size': 'contain',
            maskSize: 'contain',
            '-webkit-mask-image': `url(${Assets.getPath(_config.image)})`,
            maskImage: `url(${Assets.getPath(_config.image)})`,
        });

        $hover.css(this.styleguide.icon);
        $hover.css({
            position: 'absolute',
            top: '1.5rem',
            left: '1.5rem',
            opacity: 0,
            background: 'white',
            '-webkit-mask-size': 'contain',
            maskSize: 'contain',
            '-webkit-mask-image': `url(${Assets.getPath(_config.image)})`,
            maskImage: `url(${Assets.getPath(_config.image)})`,
        });
    };
}, 'static');

Class(function AbstractChat() {
    Inherit(this, Component);
    const _this = this;
    
    //*** Constructor
    (function () {
    
    })();
    
    //*** Event handlers
    function handleNewMessage(e) {
        if(e && e.uid && e.uid != User.uid) {
            _this.events.fire(AbstractChat.NEW_MESSAGE);
        }
    }
    //*** Public methods
    _this.listenToChat = function(messaging) {
        _this.events.sub(messaging, UIMessaging.MESSAGE_ADD, handleNewMessage)
    }
    
    _this.destroy = function() {
        if (this.element && this.element.remove) this.element = this.element.remove();
        this._destroy && this._destroy();
    }
}, ()=>{
    AbstractChat.NEW_MESSAGE = 'AbstractChat_newMessage';
});
Class(function AbstractChatHost() {
    Inherit(this, Component);
    const _this = this;
    var $unread;
    var _currTab = 0;
    var _index = 1;
    //*** Constructor
    (function () {
        addListeners();
    })();


    function addListeners() {
        _this.events.sub( AbstractChat.NEW_MESSAGE, onMessage);
        _this.events.sub(UITabView.TAB_CHANGE, onTabChange);
    }

    function onMessage(e) {
        if(_currTab != _index && $unread) {
            $unread.css({opacity:1})
        }
    }

    function onTabChange(e) {
        _currTab = e.index;
        if(_currTab == _index && $unread) {
            $unread.css({opacity:0})
        }
    }
    
    _this.injectIndicator = function($element, color, index = 1) {
        _index = index;

        $unread = $element.create('unread');
        $unread.css({
            position:'absolute',
            top:'-.4rem',
            right:'-.6rem',
            width:'1rem',
            height:'1rem',
            borderRadius:'50%',
            background: color,
            opacity:0
        })
    }

    _this.destroy = function() {
        if (this.element && this.element.remove) this.element = this.element.remove();
        this._destroy && this._destroy();
    }
});
Class(function UIChatConfirmationView(_config) {
    Inherit(this, AbstractUIComponent);
    const _this = this;
    const $this = _this.element;

    _this.title = null;
    _this.message = null;

    var $close, $title, $message;
    
    //*** Constructor
    (function () {
         _this.parseConfig(_config);
         initHTML();
         initStyles();
         addListeners();
    })();
    
    function initHTML() {
        $close = $this.create('UIChatConfimationView__close');

        $title = $this.create('UIChatConfimationView__title','h4');
        $title.text(_this.title);

        $message = $this.create('UIChatConfimationView__message','p');
        $message.text(_this.message);
    }

    function initStyles() {
        CoreUIState.instance().uiBuilder.buildUIChatConfirmationView({
            $container: $this,
            $close,
            $title,
            $message
        })
        $this.multiTween = true;
        $this.css({ opacity:0}).transform({y:100});
        $this.tween({opacity:1,y:0},300,'easeOutCubic', 100)
    }
    
    //*** Event handlers
    function addListeners() {
        $close.interact(null,()=>{
            $this.tween({opacity:0, y: 100}, 300, 'easeOutCubic',()=>{
                _this.destroy();
            })
        })
    }
    //*** Public methods
});
Class(function UIChatConfirmationViewStyles() {
    Inherit(this, Component);

    this.buildUIChatConfirmationView = function (elements) {
        let { $container, $close, $title, $message } = elements;

        $container.css({
            position: 'absolute',
            display: 'grid',
            gridAutoRows: 'min-content',
            gridGap: '2rem',
            padding: '2rem',
            bottom: 0,
            width: '100%',
        });

        this.buildCloseButton($close, '1.5rem', '1.5rem');
        
        $close.css({
            position: 'relative',
            justifySelf: 'end',
        });

        $title.css(this.styleguide.h4);

        $message.css(this.styleguide.p1);
    };
}, 'static');

Class(function UIChatMessageView(_config) {
    Inherit(this, AbstractUIComponent);
    const _this = this;
    const $this = _this.element;

    _this.text = null; 
    _this.isCurrentUser = null;
    _this.type = null;
    _this.user = null;
    _this.showImage = true;

    var $image, $message, $name, $text;
    


    //*** Constructor
    (function () {
         _this.parseConfig(_config)
         initHTML();
         initStyles();
         addListeners();
    })();
    
    function initHTML() {
        if(_this.isCurrentUser) {
            $message = $this.create(`${_this.getPrefix('message')}`);
            $image = $this.create(`${_this.getPrefix('image')}`);
        }else{
            $image = $this.create(`${_this.getPrefix('image')}`);
            $message = $this.create(`${_this.getPrefix('message')}`);
        }

        $name = $message.create(`${_this.getPrefix('message__name')}`);
        $text = $message.create(`${_this.getPrefix('message__text')}`);

    }

    function initStyles() {
        $image.css({
            backgroundImage: `url(${_this.user.image}), url(${Assets.getPath('~assets/images/conference/placeholder.png')})`,
            backgroundRepeat:'no-repeat',
            backgroundSize:'cover',
            backgroundPosition:'center'
        })
        CoreUIState.instance().uiBuilder.buildUIChatMessageView({
            $container:$this,
            $message,
            $image,
            $name,
            $text
        },_this.isCurrentUser);
        
        $name.text(_this.user.displayName +":")
        $text.text(_this.text);

        if(!_this.showImage){
            $image.css({
                display:'none'
            })
        }

        if(_this.isCurrentUser){
            $message.css({
                background:AppStyleController.colors.primary[2]
            })
            $name.css({
                display:'none'
            })
            $text.css({
                color:AppStyleController.colors.tertiary[4],
            })
        }
    }
    

    //*** Event handlers
    function addListeners() {
        $image.interact(null,()=>{
            _this.events.fire(UIChatMessageView.CLICKED, {object: $this, user: _this.user})
        })
    }
    //*** Public methods
    
}, ()=>{
    UIChatMessageView.CLICKED = 'UIChatMessageView_clicked'
});
Class(function UIChatMessageViewStyles() {
    Inherit(this, Component);

    this.buildUIChatMessageView = function (elements, isCurrentUser = false) {
        let { $container, $message, $image, $name, $text } = elements;

        $container.css({
            position: 'relative',
            display: 'grid',
            gridTemplateColumns: isCurrentUser ? '1fr auto' : 'auto 1fr',
            gridGap: '3rem',
            padding: '1rem',
            borderRadius: '.5',
        });

        $message.css({
            display: 'grid',
            gridAutoFlow: 'column',
            gridAutoColumns: 'min-content',
            gridGap: '.5rem',
            position: 'relative',
        });

        this.buildCircleAvatar($image);

        $name.css(this.styleguide.label1);
        $name.medium();
        $text.css(this.styleguide.label2);

        if (isCurrentUser) {
            $image.css({
                display: 'none',
                width: '0',
                height: '0',
            });
            $container.css({
                background: this.colors.monochrome[0],
                color: 'white',
                gridTemplateColumns: '1fr',
            });
        }
    };
}, 'static');

Class(function UIChatParticipantView(_config) {
    Inherit(this, AbstractUIComponent);
    const _this = this;
    const $this = _this.element;

    _this.image = "";

    var $image;
    
    //*** Constructor
    (function () {
         _this.parseConfig(_config);
         initHTML();
         initStyles();
    })();
    

    function initHTML() {
        $image = $this.create(`${_this.getPrefix('image')}`);
    }

    function initStyles() {
        CoreUIState.instance().uiBuilder.buildUIChatParticipantView({
            $container:$this,
            $image,
        })
        $image.css({
            backgroundImage:`url(${_this.image})`
        });
    }

    //*** Event handlers
    
    //*** Public methods
    
});
Class(function UIChatParticipantViewStyles() {
    Inherit(this, Component);

    this.buildUIChatParticipantView = function (elements) {
        let { $container, $image } = elements;
        $container.css({
            position: 'relative',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
        });

        this.buildCircleAvatar($image);
    };
}, 'static');

Class(function UIChatView(_config) {
    Inherit(this, AbstractUIComponent);
    const _this = this;
    const $this = _this.element;

    var $header,$headerTitle,$participants,$body, $bodyWrapper, $footer, $footerMain, $footerImage, $footerActions, $footerSubmit, $input, $footerOptions, $soundToggle, $settings, $settingsWrap, $settingsContent, $typingMessage;

    _this.type = "conversation";
    _this.showHeader = true;
    _this.id;
    _this._id;
    _this.showQA;
    _this.showTyping;

    var _participants = {};
    var _chatRoom, _currUser;
    var _settingsView;
    var _messages = [];
    var _storedMessages = [];
    var _culledItems = [];

    const REPOP_AMOUNT = 10;
    const MESSAGE_LIMIT = 50;
    var _intersectionObserver, _topTarget, _bottomTarget;

    //*** Constructor
    (async function () {
        await User.ready();

        _this.parseConfig(_config);
        initHTML();
        createChatIntro();
        createChat();
        initStyles();
        addListeners();
    })();

    function initHTML() {
        $header = $this.create(`${_this.getPrefix('header')}`);
        $headerTitle = $header.create(`${_this.getPrefix('header__title')}`);
        $participants = $header.create(`${_this.getPrefix('header__participants')}`);
        $body = $this.create(`${_this.getPrefix('body')}`);
        $bodyWrapper = $body.create(`${_this.getPrefix('body__wrapper')}`);

        $typingMessage = $this.create(_this.getPrefix('typing'),'p');
        $footer = $this.create(`${_this.getPrefix('footer')}`);

        $footerMain = $footer.create(_this.getPrefix('main'),'form');
        $footerMain.attr('action',null);
        $footerMain.bind('submit',submit);

        $footerImage = $footerMain.create(`${_this.getPrefix('footer__image')}`);
        $input = $footerMain.create(`${_this.getPrefix('footer__input')}`,'input');
        $input.attr('placeholder', 'Start typing');
        $input.attr('maxlength',240);

        $footerActions = $footerMain.create(`${_this.getPrefix('footer__actions')}`);
        $footerSubmit = $footerActions.create(`${_this.getPrefix('footer__submit')}`,'button');
        $footerSubmit.attr('role', 'button');
        $footerSubmit.attr('alt','submit')
        $footerSubmit.interact(handleHover, submit);


        //If conversation aka 1-on-1, we do a pseudo infinite scroll in which there are never more items than the max set above
        //We also show options for sound toggling
        if(_this.type == 'conversation'){
            _this.flag('shouldStorePastMessage',true);
            _intersectionObserver = new IntersectionObserver(onIntersect, {root: $body.div});

            $footerOptions = $footer.create(_this.getPrefix('option'));
            $soundToggle = $footerOptions.create(_this.getPrefix('option__button'));
            $soundToggle.attr('alt','sound toggle')
            $soundToggle.attr('role','button');

            $settingsWrap = $footerOptions.create(_this.getPrefix('option__button'));
            $settingsWrap.css({
                position:'relative'
            })
            $settings = $settingsWrap.create(_this.getPrefix('option__button'));
            $settings.attr('alt','settings')
            $settings.attr('role','button');

            $settingsContent = $settingsWrap.create(_this.getPrefix('option__button__content'));
            $settingsContent.css({
                left:'50%',
                bottom:0,
                height:'fit-content',
                transform:'translateX(-50%)',
                display:'none',
                boxShadow: '0px 4px 20px rgba(0,0,0,0.3)',
                opacity:0
            })
        }

    }

    function handleHover(e) {
        switch (e.action) {
            case 'over': e.object.tween({ opacity: 0.5 }, 400, 'easeOutCubic');
            case 'out': e.object.tween({ opacity: 1 }, 400, 'easeOutCubic');
        }
    }

    function submit(e) {
        if(e){
            e.preventDefault();
        }

        let value = $input.div.value

        if(!value || value.length < 1) return;
        var stripRegex = new RegExp('\/question');
        //If the option for QA is set, we send the question and show confirmation
        if( value.indexOf("/question") == 0 && _this.showQA) {
            //question
            let question = value.replace(stripRegex,'');
            _chatRoom.question(question);
            _this.initClass(UIChatConfirmationView, {title:'Thank you', message:'Your question is successfully submitted'})
        }else{
            _chatRoom.send(value);
        }

        $input.div.value = ""
        return false;

    }

    async function initStyles() {
        $footerImage.css({
            backgroundImage: `url(${_currUser.image}), url(${Assets.getPath('~assets/images/conference/placeholder.png')})`,
            backgroundRepeat:'no-repeat',
            backgroundSize:'cover',
            backgroundPosition:'center'
        })
        CoreUIState.instance().uiBuilder.buildUIChatView({
            $container:$this,
            $header,
            $headerTitle,
            $participants,
            $body,
            $bodyWrapper,
            $typingMessage,
            $footer,
            $footerMain,
            $footerImage,
            $footerActions,
            $footerInput:$input,
            $footerOptions,
            $footerSubmit,
            $soundToggle,
            $settings
        }, _this.type)

        if(!_this.showHeader || _this.type == 'video' || _this.type == 'live'){
            $header.css({
                display:'none'
            })
        }

        //On Chrome we can preemptively check permissions. Chrome. Only Chrome.
        if (window.navigator && window.navigator.permissions && Device.system.browser !== 'firefox') {
            window.navigator.permissions.query({name: 'microphone'}).then(e=>{
                //Check if audio permissions have been granted
                if(e.state == 'granted'){
                    _this.flag('audioPermissionGranted',true);
                }else{
                    //Disable the UI until the permission has been grant
                    $settings.css({
                        opacity:.5,
                        cursor:'disabled'
                    })
                    e.onchange = (event) =>{
                        if(e.state == 'granted'){
                            _this.flag('audioPermissionGranted',true);
                            $settings.css({
                                opacity:1,
                                cursor:'pointer'
                            })
                       }
                    }
                }
            })
        }
    }

    async function createMessage(message) {
        const isCurrentUser = _currUser.uid == message.uid;
        let user = null;
        if(!_participants[message.uid]){
            user = await User.getUser(message.uid);
            _participants[message.uid] = user;
        }else{
            user = _participants[message.uid];
        }
        if (user.banned && User.uid !== user.uid) return console.log('banned!'); // skip message if user is banned

        //Start removing messages from the DOM when the list surpasses the limit
        if(_messages.length >= MESSAGE_LIMIT) {
            let removedItem = _messages.shift();

            //If flag is enabled, start logic of doing pseudo infinite scroll
            if(_this.flag('shouldStorePastMessage')){
                if(_storedMessages.length == 0) {
                    _topTarget = _messages[0].div;
                    _intersectionObserver.observe(_topTarget);
                }else{
                    _intersectionObserver.unobserve(_topTarget);
                    _topTarget = _messages[0].div;
                    _intersectionObserver.observe(_topTarget);
                }
                $bodyWrapper.div.removeChild(removedItem.div);
                _storedMessages.unshift(removedItem);
            }
        }


        let newMessage = _this.initClass(UIChatMessageView,{
            text:message.message,
            isCurrentUser,
            type:_this.type,
            user,
            showImage:true
        },[$bodyWrapper])
        newMessage.element.css({
            justifySelf: isCurrentUser ? 'end' : 'start'
        })
        _messages.push(newMessage.element);

        //Scroll to bottom
        _this.delayedCall(()=>{
            $body.div.scrollTop = $body.div.scrollHeight;
        },100)
    }

    function createChat() {
        //Ideally use just id. Work around to support existing case
        _chatRoom = _this.initClass(ChatRoom, _this.id || _this._id, _this.type);
        _currUser = User.profile;
    }

    function createChatIntro() {
        let $intro = $body.create(`${_this.getPrefix('intro')}`);
        CoreUIState.instance().uiBuilder.buildUIChatIntro($intro);
    }


    //*** Event handlers
    function addListeners() {
        _this.events.sub(_chatRoom, ChatRoom.MESSAGES_INIT, onMessagesReady)
        _this.events.sub(_chatRoom, ChatRoom.MESSAGE_ADD, onMessage);
        if(_this.showTyping){
            _this.events.sub(Keyboard.DOWN,onKeyDown);
            _this.events.sub(_chatRoom, ChatRoom.TYPING_UPDATE, onTyping);
        }
        _this.events.sub(UIChatView.SOUND_CANCELED, handleAudioDisable);
        if($settings){
            $settings.interact(handleHover,async ()=>{
                //Block access if permissions haven't been granted
                if(window.navigator && window.navigator.permissions && Device.system.browser !== 'firefox') {
                    if(_this.flag('audioPermissionGranted')) {
                        $settingsContent.css({display:'block', width: '40rem', transform:'translateX(-50%)'})
                        if(_settingsView){
                            _settingsView.destroy();
                        }
                        _settingsView = _this.initClass(UIAudioInput,{parent:_this},[$settingsContent]);
                        $settingsContent.tween({opacity:1 , x:'-50%'},300,'easeOutCubic')
                    }
                }else{
                    //Safari scenario - just ask for permission here since we can't query
                    await window.navigator.mediaDevices.getUserMedia({
                        audio:true
                    });
                    $settingsContent.css({display:'block', width: '40rem', transform:'translateX(-50%)'})
                    if(_settingsView){
                        _settingsView.destroy();
                    }
                    _settingsView = _this.initClass(UIAudioInput,{parent:_this},[$settingsContent]);
                    $settingsContent.tween({opacity:1 , x:'-50%'},300,'easeOutCubic')
                }
            })
        }
        //Enable user stream when toggled
        if($soundToggle){
            $soundToggle.interact(handleHover, ()=>{
                _this.flag('soundEnabled', !_this.flag('soundEnabled'))
                AVSettingsController.instance().audioEnabled = _this.flag('soundEnabled');
                if (_this.flag('soundEnabled')) handleAudioEnable();
                else handleAudioDisable();
            })
        }
        $input.bind("focusin",handleFocus);
        $input.bind("focusout",handleFocusLoss);
        $input.bind('input', handleInput);
        $footerSubmit.interact(handleHover,submit,'#','Send message');
    }

    function onKeyDown(e) {
        if(e.code != 'Enter'){
            _chatRoom.typing();
        }
    }

    function handleAudioEnable() {
        _this.events.fire(UIChatView.SOUND_ENABLED);

        if (PlayerModel.get('audio')) {
            GameCenterMedia.userStream.enableAudio();
        }

        $soundToggle.css({
            background: AppStyleController.colors.primary[0],
            "-webkit-mask-image":`url(${Assets.getPath('~assets/images/icon/mic-on.svg')})`,
            maskImage:`url(${Assets.getPath('~assets/images/icon/mic-on.svg')})`,
        });
    }

    function handleAudioDisable() {
        _this.events.fire(UIChatView.SOUND_DISABLED);

        if (PlayerModel.get('audio')) {
            GameCenterMedia.userStream.disableAudio();
        }

        $soundToggle.css({
            background: AppStyleController.colors.primary[0],
            "-webkit-mask-image":`url(${Assets.getPath('~assets/images/icon/mic-off.svg')})`,
            maskImage:`url(${Assets.getPath('~assets/images/icon/mic-off.svg')})`,
        });
    }

    function handleHover(e) {
        switch (e.action) {
            case 'over': e.object.tween({ opacity: 0.5 }, 400, 'easeOutCubic'); break;
            case 'out': e.object.tween({ opacity: 1 }, 400, 'easeOutCubic'); break;
        }
    }

    function handleInput() {
    }

    function handleFocus(e) {
        _this.events.fire(PlayerControls.ENABLE_STATE_CHANGE,{enabled:false})
    }

    function handleFocusLoss(e) {
        _this.events.fire(PlayerControls.ENABLE_STATE_CHANGE,{enabled:true})
    }

    async function onMessagesReady(e) {
        for (const message of e) {
            await onMessage(message);
        }
    }

    async function onMessage(e) {
        await createMessage(e);
    }

    async function onTyping(e) {
        if(e && e.users) {
            e.users = e.users.filter((user)=>{
                return user != _currUser.displayName
            });

            if(e.users.length > 0){
                $typingMessage.text(e.users[0]+' is typing...')
            }else{
                $typingMessage.text('')
            }
        }
    }


    function onIntersect(e) {
        e.forEach(entry => {
            if (entry.isIntersecting) {
                if(entry.target == _topTarget) {
                    let itemsToPrepend = [];
                    //Iterate through stored messages and grab either the whole thing or the repopulation amount
                    if(_storedMessages.length < REPOP_AMOUNT) {
                        itemsToPrepend = _storedMessages.splice(0, _storedMessages.length)
                    }else{
                        itemsToPrepend = _storedMessages.splice(0, REPOP_AMOUNT);
                    }

                    //For each item, prepend to top of the list
                    itemsToPrepend.forEach((item,index)=>{
                        if(item) {
                            $bodyWrapper.div.prepend(item.div)
                            _messages.unshift(item);
                            //Cull from bottom to keep the length the same
                            let removedItem = _messages.pop();
                            _culledItems.unshift(removedItem)
                            $bodyWrapper.div.removeChild(removedItem.div);

                            //If it's the last iteration set a new top target and a new bottom target
                            if(index == itemsToPrepend.length -1 ) {
                                _intersectionObserver.unobserve(_topTarget);
                                _topTarget = item.div;
                                _intersectionObserver.observe(_topTarget);

                                //Set a new bottom target
                                if(_bottomTarget) {
                                    _intersectionObserver.unobserve(_bottomTarget);
                                }
                                _bottomTarget = _messages[_messages.length-1].div;
                                _intersectionObserver.observe(_bottomTarget);
                            }
                        }
                    })
                //Same as above but the opposite direction
                }else if(entry.target == _bottomTarget) {
                    let itemsToAppend = [];
                    if(_culledItems.length < REPOP_AMOUNT) {
                        itemsToAppend = _culledItems.splice(0, _culledItems.length);
                    }else{
                        itemsToAppend = _culledItems.splice(0, REPOP_AMOUNT);
                    }
                    itemsToAppend.forEach((item,index)=>{
                        if(item) {
                            $bodyWrapper.div.append(item.div)
                            _messages.push(item);

                            let removedItem = _messages.shift();
                            _storedMessages.unshift(removedItem)
                            $bodyWrapper.div.removeChild(removedItem.div);

                            if(index == itemsToAppend.length -1 ) {
                                _intersectionObserver.unobserve(_bottomTarget);
                                _bottomTarget = item.div;
                                _intersectionObserver.observe(_bottomTarget);

                                _intersectionObserver.unobserve(_topTarget);
                                _topTarget = _messages[0].div;
                                _intersectionObserver.observe(_topTarget);
                            }
                        }
                    })
                }

            }
        });
    }

    //*** Public methods
    this.closeSettings = function () {
        $settingsContent.tween({opacity:0, x:'-50%'},300,'easeOutCubic', ()=>{
            $settingsContent.css({display:'none'})
        })
    }

    this.onDestroy = function () {
        if(_chatRoom && _chatRoom.destroy) {
            _chatRoom.destroy()
        }
    }
}, _ => {
    UIChatView.SOUND_ENABLED = 'UIChatView_soundenabled';
    UIChatView.SOUND_DISABLED = 'UIChatView_sounddisabled';
    UIChatView.SOUND_CANCELED = 'UIChatView_soundcanceled';
});
Class(function UIChatViewStyles() {
    Inherit(this, Component);

    this.buildUIChatView = function (elements, type = 'stream') {
        let {
            $container,
            $header,
            $headerTitle,
            $participants,
            $body,
            $bodyWrapper,
            $typingMessage,
            $footer,
            $footerMain,
            $footerActions,
            $footerInput,
            $footerImage,
            $footerSubmit,
            $footerOptions,
            $soundToggle,
            $settings,
            $settingsWrap,
        } = elements;

        $container.css({
            position: 'relative',
            display: 'grid',
            gridTemplateRows: '1fr auto',
        });

        $header.css({
            position: 'relative',
            display: 'grid',
            gridAutoFlow: 'column',
            gridAutoColumns: 'min-content',
            background: this.colors.primary[0],
            padding: '2rem',
            gridGap: '4rem',
            alignItems: 'center',
        });

        $headerTitle.css(this.styleguide.h5);
        $headerTitle.css({ color: 'white' });
        $headerTitle.text('Chat');

        $participants.css({
            position: 'relative',
            display: 'grid',
            gridAutoFlow: 'column',
            gridAutoColumns: 'min-content',
            gridGap: '1rem',
        });

        $body.css({
            position: 'relative',
            minHeight: '25vh',
            overflowY: 'scroll',
            background: 'white',
        });

        $bodyWrapper.css({
            width: '100%',
            display: 'grid',
            gridAutoRows: 'min-content',
            padding: '1rem',
        });

        $typingMessage.css(this.styleguide.label1);
        $typingMessage.css({ color: this.colors.monochrome[4], position: 'relative', padding: '1rem 0rem 1rem 2rem', background: 'white' });

        if (type == 'conversation') {
            $footer.css({
                display: 'grid',
                position: 'relative',
                gridTemplateColumns: '1fr auto',
                background: this.colors.monochrome[0],
                gridGap: '1rem',
                padding: '2rem',
            });

            $footerMain.css({
                borderRadius: '0.3rem',
                background: 'white',
                position: 'relative',
                display: 'grid',
                gridTemplateColumns: 'auto 1fr auto',
                gridGap: '1rem',
                alignItems: 'center',
                padding: '0.5rem 1rem',
            });

            $footerOptions.css({
                borderRadius: '0.3rem',
                position: 'relative',
                background: 'white',
                padding: '1rem 1rem',
                alignItems: 'center',
                display: 'grid',
                position: 'relative',
                gridAutoFlow: 'column',
                gridAutoColumns: 'min-content',
                gridGap: '1rem',
            });

            this.buildMaskIcon($soundToggle, '~assets/images/icon/mic-off.svg', '2rem', '2rem', this.colors.primary[0]);
            $soundToggle.css({
                cursor: 'pointer',
            });

            this.buildMaskIcon($settings, '~assets/images/icon/setting.svg', '2rem', '2rem', this.colors.primary[0]);
            $settings.css({
                cursor: 'pointer',
            });
        } else {
            $footer.css({
                position: 'relative',
                padding: '2rem',
                background: this.colors.monochrome[0],
            });

            $footerMain.css({
                borderRadius: '0.3rem',
                width: '100%',
                background: 'white',
                position: 'relative',
                display: 'grid',
                gridTemplateColumns: 'auto 1fr auto',
                gridGap: '1rem',
                alignItems: 'center',
                padding: '1rem',
            });
        }

        this.buildCircleAvatar($footerImage);
        $footerImage.css({
            width: '4rem',
            height: '4rem',
        });

        $footerInput.css({
            ...this.styleguide.label4,
            width: '100%',
            height: '100%',
            position: 'relative',
            outline: 'none',
            border: 'none',
        });

        $footerActions.css({
            position: 'relative',
            display: 'grid',
            gridAutoFlow: 'column',
            gridAutoColumns: 'min-content',
            alignItems: 'center',
            gridGap: '1rem',
        });

        this.buildMaskIcon($footerSubmit, '~assets/images/conference/icons/chat-send.svg', '3rem', '3rem', this.colors.primary[0]);

        $footerSubmit.css({
            background: 'none',
            border: 'none',
            outline: 'none',
        });
    };

    this.buildUIChatIntro = function (element) {
        element.css(this.styleguide.label2);
        element.css({ textAlign: 'center' });
    };
}, 'static');

/**
 * Possible _config values:
 *
 *      - type
 *      @type {string}
 *      delegating a unique type allows for specific styles to be applied to that type
 *
 *      - revealAnimationCb
 *      @type {function}
 *      @param $background: element
 *      @param $checkmark: element
 *          callback to handle showing checkmark
 *
 *      - hideAnimationCb: {Function}
 *      same as revealAnimationCb, but to hide
 */
Class(function UICheckboxView(_config) {
    Inherit(this, AbstractUIComponent);
    var $checkboxContainer, $label, $input, $background, $checkmark;

    const _this = this;
    const $this = _this.element;

    _this.value = false;
    _this.type = 'default';

    //*** Constructor
    (function () {
        _this.parseConfig(_config);
        initHTML();
        addListeners();
        initStyle();
    })();

    function initHTML() {
        $checkboxContainer = $this.create(`${_this.getPrefix('checkbox-container')}`);
        $input = $checkboxContainer.create(`${_this.getPrefix('checkbox-input')}`, 'input');
        $input.attr('type', 'checkbox');
        if (_this.name) {
            $input.attr('name', _this.name);
        }
        $background = $checkboxContainer.create(`${_this.getPrefix('checkbox-container__background')}`);
        $checkmark = $checkboxContainer.create(`${_this.getPrefix('checkbox-container__icon')}`);
        $label = $this.create(`${_this.getPrefix('label')}`);
        $label.text(_this.label);
    }

    function initStyle() {
        CoreUIState.instance().uiBuilder.buildUICheckboxView({
            $container: $this,
            $input,
            $checkboxContainer,
            $label,
            $background,
            $checkmark,
        }, {
            type: _this.type
        });
    }

    //*** Event handlers
    function addListeners() {
        $this.interact(null, toggleState, _this.seoLink ? _this.seoLink : null, '');
    }

    function toggleState() {
        _this.value = !_this.value;
        _this.events.fire(UICheckboxView.CLICK, _this);

        if (_this.value) {
            reveal();
        } else {
            hide();
        }
    }

    function reveal() {
        if (_this.revealAnimationCb) {
            _this.revealAnimationCb({$checkboxContainer, $background, $checkmark});
            return;
        }

        $background.tween({ opacity: 1, background: _this.backgroundColor || AppStyleController.colors.primary[0] }, 200, 'easeOutCubic');
        $checkmark.tween({ opacity: 1 }, 200, 'easeOutCubic', 100);
    }

    function hide() {
        if (_this.hideAnimationCb) {
            _this.hideAnimationCb({$checkboxContainer, $background, $checkmark});
            return;
        }
        $background.tween({ opacity: 0, background: _this.backgroundColor || AppStyleController.colors.primary[0] }, 200, 'easeOutCubic');
        $checkmark.tween({ opacity: 0 }, 300, 'easeOutCubic');
    }

    //*** Public methods
    this.clickHandler = toggleState;

    this.hide = function() {
        hide();
        _this.value = false; 
    }
    
    this.reveal = function() {
        reveal();
        _this.value = true;
    }

}, (_) => {
    UICheckboxView.CLICK = 'uicv_click';
});

Class(function UICheckboxViewStyles() {
    Inherit(this, Component);

    this.buildUICheckboxView = function (elements, { type }) {
        const { $container, $checkboxContainer, $input, $label, $background, $checkmark } = elements;
        $container.css({
            position: 'relative',
            display: 'grid',
            gridAutoFlow: 'column',
            height: 'fit-content',
            gridAutoColumns: 'min-content',
            gridGap: `1rem`,
            alignItems: 'center',
        });
        $checkboxContainer.css({
            display: 'flex',
            height: '2.5rem',
            width: '2.5rem',
            position: 'relative',
            border: `1px solid ${this.colors.monochrome[2]}`,
            cursor: 'pointer',
            borderRadius: '.3rem',
        });
        $background.css({
            width: '100%',
            height: '100%',
            top: 0,
            left: 0,
            opacity: 0,
        });
        $input.css({
            border: 0,
            clip: 'rect(0 0 0 0)',
            height: '1px',
            margin: '-1px',
            overflow: 'hidden',
            padding: '0',
            position: 'absolute',
            width: '1px',
            outline: '0',
            '-webkit-appearance': 'none',
        });
        this.buildMaskIcon($checkmark, '~assets/images/icon/chevron-down.svg', '2rem', '2rem', 'white');

        $label.css({
            position: 'relative',
            color: this.colors.monochrome[6],
        });
        $label.css(this.styleguide.label4);
    };
}, 'static');

Class(function UICheckboxGroup(_config) {
    Inherit(this, AbstractUIComponent);
    const _this = this;
    const $this = _this.element;
    var options = [];
    _this.activeValue = null;
    //*** Constructor
    (function () {
        _this.parseConfig(_config);
        initHTML();
        initStyles();
    })();

    function initHTML() {
        for (let option of _this.options) {
            let $newOption = _this.initClass(UICheckboxView, {
                label: option.label,
                backgroundColor: _this.backgroundColor,
            })
            options.push($newOption)
            if (_this.currentAnswer !== undefined && _this.currentAnswer === option.value) {
                _this.activeValue = option.value;
                $newOption.reveal()
            }
            _this.events.sub($newOption, UICheckboxView.CLICK, handleCheckboxClick)
        }
    }

    function initStyles() {
        CoreUIState.instance().uiBuilder.buildUICheckboxGroup({
            $container: $this,
        })
    }

    //*** Event handlers

    function handleCheckboxClick(activeOption) {
        _this.events.fire(UICheckboxGroup.CLICK)
        const nonActiveOptions = options.filter(option => option.label !== activeOption.label);
        nonActiveOptions.forEach(option => option.hide());
        activeOption.reveal();
        let selected = _this.options.find(option => option.label === activeOption.label);
        _this.activeValue = selected.value;
    }
}, (_) => {
    UICheckboxGroup.CLICK = 'uicg_click';
});
Class(function UICheckboxGroupStyles() {
    Inherit(this, Component);

    this.buildUICheckboxGroup = function (elements) {
        const {$container} = elements

        $container.css({
            position: 'relative',
            display: 'grid',
            gridRowGap: '1rem'
        })
    };
}, 'static');

Class(function UIDropdown(_config) {
    Inherit(this, AbstractUIComponent);

    const _this = this;
    const $this = _this.element;

    _this.label = '';
    _this.options = [];

    var $header, $headerTitle, $headerIcon;
    var $dropdown, $dropdownList;

    //*** Constructor
    (function () {
        _this.parseConfig(_config);

        initHeader();
        initDropdown();

        CoreUIState.instance().uiBuilder.buildUIDropdown({
            $container: $this,
            $header,
            $headerTitle,
            $headerIcon,
            $dropdown,
        });
    })();

    function initHeader() {
        $header = $this.create(_this.getPrefix('header'), 'button');
        $header.interact(handleHeaderHover, handleHeaderClick);

        $headerTitle = $header.create(_this.getPrefix('header__title'));
        $headerTitle.text(_this.label);

        $headerIcon = _this.initClass(Sprite, 'chevron-bottom', [$header]);
    }

    function initDropdown() {
        $dropdown = $this.create(_this.getPrefix('dropdown'));

        $dropdownList = _this.options.map((option) => {
            let $option = $dropdown.create(_this.getPrefix('dropdown__item'), 'button');

            $option.interact(handleOptionHover, handleOptionClick);

            $option.text = $option.create(_this.getPrefix('dropdown__text'));
            $option.text.text(option.title);

            $option.background = $option.create(_this.getPrefix('dropdown__background'));

            if (option.active) {
                handleOptionHover({ action: 'over', object: $option });
            }

            $option.active = option.active;
            $option.value = option.perma;

            CoreUIState.instance().uiBuilder.buildUIDropdownOption({
                $option,
                $background: $option.background,
                $text: $option.text,
            }, {
                isActive: option.active,
            });

            return $option;
        });
    }

    //*** Event handlers
    function handleHeaderHover(event) {
        CoreUIState.instance().uiBuilder.buildUIDropdownHeaderHover(event);
    }

    function handleHeaderClick(e) {
        if (_this.flag('isOpened')) {
            _this.close();
        } else {
            _this.open();
        }
    }

    function handleOptionHover(event) {
        CoreUIState.instance().uiBuilder.buildUIDropdownOptionHover(event);
    }

    function handleOptionClick(e) {
        if (e.object.active) return;
        
        $dropdownList.forEach(option => {
            if (option === e.object) {
                option.active = true;
            } else {
                option.active = false;
            }
        });
        
        $dropdownList.forEach(object => {
            CoreUIState.instance().uiBuilder.buildUIDropdownOptionState({ object });
        });

        _this.events.fire(UIDropdown.CLICK, { value: e.object.value });

        _this.close();
    }

    //*** Public methods
    _this.open = function () {
        _this.flag('isOpened', true);

        CoreUIState.instance().uiBuilder.buildUIDropdownOpen({
            $container: $this,
            $header,
            $headerTitle,
            $headerIcon,
            $dropdown,
        });
    };

    _this.close = function () {
        _this.flag('isOpened', false);

        CoreUIState.instance().uiBuilder.buildUIDropdownClose({
            $container: $this,
            $header,
            $headerTitle,
            $headerIcon,
            $dropdown,
        });
    };
}, _ => {
    UIDropdown.CLICK = 'UIDropdown.CLICK';
});

Class(function UIDropdownStyles() {
    Inherit(this, Component);

    this.buildUIDropdown = function ({ $container, $header, $headerTitle, $headerIcon, $dropdown }) {
        $container.css({
            position: 'relative',
            zIndex: 10,
        });

        $header.css({
            alignItems: 'center',
            background: 'none',
            border: 'none',
            display: 'flex',
            height: '3.6rem',
            outline: 'none',
            padding: '0 1.8rem',
            position: 'relative',
            '-webkit-appearance': 'none',
            zIndex: 1,
        });

        $headerTitle.css({
            ...this.styleguide.label4,
            position: 'relative',
            textTransform: 'uppercase',
        });

        $headerTitle.bold();

        $headerIcon.element.css({
            height: '2.4rem',
            marginLeft: '0.5rem',
            position: 'relative',
            width: '2.4rem',
        });

        $dropdown.css({
            background: '#fff',
            borderRadius: '0.8rem',
            boxShadow: '0 0.2rem 0.9rem rgba(0, 0, 0, 0.15)',
            overflow: 'hidden',
            paddingTop: '3.6rem',
            left: 0,
            opacity: 0,
            top: 0,
            visibility: 'hidden',
        });
    };

    this.buildUIDropdownOption = function ({ $option, $background, $text }, { isActive }) {
        $option.css({
            ...this.styleguide.label3,
            background: 'none',
            border: 'none',
            color: this.colors.secondary[0],
            height: '3.6rem',
            outline: 'none',
            padding: '0 1.8rem',
            position: 'relative',
            textAlign: 'left',
            whiteSpace: 'nowrap',
            width: '100%',
            '-webkit-appearance': 'none',
        });

        $background.size('100%');

        $background.css({
            background: this.colors.monochrome[1],
            left: 0,
            opacity: 0,
            top: 0,
        });

        $text.css({
            position: 'relative',
            zIndex: 1,
        });
    };
    
    this.buildUIDropdownHeaderHover = function ({ action, object }) {
        switch (action) {
            case 'over':
                object.tween({ opacity: 0.5 }, 400, 'easeOutCubic');
                break;
            case 'out':
                object.tween({ opacity: 1 }, 400, 'easeOutCubic');
                break;
        }
    };

    this.buildUIDropdownOptionHover = function ({ action, object }) {
        if (object.active) return;

        switch (action) {
            case 'over':
                object.background.tween({ opacity: 1 }, 400, 'easeOutCubic');
                break;
            case 'out':
                object.background.tween({ opacity: 0 }, 400, 'easeOutCubic');
                break;
        }
    };

    this.buildUIDropdownOptionState = function ({ object }) {
        object.background.tween({ opacity: object.active ? 1 : 0 }, 400, 'easeOutCubic');
    };

    this.buildUIDropdownOpen = function ({ $dropdown, $headerIcon }) {
        $dropdown.visible();
        $dropdown.tween({ opacity: 1 }, 400, 'easeOutCubic');

        $headerIcon.element.tween({ rotation: -180 }, 400, 'easeOutCubic');
    };

    this.buildUIDropdownClose = function ({ $dropdown, $headerIcon }) {
        $dropdown.tween({ opacity: 0 }, 400, 'easeOutCubic', _ => {
            $dropdown.invisible();
        });

        $headerIcon.element.tween({ rotation: 0 }, 400, 'easeOutCubic');
    };
}, 'static');
Class(function UIForm() {
    Inherit(this, Component);
    const _this = this;

    _this.controls = [];
    _this.errors = [];
    _this.valid = false;
    //*** Constructor
    (function () {
    
    })();
    
    //*** Event handlers
    
    //*** Public methods
    this.validate = function () {
        _this.valid = !_this.controls.some((control)=>{
            let valid = control.isValid;
            if(!el.isValid) {
                _this.errors.push(el);
            }
            return !valid;
        });
    }

    this.addControl = function (control) {
        _this.controls.push(control);
    }
});
Class(function UIFormControl() {
    Inherit(this, Element);
    const _this = this;
    const $this = _this.element;
    
    _this.value = null; 
    _this.validator = null;
    _this.disabled = false; 
    _this.label = ""; 
    _this.required = false; 
    _this.controlName = '';

    //*** Constructor
    (function () {

    })();
    
    
    //*** Event handlers
    
    //*** Public methods
    
},()=>{
    UIFormControl.VALUE_CHANGE = "formcontrol_value_change";
});
Class(function UIInputView(_config) {
    Inherit(this, AbstractUIComponent);
    Inherit(this, UIFormControl);

    var $input, $focusBar, $label, $prefixWrapper, $prefixTitle;
    const _this = this;
    const $this = _this.element;

    _this.maxLength;
    _this.type;
    _this.inputType = 'open';
    _this.isTextArea;
    _this.activeColor;
    _this.required;
    _this.customCallback;

    var _floatingPos, _basePos;
    //*** Constructor
    (function () {
        _this.parseConfig(_config);
        initHTML();
        addListeners();
        initStyle();
    })();

    function initHTML() {
        $this.css({
            position: 'relative',
            height: 'fit-content',
        });
        if (!_this.isTextArea) {
            $input = $this.create(_this.getPrefix('input'), 'input');
            _floatingPos = '5%';
            _basePos = '50%';
        } else {
            $input = $this.create(_this.getPrefix('input'), 'textarea');
            _floatingPos = '0%';
            _basePos = '10%';
        }

        if (_this.type === 'password') $input.attr('type', 'password');
        if (_this.type === 'email') $input.attr('type', 'email');
        if (_this.type === 'file') $input.attr('type', 'file');

        if (_this.prefix) {
            initPrefix()
        }

        $input.attr('tabindex', '0');


        $focusBar = $this.create(_this.getPrefix('focus-bar'), 'span');
        $label = $this.create(_this.getPrefix('label'), 'label');
        $label.text(_this.label);

        if(_this.label) {
            let stripped = _this.label.replace(' ','');

            $input.attr('name', stripped);
            $input.attr('aria-labeledby', stripped + '_label');
            $label.attr('for', stripped);
            $label.attr('id', stripped + '_label');
        }

        if (_this.required) {
            $label.inner = $label.create('required', 'span');
            $label.inner.text(' *');
            $label.inner.css({ color: Colors.off });

            $input.attr('required', true);
        }
        if (_this.disabled) {
            $input.attr('disabled', true);
        }

        if (_this.maxLength) {
            $input.attr('maxlength', _this.maxLength);
        }

        if (_this.prefix) {
            $label.css({
                top: _this.preventFloating ? _basePos : _floatingPos,
            })
        }

        if (_this.placeholderInput) {
            $input.attr('placeholder', _this.placeholderInput)
            $label.css({
                top: _this.preventFloating ? _basePos : _floatingPos,
            })
        }
    }

    function initPrefix() {
        $prefixWrapper = $this.create(_this.getPrefix('prefix-wrapper'))
        $prefixWrapper.css({
            position: 'absolute',
            left: '0%',
            transform: 'translateY(-100%)',
            height: '100%',
            width: 'fit-content',
            padding: 16,
            background: "#EEEEEE",
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center'
        })

        $prefixTitle = $prefixWrapper.create(_this.getPrefix('prefix-title'), 'label')
        $prefixTitle.css({
            ...InboundStyleguide.label3,
            color: "#0D152B"
        })
        $prefixTitle.text(_this.prefixInput)
        setInputMargin()
    }

    async function setInputMargin() {
        await _this.wait(500)
        const paddingAmt = $prefixWrapper.div.getBoundingClientRect().width + 5
        $input.css({
            paddingLeft: paddingAmt
        })
    }

    function addListeners() {
        $input.bind('focusin', handleFocus);
        $input.bind('focusout', handleFocusLoss);
        $input.bind('change', handleValueChange);
        $input.bind('input', handleValueChange);
    }

    function initStyle() {
        CoreUIState.instance().uiBuilder.buildUIInputView(
            {
                $container: $this,
                $input,
                $focusBar,
                $label,
            },
            _this.inputType,
            _basePos,
            _floatingPos,
            _this.prefix,
            _this.placeholderInput,
            _this.isTextArea,
            _this.noBorder
        );

        if (_this.value) {
            $input.div.value = _this.value;
            handlePrepopulatedValue();
        
            if (_this.inputType === 'fill' || _this.inputType === 'border') {
                $label.css({
                    color: '#0D152B'
                })
            }
        }
        if (!_this.label) {
            $label.css({
                display: 'none',
            });
        }
        if (_this.disabled) {
            $this.css({opacity: 0.5})
        }
    }

    function handleValueChange(e) {
        if (_this.customCallback) {
            _this.customCallback()
        }
        _this.value = $input.div.value;
        _this.events.fire(UIFormControl.VALUE_CHANGE, { value: _this.value, name: _this.inputElement.attr('name') });
        if (_this.value) {
            handlePrepopulatedValue();
        }
    }

    function handleFocus() {
        if (!_this.alwaysFloatLabel) {
            $label.css({
                top: _this.preventFloating ? _basePos : _floatingPos,
                background: _this.inputType === 'open' ? 'transparent' : 'white',
                color: _this.activeColor || AppStyleController.colors.primary[0],
                opacity: 1,
            });
        }
        switch (_this.inputType) {
            case 'border': {
                if (!_this.prefix) {
                    $input.css({
                        border: `1px solid #6FE2FF`,
                    });
                }
                break;
            }

            case 'open': {
                $focusBar.tween({ width: '100%', x: '-50%' }, 500, 'easeOutCubic');
                break;
            }

            case 'fill': {
                $input.css({
                    border: '0px solid #FA0510',
                });
            }
        }
    }
    function handlePrepopulatedValue() {
        if (!_this.alwaysFloatLabel) {
            $label.css({
                top: _this.preventFloating ? _basePos : _floatingPos,
                background: _this.inputType === 'open' ? 'transparent' : 'white',
                opacity: 1,
            });
        }
    }

    function handleFocusLoss() {
        _this.value = $input.div.value;
        if (!_this.inputType === 'border') {
            $label.css({
                color: Colors.monochrome[3],
            });
        }
        switch (_this.inputType) {
            case 'border': {
                if (!_this.alwaysFloatLabel) {
                    $input.css({
                        border: `1px solid ${Colors.monochrome[2]}`,
                    });
                    $label.css({
                        color: "#0D152B"
                    })
                } else {
                    $input.css({
                        border: `2px solid #cecece`,
                    });
                }
                break;
            }

            case 'open': {
                $focusBar.tween({ width: '0%', x: '-50%' }, 500, 'easeOutCubic');
            }
        }
        if (!_this.prefix && !_this.alwaysFloatLabel && (!_this.value || _this.value.length == 0)) {
            $label.css({
                top: _basePos,
                background: 'transparent',
                color: '#0D152B'
            });
        }
    }

    //*** Event handlers

    //*** Public methods

    this.updateLabel = function(text) {
        $label.text(text)
    }

    this.reset = function() {
        _this.value = ''
        $input.div.value = ''
    }

    this.get('isValid', () => {
        _this.value = $input.div.value;
        let requiredState = false;
        if (_this.required && _this.value && _this.value.length > 0) {
            requiredState = true;
        } else if (_this.required && (!_this.value || (_this.value && _this.value.length < 1))) {
            requiredState = false;
        } else {
            requiredState = true;
        }
        let valid = false;
        if (_this.validator) {
            valid = _this.validator(_this.value) && requiredState;
        } else {
            valid = requiredState;
        }
        if (!valid) {
            switch (_this.inputType) {
                case 'border': {
                    $input.css({
                        border: `1px solid ${Colors.off}`,
                    });
                    break;
                }

                case 'open': {
                    $focusBar.tween({ width: '0%', x: '-50%' }, 500, 'easeOutCubic');
                    break;
                }

                case 'fill': {
                    $input.css({
                        border: '2px solid #FA0510',
                    });
                }
            }
        } else {
            switch (_this.inputType) {
                case 'border': {
                    $input.css({
                        border: `1px solid ${Colors.monochrome[2]}`,
                    });
                    break;
                }

                case 'open': {
                    $focusBar.tween({ width: '0%', x: '-50%' }, 500, 'easeOutCubic');
                }
            }
        }

        return valid;
    });

    this.get('inputElement', () => {
        return $input;
    });

    this.get('inputLabel', () => {
        return $label;
    });
});

Class(function UIInputViewStyles() {
    Inherit(this, Component);

    this.buildUIInputView = function (elements, type, basePos, floatingPos, prefix, placeholder, isTextArea, noBorder) {
        const isFillType = type === 'fill';
        const { $container, $input, $focusBar, $label } = elements;
        $container.css({
            position: 'relative',
        });

        $label.css(this.styleguide.label1);
        $label.css({
            color: isFillType ? this.colors.monochrome[7] : this.colors.monochrome[3],
            position: 'absolute',
            top: basePos,
            transform: 'translateY(-50%)',
            transition: '0.2s ease all',
            padding: '.25rem',
            pointerEvents: 'none',
            background: 'none',
        });

        if (prefix || placeholder) {
            $label.css({
                top: floatingPos,
                background: 'white',
                color: '#0D152B',
                fontWeight: '700'
            })
        }

        $input.css({
            ...this.styleguide.label3,
            color: '#354253',
            '-webkit-user-select':'text',
            '-webkit-appearance': 'none',
        });

        switch (type) {
            case 'border': {
                $input.css({
                    color: '#747474',
                    position: 'relative',
                    background: isTextArea ? 'white' : 'none',
                    width: '100%',
                    border: noBorder ? 'none' : `1px solid ${this.colors.monochrome[2]}`,
                    outline: 'none',
                    padding: '1.5rem 2rem',
                    fontSize: '1.5rem',
                    minHeight: isTextArea ? '150px' : 'auto',
                    lineHeight: isTextArea ? '2.1rem' : 'initial'
                });
                $label.css({
                    left: '1rem',
                });
                $focusBar.css({
                    display: 'none',
                });
                break;
            }
            case 'fill': {
                $input.css({
                    position: 'relative',
                    background: 'white',
                    width: '100%',
                    border: noBorder ? 'none' : `1px solid ${this.colors.monochrome[3]}`,
                    outline: 'none',
                    padding: '1.5rem 2rem',
                    paddingBottom: '1rem',
                    fontSize: '1.5rem',
                });
                $label.css({
                    left: '1rem',
                });
                $focusBar.css({
                    display: 'none',
                });
                break;
            }
            case 'open': {
                $input.css({
                    position: 'relative',
                    background: 'none',
                    width: '100%',
                    border: 'none',
                    borderBottom: `1px solid ${this.colors.monochrome[2]}`,
                    outline: 'none',
                    padding: '1.5rem 0rem',
                    paddingBottom: '1rem',
                    fontSize: '1.5rem',
                });
                $label.css({
                    left: '0rem',
                });
                $focusBar.css({
                    transformOrigin: 'center center',
                    position: 'absolute',
                    bottom: 0,
                    width: '0%',
                    left: '50%',
                    height: '.2rem',
                    background: this.colors.primary[0],
                });
                $focusBar.transform({ x: '-50%' });
                break;
            }
            case 'chat': {
                $input.css({
                    position: 'relative',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    display: 'flex',
                    background: 'none',
                    width: '100%',
                    border: `1px solid ${this.colors.monochrome[2]}`,
                    outline: 'none',
                    padding: '1.5rem',
                });
                $image.css({ background: this.colors.primary[0] });
                $label.css({ display: 'none' });
                $focusBar.css({ display: 'none' });
                break;
            }
        }
    };
}, 'static');

Class(function UILink(_config) {
    Inherit(this, AbstractUIComponent, _config.type || 'a');

    const _this = this;
    const $this = _this.element;

    var $text, $line;

    _this.color = null;
    _this.href = null;
    _this.rel = null;
    _this.target = null;
    _this.text = null;
    _this.title = null;

    _this.onClick = null;

    //*** Constructor
    (function () {
        _this.parseConfig(_config);

        initHTML();
        initStyles();

        addHandlers();
    })();

    function initHTML() {
        if (_this.href) $this.attr('href', _this.href);
        if (_this.rel) $this.attr('rel', _this.rel);
        if (_this.target) $this.attr('target', _this.target);
        if (_this.title) $this.attr('title', _this.title);
        if (_this.value) $this.attr('value', _this.value);

        $text = $this.create(`${_this.getPrefix('text')}`, 'span');
        $text.text(_this.text);

        $line = $this.create(`${_this.getPrefix('line')}`);
    }

    function initStyles() {
        CoreUIState.instance().uiBuilder.buildUILink({
            $container: $this,
            $text,
            $line,
        }, _config);
    }

    //*** Event handlers
    function addHandlers() {
        $this.interact(handleHover, handleClick, _this.text, _this.text);
    }

    function handleHover(event) {
        CoreUIState.instance().uiBuilder.buildUILinkHover(event, {
            $this,
            $line,
            $text
        }, _config);
    }

    function handleClick() {
        if (_this.onClick) _this.onClick();
        
        CoreUIState.instance().uiBuilder.buildUILinkClick({
            $this,
            $line,
            $text
        }, _config);
    }
});

Class(function UILinkStyles() {
    Inherit(this, Component);

    this.buildUILink = function ({ $container, $text, $line }, { color, fontWeight, isUnderscored }) {
        $container.css({
            color: color || this.colors.primary[0],
            position: 'relative',
            whiteSpace: 'nowrap',
        });

        $text.css({
            ...this.styleguide.label1,
            fontWeight: fontWeight || 'normal',
        });

        $line
            .css({
                background: 'currentColor',
                bottom: -2,
                height: 1,
                left: 0,
                transformOrigin: isUnderscored ? '100% 0' : '0 0',
                width: '100%',
            })
            .transform({ scaleX: isUnderscored ? 1 : 0 });
    };
    
    this.buildUILinkHover = function ({ action }, { $line }, { isUnderscored }) {
        switch (action) {
            case 'over':
                $line.css({ transformOrigin: isUnderscored ? '100% 0' : '0 0' });
                $line.tween({ scaleX: isUnderscored ? 0 : 1 }, 400, 'easeOutCubic');
                break;

            case 'out':
                $line.css({ transformOrigin: isUnderscored ? '0 0' : '100% 0' });
                $line.tween({ scaleX: isUnderscored ? 1 : 0 }, 400, 'easeOutCubic');
                break;
        }
    };

    this.buildUILinkClick = function ({ $container, $line }) {

    };
}, 'static');
Class(function UIRadioView (_config) {
    Inherit(this, AbstractUIComponent);
    var $label, $optionContainer;
    const _this = this;
    const $this = _this.element;

    _this.options = [];
    _this.type = 'default';
    _this.seoLink = null;
    
    //*** Constructor
    (function () {
        _this.parseConfig(_config);
        initHTML();
        initStyle();
    })();
    
    function initHTML() {
        $this.css({
            position:'relative',
            height:'fit-content'
        })
        $label = $this.create(_this.getPrefix("label"),"label");
        $label.text(_this.label);
        if(_this.required){
            $label.inner = $label.create("required",'span');
            $label.inner.text(" *");
            $label.inner.css({color:Colors.off})
        }
        $optionContainer = $this.create(_this.getPrefix('option-container'));
        _this.options = _this.options.map((option)=>{
            return {
                value: option.value,
                label: option.label,
                selected:false
            }
        })
        for(let option of _this.options){
            createOption(option)
        }
    }

    function initStyle() {
        CoreUIState.instance().uiBuilder.buildUIRadioView({
            $container:$this,
            $label,
            $optionContainer
        }, {
            type: _this.type,
        });

    }

    function createOption(option) {
        let newOptionContainer = $optionContainer.create(_this.getPrefix('option'));
        newOptionContainer.attr('role','button');

        let $circle = newOptionContainer.create(_this.getPrefix('option__circle'));

        $circle.inner = $circle.create('inner');
        $circle.inner.attr('tabindex', 0);

        let $label = newOptionContainer.create(_this.getPrefix('option__label'),'p');
        $label.text(option.label);

        option.container = newOptionContainer;
        option.circle = $circle;
        option.clickHandler = _ => handleClick($circle, option);

        CoreUIState.instance().uiBuilder.buildUIRadioOption({
            $container:newOptionContainer,
            $circle,
            $label
        }, {
            type: _this.type,
        });

        newOptionContainer.interact(null, option.clickHandler, _this.seoLink ? _this.seoLink : null, option.label)
    }

    function handleClick($circle, option) {
        $circle.inner.tween({opacity:1},300,'easeOutCubic');

        _this.options.forEach((opt)=>{
            if(opt.value != option.value){
                opt.circle.inner.tween({opacity:0},300,'easeOutCubic');
                opt.selected = false;
            }else{
                opt.selected = true;
            }
        })
        

        _this.value = option.value;

        if (_this.onChangeCb) {
            _this.onChangeCb(_this.value);
        }
    }

  

    //*** Event handlers

    //*** Public methods
    this.get('clickHandler', _ => handleClick);

    this.get('isValid',()=>{
        if(_this.required && _this.value && _this.value.length > 0){
            return true;
        }else if(_this.required && ((!_this.value) || (_this.value && _this.value.length < 1))){
            return false
        }else{
            return true;
        }
    });

    this.get('inputLabel', _ => $label);
});
Class(function UIRadioViewStyles() {
    Inherit(this, Component);

    this.buildUIRadioView = function (elements, { type }) {
        let { $container, $label, $optionContainer } = elements;
        $container.css({
            position: 'relative',
            display: 'grid',
            gridAutoRows: 'min-content',
            gridGap: '2rem',
        });
        $label.css(this.styleguide.label3);
        $label.medium();
        $label.css({
            color: '#354253',
            position: 'relative',
        });
        $optionContainer.css({
            position: 'relative',
            display: 'grid',
            gridAutoRows: 'min-content',
            gridGap: '2rem',
        });
    };

    this.buildUIRadioOption = function (elements, { type }) {
        let { $container, $circle, $label } = elements;
        $container.css({
            position: 'relative',
            display: 'grid',
            gridAutoFlow: 'column',
            gridAutoColumns: 'max-content',
            gridGap: '1rem',
        });
        $circle.css({
            position: 'relative',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            borderRadius: '50%',
            border: `1px solid ${this.colors.tertiary[1]}`,
            height: '2rem',
            width: '2rem',
        });

        $circle.inner.css({
            background: `${this.colors.tertiary[1]}`,
            height: '1.25rem',
            width: '1.25rem',
            position: 'relative',
            borderRadius: '50%',
            opacity: 0,
        });
        $label.css(this.styleguide.label3);
        $label.css({
            color: this.colors.tertiary[2],
        });
    };
}, 'static');

/*
    Configuration allows for the following:
         isDisabled : boolean
            - Boolean whether or not the input is active
        
         label: string
            - Text for input label

         inputType: string
            - Type of input. Either 'border' or 'open'

         required: boolean
            - Whether or not the input is required to have a value
*/
Class(function UISelectView(_config) {
    Inherit(this, AbstractUIComponent);
    Inherit(this, UIFormControl);

    const _this = this;
    const $this = _this.element;

    _this.inputType = 'open';
    _this.options = [];

    var $input,
        $focusBar,
        $label,
        $image,
        $icon,
        $options = [];

    //*** Constructor
    (function () {
        _this.parseConfig(_config);
        initHTML();
        addListeners();
        initStyle();
    })();

    function initHTML() {
        $this.css({
            position: 'relative',
            height: 'fit-content',
        });

        if (_this.icon) {
            $icon = $this.create(_this.getPrefix('icon'), 'div');
            $icon.bg('~assets/images/icon/chevron-down.svg');
            $icon.css({
                right: 20,
                zIndex: 10,
                width: 24,
                height: 24,
                transform: 'translate(-50%, -50%)',
                top: '50%',
                pointerEvents: 'none'
            });
        }

        _this.inputElement = $input = $this.create(_this.getPrefix('input'), 'select');
        
        let stripped = _this.label.replace(' ','');

        $input.attr('name', stripped);
        $input.attr('aria-labeledby', stripped + '_label');
        $input.attr('role', 'button');
        $input.attr('tabindex', '0');

        $image = $input.create(_this.getPrefix('input__text'));
        $focusBar = $this.create(_this.getPrefix('focus-bar'), 'span');

        $label = $this.create(_this.getPrefix('label'), 'label');
        $label.text(_this.label);
        $label.attr('for', stripped);
        $label.attr('id', stripped + '_label');

        if (_this.required) {
            $label.inner = $label.create('required', 'span');
            $label.inner.text(' *');
            $label.inner.css({ color: Colors.off });
        }
    }

    function initStyle() {
        CoreUIState.instance().uiBuilder.buildUISelectView(
            {
                $container: $this,
                $input,
                $focusBar,
                $image,
                $label,
            },
            _this.inputType
        );

        //Blank option to not have default
        let blankOption = $input.create(_this.getPrefix('option'), 'option');
        blankOption.attr('disabled', true);
        blankOption.attr('value', false);
        blankOption.attr('selected', true);
        blankOption.css({
            display: 'none',
        });

        blankOption.text('');
        if (_this.disabledOption) {
            let $newOption = $input.create(_this.getPrefix('option'), 'option');
            $newOption.attr('disabled', true);
            $newOption.attr('selected', false);
            $newOption.attr('value', false);
            $newOption.text(_this.disabledOption);
            CoreUIState.instance().uiBuilder.buildUISelectOption($newOption);
            $options.push($newOption)
        }
        for (let option of _this.options) {
            let $newOption = $input.create(_this.getPrefix('option'), 'option');
            $newOption.attr('value', option.value);
            $newOption.text(option.label);
            CoreUIState.instance().uiBuilder.buildUISelectOption($newOption);
            $options.push($newOption);
        }

        if (_this.value) {
            for (let option of $options) {
                if (option.div.value == _this.value) {
                    option.div.selected = true;
                    handlePrepopulatedValue();
                    break;
                }
            }
        }

        if (!_this.options || _this.options.length == 0) {
            _this.disabled = true;
            $input.attr('disabled', 'true');
            $label.text('No options are available.');
            $label.css({
                textTransform: 'none',
            });
            $this.css({
                opacity: 0.5,
            });
        }
    }

    function handleValueChange(e) {
        _this.value = $input.div.value;
        if (_this.value) {
            handlePrepopulatedValue();
        }
        _this.events.fire(UIFormControl.VALUE_CHANGE, { value: _this.value });
    }

    function handlePrepopulatedValue() {
        $label.css({
            top: '5%',
            background: 'white',
            opacity: 1,
        });
    }

    function handleFocus() {
        $label.css({
            top: '5%',
            background: 'white',
            color: AppStyleController.colors.primary[0],
            opacity: 1,
        });
        switch (_this.inputType) {
            case 'border': {
                $input.css({
                    border: _this.fill ? '1px solid rgb(211,211,211)' : `1px solid ${AppStyleController.colors.primary[0]}`,
                });
                break;
            }

            case 'open': {
                $focusBar.tween({ width: '100%', x: '-50%' }, 500, 'easeOutCubic');
                break;
            }
        }
    }

    function handleFocusLoss() {
        $label.css({
            color: Colors.monochrome[3],
        });
        switch (_this.inputType) {
            case 'border': {
                $input.css({
                    border: `1px solid ${Colors.monochrome[2]}`,
                });
                break;
            }

            case 'open': {
                $focusBar.tween({ width: '0%', x: '-50%' }, 500, 'easeOutCubic');
            }
        }
        if (!_this.value || _this.value.length == 0) {
            $label.css({
                top: '50%',
                background: 'transparent',
            });
        }
    }

    //*** Event handlers
    function addListeners() {
        $input.bind('focusin', handleFocus);
        $input.bind('focusout', handleFocusLoss);
        $input.bind('change', handleValueChange);
    }

    //*** Public methods
    this.get('isValid', () => {
        _this.value = $input.div.value;
        let valid = false;
        if (_this.required && _this.value && _this.value.length > 0) {
            valid = true;
        } else if (_this.required && (!_this.value || (_this.value && _this.value.length > 0))) {
            valid = false;
        } else {
            valid = true;
        }
        if (!valid) {
            switch (_this.inputType) {
                case 'border': {
                    $input.css({
                        border: _this.fill ? '2px solid #FA0510' : `1px solid ${Colors.off}`,
                    });
                    break;
                }

                case 'open': {
                    $focusBar.tween({ width: '0%', x: '-50%' }, 500, 'easeOutCubic');
                    break;
                }
            }
        } else {
            switch (_this.inputType) {
                case 'border': {
                    $input.css({
                        border: `1px solid ${Colors.monochrome[2]}`,
                    });
                    break;
                }

                case 'open': {
                    $focusBar.tween({ width: '0%', x: '-50%' }, 500, 'easeOutCubic');
                }
            }
        }
        return valid;
    });
});

Class(function UISelectViewStyles() {
    Inherit(this, Component);

    this.buildUISelectView = function (elements, type) {
        const { $container, $input, $image, $focusBar, $label } = elements;

        $container.css({
            position: 'relative',
        });

        $label.css(this.styleguide.label1);
        $label.css({
            color: this.colors.monochrome[3],
            position: 'absolute',
            top: '50%',
            transform: 'translateY(-50%)',
            transition: '0.2s ease all',
            padding: '.25rem',
            pointerEvents: 'none',
        });

        $input.css({
            '-webkit-appearance': 'none',
            '-moz-appearance': 'none',
            appearance: 'none',
        });
        $input.css(this.styleguide.label3);
        $input.css({
            color: '#354253',
        });

        switch (type) {
            case 'border': {
                $label.css({
                    fontWeight: '500'
                })
                $input.css({
                    position: 'relative',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    display: 'flex',
                    background: 'none',
                    width: '100%',
                    border: `1px solid ${this.colors.monochrome[2]}`,
                    outline: 'none',
                    padding: '1.5rem',
                    paddingBottom: '1rem',
                });
                $label.css({
                    left: '1rem',
                });
                $focusBar.css({
                    display: 'none',
                });
                break;
            }
            case 'open': {
                $input.css({
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    position: 'relative',
                    background: 'none',
                    width: '100%',
                    border: 'none',
                    borderBottom: `1px solid ${this.colors.monochrome[2]}`,
                    outline: 'none',
                    padding: '1.5rem 0rem',
                    paddingBottom: '1rem',
                });
                $label.css({
                    left: '0rem',
                });
                $focusBar.css({
                    transformOrigin: 'center center',
                    position: 'absolute',
                    bottom: 0,
                    width: '0%',
                    left: '50%',
                    height: '.2rem',
                    background: this.colors.primary[0],
                });
                $focusBar.transform({ x: '-50%' });
                break;
            }
        }
        this.buildMaskIcon($image, '~assets/images/icon/chevron-down.svg', '2rem', '2rem', this.colors.primary[0]);
    };

    this.buildUISelectOption = function ($option) {
        $option.css({
            position: 'relative',
            padding: '1.5rem',
        });

        $option.css(this.styleguide.label3);
    };
}, 'static');

Class(function UITabView(_config) {
    Inherit(this, AbstractUIComponent);

    const _this = this;
    const $this = _this.element;

    _this.align = 'center';
    _this.persist = false;
    _this.handleScroll = false;
    _this.tabs = [];
    _this.transition = 'slide';
    _this.transitionDuration = 600;
    _this.size = null;

    var _currentTab;
    var _currentTabIndex = null;

    var $content, $header, $bar;

    var _tabsData = [];
    var _tabsInstances = {};

    var $tabs = [];
    var $tabsHeaders = [];

    var _tabMap = {};
    var _isMoving = false;

    //*** Constructor
    (async function () {
        _this.parseConfig(_config);

        initHTML();
        await initTabs();
        initStyles();

        let index = 0;

        if (Router.getState().length > 1 && _tabMap[Router.getState()[1]]) {
            index = _tabMap[Router.getState()[1]].index;
        }

        $tabs.forEach((tab, i) => {
            if (i === index) return;
            tab.body.css({ opacity: 0 });
        });
        switchTab(index);

        addListeners();
    })();

    function initHTML() {
        $header = $this.create(`${_this.getPrefix('tab-header')}`);
        $content = $this.create(`${_this.getPrefix('tab-content')}`);
        $bar = $header.create(`${_this.getPrefix('tab-bar')}`);
    }

    async function initTabs() {
        _this.tabs.forEach((tab, index) => {
            addTab({ ...tab, index });
        });
    }

    function initStyles() {
        CoreUIState.instance().uiBuilder.buildUITabView({
            $container: $this,
            $header,
            $content,
            $bar,
        }, {
            align: _this.align,
            barColor: _this.barColor,
            handleScroll: _this.handleScroll,
            size: _this.size,
        });
    }

    async function animateBar(index) {
        if (!$this || !$this.div || !$tabsHeaders[index] || !$tabsHeaders[index].div) return;

        await _this.wait(200);

        let scroll = $header.div.scrollLeft || 0;
        let { left, width } = $tabsHeaders[index].div.getBoundingClientRect();
        const fullWidth = $this.div.getBoundingClientRect().left;
        left += scroll;

        $bar.tween({ width, x: left - fullWidth, y: '-50%' }, 600, 'easeOutCubic');
    }

    async function addTab(tab) {
        let { disabled, index, label, route, view, viewOptions, handleScroll } = tab;

        let header = $header.create(`${_this.getPrefix('tab-header__tab')}`);
        header.attr('role', 'tab');

        header.disabled = disabled;
        header.index = index;
        header.route = route;

        header.inner = header.create('label', 'p');
        header.inner.text(label);

        header.interact(handleTabHover, _ => {
            if (_isMoving || index === _currentTabIndex || header.disabled) return;

            if (route) {
                let currRoute = Router.getState();

                Router.setState(currRoute[0] + '/' + route);
            } else {
                switchTab(index);
            }
        }, '#', label);

        if (_this.accessibility) {
            _this.accessibility.instance().enableTabNavigation(header, () => {
                if (_isMoving || index === _currentTabIndex || header.disabled) return;

                if (route) {
                    let currRoute = Router.getState();

                    Router.setState(currRoute[0] + '/' + route);
                } else {
                    switchTab(index);
                }
             });
        }

        $tabsHeaders.push(header);

        let body = $content.create(`${_this.getPrefix('tab-content__item')}`);
        let content = body.create(`${_this.getPrefix('tab-content__item')}`);

        CoreUIState.instance().uiBuilder.buildUITab({
            $header: header,
            $body: body,
            $content: content,
        }, {
            disabled,
            handleScroll,
            size: _this.size
        });

        CoreUIState.instance().uiBuilder.buildUITabLabel({
            $label: header.inner,
        });

        $tabs.push({ header, body, content, disabled, handleScroll });
        _tabsData.push(tab);

        if (route) {
            _tabMap[route] = { index: tab.index };
        }

        if (_this.persist) {
            if (typeof view === 'function') {
                _tabsInstances[label] = _this.initClass(view, {
                    options: viewOptions,
                    tab: _this
                }, [content]);
            }

            view.tab = _this;
            view.options = viewOptions;
            content.add(view);
        }
    }

    function enableTab(index) {
        $tabsHeaders[index].tween({ opacity: 1 }, 400, 'easeOutCubic');
        $tabsHeaders[index].disabled = false;
    }

    function disableTab(index) {
        $tabsHeaders[index].tween({ opacity: 0.25 }, 400, 'easeOutCubic');
        $tabsHeaders[index].disabled = true;
    }

    function checkTab(index) {
        $tabs.forEach(($tab, tabIndex) => {
            if (index === tabIndex) {
                focusTab($tab.header.inner);
                $tab.header.attr('aria-selected', 'true');
            } else {
                unfocusTab($tab.header.inner);
                $tab.header.attr('aria-selected', 'false');
            }
        });
    }

    function focusTab(element) {
        element.tween({ color: _this.focusTabColor || AppStyleController.colors.primary[0] }, 500, 'easeOutCubic');
    }

    function unfocusTab(element) {
        element.tween({ color: _this.unfocusTabColor || '#A7A7A7' }, 500, 'easeOutCubic');
    }

    function handleTabHover(e) {

    }

    async function switchTab(index) {
        _isMoving = true;

        let currentTab = $tabs[_currentTabIndex];
        let selectedTab = $tabs[index];

        let direction = _this.transition === 'slide' ? _currentTabIndex > index ? 'calc(50% - 3rem)' : 'calc(-50% + 3rem)' : 0;
        let incomingDirection = _this.transition === 'slide' ? _currentTabIndex < index ? 'calc(50% - 3rem)' : 'calc(-50% + 3rem)' : 0;

        selectedTab.body.transform({ x: incomingDirection }).css({ opacity: 0 });
        selectedTab.body.css({ zIndex: 2 });

        checkTab(index);

        let currentTabView = _currentTab;

        if (!_this.persist) {
            let { view, viewOptions } = _tabsData[index];

            _currentTab = _this.initClass(view, {
                options: viewOptions,
                tab: _this
            }, [selectedTab.content]);
        }

        if (currentTab) {
            currentTab.body.css({ zIndex: 1 });

            let tween = currentTab.body.tween({ x: direction, opacity: 0 }, _this.transitionDuration, 'easeInOutCubic', _ => {
                currentTab.body.css({ visibility: 'hidden' });

                if (!_this.persist && currentTabView && currentTabView.destroy) {
                    currentTabView.destroy();
                }

                Router.unlock();
            });

            if (_this.transition === 'opacity') {
                await tween.promise();
            }
        }

        selectedTab.body.tween({ x: '0%', opacity: 1, visibility: 'visible' }, _this.transitionDuration, 'easeInOutCubic', _ => {
            _isMoving = false;
        });

        animateBar(index);

        _currentTabIndex = index;

        _this.events.fire(UITabView.TAB_CHANGE, { index, previousTab: currentTab, selectedTab });
    }

    //*** Event handlers
    function addListeners() {
        _this.events.sub(Router, Router.UPDATE, routeUpdate);
        _this.onResize(handleResize);
    }

    function handleResize() {
        $tabs.forEach(tab => {
            CoreUIState.instance().uiBuilder.buildUITabLabel({
                $label: tab.header.inner,
            });
        });

        let scroll = $header.div.scrollLeft || 0;
        let { left, width } = $tabsHeaders[_currentTabIndex].div.getBoundingClientRect();
        const fullWidth = $this.div.getBoundingClientRect().left;
        left += scroll;

        $bar.css({ width }).transform({ x: left - fullWidth, y: '-50%' });
    }

    async function routeUpdate(e) {
        const manualSplit = e.value.split('/');
        if (manualSplit.length > 1) {
            let subPath = manualSplit[1];
            if (_tabMap[subPath]) {
                switchTab(_tabMap[subPath].index);
            }
        }
    }

    //*** Public methods
    this.get('header', _ => {
        return $header;
    });

    this.get('tabHeaders', _ => {
        return $tabsHeaders;
    });

    this.get('content', _ => {
        return $content;
    });

    this.enableTab = enableTab;
    this.disableTab = disableTab;
    this.switchTab = switchTab;
}, _ => {
    UITabView.TAB_CHANGE = 'tabview_tab_change';
});

Class(function UITabViewStyles() {
    Inherit(this, Component);

    this.buildUITab = function ({ $body, $header, $content }, { disabled, handleScroll }) {
        $header.inner.css({ ...this.styleguide.label1, fontWeight: '700', textTransform: 'uppercase', color: '#C2C0C0', letterSpacing: '0.5px' });

        $header.css({
            opacity: disabled ? 0.25 : 1,
            padding: '0em 0rem 2.4rem ',
            position: 'relative',
            textAlign: 'center',
            margin: '0 2rem',
        });

        $body.css({
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            opacity: 0,
            position: 'absolute',
            display: 'block',
            flexBasis: '100%',
            height: '100%',
            visibility: 'hidden',
        });

        $content.css({
            height: '100%',
            position: 'relative',
            opacity: 1,
            overflow: handleScroll ? 'auto' : 'unset'
        });
    };

    this.buildUITabLabel = function ({ $label }) {
        $label.css({
            position: 'relative',
        });
    };

    this.buildUITabView = function ({ $container, $header, $content, $bar }, { align, barColor, handleScroll }) {
        $container.css({
            position: 'relative',
            display: 'flex',
            flexDirection: 'column',
            flex: handleScroll ? '2 0 100%' : 'unset',
            height: '100%'
        });

        $header.css({
            display: 'flex',
            justifyContent: align,
            position: 'relative',
            borderBottom: '1px solid #E8E8E8',
        });

        $content.css({
            height: '100%',
            position: 'relative',
            display: 'flex',
            transition: 'height 500ms cubic-bezier(0.35, 0, 0.25, 1)',
            padding: '0rem 3rem 3rem 3rem',
            flex: handleScroll ? '2 0 100%' : 'unset',
        });

        $bar.css({
            position: 'absolute',
            height: 2,
            bottom: -2,
            background: barColor || this.colors.primary[0],
            left: align === 'center' ? '0%' : 'auto',
        });
    };
}, 'static');

Class(function UITimer({autoStart, countdown, countdownTime, prependMessage, hasClock, anchorTop, size, bgColor, noTimer}) {
    Inherit(this, Element);
    const _this = this;
    const $this = _this.element;
    const _prefix = 'UITimer'
    var interval;
    var _totalSeconds = 0;
    var $content, $endingMessage, $icon, $minutesLabel, $secondsLabel, $prependMessage;

    
    //*** Constructor
    (function () {
        initHTML();
        if (prependMessage) initPrepend()
        initClock()
        initStyles();
        if (countdown) handleCountdown()
        if (autoStart) handleStartTimer() 
        _this.onResize(resize);
    })();
    
    function initHTML() {
        $content = $this.create(`${_prefix}__content`)
        $prependMessage = $content.create(`${_prefix}__prepend-message`, 'h5')
        
        $endingMessage = $this.create(`${_prefix}__ending-message`)
    
    }

    function initPrepend() {
        $prependMessage.text(prependMessage)
        $prependMessage.css({
            marginRight: '0.6rem'
        })
    }

    function initClock() {
        $icon =  $content.create(`${_prefix}__icon`) 
        $minutesLabel =  $content.create(`${_prefix}__minutes-label`, 'p')
        $secondsLabel =  $content.create(`${_prefix}__seconds-label`, 'p')
        $minutesLabel.text('00:')
        $secondsLabel.text('00')
    }
        
    function initStyles() {
        CoreUIState.instance().uiBuilder.buildUITimer({
            $container: $this,
            $content,
            $icon,
            $minutesLabel, 
            $secondsLabel,
            $endingMessage, 
            $prependMessage 
        }, {
            hasClock,
            prependMessage,
            size,
            bgColor
        })

        if (anchorTop) {
            $this.css({
                position: 'absolute',
                top: '2rem'
            })
        }
        if (noTimer) {
            $minutesLabel.hide()
            $secondsLabel.hide()
        }
    }

    function handleStartTimer() {
        $this.tween({opacity: 1}, 250, 'easeOutCubic')
        startTimer()
    }

    function handleCountdown() {
        $minutesLabel.text(pad(parseInt(countdownTime / 60)) + ':');
        $secondsLabel.text(pad(countdownTime % 60));
        _totalSeconds = countdownTime
    }

    function startTimer() {
        interval = setInterval(setTime, 1000);
    }
    function pauseTimer() {
        clearInterval(interval);
    }

    function resetTimer() {
        $endingMessage.css({display: 'none'})
        $content.css({display: 'flex'})
        _totalSeconds = countdown ? countdownTime : 0
        clearInterval(interval)
        if (countdown) {
            handleCountdown()
        }
        startTimer()
    }


    function setTime() {
        if (countdown && _totalSeconds <= 0) {
            return 
        }
        if (countdown) {
            --_totalSeconds;
        } else {
            ++_totalSeconds;
        }
        $minutesLabel.text(pad(parseInt(_totalSeconds / 60)) + ':');
        $secondsLabel.text(pad(_totalSeconds % 60));
      }

    function pad(val) {
        var valString = val + "";
        if (valString.length < 2) {
          return "0" + valString;
        } else {
          return valString;
        }
      }

    function resize() {
        if(Device.mobile) {
            if($prependMessage) {
                $prependMessage.css({
                    fontSize:'1.4rem'
                })
            }
        }else{
            if($prependMessage) {
                $prependMessage.css({
                    fontSize:'2.1rem'
                })
            }
        }
    }
    
    //*** Public methods

    this.startTimer = function() {
        handleStartTimer()
    }

    this.resetTimer = function() {
        resetTimer()
    }
    this.pauseTimer = function() {
        pauseTimer();
    }

    this.animateOut = function() {
        $this.tween({opacity: 0}, 400, 'easeOutCubic')
    }
    this.animateIn = function() {
        $this.tween({opacity: 1}, 400, 'easeOutCubic')
    }
    this.onDestroy = function() {
       clearInterval(interval)
    }

});
Class(function UITimerStyles() {
    Inherit(this, Component);

    this.buildUITimer = function (els, properties) {
        const {$container, $icon, $minutesLabel, $secondsLabel, $content, $endingMessage, $prependMessage } = els;
        const {hasClock, prependMessage, bgColor, size} = properties;

        const clockStyle = size === 'large' ? this.styleguide.h5 : this.styleguide.label2
        $container.css({
            position: 'relative',
            opacity: 1,
            padding: '1.3rem 1.8rem',
            borderRadius: '3rem',
            background: bgColor || 'white',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
        })

        $prependMessage.css({
            ...this.styleguide.h5,
            textTransform: 'uppercase',
            color: "#0D152B",
        })

        $content.css({
            position: 'relative',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
        })

        $icon.css({
            height: '2.4rem',
            width: '2.4rem',
            marginRight: '0.6rem',
            objectFit: 'cover',
            position: 'relative',
            display: hasClock ? 'block' : 'none'
        })
        $icon.bg('~assets/images/icon/altclock.svg')

        $minutesLabel.css({
            ...clockStyle,
            color: "#0D152B",
            fontVariantNumeric: 'tabular',
        })

        $secondsLabel.css({
            ...clockStyle,
            color: "#0D152B",
            fontVariantNumeric: 'tabular',
        })

        $endingMessage.css({
            ...this.styleguide.h5,
            color: "#0D152B",
            opacity: 0,
            display: 'none'
        })
    };
}, 'static');

Class(function AbstractDragUtil() {
    Inherit(this, Component);
    const _this = this;

    _this.dMap = {};
    _this.pos = {};
    _this.distanceThreshold = 15;
    //*** Constructor
    (function () {
    
    })();
    
    //*** Event handlers
    
    //*** Public methods
    
    this.closestEdge = function (e,elem) {
        var elemBounding = elem.getBoundingClientRect();

        var elementLeftEdge = elemBounding.left;
        var elementTopEdge = elemBounding.top;
        var elementRightEdge = elemBounding.right;
        var elementBottomEdge = elemBounding.bottom;
        
        var mouseX = e.x;
        var mouseY = e.y;
      
        var topEdgeDist = Math.abs(elementTopEdge - mouseY);
        var bottomEdgeDist = Math.abs(elementBottomEdge - mouseY);
        var leftEdgeDist = Math.abs(elementLeftEdge - mouseX);
        var rightEdgeDist = Math.abs(elementRightEdge - mouseX);

        _this.dMap = {top:topEdgeDist<=_this.distanceThreshold, bottom: bottomEdgeDist<=_this.distanceThreshold, left: leftEdgeDist<= _this.distanceThreshold, right: rightEdgeDist<=_this.distanceThreshold};
    }

    this.resolveCSS = function () {
      if(_this.pos.y <= Stage.height /2.){
          let projectedTop = _this.pos.y;
          _this.object.css({
              top:projectedTop >= 0 ? projectedTop : 0,
              left:_this.pos.x,
          })
      }else{
          let projectedBottom = Stage.height - (_this.pos.y) - _this.object.div.clientHeight;
          _this.object.css({
              bottom:projectedBottom >= 0 ? projectedBottom : 0,
              left:_this.pos.x,
          })
      }
    }

    this.determineTransformOrigin = function () {
        let yAxis = _this.dMap.top ? 'top ' : (_this.dMap.bottom ?  'bottom ' : ''); 
        let xAxis = _this.dMap.left ? 'left ' : (_this.dMap.right ?  'right ' : ''); 
        return yAxis + xAxis;
    }

    this.parseStyle = function (style) {
      if(style.includes('rem')) {
        return parseInt(style) * 10;
      }else{
        return parseInt(style);
      }
    }


},()=>{
  AbstractDragUtil.CHANGE_START = 'AbstractDragUtil_change_start';
  AbstractDragUtil.CHANGE_END = 'AbstractDragUtil_change_end';
});
//Utility to animate elements
Class(function AnimationBuilder() {
  Inherit(this, Component);
  const _this = this;

  //*** Constructor
  (function () {})();

  //*** Event handlers

  //*** Public methods
  this.backOver = function (icon) {
    icon.element.tween({ opacity: 0, x: -5 }, 250, "easeOutCubic", (_) => {
      icon.element.transform({ x: 5 });
      icon.element.tween({ opacity: 1, x: 0 }, 250, "easeOutCubic");
    });
  };

  this.backOut = function (icon) {
    icon.element.tween({ opacity: 1, x: 0 }, 400, "easeOutCubic");
  };

  this.fadeInStagger = function ({
    ease,
    items,
    onComplete,
    stagger,
    time,
    x = 0,
    y = 0,
  }) {
    items.forEach((item, index) => {
      item.css({ opacity: 0 }).transform({ x, y });
      item.tween(
        { opacity: 1, x: 0, y: 0 },
        time,
        ease,
        stagger * index,
        (_) => {
          if (index === items.length - 1 && onComplete) onComplete();
        }
      );
    });
  };

  this.fadeOutStagger = function ({
    ease,
    items,
    onComplete,
    stagger,
    time,
    x = 0,
    y = 0,
  }) {
    items.forEach((item, index) => {
      item.tween({ opacity: 0, x, y }, time, ease, stagger * index, (_) => {
        if (index === items.length - 1 && onComplete) onComplete();
      });
    });
  };

  this.cardEntrance = function (card, delay) {
    const easing = "easeOutCubic";
    card.css({ opacity: 0 });
    card.transform({ y: 75 });
    card.tween({ opacity: 1, y: 0 }, 500, easing, delay);
  };

  this.cardEntranceHorizontal = function (card, direction, delay) {
    const easing = "easeOutCubic";
    card.css({ opacity: 0 });
    if (direction == "left") {
      card.transform({ x: 80 });
    } else {
      card.transform({ x: -80 });
    }
    card.tween({ opacity: 1, x: 0 }, 400, easing, delay);
  };

  this.fadeInRight = function (item, delay) {
    item.transform({ x: 50 }).css({ opacity: 0 });
    item.tween({ x: 0, opacity: 1 }, 500, "easeOutCubic", delay);
  };

  this.fadeOutRight = function (item, delay) {
    item.tween({ x: 50, opacity: 0 }, 500, "easeOutCubic", delay);
  };

  this.fadeOutUp = function (item, delay) {
    return new Promise((resolve, reject) => {
      item.tween({ y: -50, opacity: 0 }, 500, "easeOutCubic", delay, () => {
        resolve();
      });
    });
  };

  this.fadeInUp = function (item, delay) {
    return new Promise((resolve, reject) => {
      item.css({ opacity: 0 }).transform({ y: 75 });
      item.tween({ y: 0, opacity: 1 }, 500, "easeOutCubic", delay, () => {
        resolve();
      });
    });
  };

  this.fadeIn = function (item, delay) {
    return new Promise((resolve, reject) => {
      item.css({ opacity: 0 }).transform({ scale: 0.8 });
      item.tween(
        { opacity: 1, scale: 1, y: 0 },
        500,
        "easeOutCubic",
        delay,
        () => {
          resolve();
        }
      );
    });
  };

  this.fadeOut = function (item, delay, shouldScale = true) {
    return new Promise((resolve, reject) => {
      item.tween(
        { opacity: 0, scale: shouldScale ? 0.75 : 1, y: 0 },
        500,
        "easeOutCubic",
        delay,
        () => {
          resolve();
        }
      );
    });
  };

  this.swipeTransition = function (content, layer, direction, callback) {
    const layerInitial = { opacity: 1, visibility: "visible", zIndex: 20 };
    const layerEnd = { opacity: 0, visibility: "hidden", zIndex: -1 };
    const easing = "easeOutCubic";

    switch (direction) {
      case "up": {
        content.tween({ y: "-50%", opacity: 0 }, 500, easing, (_) => {
          content.transform({ y: "50%" });
          content.tween({ y: 0, opacity: 1 }, 600, easing, 300);
          callback();
        });

        layer.css(layerInitial).transform({ y: "101%" });
        layer.tween({ y: "-101%" }, 900, easing, 200, (_) => {
          layer.css(layerEnd).transform({ y: "101%" });
        });

        break;
      }

      case "down": {
        content.tween({ y: "50%", opacity: 0 }, 500, easing, (_) => {
          content.transform({ y: "-50%" });
          content.tween({ y: 0, opacity: 1 }, 600, easing, 300);
          callback();
        });

        layer.css(layerInitial).transform({ y: "-101%" });
        layer.tween({ y: "101%" }, 900, easing, 200, (_) => {
          layer.css(layerEnd).transform({ y: "-101%" });
        });

        break;
      }

      case "left": {
        content.tween({ x: "-25%", opacity: 0 }, 500, easing, (_) => {
          content.transform({ x: "25%" });
          content.tween({ x: 0, opacity: 1 }, 600, easing, 300);
          callback();
        });

        layer.css(layerInitial).transform({ x: "101%" });
        layer.tween({ x: "-101%" }, 900, easing, 200, (_) => {
          layer.css(layerEnd).transform({ x: "101%" });
        });

        break;
      }

      case "right": {
        content.tween({ x: "25%", opacity: 0 }, 500, easing, (_) => {
          content.transform({ x: "-25%" });
          content.tween({ x: 0, opacity: 1 }, 600, easing, 300);
          callback();
        });

        layer.css(layerInitial).transform({ x: "-101%" });
        layer.tween({ x: "101%" }, 900, easing, 200, (_) => {
          layer.css(layerEnd).transform({ x: "-101%" });
        });

        break;
      }
    }
  };
}, "static");

/*
Utility to build styles for UIElements


     Overriding these styles:
     - Your custom builder needs to inherit from tihs class and simply override the corresponding function you wish to customize.
*/
Class(function CoreUIBuilder() {
    Inherit(this, Component);

    const _this = this;

    //*** Constructor
    (function () {

    })();

    _this.buildCircleAvatar = (element) => {
        element.css({
            width: '5rem',
            height: '5rem',
            borderRadius: '50%',
            position: 'relative',
            backgroundSize: 'cover',
            backgroundPosition: 'center'
        });
    };

    //*** Video Player
    this.buildUIIVideoPlayer = UIVideoPlayerStyles.buildUIIVideoPlayer.bind(_this);

    //*** Icon
    this.buildIcon = function (element) {
        element.css(_this.styleguide.icon);
        element.css({
            position: 'relative',
            backgroundSize: 'contain',
            backgroundRepeat: 'no-repeat'
        });
    };

    this.buildMaskIcon = function (element, iconSrc, height = '2rem', width = '2rem', color = 'black') {
        element.css({
            "background": color,
            '-webkit-mask-size': 'contain',
            "maskSize": 'contain',
            '-webkit-mask-image': `url(${Assets.getPath(iconSrc)})`,
            "maskImage": `url(${Assets.getPath(iconSrc)})`,
            "width": height,
            "height": width,
            "position": 'relative'
        });
    };

    this.buildCloseButton = function (element, height = '2rem', width = '2rem', color = 'black') {
        _this.buildMaskIcon(element, '~assets/images/icon/close.svg', height, width, color);
    };

    //*** Buttons
    this.buildUIButton = UIButtonStyles.buildUIButton.bind(_this);

    this.buildTextButton = function (button) {
        button.attr('role', 'button');
        button.css({
            display: 'block',
            position: 'relative',
            width: '60%',
            padding: '1.5rem',
            color: 'white',
            border: 'none',
            outline: 'none',
            cursor: 'pointer',
            textAlign: 'center',
            height: 'fit-content',
            border: '2px solid white',
            margin: '9rem auto 0'
        });
        button.css(_this.styleguide.button);
    };

    this.buildOutlineButton = function (button) {
        button.attr('role', 'button');
        button.css({
            position: 'relative',
            width: '100%',
            padding: '2rem 4rem',
            color: 'white',
            border: 'none',
            outline: 'none',
            cursor: 'pointer',
            borderRadius: '5px',
            textAlign: 'center',
            height: 'fit-content',
            border: `2px solid ${_this.colors.monochrome[2]}`
        });
        button.css(_this.styleguide.button);
    };

    this.textButtonHover = function ($button) {
        $button.css({
            background: _this.colors.primary[1]
        });
    };

    //*** Back Button
    this.buildUIBackButton = UIBackButtonStyles.buildUIBackButton.bind(_this);
    this.buildUIBackButtonHover = UIBackButtonStyles.buildUIBackButtonHover.bind(_this);
    this.buildUIBackButtonClick = UIBackButtonStyles.buildUIBackButtonClick.bind(_this);

    //*** Icon Button
    this.buildUIIconButton = UIIconButtonStyles.buildUIIconButton.bind(_this);
    this.buildUIIconButtonHover = UIIconButtonStyles.buildUIIconButtonHover.bind(_this);
    this.buildUIIconButtonClick = UIIconButtonStyles.buildUIIconButtonClick.bind(_this);

    //*** Link
    this.buildUILink = UILinkStyles.buildUILink.bind(_this);
    this.buildUILinkHover = UILinkStyles.buildUILinkHover.bind(_this);
    this.buildUILinkClick = UILinkStyles.buildUILinkClick.bind(_this);

    //*** Input
    this.buildUIInputView = UIInputViewStyles.buildUIInputView.bind(_this);

    //*** Select
    this.buildUISelectView = UISelectViewStyles.buildUISelectView.bind(_this);
    this.buildUISelectOption = UISelectViewStyles.buildUISelectOption.bind(_this);

    //*** Radio
    this.buildUIRadioView = UIRadioViewStyles.buildUIRadioView.bind(_this);
    this.buildUIRadioOption = UIRadioViewStyles.buildUIRadioOption.bind(_this);

    //*** View Toggle
    this.buildUIViewToggleBody = UIViewToggleControllerStyles.buildUIViewToggleBody.bind(_this);
    this.buildUIViewToggleMobile = UIViewToggleControllerStyles.buildUIViewToggleMobile.bind(_this);
    this.buildUIViewToggleItem = UIViewToggleControllerStyles.buildUIViewToggleItem.bind(_this);

    //*** Participant
    this.buildUIParticipantsContainer = UIParticipantsViewStyles.buildUIParticipantsContainer.bind(_this);
    this.buildUIParticipantsBody = UIParticipantsViewStyles.buildUIParticipantsBody.bind(_this);
    this.buildUIParticipantsMobileBody = UIParticipantsViewStyles.buildUIParticipantsMobileBody.bind(_this);
    this.buildUIParticipantsHeader = UIParticipantsViewStyles.buildUIParticipantsHeader.bind(_this);
    this.buildUIParticipantsUserItem = UIParticipantsViewStyles.buildUIParticipantsUserItem.bind(_this);
    this.buildUIParticipantsNotification = UIParticipantsViewStyles.buildUIParticipantsNotification.bind(_this);

    //*** Checkbox
    this.buildUICheckboxView = UICheckboxViewStyles.buildUICheckboxView.bind(_this);
    this.buildUICheckboxGroup = UICheckboxGroupStyles.buildUICheckboxGroup.bind(_this);

    //*** Tabs
    this.buildUITab = UITabViewStyles.buildUITab.bind(_this);
    this.buildUITabLabel = UITabViewStyles.buildUITabLabel.bind(_this);
    this.buildUITabView = UITabViewStyles.buildUITabView.bind(_this);

    //*** Chat
    this.buildUIChatMessageView = UIChatMessageViewStyles.buildUIChatMessageView.bind(_this);
    this.buildUIChatParticipantView = UIChatParticipantViewStyles.buildUIChatParticipantView.bind(_this);

    this.buildUIChatView = UIChatViewStyles.buildUIChatView.bind(_this);
    this.buildUIChatIntro = UIChatViewStyles.buildUIChatIntro.bind(_this);
    this.buildUIChatConfirmationView = UIChatConfirmationViewStyles.buildUIChatConfirmationView.bind(_this);

    //*** AV Input
    this.buildUIAVInputContainer = UIAVInputViewStyles.buildUIAVInputContainer.bind(_this);
    this.buildUIAVInputTitle = UIAVInputViewStyles.buildUIAVInputTitle.bind(_this);
    this.buildUIAVInputHeaderItem = UIAVInputViewStyles.buildUIAVInputHeaderItem.bind(_this);
    this.buildUIAVInputSubsection = UIAVInputViewStyles.buildUIAVInputSubsection.bind(_this);
    this.buildUIAVInputAudioTestButton = UIAVInputViewStyles.buildUIAVInputAudioTestButton.bind(_this);
    this.buildUIAVInputDropdown = UIAVInputViewStyles.buildUIAVInputDropdown.bind(_this);
    this.buildUIAVInputEmptyDropdown = UIAVInputViewStyles.buildUIAVInputEmptyDropdown.bind(_this);
    this.buildUIAVInputDropdownOption = UIAVInputViewStyles.buildUIAVInputDropdownOption.bind(this);

    this.buildUIAudioInput = UIAudioInputStyles.buildUIAudioInput.bind(_this);

    //*** AD Blocker
    this.buildUIAdBlockerNotice = UIAdBlockerNoticeStyles.buildUIAdBlockerNotice.bind(_this);

    //*** Timer
    this.buildUITimer = UITimerStyles.buildUITimer.bind(_this);

    //*** Video Layout Object
    this.buildVideoInstructions = VideoInstructionsViewStyles.buildVideoInstructions.bind(_this);
    this.buildVideoChatZoneAVSettings = VideoChatZoneAVSettingsStyles.buildVideoChatZoneAVSettings.bind(_this);
    this.buildMediaAccessToastStyles = MediaAccessToastStyles.buildMediaAccessToastStyles.bind(_this);

    //*** Filled Button
    this.buildUIFilledButton = UIFilledButtonStyles.buildUIFilledButton.bind(_this);
    this.buildUIFilledButtonHover = UIFilledButtonStyles.buildUIFilledButtonHover.bind(_this);
    this.buildUIFilledButtonClick = UIFilledButtonStyles.buildUIFilledButtonClick.bind(_this);
    this.buildUIFilledButtonEnable = UIFilledButtonStyles.buildUIFilledButtonEnable.bind(_this);
    this.buildUIFilledButtonDisable = UIFilledButtonStyles.buildUIFilledButtonDisable.bind(_this);

    //*** Emotes
    this.buildUIEmotes = EmoteUIStyles.buildUIEmotes.bind(_this);
    this.buildUIEmotesItem = EmoteUIStyles.buildUIEmotesItem.bind(_this);

    //*** Camera View Toggle
    this.buildUICameraViewToggle = UICameraViewToggleStyles.buildUICameraViewToggle.bind(_this);
    this.cameraViewToggleActive = UICameraViewToggleStyles.cameraViewToggleActive.bind(_this);

    //*** Dropdown
    this.buildUIDropdown = UIDropdownStyles.buildUIDropdown.bind(_this);
    this.buildUIDropdownHeaderHover = UIDropdownStyles.buildUIDropdownHeaderHover.bind(_this);
    this.buildUIDropdownOption = UIDropdownStyles.buildUIDropdownOption.bind(_this);
    this.buildUIDropdownOptionHover = UIDropdownStyles.buildUIDropdownOptionHover.bind(_this);
    this.buildUIDropdownOptionState = UIDropdownStyles.buildUIDropdownOptionState.bind(_this);
    this.buildUIDropdownOpen = UIDropdownStyles.buildUIDropdownOpen.bind(_this);
    this.buildUIDropdownClose = UIDropdownStyles.buildUIDropdownClose.bind(_this);

    //*** Tutorial
    this.buildUITutorialView = UITutorialViewStyles.buildUITutorialView.bind(_this);

    //*** Tooltip
    this.buildUITooltip = UITooltipStyles.buildUITooltip.bind(_this);

    //*** Styleguide
    this.setStyleguide = function (styleguide) {
        _this.styleguide = styleguide;
    };

    this.setColors = function (colors) {
        _this.colors = colors;
    };
});

Class(function UIMovable(_config) {
    Inherit(this, AbstractDragUtil);
    
    const _this = this;
    var _input;

    var _xPos = 0;
    var _yPos = 0;
    var _targetWidth =0;
    var _targetHeight =0;
    var _targetX = 0;
    var _targetY = 0;

    //*** Constructor
    (function () {
        _this.object = _config.object;

        _this.gateFn = _config.gateFn;
        _this.maxHeight = _config.maxHeight || Stage.height;
        _this.maxWidth = _config.maxWidth || Stage.width; 
        _this.minWidth = _config.minWidth || 100; 
        _this.minHeight = _config.minHeight || 100; 
        _this.resizeEnabled = _config.resizeEnabled || true;
        _this.dragEnabled = _config.dragEnabled || true;

        _input = _this.initClass(Interaction, _this.object);
        _input.ignoreLeave = true;

        _targetWidth = _this.object.div.clientWidth;
        _targetHeight = _this.object.div.clientHeight;


        _xPos = 0;
        _targetX = _xPos;

        _yPos = 0;
        _targetY = _yPos;
        _this.initial = false;
        _this.dimensionsNeedUpdate = false;
        addListeners();
    })();
    

    function loop() {
        if(_this.dimensionsNeedUpdate && (_targetWidth != _this.object.div.clientWidth || _targetHeight != _this.object.div.clientHeight)) {
            _targetHeight = Math.lerp(_targetHeight, _this.object.div.clientHeight,1.);
            _targetWidth = Math.lerp(_targetWidth, _this.object.div.clientWidth, 1.);
            _this.object.css({
                width:_targetWidth,
                height:_targetHeight,
            })
        }else{
            if(_this.dimensionsNeedUpdate && !_this.isResizing) {
                _this.dimensionsNeedUpdate = false;
            }
        }
        
        if(_xPos != _targetX) {
            _xPos = Math.lerp(_targetX, _xPos,.3);
        }
        if(_yPos != _targetY) {
            _yPos = Math.lerp(_targetY, _yPos,.3);
        }

        if((Math.abs(_xPos -_targetX > .1) || Math.abs(_yPos -_targetY > .1))) {
            _this.object.transform({y:_yPos,x:_xPos })
        }

    }

    //*** Event handlers
    function addListeners() {
        _this.events.sub(_input, Interaction.START,onInteractionStart);   
        _this.events.sub(Mouse.input, Interaction.MOVE,onMove);     
        _this.events.sub(_input, Interaction.END, onInteractionEnd);  
    }

    function onInteractionStart(e) {
        if(_this.gateFn  == null || (_this.gateFn!= null && _this.gateFn())){

            _this.events.fire(AbstractDragUtil.CHANGE_START)

            _this.closestEdge(e,_this.object.div)
            _this.isDragging = (!_this.dMap.right && !_this.dMap.left && !_this.dMap.top && !_this.dMap.bottom) && _this.dragEnabled;
            _this.isResizing = !_this.isDragging && _this.resizeEnabled;;
    
            _this.pos.x = e.x;
            _this.pos.y = e.y;

   
         

            if(!_this.initial) {
                let rect = _this.object.div.getBoundingClientRect();
                let initialY = rect.top;
                let initialX = rect.left;
        
                _this.object.css({
                    willChange:'transform',
                    top:'unset',
                    left:'unset',
                    right:'unset',
                    bottom:'unset'
                }).transform({
                    x:initialX,
                    y:initialY
                }).tween({opacity:.5},400,'linear')
                _this.initial = true;
                if(_this.isResizing) {
                    _targetY = initialY;
                    _targetX = initialX;
                    _xPos = _targetX;
                    _yPos = _targetY;
                }
                _this.startRender(loop);
               
            }else{
                _this.object.tween({opacity:.5},400,'linear')
            }


            if(_this.isDragging) {
                startDrag(e);
             }
 
        }
    }

    function onMove(e) {
        if(_this.isDragging) {
            console.log(e)
            dragMove(e);
        }else if(_this.isResizing){
            resizeMove(e);
        }
    }

    function onInteractionEnd(e) {
        if(_this.isDragging) {
            endDrag();
        }else if(_this.isResizing){
            endResize();
        }

        _this.object.tween({opacity:1},400,'linear')
        _this.events.fire(AbstractDragUtil.CHANGE_END)
    }

    function startDrag(e) {
        let destinationX = e.x - _this.object.div.clientWidth/2.;
        let destinationY = e.y - _this.object.div.clientHeight/2.;
        _targetY = destinationY;
        _targetX = destinationX;
        _xPos = _targetX;
        _yPos = _targetY;
    }

    function dragMove(e) {
        let destinationX = e.x - _this.object.div.clientWidth/2.;
        let destinationY = e.y - _this.object.div.clientHeight/2.;
        if(destinationX >= 0 && destinationX < Stage.width && destinationY <= Stage.height && destinationY >= 0) {
           _this.pos.x = destinationX;
           _this.pos.y = destinationY;
           _targetY = destinationY;
           _targetX = destinationX;

        }
    }

    function endDrag() {
        _this.isDragging = false;
    }

    function resizeMove(e) {
        let dx = e.x - _this.pos.x ;
        let dy = _this.pos.y - e.y;
        _this.pos.x = e.x;
        _this.pos.y = e.y;

        if(_this.dMap.right || _this.dMap.left) {
            let nextTarget = _targetWidth + (dx * (_this.dMap.right ? 1 : -1));
            if(nextTarget < _this.maxWidth && nextTarget > _this.minWidth) {
                _targetWidth = nextTarget;
                if(_this.dMap.left) {
                    _targetX = _targetX + dx;
                }
            }
        }

        if(_this.dMap.top || _this.dMap.bottom) {
            let nextTarget = _targetHeight + (dy * (_this.dMap.top ? 1 : -1));
            if(nextTarget < _this.maxHeight && nextTarget > _this.minHeight) {
                _targetHeight = nextTarget;
                _targetY = _targetY - dy;
            }
        }

        _this.events.fire(UIMovable.RESIZE, {width: _targetWidth, height: _targetHeight});

        _this.dimensionsNeedUpdate = true;
    }

    function endResize() {
        _this.isResizing = false;
    }



    
    //*** Public methods
    
},()=>{
    UIMovable.RESIZE = 'UIMovable_resize';
});
Class(function UIResizable(_config) {
    Inherit(this, AbstractDragUtil);
    
    const _this = this;
    var _input;

    var _xPos = 0;
    var _yPos = 0;
    var _targetWidth =0;
    var _targetHeight =0;
    var _targetX = 0;
    var _targetY = 0;

    //*** Constructor
    (function () {
        _this.object = _config.object;

        _this.gateFn = _config.gateFn;
        _this.maxHeight = _config.maxHeight || Stage.height;
        _this.maxWidth = _config.maxWidth || Stage.width; 
        _this.minWidth = _config.minWidth || 100; 
        _this.minHeight = _config.minHeight || 100; 
        _this.isEmit = _config.isEmit || false;
        _this.enabledDirections = _config.enabledDirections || {left:1, right:1, top:1, bottom:1}

        _input = _this.initClass(Interaction, _this.object);
        _input.ignoreLeave = true;

        _targetWidth = _this.object.div.clientWidth;
        _targetHeight = _this.object.div.clientHeight;

        _xPos = 0;
        _targetX = _xPos;

        _yPos = 0;
        _targetY = _yPos;
        _this.initial = false;
        _this.dimensionsNeedUpdate = false;
        addListeners();
    })();
    

    function loop() {
        if(_this.dimensionsNeedUpdate && (_targetWidth != _this.object.div.clientWidth || _targetHeight != _this.object.div.clientHeight)) {
            _targetHeight = Math.lerp(_targetHeight, _this.object.div.clientHeight,1.);
            _targetWidth = Math.lerp(_targetWidth, _this.object.div.clientWidth, 1.);
            if(!_this.isEmit) {
                _this.object.css({
                    width:_targetWidth,
                    height:_targetHeight,
                })
            }
            _this.events.fire(UIResizable.RESIZE, {width: _targetWidth, height: _targetHeight});
           
        }else{
            if(_this.dimensionsNeedUpdate && !_this.isResizing) {
                _this.dimensionsNeedUpdate = false;
            }
        }
    }

    //*** Event handlers
    function addListeners() {
        _this.events.sub(_input, Interaction.START,onInteractionStart);   
        _this.events.sub(Mouse.input, Interaction.MOVE,onMove);     
        _this.events.sub(_input, Interaction.END, onInteractionEnd);  
    }

    function onInteractionStart(e) {
        if(_this.gateFn  == null || (_this.gateFn != null && _this.gateFn())){

            _this.events.fire(AbstractDragUtil.CHANGE_START)

            _this.closestEdge(e,_this.object.div)
            _this.isDragging = (!_this.dMap.right && !_this.dMap.left && !_this.dMap.top && !_this.dMap.bottom)
            _this.isResizing = !_this.isDragging;
    
            _this.pos.x = e.x;
            _this.pos.y = e.y;
                                           
             _this.startRender(loop);
 
        }
    }

    function onMove(e) {
        if(_this.isResizing) {
            resizeMove(e);
        }
    }

    function onInteractionEnd(e) {
        endResize();

        _this.object.tween({opacity:1},400,'linear')
        _this.events.fire(AbstractDragUtil.CHANGE_END)
    }

    function resizeMove(e) {
        let dx = e.x - _this.pos.x ;
        let dy = _this.pos.y - e.y;
        _this.pos.x = e.x;
        _this.pos.y = e.y;

        if((_this.dMap.right && _this.enabledDirections.right)|| (_this.dMap.left && _this.enabledDirections.left)) {
            let nextTarget = _targetWidth + (dx * (_this.dMap.right ? 1 : -1));
            if(nextTarget < _this.maxWidth && nextTarget > _this.minWidth) {
                _targetWidth = nextTarget;
            }
        }

        if((_this.dMap.top && _this.enabledDirections.top) || (_this.dMap.bottom && _this.enabledDirections.bottom)) {
            let nextTarget = _targetHeight + (dy * (_this.dMap.top ? 1 : -1));
            if(nextTarget < _this.maxHeight && nextTarget > _this.minHeight) {
                _targetHeight = nextTarget;
            }
        }

        _this.dimensionsNeedUpdate = true;
    }

    function endResize() {
        _this.isResizing = false;
    }



    
    //*** Public methods
    
},()=>{
    UIResizable.RESIZE = 'UIResizable_resize';
});
/**
 * @namespace UIStylingUtils
 */
Class(function UIStylingUtils() {
    Inherit(this, Component);

    /**
     * @method makeElementsRelative
     * @memberOf StylingUtils
     * Styles root DOM element and all [Hydra] children
     * position: relative
     * 
     * Best used on small chunks of DOM, like a container
     * with 4 children that all need to be relative
     */
    this.makeElementsRelative = $root => {
        $root.css({position: 'relative',});
        $root.children(true).forEach($child => this.makeElementsRelative($child));
    }

}, 'static');
Class(function UIAdBlockerNotice() {
    Inherit(this, Element);
    const _this = this;
    const $this = _this.element;
    var $close, $icon, $title, $description, $button;
    
    //*** Constructor
    (function () {
         initHTML();
         initStyles();
         addListeners();
    })();
    
    function initHTML() {    
        $icon = $this.create('UIAdBlockerNotice__icon');

        $title = $this.create('UIAdBlockerNotice__title','h4');
        $title.text('Turn off adblocker');
        
        $description = $this.create('UIAdBlockerNotice__desc','p');
        $description.text('Your adblocker blocks WebSockets which are key to the experience. Please disable your adblocker and refresh the page to continue.');

        $button = $this.create('UIAdBlockerNotice__button','button');
        $button.text('Refresh page');
    }

    function initStyles() {
        CoreUIState.instance().uiBuilder.buildUIAdBlockerNotice({
            $container:$this,
            $icon,
            $title,
            $description
        })

        $button.css({
            width:'fit-content'
        })
        CoreUIState.instance().uiBuilder.buildTextButton($button);
    }

    function addListeners() {
        $button.interact(hover, ()=>{
            location.reload()
        },'#','Refresh')
    }

    function hover(e){
        if(e.action == 'over') {
            CoreUIState.instance().uiBuilder.textButtonHover($button);
        }else{
            CoreUIState.instance().uiBuilder.buildTextButton($button);
        }
    }
    
    //*** Event handlers
    
    //*** Public methods
    
});
Class(function UIAdBlockerNoticeStyles() {
    Inherit(this, Component);

    this.buildUIAdBlockerNotice = function (elements) {
        let { $container, $icon, $title, $description } = elements;

        $container.css({
            display: 'grid',
            gridAutoRows: 'min-content',
            gridGap: '1rem',
            position: 'relative',
            padding: '3rem',
            background: 'white',
            width: '45rem',
            justifyItems: 'center',
        });

        this.buildMaskIcon($icon, '~assets/images/icon/warning.svg', '5rem', '5rem', this.colors.off);
        
        $icon.css({
            marginBottom: '2rem',
        });

        $title.css(this.styleguide.h2);
        $title.css({
            color: '#354253',
            textAlign: 'center',
            marginBottom: '1rem',
        });

        $description.css(this.styleguide.p1);
        $description.css({
            color: '#6D7278',
            textAlign: 'center',
            marginBottom: '2rem',
        });
    };
}, 'static');

Class(function UIAllowVideoNotice({
    styles = {}
}) {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    const $this = _this.element;
    let $title, $content;

    //*** Constructor
    (async function () {
        await UIAllowVideoNoticeStyles.ready();
        initHTML();
        initStyles();
        _this.flag('isReady', true);
    })();

    function initHTML() {
        $content = $this.create(_this.getPrefix('content'));
        $title = $content.create(_this.getPrefix('title'), 'h4');
    }

    function initStyles() {
        $this.css(_this.combineStyles([UIAllowVideoNoticeStyles.element, styles.element]));
        $content.css(_this.combineStyles([UIAllowVideoNoticeStyles.content, styles.content]));
        $title.css(_this.combineStyles([UIAllowVideoNoticeStyles.title, styles.title]));
    }

    _this.setText = async text => {
        await _this.wait('isReady');
        $title.text(text);
    };

    _this.setStyles = newStyles => {
        if (newStyles.element) $this.css(newStyles.element);
        if (newStyles.content) $content.css(newStyles.content);
        if (newStyles.title) $title.css(newStyles.title);
    };
});

Class(function UIAllowVideoNoticeStyles() {
    Inherit(this, Component);
    const _this = this;

    (async function() {
        await DreamStyleguide.instance().ready();
        await DreamColors.instance().ready();

        _this.element = {
            position: 'relative',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            background: DreamColors.instance().gray800,
            width: '100%',
            height: '100%',
            margin: '2rem',
            maxHeight: 389,
            maxWidth: 692
        };

        _this.content = {
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            textAlign: 'center',
            width: '80%',
            maxWidth: '45rem',
            background: DreamColors.instance().white,
            borderRadius: 8,
            height: '100%',
            maxHeight: '22rem',
            padding: '2rem'
        };

        _this.title = {
            ...DreamStyleguide.instance().label5,
            maxWidth: '30rem',
            position: 'relative',
            color: DreamColors.instance().black
        };

        _this.flag('isReady', true);
    }());

    _this.ready = _ => _this.wait('isReady');
}, 'static');

Class(function UIModalController() {
    Inherit(this, Element);
    const _this = this;
    var $this;
    var _view;
    var _currOptions = {};
    //*** Constructor
    (function () {
        initHTML();
        initView();
        addListeners();
    })();

    function initHTML() {
        $this = _this.element;
        $this.mouseEnabled(true);
        $this.css({
            left: 0,
            top: 0,
            display: 'none',
            position: 'absolute'
        });
        $this.size('100%');
    }

    function initView() {
        _view = _this.initClass(UIModalView, _this);
    }

    //*** Event handlers

    function addListeners() {
        _this.events.sub(Keyboard.UP, keyUp);
    }

    function keyUp(e) {
        switch (e.key) {
            case 'Escape': {
                if (_this.flag('isOpen') || !_currOptions.disableClose) {
                    _this.closeModal();
                }
            }
        }
    }
    //*** Public methods
    this.openModal = function (Class, _options = {}) {
        UIController.instance().element.div.classList.add('prevent_interaction3d');
        UIController.instance().element.div.classList.add('prevent_interactionScroll');

        $this.css({ display: 'block' });

        const { resolve, reject, promise } = DeferredPromise();
        let options = Object.assign(_options, { onComplete: resolve, onReject: reject });
        _currOptions = options;
        _this.flag('isOpen', true);
        _view.openModal(Class, options);
        return promise;
    };

    this.replaceModal = async function(Class, _options = {}) {
        await _view.closeModal();

        _this.openModal(Class, _options);
    };

    this.closeModal = async function () {
        UIController.instance().element.div.classList.remove('prevent_interaction3d');

        _this.flag('isOpen', false);
        _view.closeModal();
    };
});

Class(function UIModalView($parent) {
    Inherit(this, Element);
    const _this = this;
    const $this = _this.element;
    var $content, $back, $injectedElement;
    const _prefix = 'Modal';
    var _currOptions = {};
    var _isOpen = false;
    const focusableElements = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
    var _firstFocusableElement, _focusableContent, _lastFocusableElement;
    var _isFocused = false;
    //*** Constructor
    (function () {
        initHTML();
        addListeners();
    })();

    function initHTML() {
        $this.css({
            height: '100vh',
            width: '100vw',
            display: 'none',
            justifyContent: 'center',
            alignItems: 'center',
            opacity: 0,
            position: 'absolute',
            zIndex: 100000
        });

        $content = $this.create(`${_prefix}__content`);
        $content.css({
            height: '100%',
            width: '100%',
            maxHeight: '100vh',
            overflow: 'auto',
            position: 'relative',
            boxShadow: '0 5px 35px rgba(0,0,0,0.25)',
            zIndex: 12,
            justifyContent: 'center',
            alignItems: 'center'
        });

        $back = $this.create(`${_prefix}__modal__back`);
        $back.css({
            height: '100%',
            width: '100%',
            opacity: 0,
            background: '#222222',
            zIndex: 11,
            display: 'none',
            visibility: 'hidden',
            position: 'absolute'
        });
        $back.interact(null, () => {
            if (!_currOptions.disableClose) {
                _this.parent.closeModal();
            }
        });
    }

    this.openModal = function (Class, _options = {}) {
        _options = {
            ..._options,
            disableBoxShadow: true
        };

        $this.css({
            display: 'flex'
        });

        if ($injectedElement) {
            $injectedElement.destroy();
            $injectedElement = null;
        }
        let options = Object.assign(_options, { inModal: true, modal: _this });
        _currOptions = options;

        if (_currOptions.isLocal) {
            $this.css({
                height: '100%',
                width: '100%'
            });
        } else if (_currOptions.css) {
            $this.css(_currOptions.css);
        } else {
            $this.css({
                height: '100vh',
                width: '100vw'
            });
        }

        if (_currOptions.maxHeight) {
            $content.css({
                maxHeight: _currOptions.maxHeight
            });
        } else {
            $content.css({
                maxHeight: '100vh'
            });
        }

        if (_currOptions.contentHeight) {
            $content.css({
                height: _currOptions.contentHeight
            });
        }

        if (_currOptions.contentWidth) {
            $content.css({
                width: _currOptions.contentWidth
            });
        }

        if (_currOptions.disablePlayerControls) {
            _this.events.fire(PlayerControls.ENABLE_STATE_CHANGE, { enabled: false });
        }

        if (_currOptions.disableBoxShadow) {
            $content.css({
                boxShadow: 'unset'
            });
        } else {
            $content.css({
                boxShadow: '0 5px 35px rgba(0,0,0,0.25)'
            });
        }

        $injectedElement = _this.initClass(Class, options, [$content]);
        $this.tween({ opacity: 1 }, 300, 'easeOutSine');

        if ($injectedElement && $injectedElement.animateIn) {
            $injectedElement.animateIn();
        }

        if (!_currOptions.hideBack) {
            if (_currOptions.bgColor) {
                $back.css({ background: _currOptions.bgColor });
            }
            _this.delayedCall(() => {
                $back.css({ opacity: 0, visibility: 'visible', display: 'block' }).tween({ opacity: _currOptions.bgColor ? 1 : 0.7 }, 300, 'easeOutSine', 0);
            }, 50);
        }

        let { parent } = _currOptions;
        let parentBounds = parent && parent.div.getBoundingClientRect();
        let y = parent ? (parentBounds.top + parentBounds.height / 2) - window.innerHeight / 2 : 0;

        $content.css({ opacity: 0, display: 'flex', visibility: 'visible' });
        $content.transform({ scale: 0.85, y });
        $content.tween({ opacity: 1, y: 0, scale: 1 }, 700, 'easeOutCubic', 0, () => {
        });

        _isOpen = true;
        _this.events.fire(UIModalView.OPEN);

        _this.delayedCall(() => {
            if ($injectedElement) {
                _focusableContent = $injectedElement.element.div.querySelectorAll(focusableElements);
                _firstFocusableElement = _focusableContent[0];
                _lastFocusableElement = _focusableContent[_focusableContent.length - 1]; // get last element to be focused inside modal
            }
        }, 100);
    };

    this.closeModal = function() {
        _isOpen = false;
        _isFocused = false;
        _firstFocusableElement = null;
        _lastFocusableElement = null;
        _focusableContent = [];
        _this.events.fire(UIModalView.CLOSE);

        if (_currOptions.disablePlayerControls) {
            _this.events.fire(PlayerControls.ENABLE_STATE_CHANGE, { enabled: true });
        }

        if ($injectedElement) {
            $injectedElement.animateOut && $injectedElement.animateOut();
            $injectedElement.destroy && $injectedElement.destroy();
            $injectedElement = null;
        }

        $content.tween({ scale: 0.95, opacity: 0 }, 400, 'easeOutCubic', 0, () => {
            $content.css({ visibility: 'hidden', display: 'none' });
        });

        $back.tween({ opacity: 0 }, 300, 'easeOutCubic', 0, () => {
            $back.css({
                display: 'none'
            });
        });

        return $this.tween({ opacity: 0 }, 400, 'easeOutSine', _ => {
            $this.css({ display: 'none' });
            $parent.element.css({ display: 'none' });
        }).promise();
    };

    function addListeners() {
        _this.events.sub(Keyboard.DOWN, keyDown);
    }


    function keyDown(e) {
        let isTabPressed = e.key === 'Tab' || e.keyCode === 9;

        if (!_isOpen || !isTabPressed) {
            return;
        }
        if (!_isFocused && _firstFocusableElement) {
            _firstFocusableElement.focus();
            e.preventDefault();
            _isFocused = true;
        }
    }
}, _ => {
    UIModalView.OPEN = 'UIModalView_open';
    UIModalView.CLOSE = 'UIModalView_close';
});

Class(function AbstractNavDrawer() {
    Inherit(this, Element);
    const _this = this;
    //*** Event handlers

    //*** Public methods
    this.hide = async function(delay) {
        //animation to hide
        console.warn('AbstractNavDrawer::hide not implemented');
    }

    this.registerClass = async function(delay) {
        //Register view to show when opened
        console.warn('AbstractNavDrawer::registerClass not implemented');
    }
});
/*
    Config may have data for the following:

         parent - the parent element of the container
        
         showBackdrop - boolean to denote whether or not a backdrop is visible when the menu is expanded

         closeOnBackdropClick - boolean to denote to collapse when backdrop is clicked


*/

Class(function UIExpandingNavDrawerController(_config) {
    Inherit(this, AbstractNavDrawer);
    const _this = this;
    var $this;
    var $content,$view,$backdrop;

    var _innerView;
    
    var _expanded = false;

    //*** Constructor
    (function () {
        initHTML();
        if(_config.showBackdrop){
            createBackdrop();
        }
        createIcon();
        createContentContainer();
        addListeners();
    })();

    function initHTML() {
        $this = _this.element;
        $this.css({
            position:'relative',
            display:'flex',
            flexDirection:"column",
            borderRadius:'50%',
            boxShadow: '0px 4px 20px rgba(0,0,0,0.2)',
        })
    }   

    function createBackdrop(){
        $backdrop = _config.parent.create('Backdrop');
        $backdrop.css({
            top:0,
            width:0,
            height:'100%',
            width:'100%',
            background:'rgba(0,0,0,.5)',
            zIndex:-1,
            opacity:0
        })
        if(_config.closeOnBackdropClick){
            $backdrop.interact(null,()=>{
                collapse()
            })
        }
    }

    function createIcon() {
        $view = $this.create('Icon')
        $view.css({
            padding:'1.5rem',
            position:'relative',
            width:'fit-content',
            height:'fit-content',
            cursor:'pointer',
            marginLeft:'auto'
        });
        let image = $view.create(`Icon__image`);
        CoreUIState.instance().uiBuilder.buildMaskIcon(image,'~assets/images/icon/menu.svg','1.5rem','1.5rem',AppStyleController.colors.primary[0]);
    }

    function createContentContainer() {
        $content = $this.create("content");
        $content.css({
            opacity:0,
            position:'relative',
            overflow:'hidden',
            transformOrigin:'left bottom',
            width:0,
            height:0,
            transition:'border-radius .2s ease'
        })
    }

    function expand() {
        if($backdrop){
            $backdrop.css({zIndex:1});
            $backdrop.tween({opacity:1},300,'easeOutCubic');
        }
        const target = _innerView.element.div;
        let paddingLeft = parseFloat(window.getComputedStyle(target, '').getPropertyValue('padding-left'));
        let paddingRight = parseFloat(window.getComputedStyle(target, '').getPropertyValue('padding-right'));
        let paddingTop = parseFloat(window.getComputedStyle(target, '').getPropertyValue('padding-left'));
        let paddingBottom = parseFloat(window.getComputedStyle(target, '').getPropertyValue('padding-right'));
        _innerView.element.tween({opacity:1},600,'easeOutCubic',200)
        $content.tween({width:target.clientWidth + paddingLeft + paddingRight,height:target.clientHeight + paddingTop + paddingBottom,opacity:1},600,'easeOutCubic')
        $this.tween({borderRadius:'2rem'},600,'easeOutCubic')
    }

    function collapse() {
        if($backdrop){
            $backdrop.tween({opacity:0},300,'easeOutCubic',()=>{
                $backdrop.css({zIndex:-1});
            });
        }
        _innerView.element.tween({opacity:0},300,'easeOutCubic',()=>{
            $this.tween({borderRadius:'50%'},200,'easeOutCubic')
        })
        $content.tween({width:0,height:0,opacity:0},400,'easeOutCubic',0)
    }

    //*** Event handlers
    function click() {
        _expanded = !_expanded;
        if(_expanded) {
            expand()
        }else {
            collapse();
        }

        // _this.events.fire(PlayerControls.ENABLE_STATE_CHANGE,{isEnabled:false});
    }
    
    function addListeners() {
        $this.interact(null,click);
        _this.onResize(resize);
    }

    function resize() {

    }
    //*** Public methods
    this.registerClass = function(Class) {
        _innerView = _this.initClass(Class,[$content]);
    }
    this.hide = function() {
        $content.tween({x:'-100%',y:'-50%'},600,'easeInOutCubic')
        // _this.events.fire(PlayerControls.ENABLE_STATE_CHANGE,{isEnabled:true});

    }
});
Class(function UINavDrawerController(_config) {
    Inherit(this, AbstractNavDrawer);
    Inherit(this, AbstractUIComponent);

    const _this = this;
    var $this;
    var $content, $view;
    var _innerView;

    _this.direction = "left";
    //*** Constructor
    (function () {
        _this.parseConfig(_config);
        initHTML();
        addListeners();
    })();

    function initHTML() {
        $this = _this.element;
        $this.css({
            position:'relative'
        })

        let hover = !_config.preventHover ? onHover : false
        $view = _this.initClass(UIButton,
            {
                imageColor: _this.color,
                image:'~assets/images/icon/menu.svg',
                action:click,
                onHover: hover,
                toolTipText:null
            },
        [$this]);
        $view.element.tabIndex('0');
        $content = UIController.instance().layout.primaryContentArea.create('Content');
        $content.css({
            display:'block',
            top:'50%',
            left: 0,
            zIndex:100000,
            visibility:'hidden'
        })

        if(_this.direction == 'left'){
            $content.transform({x:"-100%",y:'-50%'});
        }else{
            $content.css({right:0});
            $content.transform({x:"100%",y:'-50%'});
        }
    }

    //*** Event handlers
    function click() {
        $content.css({
            display:'block',
            visibility:'visible'
        })

        $content.tween({x:'0%',y:'-50%'},500,'easeOutCubic');

        if(_innerView.animateIn){
            _innerView.animateIn();
        }

        _this.events.fire(UINavDrawerController.OPEN);
    }

    function onHover (e) {
        switch (e.action) {
            case 'over': _this.events.fire(UINavDrawerController.OVER); break;
            case 'out': _this.events.fire(UINavDrawerController.OUT); break;
        }
    }

    function addListeners() {
        _this.onResize(resize);
    }


    function resize() {

    }

    //*** Public methods
    this.registerClass = function(Class) {
        _innerView = _this.initClass(Class,{parent:_this},[$content]);
    }

    this.open = click;

    this.hide = function() {
        if(_this.direction == 'left') {
            $content.tween({x:'-100%',y:'-50%'},1100,'easeOutCubic',()=>{
                $content.css({
                    display:'none',
                    visibility:'hidden'
                })
            })
        }else{
            $content.tween({x:'100%',y:'-50%'},1100,'easeOutCubic',()=>{
                $content.css({
                    display:'none',
                    visibility:'hidden'
                })
            })
        }




        if(_innerView.animateOut){
            _innerView.animateOut();
        }

        // _this.events.fire(PlayerControls.ENABLE_STATE_CHANGE,{isEnabled:true});
        _this.events.fire(UINavDrawerController.CLOSE);
    }
}, _ => {
    UINavDrawerController.OVER = 'UINavDrawerController_over';
    UINavDrawerController.OUT = 'UINavDrawerController_out';
    UINavDrawerController.OPEN = 'UINavDrawerController_open';
    UINavDrawerController.CLOSE = 'UINavDrawerController_close';
});
Class(function TestLayout() {
    Inherit(this, Element);
    const _this = this;
    const $this = _this.element;
    const navItems = ["Home","Contact","Images","FAQ"];
    //*** Constructor
    (function () {
         initHTML();
    })();
    
    function initHTML() {
        $this.css({
            position:'relative',
            display:'grid',
            gridAutoRows:'min-content',
            minWidth:'20vw',
            justifyContent:'center',
            gridGap:'1rem',
            padding:'4rem'
        })

        for(let item of navItems){
            createNavItem(item);
        }
        
    }
    function createNavItem(text){
        let item = $this.create('Item');
        item.css({
            position:'relative',
        })
        item.text(text);
        item.css(UIController.instance().h3)
    }

    
    //*** Event handlers
    
    //*** Public methods
    
});
Class(function TestLayout2() {
    Inherit(this, Element);
    const _this = this;
    const $this = _this.element;
    const navItems = ["Home","Contact","Images","FAQ"];
    //*** Constructor
    (function () {
         initHTML();
    })();
    
    function initHTML() {
        $this.css({
            position:'relative',
            display:'grid',
            gridAutoRows:'min-content',
            minWidth:'20vw',
            justifyContent:'center',
            gridGap:'1rem',
            padding:'4rem'
        })

        let item = $this.create('Item');
        item.css({
            position:'relative',
        })
        item.text("Heading");
        item.css(CoreUIState.instance().styleguide.h3)

        let paragraph = $this.create('paragraph');
        paragraph.css({
            position:'relative',
        })
        paragraph.text(`Nulla feugiat sem vitae massa hendrerit porta. Maecenas dictum massa ac tincidunt sollicitudin. 
        Ut lobortis fermentum nunc, sed dictum augue condimentum id. Vestibulum euismod, lorem sed mattis consectetur, sem purus sodales magna, 
        non ultrices nisi metus et ante. Nunc tincidunt maximus mauris sed lobortis. Praesent sit amet eros id purus varius lobortis eu quis augue. 
        Nam rhoncus nec dui at tincidunt. Vestibulum sodales rutrum justo. Nulla erat libero, bibendum et odio non, fringilla imperdiet nunc. 
        Integer maximus dignissim lacus, vel fermentum odio faucibus a. Cras mattis, augue vitae tincidunt vestibulum, urna diam auctor neque, non pretium sapien lectus sit amet urna. Sed quis nunc turpis.
        Quisque condimentum diam in convallis faucibus. Morbi pellentesque augue sem, id finibus lectus condimentum non. Morbi felis sem, tempor nec velit vitae, eleifend ornare nunc. 
        Nullam condimentum odio justo.`);
        paragraph.css(CoreUIState.instance().styleguide.p1)
    }

    
    //*** Event handlers
    
    //*** Public methods
    
});
Class(function UIParticipantsController() {
    Inherit(this, Element);
    const _this = this;
    var $this;
    var _view;
    var _players = new Map();

    //*** Constructor
    (function () {
        initHTML();
        initView();
        addListeners();
    })();

    function initHTML() {
        $this = _this.element;
        $this.css({
            position:'relative'
        })
    }

    function initView() {
        _view = _this.initClass(UIParticipantsView);
    }

    //*** Event handlers
    function addListeners() {
        _this.events.sub(Player.JOIN, playerJoin);
        _this.events.sub(Player.LEAVE, playerLeave);
        _this.events.sub(Keyboard.DOWN, keyPress);
        _this.events.sub(Mouse.input,Interaction.START, handleClick);
    }

    function playerJoin(e) {
        _players.set(e.player.state.get("uid"),e.player);
        _view.addUserToList(e.player);
    }

    function playerLeave(e) {
        _players.delete(e.player);
        _view.removeUserFromList(e.player);
    }

    function keyPress(e) {
        switch (e.key) {
            case 'Escape':{
                _view.hide();
            }
        }
    }

    function handleClick(e) {
        _view.hide();  
    }

    //*** Public methods

});
Class(function UIParticipantsView() {
    Inherit(this, Element);
    const _this = this;
    const $this = _this.element
    const _prefix = 'UIParticipantsView';
    var $header,$body,$icon,$mobileDrawer,$mobileBody, $numOfPeople, $numOfPeopleMobile, $notification;
    var _isExpanded,_isMobile = false;
    var _players = {};

    //*** Constructor
    (function () {
        initHTML();
        $header = createHeader($this);
        createBody();
        createMobileBody();
        createNotification();
        addListeners();
    })();

    function initHTML() {
        CoreUIState.instance().uiBuilder.buildUIParticipantsContainer($this)   
    }

    function createHeader(parent,isMobile = false) {
        let header = parent.create(`${_prefix}__header`);
        let icon = header.create(`${_prefix}__icon`,'div');
        let numPeople = header.create(`${_prefix}__num`,'p');
        CoreUIState.instance().uiBuilder.buildUIParticipantsHeader({header,icon,numPeople,$numOfPeopleMobile},isMobile);
        if(isMobile){
            $numOfPeopleMobile = numPeople;
        }else{
            $numOfPeople = numPeople;
            $icon = icon
        }
        return header;
    }

    function createBody() {
        $body = $this.create(`${_prefix}__body`);
        $body.inner = $body.create('inner');
        $body.inner.css({ position: 'relative' });
        CoreUIState.instance().uiBuilder.buildUIParticipantsBody($body)
    }

    function createMobileBody() {
        $mobileDrawer = _this.parent.element.create(`${_prefix}__mobile-drawer`);
        let $mHeader = $mobileDrawer.create(`${_prefix}__mobile-drawer__header`);
       
        createHeader($mHeader,true);

        let $mHeaderClose = $mHeader.create(`${_prefix}__mobile-drawer__close`);
        $mHeaderClose.interact(null,onClick)
        $mobileBody = $mobileDrawer.create(`${_prefix}__mobile-drawer__body`);

        CoreUIState.instance().uiBuilder.buildUIParticipantsMobileBody({
            mobileDrawer:$mobileDrawer,
            mHeader:$mHeader,
            mHeaderClose:$mHeaderClose,
            mobileBody:$mobileBody
        })
    }

    function createNotification() {
        $notification = _this.parent.element.create(`${_prefix}__notification`);
        CoreUIState.instance().uiBuilder.buildUIParticipantsNotification($notification);
    }

    function addUser(user,parent) {
        const isCurrentPlayer = user.state.get("uid") == PlayerModel.get("uid");

        let userItem = parent.create(`${_prefix}__body__item`,'div');
        if(!isCurrentPlayer){
            userItem.interact(onUserHover, null);
        }
   
        let $dot = userItem.create(`${_prefix}__body__item__dot`);
        let $name = userItem.create(`${_prefix}__body__item__name`);
        let $actions = userItem.create(`${_prefix}__body__item__actions`);
        let $chatIcon = $actions.create(`${_prefix}__body__item__action`);
        let $locationIcon = $actions.create(`${_prefix}__body__item__action`);

        CoreUIState.instance().uiBuilder.buildUIParticipantsUserItem({
            userItem,
            dot:$dot,
            name:$name,
            actions:$actions,
            chatIcon:$chatIcon,
            locationIcon:$locationIcon
        },user)

        _players[user.state.get("uid")].push(userItem);
    }
    function resetHeader() {
        $header.css({
            background:'white'
        })
        $icon.css({
            background:AppStyleController.colors.primary[0]
        })
        $numOfPeople.css({
            color:AppStyleController.colors.primary[0]
        })
    }

    //*** Event handlers
    function addListeners(){
        $header.interact(onHover, onClick);
        $body.interact(null,(e)=>{
            e.preventDefault();
        })
        _this.onResize(resize);

    }

    function resize() {
        hideAll()
        const size = Breakpoints.getSize();
        switch (size) {
            case 'big-desktop':
            case 'desktop':
            case 'tab-land':
            case 'tab-port':{
                $notification.transform({x:'calc(-100% - 2rem)'})
                $notification.css({
                    padding:'1.5rem 2rem',
                    right:'unset',
                    left:0
                })
                $header.css({
                    padding:'1.5rem 2rem',
                    gridGap:'.5rem',
                    gridAutoColumns:'min-content'
                })
                $body.css({
                    padding:'0rem 6rem 0rem 2rem'
                })
                $this.css({
                    overflow:'hidden'
                })
                _isMobile = false;
                break;
            }
            case 'phone':{
                $notification.transform({x:0})
                $notification.css({
                    padding: '1rem',
                    right:0,
                    left:'unset'
                })
                $header.css({
                    padding: '1rem',
                    gridGap:0,
                    gridAutoColumns:'min-content'
                })
                $body.css({
                    padding:'0rem'
                })
                _isMobile = true;
                break;
            }
            default:
                break;
        }
    }
    function onUserHover(e) {
        e.object._children.last.tween({
            opacity: e.action == 'over' ? 1 : 0
        }, 500, 'easeOutQuad', 0);

    }
    function onClick(e) {
        _isExpanded = !_isExpanded;
        if(_isExpanded){
            resetHeader();
            if(!_isMobile){
                revealLarge(e)
            }else{
                revealMobile()
            }
        }else{
            if(!_isMobile){
                hideLarge(e)
            }else{
                hideMobile()
            }
        }
    }
    function onHover(e) {
        if(!_isExpanded){
            switch(e.action){
                case 'over':{
                    $header.css({
                        background:AppStyleController.colors.primary[0]
                    })
                    $icon.css({
                        background:'white'
                    })
                    $numOfPeople.css({
                        color:'white'
                    })
                    break;
                }
                case 'out':{
                    resetHeader()
                    break;
                }
            }
        }

    }
    function hideAll() {
        _isExpanded = false;
        hideMobile();
        hideLarge();
    }
    function revealMobile() {
        if(_isExpanded){
            $mobileDrawer.tween({y:'0%'},500,'easeOutQuad')
        }else{
            $mobileDrawer.tween({y:'200'},500,'easeOutQuad')
        }
    }

    function revealLarge(e) {
        let target = $body;
        if(_isExpanded){
            let child = target._children.first.div;
            let paddingLeft = parseFloat(window.getComputedStyle(target.div, '').getPropertyValue('padding-left'));
            let paddingRight = parseFloat(window.getComputedStyle(target.div, '').getPropertyValue('padding-right'));
            let totalWidth = child.clientWidth + paddingLeft + paddingRight;
            totalWidth = Math.max(totalWidth, 300);
            $header.css({
                gridAutoColumns:'min-content'
            })
            target._parent.tween({
                paddingBottom:'2rem'
            },100,'easeOutCubic');

            $body.inner.tween({ opacity: 1 }, 200, 'easeOutSine', 400);
            target.tween({
                width:totalWidth,
                height: Stage.height/4,
                opacity:1,
                marginTop:'1rem',
            }, 600, 'easeOutCubic');
        }else{
            hideLarge();
        }
    }

    function revealNotification(user) {
        const size = Breakpoints.getSize();
        let targetX = 'calc(-100% - 2rem)'
        let targetY = '0';
        let startY = 25;
        if(size == 'phone'){
            targetX = '0';
            targetY = 'calc(100% + 2rem)';
            startY = 100;
        }

        $notification.transform({x:targetX,y:startY})
        $notification.css({opacity:0});
        $notification.text(user.state.get("name") + " just joined")
        $notification.tween({opacity:1,y:targetY,x:targetX},1000,'easeOutQuad',()=>{
            $notification.tween({opacity:0,y:targetY,x:targetX},1000,'easeOutQuad',500)
        })
    }
    function hideMobile() {
        $mobileDrawer.tween({y:'-200%'},500,'easeOutQuad')
    }
    function hideLarge() {
        let target = $body;

        _this.delayedCall(_ => {
            $header.css({
                gridAutoColumns:'unset'
            });
        }, 600);

        target._parent.tween({
            paddingBottom:'0rem',
        },600,'easeOutCubic');

        $body.inner.tween({ opacity: 0 }, 50, 'easeOutSine');

        target.tween({
            height: 0,
            width:0,
            opacity:0,
            marginTop:'0'
        }, 600, 'easeOutCubic');
    }
    //*** Public methods
    this.addUserToList = function (e) {
        revealNotification(e)
        _players[e.state.get("uid")] = [];
        addUser(e,$body.inner);
        addUser(e,$mobileBody);
        $numOfPeople.text("+"+Object.keys(_players).length)
        $numOfPeopleMobile.text("+"+Object.keys(_players).length)

    }
    this.removeUserFromList = function (e) {
        let elements = _players[e.state.get("uid")];
        if(elements){
            for(let element of elements){
                element.destroy();
            }
        }
        delete _players[e.state.get("uid")];
        $numOfPeople.text("+"+Object.keys(_players).length)
    }
    this.hide = function() {
        hideAll();
    }
});
Class(function UIParticipantsViewStyles() {
    Inherit(this, Component);

    this.buildUIParticipantsContainer = function (container) {
        container.css({
            position: 'relative',
            display: 'flex',
            flexDirection: 'column',
            background: 'white',
            width: 'fit-content',
            gridGap: '2rem',
            cursor: 'pointer',
            overflow: 'hidden',
            boxShadow: '0px 4px 20px rgba(0,0,0,0.1)',
            borderRadius: '3rem',
        });
    };

    this.buildUIParticipantsBody = function (body) {
        body.css({
            position: 'relative',
            display: 'grid',
            height: '0',
            width: '0',
            overflow: 'hidden',
            overflowY: 'scroll',
            gridGap: '1rem',
            gridAutoRows: 'max-content',
            gridAutoColumns: 'max-content',
            padding: '0rem 6rem 0rem 2rem',
        });
    };

    this.buildUIParticipantsMobileBody = function (elements) {
        let { mobileDrawer, mHeader, mHeaderClose, mobileBody } = elements;
        mobileDrawer.css({
            position: 'absolute',
            display: 'grid',
            gridGap: '2rem',
            gridAutoRows: 'max-content',
            background: 'white',
            zIndex: 2,
            borderRadius: '3rem 0rem 0rem 3rem',
            height: '50vh',
            width: '80vw',
            top: '-3rem',
            right: '-3rem',
            padding: '2rem',
        });
        mHeader.css({
            position: 'relative',
            display: 'flex',
            justifyContent: 'space-between',
        });
        mHeaderClose.css({
            height: '2.3rem',
            width: '2.3rem',
            gridGap: '.25rem',
            position: 'relative',
            backgroundSize: 'contain',
            background: this.colors.primary[0],
            '-webkit-mask-size': 'contain',
            maskSize: 'contain',
            '-webkit-mask-image': `url(${Assets.getPath(`~assets/images/icon/chevron-up.svg`)})`,
            maskImage: `url(${Assets.getPath(`~assets/images/icon/chevron-up.svg`)})`,
        });
        mobileBody.css({
            position: 'relative',
            display: 'grid',
            overflowX: 'hidden',
            overflowY: 'scroll',
            gridGap: '1rem',
            gridAutoRows: 'max-content',
            gridAutoColumns: 'max-content',
        });
        mobileDrawer.transform({ y: '-200%' });
    };

    this.buildUIParticipantsHeader = function (elements, isMobile) {
        let { header, icon, numPeople } = elements;

        header.css({
            display: 'grid',
            position: 'relative',
            alignItems: 'center',
            gridGap: '.5rem',
            gridAutoFlow: 'column',
            padding: !isMobile ? '1.5rem 2rem' : '0rem',
        });
        icon.css(this.styleguide.icon);
        icon.css({
            background: this.colors.primary[0],
            '-webkit-mask-size': 'contain',
            maskSize: 'contain',
            '-webkit-mask-image': `url(${Assets.getPath(`~assets/images/icon/user.svg`)})`,
            maskImage: `url(${Assets.getPath(`~assets/images/icon/user.svg`)})`,
        });

        numPeople.css(this.styleguide.label3);
        numPeople.css({
            color: this.colors.primary[0],
            whiteSpace: 'nowrap',
        });
        numPeople.bold();
    };

    this.buildUIParticipantsUserItem = function (elements, user) {
        let { userItem, name, dot, actions, chatIcon, locationIcon } = elements;
        const isCurrentPlayer = user.state.get('uid') == PlayerModel.get('uid');
        userItem.css({
            display: 'grid',
            position: 'relative',
            gridAutoFlow: 'column',
            alignItems: 'center',
            gridGap: '1rem',
            marginBottom: '1rem',
            gridAutoColumns: 'min-content',
        });
        name.css(this.styleguide.label3);
        name.css({ color: this.colors.monochrome[6], whiteSpace: 'nowrap' });
        name.text(`${user.state.get('name')}`);
        if (isCurrentPlayer) {
            name.bold();
        }
        user.state.bind('name', name);
        dot.css({
            position: 'relative',
            height: '1rem',
            width: '1rem',
            borderRadius: '50%',
            background: this.colors.primary[0],
            opacity: isCurrentPlayer ? 1 : 0,
        });

        actions.css({
            position: 'relative',
            display: 'flex',
            opacity: 0,
        });
        chatIcon.css({
            position: 'relative',
            height: '1.8rem',
            width: '1.8rem',
            backgroundSize: 'contain',
            backgroundRepeat: 'no-repeat',
            opacity: isCurrentPlayer ? 0 : 1,
            background: this.colors.primary[0],
            '-webkit-mask-size': 'contain',
            maskSize: 'contain',
            '-webkit-mask-image': `url(${Assets.getPath(`~assets/images/icon/chat.svg`)})`,
            maskImage: `url(${Assets.getPath(`~assets/images/icon/chat.svg`)})`,
        });
        locationIcon.css({
            position: 'relative',
            height: '1.8rem',
            width: '1.8rem',
            backgroundSize: 'contain',
            backgroundRepeat: 'no-repeat',
            marginLeft: '.5rem',
            opacity: isCurrentPlayer ? 0 : 1,
            background: this.colors.primary[0],
            '-webkit-mask-size': 'contain',
            maskSize: 'contain',
            '-webkit-mask-image': `url(${Assets.getPath(`~assets/images/icon/location.svg`)})`,
            maskImage: `url(${Assets.getPath(`~assets/images/icon/location.svg`)})`,
        });
    };

    this.buildUIParticipantsNotification = function (notification) {
        notification.css(this.styleguide.label3);
        notification.css({
            position: 'absolute',
            left: 0,
            padding: '1.5rem 2rem',
            borderRadius: '3rem',
            background: 'rgba(255,255,255,0.5)',
            whiteSpace: 'nowrap',
        });
        notification.transform({ x: 'calc(-100% - 2rem)' });
    };
}, 'static');

Class(function UIShareController() {
    Inherit(this, Element);
    const _this = this;
    var $this;
    var $content,$wrapper;
    var _view;
    var _showing = false;

    //*** Constructor
    (function () {
        initHTML();
    })();

    function initHTML() {
        $this = _this.element;
        $this.css({
            position:'absolute',
            top:'50%',
            left:'3rem'
        })
        $this.transform({y:"-50%"})
        $wrapper = _this.initClass(UIButton,
            {
                image:'~assets/images/icon/share2.svg',
                action:click,
                toolTipText:null,
                isDisabled:true
            },
        [$this]);
        $wrapper.element.css({
            zIndex:2
        })
        _view = _this.initClass(UIShareControllerView,{container:$wrapper.element},[$wrapper.element]);
    }

    //*** Event handlers
    function click() {
        _showing = !_showing;
        if(_showing){
            _view.show();
            $wrapper.setAppearance(AppStyleController.colors.primary[0],'white',true)
        }else{
            _view.hide();
            $wrapper.setAppearance('white',AppStyleController.colors.primary[0],false)
        }
    } 
    //*** Public methods
    this.addItems = function(items) {
        _view.addItems(items);
    }
});
Class(function UIShareControllerView(_config) {
    Inherit(this, Element);
    const _this = this;
    const $this = _this.element;
    var $wrapper;
    var $wraps = [];
    const _prefix = 'Share';
    var _parent;

    //*** Constructor
    (function () {
        _parent = _config.container.div;
         initHTML();
         addListeners();
    })();
    
    function initHTML() {
        $this.css({
            position:'absolute',
            width:'100%',
            height:'100%',
            overflow:'hidden',
            borderRadius:'50%',
            padding:'0rem',
            background:'white',
            display:'flex',
            justifyContent:'center',
            alignItems:'center',
            top:0,
            left:0,
            zIndex:-1
        })
        $wrapper = $this.create(`${_prefix}__wrapper`);
        $wrapper.css({
            opacity:0,
            position:'relative',
            display:'grid',
            gridAutoFlow:'column',
            gridAutoRows:'min-content',
            gridGap:"4rem",
            alignContent:'center',
            justiftContent:'center'
        })
    }
    function hideContent() {
        const size = Breakpoints.getSize();
        $wrapper.tween({opacity:0},300,'easeOutQuad',0,()=>{
            $wrapper.css({padding:'0'});
        });
        if(size == 'phone' || size == 'tab-port'){
            $this.tween({y:0,height:_parent.clientHeight,opacity:0},300,'easeOutQuad',100,()=>{
                $this.tween({borderRadius:'50%'},100,'easeOutQuad')
            })            
        }else{
            $this.tween({x:0,width:_parent.clientWidth,opacity:0},600,'easeOutQuad',100,()=>{
                $this.tween({borderRadius:'50%'},100,'easeOutQuad')
            })
        }
    }
    function addListeners(){
        _this.onResize(resize);
    }

    function resize() {
        hideContent();
        const size = Breakpoints.getSize();
        $this.css({
            width:'100%',
            height:'100%',
        })
        switch (size) {
            case 'big-desktop':
            case 'desktop':
            case 'tab-land':{
                $wrapper.css({
                    gridAutoFlow:'column',
                })
                $wrapper.css({
                    gridGap:'4rem'
                })

                break;
            }
            case 'tab-port':{
                $wrapper.css({
                    gridAutoFlow:'unset',
                })
                $wrapper.css({
                    gridGap:'4rem'
                })
                break;
            }
            case 'phone':{
                $wrapper.css({
                    gridAutoFlow:'unset',
                });
                $wrapper.css({
                    gridGap:'2rem'
                })
               break;
            }
            default:
                break;
        }
    }

    this.addItems = function(items) {
        const size = Breakpoints.getSize();
        for(let item of items){
            let $wrap = $wrapper.create(`${_prefix}___item`);
            $wrap.css(CoreUIState.instance().styleguide.icon);
            $wraps.push($wrap);
            let $icon = $wrap.create(`${_prefix}___item__img`);
            CoreUIState.instance().uiBuilder.buildMaskIcon($icon,item.image,'1.5rem','1.5rem',AppStyleController.colors.primary[0]);

            $icon.css({
                width:"100%",
                height:'100%',
                backgroundSize:'contain',
                backgroundRepeat:'no-repeat',
                position:'relative',
                margin:"0 auto",
            })
            let $pulse = $wrap.create(`${_prefix}___item__pulse`)
            $pulse.css({
                width:'100%',
                height:'100%',
                borderRadius:'50%',
                top:'50%',
                left:'50%',
                opacity:0,
                background:AppStyleController.colors.primary[0],
            });
            $pulse.transform({x:'-50%',y:'-50%'});
            $wrap.interact(null, ()=>{
                item.action();
                $pulse.tween({opacity:.3,x:'-50%',y:'-50%',scale:1}, 0, 'easeOutQuad',() => {
                    $pulse.tween({scale:2.,x:'-50%',y:'-50%',opacity:0}, 600, 'easeOutQuad');
                })
            });
        }
    }
 
    this.show = function() {
        const size = Breakpoints.getSize();
        const targetPaddingY = 30;
        const targetPaddingX = 80;
        $wrapper.tween({opacity:1},300,'easeOutQuad',0,()=>{
            $wrapper.css({padding:'1.5rem 4rem'});
        });
        if(size == 'phone' || size == 'tab-port'){
            $this.tween({y:'-120%',height:$wrapper.div.clientHeight + targetPaddingY,borderRadius:'5rem',opacity:1},400,'easeOutQuad',100);
        }else{
            $this.tween({x:80,width:$wrapper.div.clientWidth + targetPaddingX,borderRadius:'5rem',opacity:1},400,'easeOutQuad',100);
        }
    }
    this.hide = function() {
        hideContent();
    }
});
Class(function UIToolbeltController() {
    Inherit(this, Element);
    const _this = this;
    var $this;
    var _view;

    //*** Constructor
    (function () {
        initHTML();
        initView();
        addListeners();
    })();

    function initHTML() {
        $this = _this.element;
        $this.css({
            position:'relative'
        })
    }

    function initView() {
        _view = _this.initClass(UIToolbeltView);
    }

    //*** Event handlers
    function addListeners() {

    }
    //*** Public methods
    this.addItems = function(items) {
        _view.addItems(items);
    }
});
Class(function UIToolbeltView(_config) {
    Inherit(this, Element);
    const _this = this;
    var $this,$wrapper;
    var $wraps = [];
    var _prefix = "Toolbelt";
    var _hasItemsInMobile = false;
    //*** Constructor
    (function () {
        initHTML();
        addListeners();
    })();

    function initHTML() {
        $this = _this.element;
        $this.css({
            position:'relative',
            width:'fit-content',
            height:'fit-content',
            background:'white',
            padding:"1.5rem 3rem",
            justifySelf:'center',
            boxShadow: '0px 4px 20px rgba(0,0,0,0.1)',
            borderRadius:'5rem',
        })
        $wrapper = $this.create(`${_prefix}__wrapper`);
        $wrapper.css({
            position:'relative',
            display:'grid',
            gridAutoFlow:'column',
            gridAutoRows:'min-content',
            gridGap:"4rem",
            alignContent:'center',
            justiftContent:'center'
        })
    }

    //*** Event handlers
    function addListeners() {
        _this.onResize(resize);
    }

    function resize() {
        const size = Breakpoints.getSize();
        switch (size) {
            case 'big-desktop':
            case 'desktop':
            case 'tab-land':{
                $this.css({
                    opacity:1
                })
                $wrapper.css({
                    gridGap:'4rem'
                })
                for(let wrap of $wraps){
                    wrap.css({
                        display:'block'
                    })
                }
                $this.css({
                    padding:"1.5rem 3rem",
                })
                break;
            }
            case 'tab-port':{
                $this.css({
                    opacity:1
                })
                $wrapper.css({
                    gridGap:'4rem'
                })
                for(let wrap of $wraps){
                    wrap.css({
                        display:'block'
                    })
                }
                break;
            }
            case 'phone':{
                $wrapper.css({
                    gridGap:'2rem'
                })
                $this.css({
                    padding:"1rem 2rem",
               })
                for(let wrap of $wraps){
                    wrap.css({
                        display: wrap.inMobile ? 'block' : 'none'
                    })
                }
               break;
            }
            default:
                break;
        }
        if(!_hasItemsInMobile && Device.mobile){
            $this.css({
                opacity:0
            })
        }
    }
    //*** Public methods
    this.addItems  = function(items) {
        const size = Breakpoints.getSize();
        _hasItemsInMobile = items.some((item)=>{
            return item.inMobile && !item.isDisabled;
        })

        for(let item of items){
            if(item.isDisabled) continue;
            let $wrap = $wrapper.create(`${_prefix}___item`);
            $wrap.css(CoreUIState.instance().styleguide.icon);
            if(size == 'phone'|| Device.mobile){
                $wrap.css({
                    position:'relative',
                    display: item.inMobile ? 'block' : 'none',
                    opacity:1,
                });
            }else{
                $wrap.css({
                    position:'relative',
                    opacity:1,
                });
            }
            $wrap.inMobile = item.inMobile;
            $wraps.push($wrap);
            let $icon = $wrap.create(`${_prefix}___item__img`);
            CoreUIState.instance().uiBuilder.buildMaskIcon($icon,item.image,'1.5rem','1.5rem',AppStyleController.colors.primary[0]);

            $icon.css({
                width:"100%",
                height:'100%',
                backgroundSize:'contain',
                backgroundRepeat:'no-repeat',
                position:'relative',
                margin:"0 auto",
            })
            

            let $pulse = $wrap.create(`${_prefix}___item__pulse`)
            $pulse.css({
                width:'100%',
                height:'100%',
                borderRadius:'50%',
                top:'50%',
                left:'50%',
                opacity:0,
                background:AppStyleController.colors.primary[0],
            });
            $pulse.transform({x:'-50%',y:'-50%'});
            $wrap.interact(null, ()=>{
                item.action();
                $pulse.tween({opacity:.3,x:'-50%',y:'-50%',scale:1}, 0, 'easeOutQuad',() => {
                    $pulse.tween({scale:2.,x:'-50%',y:'-50%',opacity:0}, 600, 'easeOutQuad');
                })
            });
        }

    }


});
Class(function UITooltip(_config) {
    Inherit(this, AbstractUIComponent);

    const _this = this;
    const $this = _this.element;

    _this.background = '';
    _this.color = '';
    _this.direction = 'left';
    _this.text = '';

    var $arrow, $text;

    //*** Constructor
    (function () {
        _this.parseConfig(_config);

        initHTML();
    })();

    function initHTML() {
        $arrow = $this.create(_this.getPrefix('arrow'));
        $text = $this.text(_this.text);

        CoreUIState.instance().uiBuilder.buildUITooltip(
            {
                $container: $this,
                $arrow,
            },
            {
                background: _this.background,
                color: _this.color,
                direction: _this.direction,
            }
        );

        if ( !_this.mouseEnabled ) $this.mouseEnabled( false );
    }

    //*** Public methods
    _this.animateIn = function ( delay = 0 ) {
        let x = _this.direction === 'top' || _this.direction === 'bottom' ? '-50%' : 0;
        let y = _this.direction === 'left' || _this.direction === 'right' ? '-50%' : 0;

        $this.tween({ opacity: 1, x, y }, 400, 'easeOutCubic', delay );
    };

    _this.animateOut = function ( delay = 0 ) {
        let x = _this.direction === 'top' || _this.direction === 'bottom' ? '-50%' : 0;
        let y = _this.direction === 'left' || _this.direction === 'right' ? '-50%' : 0;

        $this.tween({ opacity: 0, x, y }, 400, 'easeOutCubic', delay );
    };
});

Class(function UITooltipStyles() {
    Inherit(this, Component);

    this.buildUITooltip = function ({ $container, $arrow }, { background, color, direction } = {}) {
        $arrow.css({
            background,
            height: '0.9rem',
            width: '0.9rem',
        });

        $container.css({
            ...this.styleguide.label1,
            background,
            color,
            borderRadius: '0.8rem',
            opacity: 0,
            padding: '1rem 1.2rem',
            position: 'absolute',
            whiteSpace: 'nowrap',
            zIndex: 10000,
            zIndex: 1
        });

        if (direction === 'top') {
            $arrow.css({ left: '50%', top: '100%' });
            $arrow.transform({ rotation: 45, x: '-50%', y: '-50%' });

            $container.css({ bottom: '100%', left: '50%', marginTop: '1.5rem' });
            $container.transform({ x: '-50%' });
        } else if (direction === 'right') {
            $arrow.css({ right: '100%', top: '50%' });
            $arrow.transform({ rotation: 45, x: '50%', y: '-50%' });

            $container.css({ left: '100%', marginLeft: '1.5rem', top: '50%' });
            $container.transform({ y: '-50%' });
        } else if (direction === 'bottom') {
            $arrow.css({ bottom: '100%', left: '50%' });
            $arrow.transform({ rotation: 45, x: '-50%', y: '50%' });

            $container.css({ left: '50%', marginBottom: '1.5rem', top: '100%' });
            $container.transform({ x: '-50%' });
        } else if (direction === 'left') {
            $arrow.css({ left: '100%', top: '50%' });
            $arrow.transform({ rotation: 45, x: '-50%', y: '-50%' });

            $container.css({ marginRight: '1.5rem', right: '100%', top: '50%' });
            $container.transform({ y: '-50%' });
        }
    };
}, 'static');

Class(function UI3DTutorialView(_config = {}) {
    Inherit(this, Object3D);
    const _this = this;
    var $root;

    _this.dimensions = {x: 1024, y: 320};
    _this.padding = {x: 80, y: 80};
    _this.text = 'Would you like to do the thing';
    _this.font = 'myriad';
    _this.fontSize = 50;
    _this.fontColor = '#000000';
    _this.lineHeight = 1.1;
    _this.bgColor = '#FFFFFF';
    _this.scale = _config.scale || 1;

    var $capture, $bg, $content, $image, $title, $text, $line, $progress;

    //*** Constructor
    (async function () {
        Object.assign(_this, _config);
        init();
        initLayers();
        addListeners();
        _this.flag('initialized', true);
        if (!Global.PLAYGROUND) _this.group.visible = false;
    })();

    function initLayers() {
        $bg = $gl(_this.dimensions.x, _this.dimensions.y, _this.bgColor);
        $bg.setZ(-2);
        $root.add($bg)

        $content = $gl();
        $content.x = _this.padding.x;
        $content.y = _this.padding.y;
        $root.add($content)

        if (_this.icon) {
            $image = $gl(236, 200, Assets.getPath(_this.icon));
            $image.y = -18;
            $content.add($image);
        }

        if (_this.title) {
            $title = $glText(_this.title, _this.font, 36, {
                width: _this.dimensions.x - (_this.padding.x * 2),
                lineHeight: _this.lineHeight,
                letterSpacing: 0,
                color: '#FFFFFF',
            });
            $content.add($title);
        }

        $text = $glText(_this.text, _this.font, 38, {
            width: _this.dimensions.x - (_this.padding.x * 2),
            lineHeight: _this.lineHeight,
            letterSpacing: 0,
            color: '#AAAAAA',
        });
        $text.y = 60;
        $content.add($text);

        if (_this.type === 'timer') {
            if (_this.icon) {
                $title.x = 350 - _this.padding.x;
                $text.x = 350 - _this.padding.x;
            }

            $line = $gl(_this.dimensions.x - (_this.padding.x * 2), 4, '#2D2D2D');
            $line.y = _this.dimensions.y - _this.padding.y - 40;
            $content.add($line);

            $progress = $gl(_this.dimensions.x - (_this.padding.x * 2), 4, '#FFC539');
            $progress.y = $line.y;
            $progress.width = 0;
            $progress.setZ(1);
            $content.add($progress);
        }
    }

    function init() {
        let capture = _this.initClass(StageLayoutCapture, 1024, 1024, true);

        $root = capture.root;
        $capture = $gl(2., 2., capture);
        $capture.enable3D();
        _this.add($capture.group);
        if (!Platform.usingVR()) {
            $capture.mesh.shader.depthTest = false;
        }
        $capture.mesh.shader.depthWrite = false;
        $capture.mesh.shader.transparent = true;
        $capture.mesh.renderOrder = 999;
        capture.object3d = $capture;
        capture.mouseEnabled = false;

        _this.capture = capture;
    }

    //*** Event handlers
    async function addListeners() {
        $bg.interact(null, onClick);
    }

    function onClick() {
        _this.parent.next();
    }

    //*** Public methods
    this.animateIn = async function () {
        await _this.wait('initialized');
        _this.group.visible = true;
        _this.group.scale.setScalar(0);
        tween(_this.group.scale, {x:_this.scale, y:_this.scale, z:_this.scale}, 400, 'easeInOutCubic')
    }

    this.animateOut = async function () {
        await _this.wait('initialized');
        tween(_this.group.scale, {x:0, y:0, z:0}, 400, 'easeInOutCubic').onComplete(_ => {
            _this.group.visible = false;
        });
    }

    this.progress = function (progress) {
        if ($progress) $progress.width = (_this.dimensions.x - (_this.padding.x * 2)) * progress;
    }

});

Class(function UITutorialController() {
    Inherit(this, Component);
    const _this = this;

    var _queue = [];
    var _tutorial, _type;
    var _tweenObj = { v: 0 };

    //*** Constructor
    (async function () {
    })();

    async function displayTutorial() {
        if (!_queue.length) return;

        let { obj, env } = _queue[0];

        let {
            delay = 1000,
            time = 0,
            id,
            type,
            eventType,
        } = obj;

        await PlayerModel.ready();

        let tutorials = PlayerModel.get('tutorials') || [];

        let user = User;
        if (user) {
            let isProfileNotCompleted = user.displayName === '';
            let isTutorialCompleted = tutorials.indexOf(id) > -1;

            if (isProfileNotCompleted || isTutorialCompleted) {
                _queue.shift();
                displayTutorial();
                return;
            }

            tutorials.push(id);

            PlayerModel.set('tutorials', tutorials);

            _type = type;

            if (_type === 'timer') {
                if (time === 0) time = 10000;
                obj.splittext = false;
            }

            if (Platform.usingVR()) {
                _this.delayedCall(_ => {
                    _tutorial = _this.initClass(UI3DTutorialView, obj);
                    _tutorial.scale = 0.4;
                    _tutorial.animateIn();
                    _tutorial.group.visible = true;
                    _tutorial.group.position.copy(World.CAMERA.position);
                    _tutorial.group.position.y -= 0.25;
                    _tutorial.group.position.add(new Vector3(0, 0, -1).applyQuaternion(World.CAMERA.quaternion));
                    _tutorial.group.lookAt(World.CAMERA.position);
                    env.group.add(_tutorial.group);
                }, delay);
            } else {
                _tutorial = _this.initClass(UITutorialView, obj, [Stage]);
                _tutorial.animateIn(delay);

                if (Device.mobile) {
                    _this.events.sub(Mouse.input, Interaction.START, _this.next);
                } else if (_type === 'keyboard') {
                    _this.events.sub(Keyboard.DOWN, _this.next);
                } else if (_type === 'mouse') {
                    _this.events.sub(Mouse.input, Interaction.START, _this.next);
                }
            }

            if (time) {
                _tweenObj = { v: 0 };

                tween(_tweenObj, { v: 1 }, time, 'linear', delay)
                    .onUpdate(_ => _tutorial?.progress(_tweenObj.v))
                    .onComplete(_this.next);
            }

            addHandlers(eventType);
        }
    }

    //*** Event handlers
    function addHandlers(eventType) {
        switch (eventType) {
            case 'keyboard': _this.events.sub(Keyboard.DOWN, _this.next); break;
            case 'mouse': _this.events.sub(Mouse.input, Interaction.START, _this.next); break;
            case 'transport':
                _this.events.sub(VRInput.JOYSTICK, _this.next);
                _this.events.sub(PlayerControls.MOBILE_JOYSTICK, _this.next);
                break;
            case 'move-vr':
                _this.events.sub(Player.TELEPORT, _this.next);
                break;
            case 'chat': _this.events.sub(VideoChatZones.PROMPT, _this.next); break;
            case 'pov': _this.events.sub(PlayerControls.SWITCH_VIEW, _this.next); break;
            case 'perspective': _this.events.sub(PlayerControls.DRAGGING, _this.next); break;
            case 'settings-vr': {
                VRInput.controllers.forEach((c, i) => {
                    _this.events.sub(c, VRInput.BUTTON, vrButton);
                });
                break;
            }
        }
    }

    function vrButton(e) {
        if (e.label !== 'trigger' && !e.pressed) _this.next();
    }

    function removeHandlers() {
        _this.events.unsub(Keyboard.DOWN, _this.next);
        _this.events.unsub(Mouse.input, Interaction.START, _this.next);
        _this.events.unsub(Player.TELEPORT, _this.next);
        _this.events.unsub(VideoChatZones.PROMPT, _this.next);
        _this.events.unsub(PlayerControls.SWITCH_VIEW, _this.next);
        _this.events.unsub(PlayerControls.DRAGGING, _this.next);
        VRInput.controllers.forEach((c, i) => {
            _this.events.unsub(c, VRInput.BUTTON, vrButton);
        });
    }

    //*** Public methods
    this.show = function (obj, env) {
        _queue.push({ obj, env });

        if (_queue.length > 1) return;

        displayTutorial();
    }

    this.hide = this.clear = function () {
        clearTween(_tweenObj);

        if (_tutorial) {
            _tutorial.animateOut();
            _tutorial = null;
        }

        removeHandlers();
    }

    this.next = function () {
        _this.hide();
        _queue.shift();
        displayTutorial();
    }

}, 'singleton');

Class(function UITutorialView(_config) {
    Inherit(this, AbstractUIComponent);
    const _this = this;
    const $this = _this.element;

    var $wrapper, $icon, $title, $text, $textSpans, $line, $progress;

    //*** Constructor
    (function () {
        _this.parseConfig(_config);

        initHTML();
        initStyles();
        addListeners();
    })();

    function initHTML() {
        $this.invisible();

        $wrapper = $this.create(_this.getPrefix('wrapper'));

        if (_this.icon) {
            $icon = $wrapper.create(_this.getPrefix('icon'), 'img');
            $icon.attr('src', Assets.getPath(_this.icon));
        }

        if (_this.title) {
            $title = $wrapper.create(_this.getPrefix('title'));
            $title.text(_this.title);
        }

        $text = $wrapper.create(_this.getPrefix('text'), 'p');
        $text.html(_this.text);

        if (_this.splittext) $textSpans = SplitTextfield.split($text, 'word');

        if (_this.type === 'timer') {
            $line = $wrapper.create(_this.getPrefix('line'));

            $progress = $line.create(_this.getPrefix('progress'));
            $progress.transform({ scaleX: 0 });
        }
    }

    function initStyles() {
        $this.multiTween = true;

        CoreUIState.instance().uiBuilder.buildUITutorialView({
            $container: $this,
            $wrapper,
            $icon,
            $title,
            $text,
            $line,
            $progress,
        }, {
            type: _this.type,
        });
    }

    //*** Event handlers
    async function addListeners() {
        _this.onResize(resize);
        $wrapper.interact(null, onClick);
    }

    function resize() {
        $this.css({
            right: UIController.instance().layout.width,
            zIndex: 1000
        });
    }

    function onClick() {
        _this.parent.next();
    }

    //*** Public methods
    this.animateIn = async function (delay = 0) {
        await _this.wait(delay);

        $this.visible();

        if ($textSpans) {
            $textSpans.forEach((text, index) => {
                text.css({ opacity: 0 });
                text.transform({ y: 15 });
                text.tween({ opacity: 1, y: 0 }, 400, 'easeInOutQuint', 10 * index);
            });
        } else {
            $this.css({ opacity: 0 }).tween({ opacity: 1 }, 400, 'easeOutCubic');
        }
    }

    this.animateOut = function () {
        if ($textSpans) {
            $textSpans.forEach((text, index) => {
                text.tween({ opacity: 0, y: -15 }, 400, 'easeInOutQuint', 10 * index, () => {
                    if (index == $textSpans.length -1) _this.destroy();
                });
            });
        } else {
            $this.tween({ opacity: 0 }, 400, 'easeOutCubic', () => {
                _this.destroy();
            });
        }
    }

    this.progress = function (progress) {
        if ($progress) $progress.transform({ scaleX: progress });
    }

});

Class(function UITutorialViewStyles() {
    Inherit(this, Component);

    this.buildUITutorialView = function ({
        $container,
        $wrapper,
        $icon,
        $title,
        $text,
        $line,
        $progress,
    }, {
        type,
    }) {
        const size = Breakpoints.getSize();

        $container.css({
            top: 0,
            left: 0,
            bottom: 0,
            textAlign: size === 'phone' ? 'center' : 'left',
        }).mouseEnabled(false);

        $text.css({
            ...this.styleguide.p2,
            position: 'relative',
            paddingTop: '1rem',
            lineHeight: '110%',
            letterSpacing: '0.01rem',
            color: '#AAAAAA',
        });

        $wrapper.css({
            left: '2.3rem',
            width: '32.3rem',
            padding: '3.2rem 1.8rem',
            background: this.colors.black,
            border: '1px solid #282828',
            boxShadow: '0px 4px 10px 4px rgba(0, 0, 0, 0.3)',
            borderRadius: '0.5rem',
        });

        if (type === 'timer') {
            if ($icon) {
                $wrapper.css({
                    maxWidth: '41.6rem',
                    width: 'calc(100% - 4.6rem)'
                });

                $icon.css({
                    width: '9.7rem',
                    height: '8.25rem',
                });

                if (size === 'phone') {
                    $wrapper.css({
                        bottom: '50%',
                        height: 'auto',
                        left: '50%',
                        paddingBottom: '5.2rem',
                        paddingTop: '15rem',
                        transform: 'translate(-50%, 50%)'
                    });

                    $title.css({ marginLeft: 0 });
                    $text.css({ marginLeft: 0 });

                    $icon.css({
                        height: '15rem',
                        objectFit: 'contain',
                        left: '50%',
                        marginTop: 0,
                        top: 0,
                        transform: 'translateX(-50%)',
                    });
                } else {
                    $wrapper.css({
                        bottom: '2.3rem',
                        height: '13rem',
                        left: '2.3rem',
                        paddingBottom: '3.2rem',
                        paddingTop: '3.2rem',
                        transform: 'none'
                    });

                    $title.css({ marginLeft: '12rem' });
                    $text.css({ marginLeft: '12rem' });

                    $icon.css({
                        height: '8.25rem',
                        left: 'auto',
                        marginTop: '-1.375rem',
                        top: 'auto',
                        transform: 'none',
                    });
                }
            }

            $title.css({
                ...this.styleguide.label4,
                position: 'relative',
                color: '#fff',
            });

            $line.css({
                left: '1.8rem',
                right: '1.8rem',
                bottom: '1.6rem',
                height: 2,
                background: '#2D2D2D',
            });

            $progress.css({
                width: '100%',
                height: '100%',
                background: '#fff',
                transformOrigin: '0 0',
            });
        }
    };

}, 'static');

Class(function VideoCountdownView(_config) {
    Inherit(this, Element);
    const _prefix = 'VideoCountdownView';

    const _this = this;
    const $this = _this.element;
    var $contentWrapper, $message, _timer;
    var _video;
 
    //*** Constructor
    (function () {
        initHTML();
        initTimer();
        initVideo();
        initStyles();
        addHandlers();
    })();
 
    function initHTML() {
        $contentWrapper = $this.create(`${_prefix}__content-wrapper`)
    }

    function initTimer() {
        _timer = _this.initClass(UITimer, {
            autoStart: true, 
            countdown: true, 
            countdownTime: _config.timeToChat,
            endingMessageText: 'SESSION ENDED!'
        })
    }

    async function initVideo() {
        $videoWrapper = $contentWrapper.create(`${_prefix}__video-wrapper`)
        _video = await GameCenterMedia.getUserVideo();
        $(_video).attr('width', '100%').attr('height', 'auto').css({
            position: 'relative',
            display: 'block'
        });
        $videoWrapper.add(_video);
    }


    function initStyles() {
        $this.css({
            display: 'flex',
            flexDirection: 'column',
            left: '0%',
            top: '50%',
            width: window.innerWidth - UIController.instance().layout.width,
            height: Stage.height,
            zIndex: 10,
            transform: 'translate(0%, -50%)'
        })
        $contentWrapper.css({
            position: 'relative',
            flexGrow: '1',
            display: 'grid',
            gridRowGap: '4.8rem',
            placeItems: 'center',
            gridTemplateRows: 'repeat(3, min-content)',
            alignContent: 'center'
        })
        $message.css({
            ..._this.styleguide.h5,
            fontWeight: '700',
            textTransform: 'uppercase',
            position: 'relative',
            background: 'white',
            color: "#0D152B",
            padding: '1.6rem 2.4rem',
            borderRadius: '3rem',
            position: 'relative',
            textAlign: 'center'
        })
    }
 
    //*** Event handlers

    function addHandlers() {
        _this.onResize(resize)
    }

    function resize() {
        $this.css({
            width: window.innerWidth - UIController.instance().layout.width,
            transform: 'translate(0%, -50%)'
        })
    }
 
    //*** Public methods
 
});
Class(function VideoInstructionsView(_config) {
    Inherit(this, Element);
    const _prefix = 'VideoPreview';
    const _this = this;
    var $this = _this.element;
    var _video;
    var $contentWrapper, $iframeWrapper, $message, _startButton;

    //*** Constructor
    (async function () {
        await defer();
        initHTML();
        initMessage()
        initVideo();
        initButton();
        initStyles();
        addListeners();
    })();

    function initHTML() {
        $contentWrapper = $this.create(`${_prefix}__content-wrapper`)
    }

    function initMessage() {
        $message = $contentWrapper.create(`${_prefix}__message`)
        if (_config.messageText) {
            $message.text(_config.messageText)
        } else {
            $message.css({
                display: 'none'
            })
        }
    }

    async function initVideo() {
        $iframeWrapper = $contentWrapper.create(`${_prefix}__iframe_wrapper`)
        _video = _this.initClass(_config.view, _config.viewConfig, [$iframeWrapper])
    }


    function initButton() {
        const defaultButtonStyles = {
            background: "#F2545B",
            text: _config && _config.buttonText || "JOIN",
            onClick: () => {
                _this.flag('joined', true);
                _this.events.fire(Events.READY);
            }
        }
        const buttonStyle = _config && _config.buttonStyles || defaultButtonStyles
        _startButton = _this.initClass(UIFilledButton, {
          ...buttonStyle
        }, [$contentWrapper])
    }

    async function initStyles() {
        CoreUIState.instance().uiBuilder.buildVideoInstructions({
            $container: $this,
            $message,
            $contentWrapper,
            $iframeWrapper
        }, 
        {
            width: _this.parent.parent.getDOMElement().width
        })
    }

    //*** Event handlers
    function addListeners() {
        _this.onResize(resize);
    }

    function resize() {
        const windowHeight = Stage.height;
        $this.css({
            height: Stage.height,
            width: _this.parent.parent.getDOMElement().width,
        })
        
        //Needs work -- it loooks better on dream projects.
        if (windowHeight <= 800 && windowHeight > 600) {
            $contentWrapper.tween({scale: 0.75}, 400, 'easeOutCubic')
            $contentWrapper.css({gridRowGap: '2rem'})
        } else if (windowHeight <= 600)  {
            $contentWrapper.tween({scale: 0.6}, 400, 'easeOutCubic')
            $contentWrapper.css({gridRowGap: '1rem'})
        } else {
            $contentWrapper.tween({scale: 1}, 400, 'easeOutCubic')
            $contentWrapper.css({gridRowGap: '4.8rem'})
        }
    }

    //*** Public methods
    this.animateOut = function() {
        return $this.tween({opacity: 0, x: '0%', y: '-50%'}, 200, 'easeOutCubic').promise();
    }

    this.changeMessageText = async (text) => {
        await $message.tween({opacity: 0}, 400, 'easeOutCubic').promise()
        $message.text(text)
        await _this.wait(200)
        $message.tween({opacity: 1}, 400, 'easeOutCubic')
    }

});
Class(function VideoInstructionsViewStyles() {
    Inherit(this, Component);

    this.buildVideoInstructions = function (els, properties) {
        const {$container, $message, $contentWrapper, $iframeWrapper} = els
        const {width} = properties
        $container.css({
            display: 'flex',
            flexDirection: 'column',
            left: '0%',
            top: '50%',
            width,
            height: Stage.height,
            zIndex: 10,
            transform: 'translate(0%, -50%)',
        })

        $message.css({
            ...this.styleguide.h5,
            fontWeight: '700',
            textTransform: 'uppercase',
            position: 'relative',
            background: 'white',
            color: "#0D152B",
            padding: '1.6rem 2.4rem',
            borderRadius: '3rem',
            position: 'relative',
            textAlign: 'center'
        })

        $contentWrapper.css({
            position: 'relative',
            flexGrow: '1',
            display: 'grid',
            gridRowGap: '4.8rem',
            placeItems: 'center',
            gridTemplateRows: 'repeat(3, min-content)',
            alignContent: 'center',
            height: '90%'
        })

        $iframeWrapper.css({
            position: 'relative',
            height: '100%',
            width: '80%'
        })
    };
}, 'static');

Namespace('DreamUI');

/**
 * @name DefaultVideoLayout
 *
 * Default video layout for video features in dream.
 *
 */
Class(function DefaultVideoLayout() {
    Inherit(this, Component);
    const _this = this;
    const layoutConfig = {
        one: [0, 1],
        two: [2],
        twoByTwo: [2, 3, 4],
        threeByThree: [5, 6, 7, 8, 9],
        fourByFour: [10, 11, 12, 13, 14, 15, 16],
        fiveByFive: [17, 18, 19, 20, 21, 22, 23, 24, 25]
    };

    //*** Constructor
    (function () {
        if (!_this.parent) return;
        _this.count = _this.parent.videoObjects.length;
    })();


    /**
     * TODO also see ScreenShareLayout
     * Probably all video layouts should inherit from a base Class with common functionality
     */
    async function initStyles() {
        await VideoLayoutWrapperStyles.ready();
        if (!_this.parent) return;
        _this.parent.responsiveWrapper.css(VideoLayoutWrapperStyles.defaultVideoLayoutResponsiveWrapperVariant);
    }

    async function resolveLayout() {
        await VideoLayoutWrapperStyles.ready();
        if (!_this.parent) return;
        const videoObjects = _this.parent.videoObjects;
        _this.count = _this.parent.videoObjects.length;
        _this.parent.responsiveWrapper.css(VideoLayoutWrapperStyles.defaultVideoLayoutResolveResponsiveWrapperStyles);
        videoObjects.forEach(obj => {
            obj.view.setStyles({
                element: {
                    width: setVideoObjectWidth(_this.count),
                    height: setVideoObjectHeight(_this.count)
                },
                video: {
                    objectFit: 'cover',
                    height: '100%',
                    width: '100%'
                },
                avatarImage: {
                    height: setAvatarHeight(_this.count),
                    width: setAvatarHeight(_this.count)
                }
            });
        });
    }

    function setVideoObjectHeight(count) {
        if (layoutConfig.one.includes(count)) {
            return '80%';
        }
        if (layoutConfig.two.includes(count)) {
            return '50%';
        }
        if (layoutConfig.twoByTwo.includes(count)) {
            return '45%';
        }
        if (layoutConfig.threeByThree.includes(count)) {
            return '30%';
        }
        if (layoutConfig.fourByFour.includes(count)) {
            return '22%';
        }
        if (layoutConfig.fiveByFive.includes(count)) {
            return '18%';
        }
    }

    function setAvatarHeight(count) {
        if (layoutConfig.one.includes(count)) {
            return '40vh';
        }
        if (layoutConfig.two.includes(count)) {
            return '22vh';
        }
        if (layoutConfig.twoByTwo.includes(count)) {
            return '20vh';
        }
        if (layoutConfig.threeByThree.includes(count)) {
            return '15vh';
        }
        if (layoutConfig.fourByFour.includes(count)) {
            return '10vh';
        }
        if (layoutConfig.fiveByFive.includes(count)) {
            return '8vh';
        }
    }

    function setVideoObjectWidth(count) {
        if (layoutConfig.one.includes(count)) {
            return '80%';
        }
        if (layoutConfig.twoByTwo.includes(count)) {
            return '49%';
        }
        if (layoutConfig.threeByThree.includes(count)) {
            return '32%';
        }
        if (layoutConfig.fourByFour.includes(count)) {
            return '24%';
        }
        if (layoutConfig.fiveByFive.includes(count)) {
            return '19%';
        }
    }


    //*** Public methods

    this.load = () => {
        initStyles();
    };

    this.unload = () => {
    };

    this.update = () => {
        resolveLayout();
    };
});

/**
 * @name ScreenShareLayout
 *
 * Screenshare layout for video feature in dream.
 *
 */
Class(function ScreenShareLayout() {
    Inherit(this, Component);
    const _this = this;
    //*** Constructor
    (function () {
    })();

    /**
     * TODO: move to VideoLayoutWrapper or somewhere else? all
     * this class is doing now is updating styles of components
     * not part of this class
     */
    async function resolveLayout() {
        await VideoLayoutWrapperStyles.ready();
        if (!_this.parent) return;
        _this.parent.responsiveWrapper.css(VideoLayoutWrapperStyles.screenShareLayoutResponsiveWrapperVariant);

        _this.parent.videoObjects.forEach(obj => {
            if (!obj.screenShare || !obj.isCurrentlySharing) {
                obj.view.setStyles({
                    element: {
                        width: '20%',
                        height: '20vh'
                    }
                });
            }
            obj.view.setStyles({
                video: {
                    position: 'relative'
                },
                avatarImage: {
                    width: '7vh',
                    height: '7vh'
                }
            });
        });
    }

    //*** Public methods

    this.load = () => {
        resolveLayout();
    };

    this.unload = () => {
    };

    this.update = () => {
        resolveLayout();
    };
});

/**
 * @name MobileVideoLayout
 *
 * Screenshare layout for video feature in dream.
 *
 */
Class(function MobileVideoLayout({ styles = {} } = {}) {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    _this.SCREENSHARE_ON = false;
    //*** Constructor
    (async function () {
        await MobileVideoLayoutStyles.ready();
        if (!_this.parent) return;
        setHandlers();
        _this.events.sub(VideoLayoutWrapper.SCREENSHARE_ON, ({ screenShareOn }) => _this.SCREENSHARE_ON = screenShareOn);
    })();
    let _mainId;

    function initLayout() {
        _this.parent.responsiveWrapper.css(VideoLayoutWrapperStyles.mobileVideoLayoutResponsiveWrapperVariant);
    }

    function resolveLayout() {
        if (!_this.parent) return;
        if (_this.SCREENSHARE_ON) return;

        // only one in room
        if (_this.parent.videoObjects.length === 1) {
            setVideoLayoutObjectStyles(_this.parent.videoObjects[0]);
            handleMainVideo(_this.parent.videoObjects[0]);
            return;
        }

        _this.parent.videoObjects.forEach(async (obj, i) => {
            await obj.view.ready();
            setVideoLayoutObjectStyles(obj);
            if ((!_this.activeUid && i === 0) || (obj.data.uid === _this.activeUid)) {
                return handleMainVideo(obj);
            }
            handleNonMainVideo(obj);
        });
    }

    function handleNonMainVideo(obj) {
        obj.view.element.hide();
    }

    //*** Event handlers

    function setHandlers() {
        _this.events.sub(VideoLayoutObject.SPEAKING, handleUserSpeaking);
    }

    function handleUserSpeaking(e) {
        if (e.speaking && _this.activeUid !== e.obj.data.uid) {
            _this.activeUid = e.obj.data.uid;
            resolveLayout();
        }
    }

    function setVideoLayoutObjectStyles(obj) {
        obj?.view?.setStyles?.({
            element: _this.combineStyles([MobileVideoLayoutStyles.element, styles.element]),
            video: _this.combineStyles([MobileVideoLayoutStyles.video, styles.video])
        });
    }

    async function handleMainVideo(obj) {
        if (!obj.view) return;
        if (obj.data.uid === _mainId) return; // prevent a users screen from appearing if they have multiple instances open
        _mainId = obj.data.uid;
        await obj.view.ready();
        obj.view.element.show();
    }
    //*** Public methods

    this.load = () => {
        initLayout();
    };

    this.unload = () => {
        _this.onResize(() => {});
    };

    this.update = () => {
        resolveLayout();
    };
});

Class(function MobileVideoLayoutStyles() {
    Inherit(this, Component);
    const _this = this;

    /**
     * Provides a 16:9 aspect ratio for mobile by default
     */
    (async function() {
        await DreamColors.instance().ready();

        // TODO: refactor these styles to be easier to trace
        //// These styles are applied to the video layout object
        _this.element = {
            flex: '0.6'
        };
        _this.video = {
            height: '100%',
            width: '100%',
            objectFit: 'cover'
        };
        _this.flag('isReady', true);
    })();

    _this.ready = _ => _this.wait('isReady');
}, 'static');

/**
 * @name MobileScreenShareLayout
 *
 * Mobile Screenshare layout for video feature in dream.
 *
 */
Class(function MobileScreenShareLayout({ styles = {} } = {}) {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    //*** Constructor
    (async function () {
        await MobileScreenShareLayoutStyles.ready();
    })();

    function resolveLayout() {
        if (!_this.parent) return;
        // hide element that holds the chat videos
        _this.parent.responsiveWrapper.invisible();
        _this.parent.videoObjects
            .filter(obj => obj.screenShare)
            .forEach(obj => {
                if (!obj.view) return;
                const { element, videoMuteWrapper, video } = obj.view;
                element.css(_this.combineStyles([MobileScreenShareLayoutStyles.element, styles.element]));
                video.css(_this.combineStyles([MobileScreenShareLayoutStyles.video, styles.video]));
                videoMuteWrapper.css(_this.combineStyles([MobileScreenShareLayoutStyles.videoMuteWrapper, styles.videoMuteWrapper]));
                _this.flag('screenshare', true);
            });
        setScreenShareWrapperStyles();
    }

    function setScreenShareWrapperStyles() {
        if (typeof _this.parent.screenShareWrapper.css !== 'function') return;
        MobileScreenShareLayoutStyles.setParentWrapperStyles(_this.parent);
    }

    //*** Event handlers


    //*** Public methods

    this.load = () => {
        _this.onResize(setScreenShareWrapperStyles);
        resolveLayout();
    };

    this.unload = () => {
        _this.flag('screenshare', false);
        _this.onResize(() => {});
        _this.parent?.responsiveWrapper?.visible?.();
    };

    this.update = () => {
        _this.flag('screenshare', false);
        resolveLayout();
    };
});

Class(function MobileScreenShareLayoutStyles() {
    Inherit(this, Component);
    const _this = this;


    (function() {
        _this.flag('isReady', true);

        // like mobilelayoutstyles, these are VideoLayoutObject styles
        _this.element = {
        };

        _this.videoMuteWrapper = {
        };

        _this.video = {
            position: 'relative'
        };
        _this.name = {
        };
    })();

    _this.setParentWrapperStyles = (parent) => {
        parent.screenShareWrapper.css({
            position: 'absolute',
            maxWidth: '100%',
            padding: '0px 2rem'
        });
    };

    _this.ready = _ => _this.wait('isReady');
}, 'static');

Class(function VideoAdminControls({
    styles = {},
    gcPlayer
}) {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    const $this = _this.element;
    const tooltipConfigBase = {
        position: 'below',
        styles: {
            element: {
                background: DreamColors.instance().black
            }
        }
    };
    //*** Constructor
    (function () {
        initElement();
        initRemoveButton();
        initMuteButton();
        addHandlers();
    })();

    function initElement() {
        $this.css(_this.combineStyles([VideoAdminControlsStyles.element, styles.element]));
    }

    function initRemoveButton() {
        _this.removeButtonWrapper = $this.create(`${_this.getConstructor}__remove-button-wrapper`);
        _this.removeButtonWrapper.css(_this.combineStyles([VideoAdminControlsStyles.buttonWrapper, styles.buttonWrapper]));

        _this.removeButton = _this.initClass(DreamUI.Button, {
            preset: 'icon',
            icon: 'remove-user',
            styles: _this.combineStyles([VideoAdminControlsStyles.removeButton, styles.removeButton])
        }, [_this.removeButtonWrapper]);

        _this.removeToolTip = _this.initClass(DreamUI.Tooltip, {
            ...tooltipConfigBase,
            target: _this.removeButton,
            message: 'Remove user'
        }, [_this.removeButtonWrapper]);
    }

    function initMuteButton() {
        _this.muteButtonWrapper = $this.create(`${_this.getConstructor}__mute-button-wrapper`);
        _this.muteButtonWrapper.css(_this.combineStyles([VideoAdminControlsStyles.buttonWrapper, styles.buttonWrapper]));

        _this.muteButton = _this.initClass(DreamUI.Button, {
            preset: 'icon',
            icon: 'mic-on',
            styles: _this.combineStyles([VideoAdminControlsStyles.muteButton, styles.muteButton])
        }, [_this.muteButtonWrapper]);

        _this.muteToolTip = _this.initClass(DreamUI.Tooltip, {
            ...tooltipConfigBase,
            target: _this.muteButton,
            message: 'Mute user'
        }, [_this.muteButtonWrapper]);
    }



    //*** Event handlers

    function addHandlers() {
        _this.events.sub(_this.removeButton, DreamUI.Button.CLICK, openRemoveModal);
        _this.events.sub(_this.muteButton, DreamUI.Button.CLICK, handleMute);
    }

    function openRemoveModal() {
        if (Config.VIDEO?.disableAdminRemoveModal) return handleRemove();
        UIController.instance().modal.openModal(DreamComponentConfig.instance().videoAdminRemoveModal || VideoAdminRemoveModal, {
            onConfirm: handleRemove,
            isLocal: true
        });
    }

    function handleRemove() {
        _this.events.fire(VideoAdminControls.REMOVE, gcPlayer);
    }

    function handleMute() {
        _this.events.fire(VideoAdminControls.MUTE, gcPlayer);
    }

    //*** Public methods
    _this.show = function() {
        $this.tween({ opacity: 1 }, 500, 'easeOutCubic');
    };

    _this.hide = function() {
        $this.tween({ opacity: 0 }, 500, 'easeOutCubic');
    };
}, _ => {
    VideoAdminControls.REMOVE = 'vac_remove';
    VideoAdminControls.MUTE = 'vac_mute';
});

/**
 * @name VideoAdminControlsStyles
 */
Class(function VideoAdminControlsStyles() {
    Inherit(this, Component);
    const _this = this;

    const BASE_BUTTON_ELEMENT = {
        background: '#3C4043',
        padding: '0.8rem',
        zIndex: 101
    };

    (async function () {
        await DreamColors.instance().ready();

        _this.element = {
            position: 'absolute',
            display: 'grid',
            gridTemplateColumns: '1fr 1fr',
            gridColumnGap: '1rem',
            zIndex: 100,
            right: '1rem',
            top: '1rem',
            opacity: 0
        };

        _this.muteButton = {
            element: {
                ...BASE_BUTTON_ELEMENT
            }
        };

        _this.removeButton = {
            element: {
                ...BASE_BUTTON_ELEMENT
            }
        };

        _this.buttonWrapper = {
            position: 'relative',
            display: 'inline-block'
        };
    })();
}, 'static');

Class(function VideoAdminRemoveModal({
    onConfirm
}) {
    Inherit(this, DreamUI.DreamElement);

    const _this = this;
    const $this = _this.element;

    (function () {
        initElement();
        initContent();
        initFooter();
        initClose();
    })();

    function initElement() {
        $this.css(VideoAdminRemoveModalStyles.element);
    }

    function initContent() {
        _this.title = $this.create(`${_this.constructorName}__title`);
        _this.title.text(VideoAdminRemoveModalCopy.title);
        _this.title.css(VideoAdminRemoveModalStyles.title);
    }

    function initFooter() {
        _this.footer = $this.create(`${_this.constructorName}__footer`);
        _this.footer.css(VideoAdminRemoveModalStyles.footer);

        _this.cancelButton = _this.initClass(DreamUI.Button, {
            ...VideoAdminRemoveModalStyles.cancelButtonStyles,
            text: VideoAdminRemoveModalCopy.cancelButtonText
        }, [_this.footer]);

        _this.events.sub(_this.cancelButton, DreamUI.Button.CLICK, handleCancel);


        _this.confirmButton = _this.initClass(DreamUI.Button, {
            ...VideoAdminRemoveModalStyles.confirmButtonStyles,
            text: VideoAdminRemoveModalCopy.confirmButtonText
        }, [_this.footer]);

        _this.events.sub(_this.confirmButton, DreamUI.Button.CLICK, handleConfirm);
    }

    function initClose() {
        _this.close = _this.initClass(DreamUI.Button, {
            ...VideoAdminRemoveModalStyles.closeButtonStyles
        });

        _this.events.sub(_this.close, DreamUI.Button.CLICK, handleClose);
    }

    //*** Event handlers
    function handleCancel() {
        onCancel();

        UIController.instance().layout.modal.closeModal();
        UIController.instance().modal.closeModal();
    }

    function handleConfirm() {
        onConfirm();

        UIController.instance().layout.modal.closeModal();
        UIController.instance().modal.closeModal();
    }

    function handleClose() {
        UIController.instance().layout.modal.closeModal();
        UIController.instance().modal.closeModal();
    }

    _this.Confirm = onConfirm;
});


/**
 * @name VideoAdminRemoveModalCopy
 */

Class(function VideoAdminRemoveModalCopy() {
    Inherit(this, Component);
    const _this = this;

    (async function () {
        await DreamColors.instance().ready();

        _this.title = "Are you sure you would like to remove this user from the meeting?";
        _this.confirmButtonText = 'Remove';
        _this.cancelButtonText = 'Cancel';

        _this.flag('isReady', true);
    })();
    _this.ready = function () {
        return _this.wait('isReady');
    };
}, 'static');


/**
 * @name VideoAdminRemoveModalStyles
 */

Class(function VideoAdminRemoveModalStyles() {
    Inherit(this, Component);
    const _this = this;

    (async function () {
        await DreamColors.instance().ready();

        _this.element = {
            alignItems: 'center',
            background: DreamColors.instance().white,
            borderRadius: '0.8rem',
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'space-between',
            padding: '8rem 4.8rem 6.5rem',
            textAlign: 'center',
            width: '34rem'
        };

        _this.title = {
            ...DreamStyleguide.instance().label5,
            fontWeight: 'normal',
            color: DreamColors.instance().gray800
        };

        _this.footer = {
            alignItems: 'center',
            display: 'flex',
            marginTop: '2.5rem'
        };

        _this.confirmButtonStyles = {
            preset: 'pill',
            styles: {
                element: {
                    background: DreamColors.instance().red,
                    border: `2px solid ${DreamColors.instance().red}`,
                    padding: '1rem 2rem'
                },
                text: {
                    ...DreamStyleguide.instance().label2,
                    color: DreamColors.instance().white,
                    fontWeight: '700'
                }
            }
        };

        _this.cancelButtonStyles = {
            preset: 'pill',
            styles: {
                element: {
                    marginRight: '2rem',
                    background: 'transparent',
                    border: `2px solid ${DreamColors.instance().gray300}`,
                    padding: '1rem 2rem'
                },
                text: {
                    ...DreamStyleguide.instance().label2,
                    color: DreamColors.instance().blue500,
                    fontWeight: '700'
                }
            }
        };

        _this.closeButtonStyles = {
            icon: 'close',
            preset: 'icon',
            styles: {
                element: {
                    border: `2px solid ${DreamColors.instance().gray300}`,
                    color: DreamColors.instance().gray500,
                    position: 'absolute',
                    right: '1.6rem',
                    top: '1.6rem'
                }
            }
        };


        _this.flag('isReady', true);
    })();

    _this.ready = function () {
        return _this.wait('isReady');
    };
}, 'static');

Class(function VideoBadge({
    styles = {},
    text
}) {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    const $this = _this.element;

    //*** Constructor
    (function () {
        initElement();
        initText();
    })();

    function initElement() {
        $this.css(_this.combineStyles([VideoBadgeStyles.element, styles.element]));
    }

    function initText() {
        _this.text = $this.create(`${_this.constructorName}__text`, 'p');
        _this.text.css(_this.combineStyles([VideoBadgeStyles.text, styles.text]));
        _this.text.text(text);
    }


    //*** Event handlers

    //*** Public methods

    _this.show = function() {
        $this.show();
    };

    _this.hide = function() {
        $this.hide();
    };
});


/**
 * @name VideoBadgeStyles
 */

Class(function VideoBadgeStyles() {
    Inherit(this, Component);
    const _this = this;

    (async function () {
        await DreamColors.instance().ready();

        _this.element = {
            position: 'absolute',
            top: '5%',
            left: '5%',
            background: DreamColors.instance().primary,
            padding: '0.5rem 1rem',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            zIndex: '5',
            borderRadius: '30rem'
        };

        _this.text = {
            ...DreamStyleguide.instance().p1,
            color: DreamColors.instance().white,
            position: 'relative',
            fontWeight: '500'
        };

        _this.flag('isReady', true);
    })();
    _this.ready = function () {
        return _this.wait('isReady');
    };
}, 'static');

Namespace('DreamUI');

/**
 * @name VideoControlBar
 * @memberOf DreamUI
 *
 * Control bar for video elements
 * @param hideScreenShare {boolean}
 * @param hideVideo {boolean}
 * @param styles {}
 */
Class(function VideoControlBar({
    hideScreenShare = false,
    invisibleScreenShare = false,
    hideVideo = false,
    styles = {}
}) {
    Inherit(this, DreamUI.DreamElement);

    const _this = this;
    const $this = _this.element;

    //*** Constructor
    (function () {
        initElement();
        initHTML();
    })();

    function initElement() {
        $this.css(_this.combineStyles([VideoControlBarStyles.element, styles.element]));
    }

    function initHTML() {
        _this.content = $this.create(`${_this.constructorName}__content`);
        _this.content.css(_this.combineStyles([VideoControlBarStyles.content, styles.content]));

        //Settings Button
        _this.settingsButton = _this.initClass(UIAVSettingsButton, [_this.content]);

        //Audio + Video Toggle
        _this.audioVideoWrapper = _this.content.create(`${_this.constructorName}__audio-video-wrapper`);
        _this.audioVideoWrapper.css(_this.combineStyles([VideoControlBarStyles.audioVideoWrapper, styles.audioVideoWrapper]));


        _this.audioToggle = _this.initClass(UIAVAudioToggle, [_this.audioVideoWrapper]);
        _this.videoToggle = _this.initClass(UIAVVideoToggle, [_this.audioVideoWrapper]);

        initScreenShareButton();

        if (hideVideo) {
            _this.videoToggle.element.css({
                opacity: '0',
                pointerEvents: 'none',
                display: 'none'
            });
        }
    }

    /**
     * Init screenshare always b/c of current styling (grid, aligns items properly)
     * but hide it if user shouldn't be able to screenshare
     */
    function initScreenShareButton() {
        _this.screenshareButton = _this.initClass(UIAVShareButton, [_this.content]);


        let rolesThatCanShare = null;
        // to enable only certain roles to share, set in project Config
        if (Config.VIDEO?.rolesThatCanShare) { rolesThatCanShare = !!Object.keys(User.claims).filter(key => User.claims[key] && Config.VIDEO?.rolesThatCanShare.includes(key)).length; }

        if (hideScreenShare) {
            _this.screenshareButton.element.css({
                opacity: '0',
                pointerEvents: 'none',
                display: 'none'
            });
        }

        if (invisibleScreenShare || (rolesThatCanShare === false)) {
            _this.screenshareButton.element.css({
                opacity: '0',
                pointerEvents: 'none'
            });
        }
    }

    function setToggleButtonStyles(buttonStyles) {
        _this.settingsButton.setStyles(buttonStyles);
        _this.videoToggle.setStyles(buttonStyles);
        _this.screenshareButton.setStyles(buttonStyles);
        _this.audioToggle.setStyles(buttonStyles);
    }

    /**
     * Update the styles for video and audio toggle buttons
     * @param {*} videoToggleStyles
     * @param {*} audioToggleStyles
     */
    this.setToggleButtonStyles = setToggleButtonStyles;
});

/**
 * @name VideoControlBarStyles
 */
Class(function VideoControlBarStyles() {
    Inherit(this, Component);
    const _this = this;

    (async function () {
        await DreamColors.instance().ready();

        _this.element = {
            position: 'relative',
            bottom: '0%',
            background: 'transparent',
            width: '100%',
            padding: '1rem 0rem',
            minHeight: '8.8rem',
            height: '8.8rem',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center'
        };

        _this.content = {
            display: 'grid',
            gridAutoFlow: 'column',
            placeContent: 'center',
            placeItems: 'center',
            gridGap: '0.5rem',
            position: 'relative',
            justifyContent: 'space-between',
            padding: '0 2rem',
            width: '100%'
        };

        _this.audioVideoWrapper = {
            position: 'relative',
            display: 'grid',
            gridTemplateColumns: '1fr 1fr',
            alignItems: 'center',
            justifyContent: 'center',
            gridGap: '2.8rem'
        };
        _this.flag('isReady', true);
    })();
    _this.ready = function () {
        return _this.wait('isReady');
    };
}, 'static');

Namespace('DreamUI');

/**
 * @name VideoLayoutObject
 * @memberOf DreamUI
 *
 * Core Input component of Dream UI.
 *
 * @param animations
 * @param badge {boolean}
 * @param noScreenshare {boolean}
 * @param styles {}
 * @param obj {data, gcPlayer, me, media, user, screenShare, video}
 */
Class(function VideoLayoutObject({
    obj,
    styles = {},
    animations = VideoLayoutObjectAnimations,
    noScreenshare = false
}) {
    Inherit(this, DreamUI.DreamElement);

    const _this = this;
    const $this = _this.element;

    //*** Constructor
    (function () {
        _this.screenShare = obj.screenShare;
        if (noScreenshare) _this.screenShare = false;
        _this.videoObjectUser = obj.user; // the user belonging to video object, not User!
        initElement();
        initWrappers();
        initProfile();
        initVideo();
        initBadge();
        initAdminControls();
        addHandlers();
        if (_this.screenShare) {
            _this.videoMuteWrapper.hide();
            _this.name.hide();
            _this.avatarImage.hide();
        }
        _this.flag('isReady', true);
    })();

    function initElement() {
        $this.css(_this.combineStyles([VideoLayoutObjectStyles.element, styles.element]));
    }


    function initWrappers() {
        _this.videoSpeakingWrapper = $this.create(`${_this.constructorName}__video-speaking-wrapper`);
        _this.videoSpeakingWrapper.css(_this.combineStyles([VideoLayoutObjectStyles.videoSpeakingWrapper, styles.videoSpeakingWrapper]));

        _this.videoMuteWrapper = $this.create(`${_this.constructorName}__video-mute-wrapper`);
        _this.videoMuteWrapper.css(_this.combineStyles([VideoLayoutObjectStyles.videoMuteWrapper, styles.videoMuteWrapper]));

        _this.muteIndicator = $this.create(`${_this.constructorName}__mute-indicator`);
        _this.muteIndicator.css(_this.combineStyles([VideoLayoutObjectStyles.muteIndicator, styles.muteIndicator]));

        _this.muteIcon = _this.muteIndicator.create(`${_this.constructorName}__mute-icon`, 'img');
        _this.muteIcon.attr('alt', 'mute icon').attr('src', `${Assets.getPath('~assets/images/icon/mic-off.svg')}`);
        _this.muteIcon.css(_this.combineStyles([VideoLayoutObjectStyles.muteIcon, styles.muteIcon]));
    }

    function initProfile() {
        const { user } = obj;
        _this.name = $this.create(`${_this.constructorName}__name`);
        _this.name.css(_this.combineStyles([VideoLayoutObjectStyles.name, styles.name]));

        const src = user && user.image ? user.image : `${Assets.getPath('~assets/images/avatar/placeholder.png')}`;
        if (user) {
            _this.name.text(obj.user.displayName);
        } else {
            _this.name.css({ display: 'none' });
        }

        if (obj.screenShare) {
            _this.name.css({ display: 'none' });
        }

        _this.avatarImage = _this.videoMuteWrapper.create(`${_this.constructorName}__avatar-images`);
        _this.avatarImage.css(_this.combineStyles([VideoLayoutObjectStyles.avatarImage, styles.avatarImage]));
        _this.avatarImage.bg(src, "cover");
    }

    function initVideo() {
        $this.add(obj.video);
        _this.video = $(obj.video);
        _this.video.css(_this.combineStyles([VideoLayoutObjectStyles.video, styles.video]));
        if (_this.screenShare) {
            const screenShareStyles = VideoLayoutObjectStyles.getScreenShareStyles();
            _this.element.css(screenShareStyles.element);
            _this.video.css(screenShareStyles.video);
        }
        if (obj.me && !_this.screenShare) {
            _this.video.css({
                transform: 'scale(-1, 1)'
            });
        }
    }

    function initBadge() {
        if (obj.screenShare) return;
        if (Config.VIDEO?.disableBadges) return; // set from within project to disable badges
        _this.roleWrapper = $this.create(_this.getPrefix('role-wrapper'));
        _this.roleWrapper.css(_this.combineStyles([VideoLayoutObjectStyles.roleWrapper, styles.roleWrapper]));
        _this.roles = _this.initClass(DreamUI.Roles, {
            prefix: 'large',
            user: _this.videoObjectUser
        }, [_this.roleWrapper]);
    }

    /**
     * Init admin controls for this video object
     * dependent on current User's roles
     */
    function initAdminControls() {
        if (obj.me || obj.screenShare) return;
        // admin, superadmin and any roles set in project Config.VIDEO.adminRoles
        const adminRoles = ['admin', 'superadmin'].concat(Config.VIDEO?.adminRoles || []);
        const showControls = Object.keys(User.claims).filter(key => User.claims[key] && adminRoles.includes(key)).length;
        if (!showControls) return;
        const { gcPlayer } = obj;
        _this.adminControls = _this.initClass(VideoAdminControls, { gcPlayer });
    }

    //*** Event handlers

    function addHandlers() {
        obj.onSpeaking = function(value) {
            handleIsSpeaking(value);
        };

        obj.onVideoMute = (value) => {
            handleVideoMute(value);
        };

        obj.onAudioMute = (value) => {
            handleAudioMute(value);
        };

        _this.events.sub(VideoLayoutWrapper.SCREENSHARE_ON, ({ screenShareOn }) => {
            if (screenShareOn) {
                // _this.name.css({ display: 'none' });
                _this.muteIndicator.css({ width: '2rem', height: '2rem' });
            } else if (!screenShareOn) {
                if (!_this.parent?.videoControlBar?.videoToggle?._enabled) {
                    GameCenterMedia.userStream.disableVideo();
                }
                _this.name.css({ display: 'block' });
                _this.muteIndicator.css({ width: '3.4rem', height: '3.4rem' });
            }
        });

        if (!obj.me && _this.adminControls) {
            $this.bind('mouseenter', () => _this.adminControls.show());
            $this.bind('mouseleave', () => _this.adminControls.hide());
        }

        _this.onResize(resize);
    }


    function resize() {
        // _this.name.css({
        //     fontSize: window.innerHeight > window.innerWidth ? '1.15vw' : '2vh'
        // });
        $this.css({
            minHeight: 'auto',
            minWidth: 'auto'
        });
    }

    function handleIsSpeaking(speaking) {
        if (!_this.videoSpeakingWrapper.tween) return;
        if (speaking && !_this._mutedAudio) {
            animations.showVideoSpeakingWrapper(_this.videoSpeakingWrapper);
        } else {
            animations.hideVideoSpeakingWrapper(_this.videoSpeakingWrapper);
        }
        _this.events.fire(VideoLayoutObject.SPEAKING, { speaking, obj });
    }

    async function handleVideoMute(muted) {
        if (muted) {
            _this._mutedVideo = true;
            _this.video.attr('data-video-muted', 1);
            animations.muteVideo(_this, obj.me);
        } else {
            _this._mutedVideo = false;
            _this.video.attr('data-video-muted', 0);
            await animations.unmuteVideo(_this, obj.me);
        }
    }

    function handleAudioMute(muted) {
        if (!_this.muteIndicator.tween) return;
        if (muted) {
            _this._mutedAudio = true;
            _this.muteIndicator.tween({ opacity: 1 }, 250, 'easeOutQuad');
        } else {
            _this._mutedAudio = false;
            _this.muteIndicator.tween({ opacity: 0 }, 250, 'easeOutQuad');
        }
    }

    _this.setStyles = async function(_styles) {
        await _this.ready();
        if (!$this || !$this.css) return;
        if (_styles.element) $this.css(_styles.element);
        if (_styles.video) _this.video.css(_styles.video);
        if (_styles.avatarImage) _this.avatarImage.css(_styles.avatarImage);
        if (_styles.roleWrapper) _this.roleWrapper.css(_styles.roleWrapper);
    };

    _this.ready = _ => _this.wait('isReady');

    _this.onDestroy = () => {
    };
}, (_) => {
    VideoLayoutObject.SPEAKING = 'vlo_speaking';
});

Namespace('DreamUI');

Class(function VideoLayoutObjectAnimations() {
    Inherit(this, Component);


    this.muteVideo = (component, me) => {
        component.videoMuteWrapper.css({ transform: 'scale(1)' });
        component.video.tween({ opacity: 0, scale: component.screenShare || !me ? '1' : '-1, 1' }, 250, 'easeOutQuad');
    };

    this.unmuteVideo = (component, me) => {
        component.video
            .tween({ opacity: 1, scale: component.screenShare || !me ? '1' : '-1, 1' }, 250, 'easeOutQuad',
                _ => component.videoMuteWrapper.css({ transform: 'scale(0.99)' })).promise();
    };

    this.hideVideoSpeakingWrapper = (videoSpeakingWrapper) => {
        videoSpeakingWrapper.tween({ opacity: 0 }, 250, 'easeOutQuad');
    };

    this.showVideoSpeakingWrapper = (videoSpeakingWrapper) => {
        videoSpeakingWrapper.tween({ opacity: 1 }, 250, 'easeOutQuad');
    };
}, 'static');

Namespace('DreamUI');

/**
 * @name VideoLayoutObjectStyles
 * @memberOf DreamUI
 */
Class(function VideoLayoutObjectStyles() {
    Inherit(this, Component);
    const _this = this;


    (async function () {
        await DreamColors.instance().ready();

        _this.element = {
            position: 'relative',
            width: '100%'
        };

        _this.videoSpeakingWrapper = {
            height: '100%',
            width: '100%',
            objectFit: 'cover',
            left: 0,
            top: 0,
            opacity: 0,
            zIndex: 3,
            boxShadow: 'inset 0px 0px 0px 5px #F5C26B'
        };

        _this.video = {
            opacity: 1,
            zIndex: 1,
            width: '100%',
            height: '100%',
            objectFit: 'cover'
        };

        _this.videoMuteWrapper = {
            position: 'absolute',
            height: '100%',
            width: '100%',
            left: 0,
            top: 0,
            zIndex: 1,
            background: DreamColors.instance().gray800,
            transform: 'scale(0.99)' // cos of stupid pixel border on edges when video showing
        };

        _this.muteIndicator = {
            width: '3.4rem',
            height: '3.4rem',
            background: "#FA0510",
            opacity: 0,
            position: 'absolute',
            bottom: '1rem',
            right: '1.2rem',
            zIndex: 5,
            borderRadius: '50%',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            boxShadow: '0px 3px 4px rgba(0,0,0,0.1)'
        };

        _this.name = {
            ...DreamStyleguide.instance().p1,
            position: 'absolute',
            fontWeight: '700',
            fontSize: window.innerHeight > window.innerWidth ? '1.15vw' : '2vh',
            color: 'white',
            textShadow: '0 0 2px rgba(0,0,0,0.80)',
            transform: 'translate(0%, -50%)',
            left: '5%',
            bottom: '0%',
            zIndex: 10
        };

        _this.avatarImage = {
            borderRadius: '50%',
            transform: 'translate(-50%, -50%)',
            left: '50%',
            top: '50%',
            objectFit: 'cover',
            height: '20vh',
            width: '20vh',
            pointerEvents: 'none',
            backgroundRepeat: 'no-repeat'
        };

        _this.leader = {
            ...DreamStyleguide.instance().p1,
            position: 'absolute',
            borderRadius: '2rem',
            left: '50%',
            top: '2rem',
            transform: 'translate(-50%, 0%)',
            padding: '0.5rem 1rem',
            opacity: 0,
            color: 'white',
            zIndex: 100
        };

        _this.muteIcon = {
            maxWidth: '50%',
            objectFit: 'cover'
        };

        _this.roleWrapper = {
            position: 'absolute',
            top: 24,
            left: 16,
            zIndex: 10
        };

        _this.getScreenShareStyles = _ => ({
            element: {
                width: 'auto'
            },
            video: {
                objectFit: 'contain',
                transform: 'scale(1)',
                maxWidth: '100%',
                maxHeight: 'calc(70vh - 9rem)',
                width: 'auto',
                height: 'auto'
            }
        });

        _this.flag('isReady', true);
    })();

    _this.ready = function () {
        return _this.wait('isReady');
    };
}, 'static');

Namespace('DreamUI');

/**
 * @name VideoLayoutWrapper
 * @memberOf DreamUI
 *
 * Layout wrapper
 *
 * @param hideOnMobile {boolean}
 * @param hideScreenShare {boolean}
 * @param styles {}
 * @param controlBarStyles {}
 * @param animations {}
 * @param videoLayoutObjectStyles {} default styles for VideoLayoutObject - included in mobile as well
 * @param mobileVideoLayoutObjectStyles {} VideoLayoutObject styles for mobile only
 * @param mobileScreenShareLayoutStyles {} VideoLayoutObject styles for the screen share video object on mobile. Defaults to mobileVideoLayoutObjectStyles
 */
Class(function VideoLayoutWrapper({
    hideOnMobile = false,
    hideScreenShare = false,
    animations = VideoLayoutWrapperAnimations,
    styles = {},
    controlBarStyles = {},
    videoLayoutObjectStyles = {},
    mobileVideoLayoutObjectStyles = {},
    mobileScreenShareLayoutStyles = mobileVideoLayoutObjectStyles
}={}) {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    const $this = _this.element;
    const SCREENSHARE_LAYOUT = 'screenshare';
    const MOBILE_SCREENSHARE_LAYOUT = 'mobile-screenshare';
    const DEFAULT_CHAT_LAYOUT = 'default-layout';
    const MOBILE_CHAT_LAYOUT = 'mobile-layout';

    _this.videoObjects = [];

    //*** Constructor
    (async function () {
        await VideoLayoutWrapperStyles.ready();
        $this.mouseEnabled(true);
        initElement();
        initHTML();
        addHandlers();
        initLayouts();
    })();

    function initElement() {
        $this.css(_this.combineStyles([VideoLayoutWrapperStyles.element, styles.element]));
    }

    function initHTML() {
        _this.responsiveWrapper = $this.create(`${_this.constructorName}__responsive-wrapper`);
        _this.responsiveWrapper.css(_this.combineStyles([VideoLayoutWrapperStyles.responsiveWrapper, styles.responsiveWrapper]));
        if (Device.mobile && hideOnMobile) {
            _this.responsiveWrapper.css({
                display: 'none'
            });
        }

        _this.videoControlBar = _this.initClass(VideoControlBar, {
            hideScreenShare: Device.mobile || hideScreenShare,
            hideVideo: Device.mobile && hideOnMobile,
            styles: controlBarStyles
        });
    }

    function initLayouts() {
        _this.screenShareLayout = initScreenShareLayout();
        _this.chatLayout = initChatLayout();

        _this.activeLayout = _this.chatLayout.layout;
        _this.activeLayout.title = _this.chatLayout.title;
        _this.activeLayout.load();
    }

    function initChatLayout() {
        if (Device.mobile) {
            return {
                layout: _this.initClass(MobileVideoLayout, { styles: mobileVideoLayoutObjectStyles }),
                title: MOBILE_CHAT_LAYOUT
            };
        }

        return {
            layout: _this.initClass(DefaultVideoLayout),
            title: DEFAULT_CHAT_LAYOUT
        };
    }

    function initScreenShareLayout() {
        if (Device.mobile) {
            return {
                layout: _this.initClass(MobileScreenShareLayout, { styles: mobileScreenShareLayoutStyles }),
                title: MOBILE_SCREENSHARE_LAYOUT
            };
        }
        return {
            layout: _this.initClass(ScreenShareLayout),
            title: SCREENSHARE_LAYOUT
        };
    }

    //*** Event handlers
    function addHandlers() {
        _this.parent.getDOMElement().onResize(resize);
    }

    function resize() {
        if (Device.mobile && hideOnMobile) {
            _this.videoControlBar.element.css({
                top: '65%',
                left: '50%'
            }).transform({ x: '-50%', y: '-50%' });
        }
    }


    function changeVideoLayout(newLayout) {
        _this.activeLayout.unload();
        _this.activeLayout = newLayout.layout;
        _this.activeLayout.title = newLayout.title;
        _this.activeLayout.load();
    }

    /**
     * Called only for the main screen share view
     * Called for a brand new screen share, and when a person stops sharing and another screen share takes its place
     *
     * If other screen share objects are created while a screen share is already in progess
     * that object is handled via handleSecondScreenshare()
     *
     * @param {*} obj
     */
    function handleScreenShareLayout(obj) {
        removeScreenShareHeading();
        _this.events.fire(VideoLayoutWrapper.SCREENSHARE_ON, { screenShareOn: true });
        _this.screenShareWrapper = $this.create(`${_this.constructorName}__screenshare-wrapper`);
        _this.screenShareWrapper.css(_this.combineStyles([VideoLayoutWrapperStyles.screenShareWrapper, styles.screenShareWrapper]));

        let videoObject = _this.initClass(VideoLayoutObject, { obj, styles: videoLayoutObjectStyles }, [_this.screenShareWrapper]);
        obj.isCurrentlySharing = true;
        obj.view = videoObject;

        addScreenShareHeadeing(obj, videoObject);

        _this.videoObjects.push(obj);
        changeVideoLayout(_this.screenShareLayout);
    }

    function removeScreenShareHeading() {
        _this.screenShareHeading = null;
    }

    function addScreenShareHeadeing(obj, videoObject) {
        _this.screenShareHeading = videoObject.element.create(`${_this.constructorName}__screenshare-heading`);
        _this.screenShareHeading.css(_this.combineStyles([VideoLayoutWrapperStyles.screenShareHeading, styles.screenShareHeading]));
        _this.screenShareHeading.css({ opacity: 0 });
        _this.screenShareHeading.text(`${obj.user.displayName} is sharing`);
        _this.screenShareHeading.tween({ opacity: 1 }, 200, 'easeOutCubic', 1000);
    }

    /**
     * When a screen share is already in progress, handle new screen shares
     * @param {*} obj
     */
    function handleSecondScreenshare(obj) {
        let videoObject = _this.initClass(VideoLayoutObject, {
            obj,
            noScreenshare: true,
            styles: videoLayoutObjectStyles
        }, [_this.responsiveWrapper]);
        obj.view = videoObject;
        _this.delayedCall(() => {
            obj.view.setStyles({
                video: {
                    height: '100%',
                    width: '100%'
                }
            });

            if (obj.view.adminControls) obj.view.adminControls.hide();
        });
        _this.videoObjects.push(obj);
        // updates the ScreenShareLayout
        _this.activeLayout.update();
    }

    //*** Public methods
    this.show = function() {
        $this.show();
        animations.showVideoControlBar(_this.videoControlBar);
    };

    this.hide = function() {
        $this.hide();
        animations.hideVideoControlBar(_this.videoControlBar);
    };

    this.addVideo = async function (obj, me) {
        const { uid } = obj.data;

        // Get user and add result to obj
        if (uid) {
            const user = await DreamDirectory.get(uid);
            obj.user = user;
        }

        if (obj.screenShare && (_this.activeLayout.title === SCREENSHARE_LAYOUT || _this.activeLayout.title === MOBILE_SCREENSHARE_LAYOUT)) {
            return handleSecondScreenshare(obj);
        }

        // If obj is a screenshare, switch layout
        if (obj.screenShare) {
            _this.events.fire(VideoLayoutWrapper.VIDEO_ADDED);
            return handleScreenShareLayout(obj);
        }
        let videoObject = _this.initClass(VideoLayoutObject, {
            obj,
            styles: videoLayoutObjectStyles
        }, [_this.responsiveWrapper]);

        // If I have my mute or video mute on, update the view
        if (me) {
            if (!_this.videoControlBar.videoToggle._enabled) {
                GameCenterMedia.userStream.disableVideo();
            }
            if (!_this.videoControlBar.audioToggle._enabled) {
                GameCenterMedia.userStream.disableAudio();
            }
        }
        obj.view = videoObject;
        _this.videoObjects.push(obj);
        _this.activeLayout.update();
        _this.events.fire(VideoLayoutWrapper.VIDEO_ADDED);
    };

    function removeVideoFromListAndReturnIt(obj) {
        const activeIndex = _this.videoObjects.indexOf(obj);
        if ('isCurrentlySharing' in obj) obj.isCurrentlySharing = false;
        return _this.videoObjects.splice(activeIndex, 1);
    }

    /**
     * When a participant is removed from a session by an admin
     * @param {*} _
     */
    this.handleKickParticipant = playerId => {
        _this.videoControlBar.destroy();
        // cleanup the screenshare object if user was sharing when they were booted
        _this.videoObjects.forEach(obj => {
            if (obj.screenShare && obj.gcPlayer.id === playerId) removeLeftOverScreenShare(obj);
        });

        _this.delayedCall(_ => {
            $this.css({ display: 'flex' });
            _this.responsiveWrapper.hide();
            _this.element.css({ ...VideoLayoutWrapperStyles.elementAfterUserKicked });
            const removedView = _this.initClass(DreamComponentConfig.instance().videoUserRemoved || VideoUserRemoved);
        }, 100);
    };

    function removeLeftOverScreenShare(obj) {
        GameCenterMedia.stopScreenShare();
        if (_this.screenShareWrapper && _this.screenShareWrapper.destroy) {
            _this.screenShareWrapper.destroy();
        }
    }

    this.removeVideo = function (obj) {
        const activeVideo = removeVideoFromListAndReturnIt(obj);

        _this.events.fire(VideoLayoutWrapper.VIDEO_REMOVED);

        if (activeVideo[0]) {
            activeVideo[0].view.destroy();
        }
        const otherScreenshare = _this.videoObjects.find(obj => obj.screenShare);
        if (obj.screenShare && otherScreenshare) {
            if (otherScreenshare.view && otherScreenshare.view.destroy) {
                otherScreenshare.view.destroy();
            }
            removeVideoFromListAndReturnIt(otherScreenshare);
            return handleScreenShareLayout(otherScreenshare);
        }
        if (obj.screenShare) {
            // TODO: seems to be race condition between component destruction
            // and video cleanup handled elsewhere -
            // when a user leaves the meeting via UI (not page refresh)
            // and was sharing their screen, the screen share stays on
            //
            // adding this stops the screen share, but could be handled elsewhere?
            GameCenterMedia.stopScreenShare();

            if (_this.screenShareWrapper && _this.screenShareWrapper.destroy) {
                _this.screenShareWrapper.destroy();
            }
            _this.events.fire(VideoLayoutWrapper.SCREENSHARE_ON, { screenShareOn: false });
            changeVideoLayout(_this.chatLayout);
        }

        _this.activeLayout.update();
    };

    this.applyBackground = function ({ image, backgroundColor, blendMode, backgroundSize }) {
        $this
            .css({
                backgroundColor,
                backgroundSize: backgroundSize || 'cover',
                backgroundPosition: 'top left',
                backgroundRepeat: 'no-repeat',
                backgroundBlendMode: blendMode || 'screen'
            });
        if (image) {
            $this.bg(image);
        }
    };


    this.setToggleButtonStyles = (videoToggleStyles) => _this.videoControlBar.setToggleButtonStyles(videoToggleStyles);
}, (_) => {
    VideoLayoutWrapper.SCREENSHARE_ON = 'vlw_screenshare_on';
    VideoLayoutWrapper.VIDEO_ADDED = 'vlw_video_added';
    VideoLayoutWrapper.VIDEO_REMOVED = 'vlw_video_removed';
});

Namespace('DreamUI');

Class(function VideoLayoutWrapperAnimations() {
    Inherit(this, Component);

    this.showVideoControlBar = (controlBar) => {
        controlBar.element.css({ pointerEvents: 'auto', opacity: 1 });
    };

    this.hideVideoControlBar = (controlBar) => {
        controlBar.element.css({ pointerEvents: 'none', opacity: 0 });
    };
}, 'static');

Namespace('DreamUI');

/**
 * @name VideoLayoutWrapperStyles
 * @memberOf DreamUI
 */
Class(function VideoLayoutWrapperStyles() {
    Inherit(this, Component);
    const _this = this;

    (async function () {
        await DreamStyleguide.instance().ready();

        _this.fullHeightMinusControlBar = `calc(100% - 8.8rem)`;
        _this.element = {
            position: 'relative',
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'flex-end',
            alignItems: 'center',
            height: '100%'
        };

        _this.responsiveWrapper = {
            position: 'relative',
            display: 'flex',
            justifyContent: 'center',
            flexWrap: 'wrap',
            alignItems: 'center',
            width: '100%',
            height: _this.fullHeightMinusControlBar,
            flexGrow: '1',
            gap: '0.5rem'
        };

        _this.defaultVideoLayoutResponsiveWrapperVariant = {
            position: 'relative',
            top: '0%',
            alignItems: 'center',
            justifyItems: 'center',
            alignContent: 'center',
            height: _this.fullHeightMinusControlBar,
            overflow: 'initial',
            display: 'flex',
            flexWrap: 'wrap',
            justifyContent: 'center',
            width: '100%'
        };

        _this.mobileVideoLayoutResponsiveWrapperVariant = {
            flexDirection: 'column',
            padding: '0 2rem'
        };

        _this.screenShareLayoutResponsiveWrapperVariant = {
            position: 'relative',
            display: 'grid',
            gridTemplateColumns: '1fr',
            gridAutoRows: 'min-content',
            placeItems: 'end',
            placeContent: 'start',
            gridGap: '.5rem',
            margin: '0 0 0 auto',
            flexGrow: '1',
            width: '100%',
            height: _this.fullHeightMinusControlBar,
            overflow: 'hidden auto'
        };

        _this.elementAfterUserKicked = {
            display: 'flex',
            justifyContent: 'center'
        };

        _this.screenShareWrapper = {
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            left: 0,
            top: 0,
            pointerEvents: 'none',
            maxWidth: '80%',
            padding: '0 2rem',
            height: _this.fullHeightMinusControlBar,
            width: '100%'
        };

        _this.screenShareHeading = {
            ...DreamStyleguide.instance().h4,
            top: '-4rem',
            left: 0,
            right: 0,
            textAlign: 'center'
        };

        _this.flag('isReady', true);
    })();

    _this.ready = _ => _this.wait('isReady');
}, 'static');

Namespace('DreamUI');

/**
 * @name VideoLoader
 * @memberOf DreamUI
 *
 * Core Input component of Dream UI.
 *
 * @param styles {}
 * @param message {string}
 */
Class(function VideoLoader({ message, styles = {} }) {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    const $this = this.element;

    //*** Constructor
    (function () {
        initHTML();
        initSpinner();
        if (message) {
            initMessage();
        }
        addHandlers();
    })();

    function initHTML() {
        $this.css(_this.combineStyles([VideoLoaderStyles.element, styles.element]));

        _this.wrapper = $this.create(`${_this.constructorName}__wrapper`);
        _this.wrapper.css(_this.combineStyles([VideoLoaderStyles.wrapper, styles.wrapper]));
    }

    function initSpinner() {
        _this.spinner = _this.wrapper.create('.spinner-anim-alt');
        _this.spinner.css(_this.combineStyles([VideoLoaderStyles.spinner, styles.spinner]));
    }

    function initMessage() {
        _this.message = _this.wrapper.create(_this.getPrefix('text'), 'h5');
        _this.message.css(_this.combineStyles([VideoLoaderStyles.message, styles.message]));
        _this.message.text(message);
    }

    //add handlers
    function addHandlers() {
        _this.onResize(resize);
    }

    function resize() {
        $this.css({
            width: Stage.width,
            height: Stage.height
        });
    }

    //Public Methods
    this.appear = function() {
        $this.css({ opacity: 1 });
    };

    this.hide = function() {
        $this.css({ opacity: 0 });
    };
});

Namespace('DreamUI');

/**
 * @name VideoLoaderStyles
 * @memberOf DreamUI
 */
Class(function VideoLoaderStyles() {
    Inherit(this, Component);
    const _this = this;

    (async function () {
        await DreamColors.instance().ready();
        let spinnerSize = Device.mobile.phone ? 100 : 110;

        _this.element = {
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            width: Stage.width,
            height: Stage.height,
            pointerEvents: 'none',
            opacity: 0,
            left: 0,
            top: 0,
            zIndex: 1000
        };

        _this.message = {
            ...DreamStyleguide.instance().h5,
            position: 'relative',
            lineHeight: '1.6rem',
            letterSpacing: '0.2rem',
            opacity: 1,
            color: DreamColors.instance().black,
            marginBottom: '4rem'
        };

        _this.wrapper = {
            display: 'flex',
            flexDirection: 'column',
            flexFlow: 'column-reverse',
            alignItems: 'center',
            justifyContent: 'center',
            width: 200,
            height: 200
        };

        _this.spinner = {
            position: 'relative',
            width: spinnerSize,
            height: spinnerSize
        };
    })();
}, 'static');

/**
 * @name VideoPreview
 * @param styles {}
 * @param animations {}
 * @param hideVideoOnMobile {boolean} hides/disables video on mobile
 * @param messageText {string}
 * @param buttonText {string}
 * @param buttonPreset {string} basic | stroked | raised | flat | icon | fab | minFab | pill
 * @param fullScreen {boolean} hide the side panel when preview loads
 * @param showPanelCondition {boolean | function} when preview is destroyed, show panel if meets condition - can be boolean or function that evaluates to boolean, called in component destruction
 * @param roomId {string | null} the id for the chat room about to enter - pass null to disable attendee counter
 */
Class(function VideoPreview({
    styles = {},
    animations = VideoPreviewAnimations,
    hideVideoOnMobile = false,
    messageText = 'Set up your camera and audio',
    attendeesText = 'Attendees in room',
    buttonText = 'Join now',
    buttonPreset = 'pill',
    controlBarStyles = {},
    fullScreen = true,
    showPanelCondition = Device.mobile,
    roomId = 'test'
}) {
    Inherit(this, DreamUI.DreamElement);

    const _this = this;
    var $this = _this.element;
    var _video;
    var _mutedAudio;
    _this.vidZIndex = 200;

    //*** Constructor
    (async function () {
        await VideoPreviewStyles.ready();
        if (roomId !== null) await DreamAttendees.activate(roomId);
        _this.element.mouseEnabled(true);
        _this.parentEl = await _this.parent.parent.getDOMElement();
        if (fullScreen) UIController.instance().layout.hide();

        detectUserMediaPermissions(); // show notification if initVideo() never resolves
        initBackButton();
        initHTML();
        initMessage();
        if (roomId !== null) initAttendeesCount();

        await initVideo(); // never resolves if user has no video audio/video permissions
        initVideoControlBar();
        initVideoIndicators();
        initStartButton();
        initAvatarImage();

        if (Device.mobile && hideVideoOnMobile) {
            _this.message.css({ display: 'none' });
            await _this.wait(GameCenterMedia, 'userStream');
            GameCenterMedia.userStream.disableVideo();
        }

        _this.flag('isReady', true);
        animateIn();
        _this.startRender(_ => {}); //this is so visibility events will fire correctly
        addListeners();
    })();

    function initHTML() {
        $this.css(_this.combineStyles([VideoPreviewStyles.container, styles.container]));

        _this.contentWrapper = $this.create(`${_this.constructorName}__content-wrapper`);
        _this.contentWrapper.css(_this.combineStyles([VideoPreviewStyles.contentWrapper, styles.contentWrapper]));
    }

    function initVideoControlBar() {
        _this.videoControlBar = _this.initClass(VideoControlBar, {
            invisibleScreenShare: true,
            hideVideo: Device.mobile && hideVideoOnMobile,
            styles: controlBarStyles
        });
    }

    function initMessage() {
        _this.message = _this.contentWrapper.create(`${_this.constructorName}__message`);
        _this.message.css(_this.combineStyles([VideoPreviewStyles.message, styles.message]));
        _this.message.text(messageText);
    }

    function initAttendeesCount() {
        _this.attendeesHeader = _this.contentWrapper.create(`${_this.constructorName}__attendees-text`);
        _this.attendeesHeader.css(_this.combineStyles([VideoPreviewStyles.attendeesHeader, styles.attendeesHeader]));

        DreamAttendees.state.bind('count', count => {
            if (_this.attendeesHeader) _this.attendeesHeader.text(`${attendeesText} (${count})`);
        });
    }

    function initBackButton() {
        _this.backButton = _this.initClass(DreamComponentConfig.videoPreviewBackButton || VideoPreviewBackButton);
        _this.events.sub(_this.backButton, DreamUI.Button.CLICK, _ => _this.events.fire(VideoPreview.BACK_BUTTON_CLICK));
    }

    async function initVideo() {
        _this.videoWrapper = _this.contentWrapper.create(`${_this.constructorName}__video-wrapper`);
        _this.videoWrapper.css(_this.combineStyles([VideoPreviewStyles.videoWrapper, styles.videoWrapper]));
        _video = await GameCenterMedia.getUserVideo();
        await addVideo();
    }

    async function addVideo(getUserVideo = false) {
        if (Device.mobile && hideVideoOnMobile) return;
        if (getUserVideo) _video = await GameCenterMedia.getUserVideo();
        _this.video = $(_video);
        _this.video.css(VideoPreviewStyles.video);
        _this.videoWrapper.add(_video);
    }

    function initVideoIndicators() {
        _this.videoSpeakingWrapper = _this.videoWrapper.create(`${_this.constructorName}__video-speaking-wrapper`);
        _this.videoSpeakingWrapper.css(_this.combineStyles([VideoPreviewStyles.videoSpeakingWrapper, styles.videoSpeakingWrapper]));

        _this.videoMuteWrapper = _this.videoWrapper.create(`${_this.constructorName}__video-mute-wrapper`);
        _this.videoMuteWrapper.css(_this.combineStyles([VideoPreviewStyles.videoMuteWrapper, styles.videoMuteWrapper]));

        _this.muteIndicator = _this.videoWrapper.create(`${_this.constructorName}__mute-indicator`);
        _this.muteIndicator.css(_this.combineStyles([VideoPreviewStyles.muteIndicator, styles.muteIndicator]));

        _this.muteIcon = _this.muteIndicator.create(`${_this.constructorName}__mute-icon`, 'img');
        _this.muteIcon.attr('alt', 'mute icon');
        _this.muteIcon.attr('src', `${Assets.getPath('~assets/images/icon/mic-off.svg')}`);
        _this.muteIcon.css(_this.combineStyles([VideoPreviewStyles.muteIcon, styles.muteIcon]));
    }

    function initStartButton() {
        const buttonStyle = {
            text: buttonText,
            preset: buttonPreset,
            styles: _this.combineStyles([VideoPreviewStyles.startButton, styles.startButton])
        };

        _this.startButton = _this.initClass(DreamUI.Button, {
            ...buttonStyle
        }, [_this.contentWrapper]);
    }

    function initAvatarImage() {
        const src = User?.state.get(User.PROFILE_IMAGE) || `${Assets.getPath('~assets/images/avatar/placeholder.png')}`;
        _this.avatarImage = _this.videoMuteWrapper.create(`${_this.constructorName}__avatar-images`);
        _this.avatarImage.css(_this.combineStyles([VideoPreviewStyles.avatarImage, styles.avatarImage]));
        _this.avatarImage.bg(src, "cover");
    }


    /**
     * Listens for user's media access permissions
     * In the case audio/video are denied, shows a notice to user
     *
     * When audio & video are given permissions, removes notice
     * @returns
     */
    async function detectUserMediaPermissions() {
        // GameCenterMedia handles non-existent camera the same way as if permissions were turned
        // off for camera, so no current way to show this kind of notification
        // if (!await detectWebcam()) {
        //     showVideoNotice('You must allow audio to join. You do not have a camera connected.');
        // }

        GameCenterMedia.state.bind('hasMediaAccess', val => {
            if (val === 'fail') {
                const message = Device.mobile ? 'You must allow audio and camera for this browser in device settings to join' : 'You must allow audio and camera for this browser to join';
                showVideoNotice(message);
            } else if (val === 'success') {
                hideVideoNotice();
            }
        });
    }

    async function detectWebcam() {
        let md = await navigator.mediaDevices;
        if (!md || !md.enumerateDevices) return false;
        let devices = await md.enumerateDevices();
        if (!devices) return false;

        return devices.filter(device => device.kind === 'videoinput').length > 0;
    }


    //*** Event handlers
    function addListeners() {
        _this.events.sub(GameCenterMediaUserStream.SPEAKING, handleSpeaking);
        _this.events.sub(GameCenterMediaUserStream.AUDIO_MUTE, audioMute);
        _this.events.sub(GameCenterMediaUserStream.VIDEO_MUTE, videoMute);
        _this.events.sub(GameCenterMediaUserStream.RESET_ACCESS, resetAccess);
        _this.events.sub(_this.startButton, DreamUI.Button.CLICK, handleStartButton);
    }

    function handleStartButton() {
        _this.flag('joined', true);
        _this.events.fire(Events.READY);
    }

    function resetAccess() {
        _this.onVisible();
    }

    function handleSpeaking({ value }) {
        if (value && !_mutedAudio) {
            animations.showVideoSpeakingWrapper(_this.videoSpeakingWrapper);
        } else {
            animations.hideVideoSpeakingWrapper(_this.videoSpeakingWrapper);
        }
    }

    async function videoMute({ value }) {
        if (!_video) return;
        if (value) {
            animations.muteVideo(_this);
        } else {
            await animations.unmuteVideo(_this);
        }
    }

    function audioMute({ value }) {
        if (!_this.muteIndicator.tween) return;
        _mutedAudio = value;
        if (value) {
            animations.showMuteIndicator(_this.muteIndicator);
        } else {
            animations.hideMuteIndicator(_this.muteIndicator);
        }
    }

    async function animateIn() {
        await _this.wait(1000);
        animations.animateIn($this);
    }

    function showVideoNotice(message = 'A camera is required') {
        if (_video) return;
        if (!_this.videoAllowNotice) initAllowNotice();
        _this.videoAllowNotice.setText(message);
        VideoPreviewAnimations.showNotice(_this);
    }

    function hideVideoNotice() { if (_this.videoAllowNotice) VideoPreviewAnimations.hideNotice(_this); }

    function initAllowNotice() {
        _this.noticeWrapper = _this.parentEl.create(_this.getPrefix('notice-wrapper'));
        _this.noticeWrapper.css(_this.combineStyles([VideoPreviewStyles.noticeWrapper, styles.noticeWrapper]));
        _this.videoAllowNotice = _this.initClass(UIAllowVideoNotice, [_this.noticeWrapper]);
    }

    //*** Public methods
    this.animateOut = function() {
        $this.css({ opacity: 0 });
    };

    this.changeMessageText = async (text) => {
        await _this.message.tween({ opacity: 0 }, 400, 'easeOutCubic').promise();
        _this.message.text(text);
        await _this.wait(200);
        _this.message.tween({ opacity: 1 }, 400, 'easeOutCubic');
    };

    this.applyBackground = function (image, backgroundColor, blendMode, backgroundSize) {
        $this
            .css({
                backgroundColor,
                backgroundSize: backgroundSize || 'cover',
                backgroundPosition: 'top left',
                backgroundRepeat: 'no-repeat',
                backgroundBlendMode: blendMode || 'screen'
            })
            .bg(image);
    };

    // eslint-disable-next-line no-multi-assign
    this.onInvisible = this.onDestroy = function() {
        _this.flag('visible', false);
        if (!_this.flag('joined')) {
            if (GameCenterMedia.userStream) GameCenterMedia.userStream.reset();
        }
        if (roomId !== null) DreamAttendees.deactivate(roomId);
        if (fullScreen) {
            if (typeof showPanelCondition === "function") {
                if (showPanelCondition()) UIController.instance().layout.show();
            } else {
                if (showPanelCondition) UIController.instance().layout.show();
            }
        }
    };


    this.onVisible = async function() {
        if (!_this.flag('visible')) return;
        _this.flag('visible', true);
        if (GameCenterMedia.userStream) await GameCenterMedia.userStream.reset(true, true);
        await addVideo(true);
    };

    this.ready = _ => _this.wait('isReady');

    this.setStyles = async function(replacedStyles) {
        await _this.flag('isReady');
        if (replacedStyles.container) $this.css(replacedStyles.container);
        if (replacedStyles.startButton) _this.startButton.setStyles(replacedStyles.startButton);
        if (replacedStyles.contentWrapper) _this.contentWrapper.css(replacedStyles.contentWrapper);
        if (replacedStyles.message) _this.message.css(replacedStyles.message);
        if (replacedStyles.video && _this.video) _this.video.css(replacedStyles.video);
        if (replacedStyles.videoWrapper) _this.videoWrapper.css(replacedStyles.videoWrapper);
        if (replacedStyles.videoSpeakingWrapper) _this.videoSpeakingWrapper.css(replacedStyles.videoSpeakingWrapper);
        if (replacedStyles.videoMuteWrapper) _this.videoMuteWrapper.css(replacedStyles.videoMuteWrapper);
        if (replacedStyles.muteIndicator) _this.muteIndicator.css(replacedStyles.muteIndicator);
        if (replacedStyles.muteIcon) _this.muteIcon.css(replacedStyles.muteIcon);
        if (replacedStyles.avatarImage) _this.avatarImage.css(replacedStyles.avatarImage);
    };
}, _ => {
    VideoPreview.BACK_BUTTON_CLICK = 'VideoPreview.BACK_BUTTON_CLICK';
});

Namespace('DreamUI');

Class(function VideoPreviewAnimations() {
    Inherit(this, Component);

    this.animateIn = (el) => {
        el.tween({ opacity: 1 }, 500, 'easeOutSine');
    };

    this.animateOut = function(el) {
        el.tween({ opacity: 0 }, 300, 'easeOutSine');
    };

    this.muteVideo = (component) => {
        component.videoMuteWrapper.css({ transform: 'scale(1)' });
        component.video.tween({ opacity: 0, zIndex: component.vidZIndex, scale: '-1, 1' }, 250, 'easeOutQuad');
    };

    this.unmuteVideo = (component) => {
        component.videoMuteWrapper.tween({ transform: 'scale(0.99)' }, 250, 'easeOutQuad');
        component.video
            .tween({ opacity: 1, zIndex: component.vidZIndex, scale: '-1, 1' }, 250, 'easeOutQuad',
                _ => {}).promise();
    };

    this.hideMuteIndicator = (muteIndicator) => {
        muteIndicator.tween({ opacity: 0 }, 250, 'easeOutQuad');
    };

    this.showMuteIndicator = (muteIndicator) => {
        muteIndicator.tween({ opacity: 1 }, 250, 'easeOutQuad');
    };

    this.hideVideoSpeakingWrapper = (videoSpeakingWrapper) => {
        videoSpeakingWrapper.tween({ opacity: 0 }, 250, 'easeOutQuad');
    };

    this.showVideoSpeakingWrapper = (videoSpeakingWrapper) => {
        videoSpeakingWrapper.tween({ opacity: 1 }, 250, 'easeOutQuad');
    };

    this.showNotice = (ctx) => {
        ctx.noticeWrapper.css({ display: 'flex' }).tween({ opacity: 1 }, 200, 'easeOutCubic');
    };

    this.hideNotice = (ctx) => {
        ctx.noticeWrapper.tween({ opacity: 0 }, 200, 'easeOutCubic', _ => ctx.noticeWrapper.css({ display: 'none' }));
    };
}, 'static');

Class(function VideoPreviewRequiredMessage() {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    const $this = _this.element;
});

Namespace('DreamUI');

/**
 * @name VideoPreviewStyles
 * @memberOf DreamUI
 */
Class(function VideoPreviewStyles() {
    Inherit(this, Component);
    const _this = this;

    (async function () {
        await DreamColors.instance().ready();

        _this.startButton = {
            element: {
                background: DreamColors.instance().gray800,
                padding: '1.6rem 1.8rem'
            },
            text: {
                position: 'relative'
            }
        };

        _this.container = {
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'flex-end',
            alignItems: 'center',
            width: '100%',
            height: '100%',
            zIndex: 10,
            opacity: 0
        };

        _this.message = {
            ...DreamStyleguide.instance().h4,
            position: 'relative',
            color: DreamColors.instance().gray800,
            textAlign: 'center'
        };

        _this.attendeesHeader = {
            ...DreamStyleguide.instance().p1,
            marginTop: '4rem',
            position: 'relative',
            color: DreamColors.instance().gray600,
            textAlign: 'center'
        };

        _this.contentWrapper = {
            position: 'relative',
            flexGrow: '1',
            display: 'flex',
            width: '100%',
            maxWidth: 800,
            padding: '0 40px',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            height: '100%'
        };

        _this.videoWrapper = {
            position: 'relative',
            flexGrow: '0.8',
            width: '100%',
            minWidth: 220,
            margin: '4.4rem 0'
        };

        _this.video = {
            height: '100%',
            width: '100%',
            objectFit: 'cover',
            zIndex: 200,
            transform: 'scale(-1, 1)'
        };

        _this.noticeWrapper = {
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            zIndex: 202,
            opacity: 0
        };

        _this.videoSpeakingWrapper = {
            position: 'absolute',
            height: '100%',
            width: '100%',
            left: 0,
            top: 0,
            opacity: 0,
            zIndex: 201,
            boxShadow: 'inset 0px 0px 0px 5px #F5C26B'
        };

        _this.videoMuteWrapper = {
            position: 'absolute',
            height: '100%',
            width: '100%',
            left: 0,
            top: 0,
            opacity: 1,
            zIndex: 1,
            background: `linear-gradient(180deg, ${DreamColors.instance().gray800} 80%, #2D3E50)`,
            transform: 'scale(0.99)'
        };

        _this.muteIndicator = {
            width: '3.4rem',
            height: '3.4rem',
            background: "#FA0510",
            opacity: 0,
            position: 'absolute',
            bottom: '1rem',
            right: '1.2rem',
            zIndex: 200,
            borderRadius: '50%',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            boxShadow: '0px 3px 4px rgba(0,0,0,0.1)'
        };

        _this.avatarImage = {
            borderRadius: '50%',
            transform: 'translate(-50%, -50%)',
            left: '50%',
            top: '50%',
            objectFit: 'cover',
            height: '20vh',
            width: '20vh',
            pointerEvents: 'none',
            backgroundRepeat: 'no-repeat'
        };

        _this.muteIcon = {
            maxWidth: '50%',
            objectFit: 'cover'
        };

        _this.flag('isReady', true);
    })();

    _this.ready = _ => _this.flag('isReady');
}, 'static');

Class(function VideoPreviewBackButton() {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    const $this = _this.element;

    (async function() {
        await VideoPreviewBackButtonStyles.ready();

        $this.css(VideoPreviewBackButtonStyles.element);
        _this.button = _this.initClass(DreamUI.Button, {
            preset: 'icon',
            icon: 'arrow-left',
            text: 'leave',
            styles: {
                ...VideoPreviewBackButtonStyles.buttonStyles
            }
        });
        _this.events.bubble(_this.button, DreamUI.Button.CLICK);
    })();

    _this.setStyles = styles => {
        if (styles.element) $this.css(styles.element);
        if (styles.buttonStyles) _this.button.setStyles(styles.buttonStyles);
    };
});

Class(function VideoPreviewBackButtonStyles() {
    Inherit(this, Component);

    const _this = this;
    (async function() {
        await DreamColors.instance().ready();

        _this.element = {
            position: 'relative',
            alignSelf: 'flex-start',
            top: 30,
            left: 30,
            marginBottom: 20
        };
        // an object matching DreamUI.Button styles
        _this.buttonStyles = {
            element: {
                borderRadius: '50%',
                border: `solid 2px ${DreamColors.instance().gray300}`
            },
            icon: {
                color: DreamColors.instance().gray600
            }
        };

        _this.flag('isReady', true);
    })();

    _this.ready = _ => _this.flag('isReady');
}, 'static');

/**
 * @name VideoUserRemoved
 */
Class(function VideoUserRemoved({ styles = {} } = {}) {
    Inherit(this, DreamUI.DreamElement);
    const _this = this;
    const $this = _this.element;

    (async function() {
        await VideoUserRemovedStyles.ready();
        initContent();
        initStyles();
    })();

    function initContent() {
        _this.message = $this.create(_this.getPrefix('content'));
        _this.message.text('An admin has removed you from this meeting. If you think that this was in error please contact us.');
    }

    function initStyles() {
        $this.css(_this.combineStyles([VideoUserRemovedStyles.element, styles.element]));
        _this.message.css(_this.combineStyles([VideoUserRemovedStyles.message, styles.message]));
    }
});

/**
 * @name VideoUserRemovedAnimations
 */
Class(function VideoUserRemovedAnimations() {
    Inherit(this, Component);
    const _this = this;

    (function() {
        _this.flag('isReady', true);
    })();
    _this.ready = _ => _this.wait('isReady');
}, 'static');

/**
 * @name VideoUserRemovedStyles
 */
Class(function VideoUserRemovedStyles() {
    Inherit(this, Component);
    const _this = this;

    (async function() {
        await DreamColors.instance().ready();
        _this.element = {
            position: 'relative',
            padding: '2rem'
        };

        _this.message = {
            ...DreamStyleguide.instance().label5,
            maxWidth: '40rem',
            textAlign: 'center',
            position: 'relative',
            color: DreamColors.instance().black
        };

        _this.flag('isReady', true);
    })();

    _this.ready = _ => _this.wait('isReady');
}, 'static');

Class(function UIViewToggleController() {
    Inherit(this, Element);
    const _this = this;
    var $this,$mobileButton,$desktopBody;
    var _prefix = `UIViewToggle`;
    var _toggleElements = [];
    var _currView = '1st';
    const ITEMS = [
        {
            image:'~assets/images/icon/camera-on.svg',
            isActive:true,
            action:()=>{
                _this.events.fire(PlayerControls.SWITCH_VIEW,{view:'1st'})
            },
            name:'1st'
        },
        {
            image:'~assets/images/icon/user.svg',
            isActive:false,
            action:()=>{
                _this.events.fire(PlayerControls.SWITCH_VIEW,{view:'3rd'})
            },
            name:'3rd'
        }
    ];
    //*** Constructor
    (function () {
        initHTML();
        createDesktopBody();
        createMobileToggleButton();
        addListeners();
    })();

    function initHTML() {
        $this = _this.element;
        $this.css({
            position:'relative',
            width:'fit-content',
        })
    }
    function createDesktopBody() {
        $desktopBody = $this.create(`${_prefix}__body`);
        CoreUIState.instance().uiBuilder.buildUIViewToggleBody($desktopBody);
        addItems($desktopBody);
    }
    function createMobileToggleButton() {
        $mobileButton = $this.create(`${_prefix}__mobile-toggle`);

        let $icon = $mobileButton.create(`${_prefix}__mobile-toggle__icon`);
        CoreUIState.instance().uiBuilder.buildUIViewToggleMobile({
            mobileButton:$mobileButton,
            icon:$icon
        },{
            currView:_currView,
            items:ITEMS
        })
        $mobileButton.interact(null,()=>{
            if(_currView == '1st'){
                _currView = '3rd'
            }else{
                _currView = '1st'
            }
            _this.events.fire(PlayerControls.SWITCH_VIEW,{view:_currView})
            $mobileButton.css({
                background: _currView == '1st' ? AppStyleController.colors.primary[0] : 'white',
            })
            $icon.css({
                background: _currView == '1st' ? 'white' : AppStyleController.colors.primary[0] ,
                "-webkit-mask-image":_currView == '1st' ? `url(${Assets.getPath(ITEMS[0].image)})` : `url(${Assets.getPath(ITEMS[1].image)})`,
                maskImage:_currView == '1st' ? `url(${Assets.getPath(ITEMS[0].image)})` : `url(${Assets.getPath(ITEMS[1].image)})`
            })
        })
    }

    function addItems(parent) {
        for(let item of ITEMS){
            addItem(parent,item);
        }
    }

    function addItem(parent,item) {
        let $item = parent.create(`${_prefix}__item`);
        let $icon = $item.create(`${_prefix}__item__icon`);
        $item.interact(null,()=>{
          handleItemClicked(item)
        });

        CoreUIState.instance().uiBuilder.buildUIViewToggleItem({
            item:$item,
            icon:$icon
        },item);

        _toggleElements.push({
            element:$item,
            obj:item
        });
    }

    function handleItemClicked(item) {
        for(let listItem of _toggleElements){
            if(listItem.obj.name!=item.name){
                listItem.element.css({
                    background: 'white'
                })
                listItem.element._children.first.css({
                    background:AppStyleController.colors.primary[0]
                })
            }else{
                listItem.element.css({
                    background:AppStyleController.colors.primary[0]
                })
                listItem.element._children.first.css({
                    background:'white'
                })
                listItem.obj.action();
                _currView = listItem.obj.name;
            }
        }
    }


    //*** Event handlers
    function addListeners() {
        _this.events.sub(PlayerControls.SWITCH_VIEW,handleViewSwitch)
        _this.onResize(resize);
    }

    function handleViewSwitch(e) {
        _currView = e.view;
        for(let listItem of _toggleElements){
            if(listItem.obj.name!=e.view){
                listItem.element.css({
                    background: 'white'
                })
                listItem.element._children.first.css({
                    background:AppStyleController.colors.primary[0]
                })
            }else{
                listItem.element.css({
                    background:AppStyleController.colors.primary[0]
                })
                listItem.element._children.first.css({
                    background:'white'
                })
            }
        }
    }

    function resize() {
        const size = Breakpoints.getSize();
        switch (size) {
            case 'big-desktop':
            case 'desktop':
            case 'tab-port':
            case 'tab-land':{
                $desktopBody.css({
                    display:'grid'
                })
                $mobileButton.css({
                    display:'none'
                })
                break;
            }
            case 'phone':{
                $desktopBody.css({
                    display:'none'
                })
                $mobileButton.css({
                    display:'block'
                })
                break;
            }
            default:
                break;
        }
    }
    //*** Public methods


});
Class(function UIViewToggleControllerStyles() {
    Inherit(this, Component);

    this.buildUIViewToggleBody = function (body) {
        body.css({
            position: 'relative',
            display: 'grid',
            background: 'white',
            gridAutoFlow: 'column',
            gridAutoColumns: 'min-content',
            width: 'fit-content',
            padding: '.5rem .5rem',
            borderRadius: '3rem',
            boxShadow: '0px 4px 20px rgba(0,0,0,0.1)',
        });
    };

    this.buildUIViewToggleMobile = function (elements, _config) {
        let { mobileButton, icon } = elements;
        mobileButton.css({
            display: 'none',
            position: 'relative',
            borderRadius: '50%',
            padding: '1.5rem',
            cursor: 'pointer',
            background: _config.currView == '1st' ? this.colors.primary[0] : 'white',
        });
        icon.css(this.styleguide.icon);
        icon.css({
            background: _config.currView == '1st' ? 'white' : this.colors.primary[0],
            '-webkit-mask-size': 'contain',
            maskSize: 'contain',
            '-webkit-mask-image': `url(${Assets.getPath(_config.items[0].image)})`,
            maskImage: `url(${Assets.getPath(_config.items[0].image)})`,
        });
    };

    this.buildUIViewToggleItem = function (elements, itemData) {
        let { item, icon } = elements;
        item.css({
            position: 'relative',
            borderRadius: '50%',
            padding: '1.5rem',
            cursor: 'pointer',
            background: itemData.isActive ? this.colors.primary[0] : 'white',
        });
        icon.css(this.styleguide.icon);
        icon.css({
            background: itemData.isActive ? 'white' : this.colors.primary[0],
            '-webkit-mask-size': 'contain',
            maskSize: 'contain',
            '-webkit-mask-image': `url(${Assets.getPath(itemData.image)})`,
            maskImage: `url(${Assets.getPath(itemData.image)})`,
        });
    };
}, 'static');

Class(function DreamWorld() {
    Inherit(this, Component);
    const _this = this;
    var _active, _lastEnv;

    var _envs = [];
    var _scenes = [];
    var _preload = [];

    DreamWorld.active = _this;

    const VR = Platform.usingVR();

    function parseForPreload(Class) {
        let key = Utils.getConstructorName(Class) + '_env';
        _preload.push({key, Class});
    }

    async function preload() {
        await _this.wait(1000);
        if (!_active || Global.PLAYGROUND) return;
        _this.flag('hasPreloaded', true);
        for (let i = 0; i < _preload.length; i++) {
            let {Class, key} = _preload[i];
            if (_active.obj instanceof Class) continue;
            await SceneLayoutPreloader.load(key);
        }
    }

    //*** Event handlers

    //*** Public methods
    this.createScene = function() {
        _this.frustum = new Frustum();
        _this.testSphere = new Sphere(new Vector3(), 1.8);
        let scene = _this.initClass(FXScene, World.NUKE, {manualRender: true});
        if (RenderManager.type != RenderManager.NORMAL) {
            scene.vrWorldMode();
            scene.nuke.enabled = false;
        } else {
            if (Platform.useFXAA()) {
                scene.fxaa = new FXAA();
                scene.nuke.add(scene.fxaa);
            }
        }
        if (!Global.PLAYGROUND) {
            _this.startRender(_ => {
                if (scene.visible) scene.render();
                _this.frustum.setFromCamera(World.CAMERA);
            }, World.NUKE);
        }
        scene.visible = false;
        _scenes.push(scene);
        return scene;
    }

    this.displayScene = function(scene) {
        _this.parent.displayScene(scene);
    }

    this.createEnvironment = async function(PlayerClass, EnvironmentClass, Environment, params) {
        let scene = _this.createScene();

        parseForPreload(EnvironmentClass);

        let value = {activeCount: 0};
        let obj;
        let activate = async function() {
            if (_active && _active.scene == scene) return;
            if (_active) _active.visible = _active.scene.visible = _active.obj.group.visible = false;
            Environment.instance().registerPlayerClass(PlayerClass);

            if (VR) VRInput.controllers.forEach(c => c.group.visible = false);

            value.activeCount++;
            if (!obj) {
                _this.flag('hasEnv', false);
                obj = await Environment.instance().mount(EnvironmentClass, scene, params);
                if (VR) {
                    obj.group.position.y = 9999;
                    obj.wait('player').then(_ => {
                        obj.player.controls.disable();
                    });
                }
                if (params && params.custom) obj.customEnvironment();
                value.obj = obj;
                _this.flag('hasEnv', true);
                await obj.loaded();
                await Initializer3D.uploadAll(obj.group);
                if (!_this.flag('hasPreloaded')) preload();
            }
            if (VR) obj.group.position.y = 9999;
            if (Global.PLAYGROUND) return;
            if (_lastEnv == Environment) Environment.instance().deactivate();
            _lastEnv = Environment;
            Environment.instance().activate(obj, scene);
            obj._activate();
            scene.visible = true;
            scene.viewObj = obj;
            obj.group.visible = true;
            _active = {scene, obj, loadCount: value.activeCount};
            return scene;
        };

        value.scene = scene;
        value.activate = activate;

        _envs.push(value);

        return value;
    }

    this.createActivityEnvironment = async function(PlayerClass, EnvironmentClass, params) {
       return this.createEnvironment(PlayerClass, EnvironmentClass, GroupEnvironment, params);
    }

    this.createCommunityEnvironment = async function(PlayerClass, EnvironmentClass, params) {
        return this.createEnvironment(PlayerClass, EnvironmentClass, GroupEnvironment, params);
    }

    this.createGroupEnvironment = async function(PlayerClass, EnvironmentClass, params) {
        return this.createEnvironment(PlayerClass, EnvironmentClass, GroupEnvironment, params);
    }

    this.createGlobalEnvironment = async function(PlayerClass, EnvironmentClass, params) {
        return this.createEnvironment(PlayerClass, EnvironmentClass, GlobalEnvironment, params);
    }

    this.createCustomEnvironment = async function(EnvironmentClass, params = {}) {
        params.custom = true;
        return this.createEnvironment(AbstractAvatar, EnvironmentClass, GroupEnvironment, params);
    }

    this._onRouteChange = function(route) {
        route.shift();
        this.route = route;

        let result = this.onRouteChange ? this.onRouteChange(route) : null;

        defer(_ => {
            _envs.forEach(env => {
                if (env.obj) {
                    if (env.scene.visible && env.obj.onRouteChange) {
                        if (Render.TIME - env.obj.activateTime > 200) env.obj.onRouteChange(route);
                    }
                }
            });
        });

        return result;
    }

    this._initRoute = function(route) {
        this.baseRoute = route[0];
        route.shift();
        this.route = route;
    }

    this.setRoute = function(route) {
        Worlds.instance().setState(route);
    }

    this.disable3D = function() {
        World.instance()._disable3D();
    }

    this.get('scene', _ => _scenes);

    this.capFPS = function(fps, config) {
        if (config) {
            if (config.delay) _this.delayedCall(_ => {
                World.instance()._capFPS(fps);
            }, config.delay);

            if (config.interaction) {
                let on = false;
                World.instance()._capFPS(fps);
                let idle = _ => {
                    if (!on) {
                        World.instance()._capFPS(fps);
                        on = true;
                    }
                }
                let active = _ => {
                    if (on) {
                        World.instance()._capFPS(null);
                        on = false;
                    }
                }

                let timer;
                _this.events.sub(Mouse.input, Interaction.MOVE, _ => {
                    active();
                    clearTimeout(timer);
                    timer = _this.delayedCall(_ => {
                        idle();
                    }, config.timeout || 1000);
                });
            }
        } else {
            World.instance()._capFPS(fps);
        }
    }

    this.capturePixels = function(x, y, width, height) {
        const createCanvas = (w, h) => {
            let canvas = document.createElement('canvas');
            canvas.width = w;
            canvas.height = h;
            canvas.context = canvas.getContext('2d');
            return canvas;
        };

        if (!width) width = World.RENDERER.resolution.width;
        if (!height) height = World.RENDERER.resolution.height;

        let fullCanvas = createCanvas(Math.round(_active.scene.rt.width), Math.round(_active.scene.rt.height));
        let imageData = fullCanvas.context.createImageData(fullCanvas.width, fullCanvas.height);
        imageData.data.set(World.RENDERER.readPixels(_active.scene.rt, 0, 0));
        fullCanvas.context.putImageData(imageData, 0, 0);

        let flipped = createCanvas(Stage.width, Stage.height);
        flipped.context.scale(1, -1);
        flipped.context.drawImage(fullCanvas, 0, 0, Stage.width, -Stage.height);

        let canvas = createCanvas(width, height);
        canvas.context.drawImage(flipped, -x, -y);

        return canvas;
    }

    this._bindOnDestroy(_ => {
        World.instance()._capFPS(null);
        World.instance()._enable3D();
        _scenes.forEach(s => {
            if (s.viewObj) s.viewObj.destroy();
            Initializer3D.destroyAll(s.scene);
            s.destroy();
        });
        _scenes = null;
    });

    this.getEnvironment = async function() {
        await _this.wait('hasEnv');
        return _active.obj;
    }

    this.getActiveObject = function() {
        return _active;
    }

    this.submitPostRoutePrompt = function(config) {
        AbstractEnvironment.PENDING_PROMPT = config;
    }

    this.showTutorial = async function(obj) {
        let env = await _this.getEnvironment();
        UITutorialController.instance().show(obj, env);
    }

    this.clearTutorial = async function() {
        let env = await _this.getEnvironment();
        UITutorialController.instance().clear(env);
    }

    this.ensureSceneVisibility = function() {
        if (_active) _active.obj.group.position.y = 0;
        VRInput.controllers.forEach(c => c.group.visible = true);
    }
});
Class(function PreloadWorldLayout(_perma, _layout) {
    Inherit(this, Component);
    const _this = this;
    var _assetPath;

    var _local = Hydra.LOCAL || location.hostname.includes(['localhost', '192.', '10.0']);

    //*** Constructor
    (async function () {
        if (!_local) {
            try {
                await loadRemote();
            } catch (e) {
                throw e;
            }

        } else {
            try {
                await loadLocal();
            } catch (e) {
                try { await loadRemote(); } catch (e) { throw e; }
            }
        }
    })();

    function absolutePath(str) {
        let path = Platform.PATH;
        return path + (path.charAt(path.length - 1) == '/' ? '' : '/') + str;
    }

    async function loadRemote() {
        let uil = absolutePath(`worlds/${_perma}/assets/data/uil.json`);
        try {
            _assetPath = absolutePath(`worlds/${_perma}/`);
            let data = await get(uil);
            let js = await get(_assetPath + 'assets/js/app.js');
            let assets = JSON.parse(js.split('window.ASSETS=')[1].split(';')[0]);
            parse(data, assets);
        } catch(e) {
            throw 'Not found';
        }
    }

    async function loadLocal() {
        let root = window.location.href.toLowerCase().split('?')[0].split('#')[0].replace('platform/html', 'worlds/' + _perma + '/html');

        if (window.location.port === '8080') {
            root = 'worlds/' + _perma + '/html'
        }

        if (root.charAt(root.length - 1) == '/') root = root.slice(0, -1);

        let uil = root + '/assets/data/uil.json';
        try {
            let data = await get(uil);
            _assetPath = root + '/';
            let assetString = await get(_assetPath + 'assets/js/app/config/Assets.js');
            let assets = JSON.parse(assetString.split('window.ASSETS = ')[1].split(';')[0]);
            parse(data, assets);
        } catch(e) {
            console.log(e);
            throw 'Not found';
        }
    }

    function getPath(path) {
        return _assetPath + path;
    }

    function getCompressedExtension() {
        const gl = Device.graphics._webglContext.context;
        let astc = gl.getExtension('WEBGL_compressed_texture_astc');
        let etc1 = gl.getExtension('WEBGL_compressed_texture_etc1');
        let pvrtc = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
        let s3tc = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');

        if (s3tc) return 'dxt';
        else if (etc1) return 'astc';
        else if (pvrtc) return 'pvrtc';
        else if (s3tc) return 'astc';
    }

    function parse(data, assets) {
        let promise = Promise.create();
        let array = [];
        let ext = getCompressedExtension();

        fetch(_assetPath.replace('default', 'global') + "assets/geometry/avatar/character_4k_run.json");

        const findMatch = src => {
            if (!src) return false;
            src = src.trim();
            for (let i = assets.length-1; i > -1; i--) {
                if (assets[i].includes(src)) return true;
            }
            return false;
        };

        let keys = Object.keys(data);
        let i = 0;
        let worker = new Render.Worker(_ => {
            let key = keys[i];
            if (!key) {
                worker.stop();
                return;
            }

            if (key.includes(_layout)) {
                let val = data[key];
                if (!val.includes) return i++;

                if (key.includes('geometry')) {
                    if (!val.includes('.json')) val += '.json';
                    if (!val.includes('assets/')) val = 'assets/geometry/' + val;
                    if (findMatch(val.split('assets/')[1])) array.push(GeomThread.loadGeometry(val, null, true));
                }

                if (val.includes('.json')) {
                    if (!val.includes('assets/')) val = 'assets/geometry/' + val;
                    if (findMatch(val.split('assets/')[1])) array.push(fetch(getPath(val)).then(e => {}, e => {}));
                } else if (val.includes('src')) {
                    let obj = JSON.parse(val);
                    let src = obj.src;
                    if (obj.compressed) {
                        let src0 = src.split('.')[0];
                        let src1 = src0.split('/');
                        src = src0 + '/' + src1[src1.length-1] + '-' + ext + '.ktx';
                    }
                    if (findMatch(src.split('assets/')[1])) {
                        array.push(fetch(getPath(src)).then(e => {}, e => {}));
                    }
                }
            }
            i++;
        }, 1);
    }

    //*** Event handlers

    //*** Public methods

});
Class(function World() {
    Inherit(this, Component);
    const _this = this;
    var _renderer, _scene, _camera, _nuke, _controls;

    var _type = RenderManager.NORMAL;
    var _capFPS = null;
    var _capLast = 0;
    var _elapsed = 0;

    World.RESIZE = 'World_resize';
    World.DPR = Tests.getDPR();

    const MOBILE = Tests.mobilePhone();

    async function init() {
        if (World.PLANE) return;
        await initWorld();
        GlobalAudio3D.setup();
        if (!_renderer) return;
        initControls();
        addHandlers();
        if (!Utils.query('uilOnly')) Render.onDrawFrame(loop);
        if (RenderManager.type == RenderManager.NORMAL) Camera.instance(_camera);
    }

    async function initWorld() {
        World.PLANE = new PlaneGeometry(1, 1);
        World.QUAD = Utils3D.getQuad();
        World.BOX = new BoxGeometry(1, 1, 1);
        World.SPHERE = new SphereGeometry(1, 16, 16);
        World.TELEPORT_CYLINDER = new CylinderGeometry(1,1,3,50);

        Render.capFPS = Tests.capFPS();

        await RenderManager.initialize(_type, { powerPreference: 'high-performance', antialias: Platform.usingVR() });
        _renderer = RenderManager.gl;
        _scene = RenderManager.scene;
        _camera = RenderManager.camera.worldCamera;
        _nuke = RenderManager.nuke;

        World.SCENE = _scene;
        World.RENDERER = _renderer;
        World.ELEMENT = $(_renderer.domElement);
        World.CAMERA = _camera;
        World.NUKE = _nuke;

        _camera.near = 1;
        if (Global.PLAYGROUND) _camera.near = 0.1;
        _camera.updateProjectionMatrix();

        Global.PLAYGROUND = Hydra.LOCAL ? (Router.virtualQuery || location.search.indexOf('p=') > 0) && Utils.query('p') : false;

        if (!Global.PLAYGROUND) {
            GroupEnvironment.instance();
            UIController.instance();
        }

        if (Platform.usingVR()) {
            Transition.instance().cover();
        }

        if (Device.social) {
            setTimeout(resize, 1000);
        }

        GlobalConfig.instance();
    }

    function initControls() {
        if (!window.DebugControls) return;
        let Controls = Utils.query('wasd') ? WASDControls : DebugControls;
        _controls = new Controls(_camera, World.ELEMENT.div);

        if (RenderManager.type == RenderManager.NORMAL) {
            _camera.position.set(0.0, 0.0, 6.0);
            _camera.target = new Vector3(0.0, 0.0, 0.0);
            _camera.lookAt(_camera.target);
            _controls.target = _camera.target;
        } else {
            _controls.enabled = false;
        }

        World.CONTROLS = _controls;
    }

    //*** Event handlers
    function addHandlers() {
        _this.events.sub(Events.RESIZE, resize);
        // _this.events.sub(Events.FULLSCREEN, fullScreen);
    }

    function fullScreen(e) {
        _this.flag('externalFullscreen', e.fullscreen);
    }

    async function resize() {
        if (_this.flag('preventRender')) return;

        if (UIController.instance().layout) {
            await UIController.instance().ready();

            let { height, left, top, width } = UIController.instance().sizes;
            if ( ![ height, left, top, width ].every( value => !isNaN( value ))) return;

            if (!MOBILE && !_this.flag('ignoreUIControllerSize')) {
                // set stage to UIController sizes
                Stage.height = height;
                Stage.width = width;
            } else {
                Stage.height = height;
            }

            World.ELEMENT.css({ left, top });

            _this.events.fire(World.RESIZE);
        }

        _renderer.setSize(Stage.width, Stage.height);
        _camera.aspect = Stage.width / Stage.height;
        _camera.updateProjectionMatrix();
        GLUI.Stage.resize();
    }

    function loop(tsl, delta) {
        if (_capFPS > 0) {
            let delta = tsl - _capLast;
            _capLast = tsl;
            _elapsed += delta;
            if (_elapsed < 1000 / _capFPS) return;
            _elapsed = 0;
        }

        if (_this.flag('externalFullscreen') || _this.flag('preventRender') || _this.flag('disable3D')) return;
        if (_controls && _controls.enabled) _controls.update();
        RenderManager.render();
    }

    //*** Public methods
    this.initXR = async function(type) {
        _type = type;
        await init();
        await XRDeviceManager.startSession();
    };

    this.init = function() {
        return init();
    };

    this.resize = function(width) {
        resize(width);
    };

    //stop and start happen if the UI goes full screen
    this.stopRender = function() {
        _this.flag('preventRender', true);
    };

    this.startRender = function() {
        _this.flag('preventRender', false);
        resize();
    };

    this.isRendering = function() {
        return !_this.flag('preventRender');
    };

    this._capFPS = function(fps) {
        _capFPS = fps;
    };

    //disable and enable happen when a DreamWorld module says it never needs WebGL
    this._disable3D = function() {
        _this.flag('disable3D', true);
    };

    this._enable3D = function() {
        _this.flag('disable3D', false);
        resize();
    };

    this.isDisabled = function() {
        return _this.flag('disable3D');
    };

    /**
     * setting ignoreUIControllerSize causes the stage to ignore
     * the side panel, so will fill full width of screen
     * @param {*} _
     */
    this.doIgnoreUIControllerSize = _ => _this.flag('ignoreUIControllerSize', true);

    this.doNotIgnoreUIControllerSize = _ => _this.flag('ignoreUIControllerSize', false);

    this.isIgnoringControllerSize = _ => _this.flag('ignoreUIControllerSize');
}, function() {
    var _instance;
    World.instance = function() {
        if (!_instance) _instance = new World();
        return _instance;
    };
});

Class(function WorldEnvironment(_perma, _dependency) {
    const _this = this;

    var _local = Hydra.LOCAL || location.hostname.includes(['localhost', '192.', '10.0']);
    var _main, _remote;
    var _current, _component;

    this.perma = _perma

    if (_perma == '') throw 'Missing route!';

    function absolutePath(str) {
        let path = Platform.PATH;
        return path + (path.charAt(path.length - 1) == '/' ? '' : '/') + str;
    }

    let loadRemote = async _ => {
        try {
            let version = window._ES5_ ? 'es5-app' : 'app';
            let code = await get(absolutePath(`worlds/${_perma}/assets/js/${version}.js?${window._CACHE_ || Date.now()}`));

            if (window._ES5_ && code.includes('//es5-polyfill')) {
                code = code.split('//es5-polyfill')[1];
            }

            WorldEnvironment.clearScripts();
            try {
                WorldEnvironment.addCode(code);
            } catch (e) {
                console.error(e);
                throw e;
            }

            _remote = true;
        } catch (e) {
            console.error(e);
            throw e;
            _remote = false;
        }
    };

    let loadLocal = async _ => {
        let root = window.location.href.toLowerCase().split('?')[0].split('#')[0].replace('platform/html', 'worlds/' + _perma + '/html');

        if (window.location.port === '8080') {
            root = 'worlds/' + _perma + '/html'
        }

        if (root.charAt(root.length - 1) == '/') root = root.slice(0, -1);

        let html = await get(root);
        if (!html.includes(['RUNTIME_SCRIPTS', `eval('async () => {};')`, `eval('let obj = {}; obj?.prop')`, `runtime/boot.js`])) throw '404';

        try {
            let scripts;

            const parseScripts = code => {
                scripts = JSON.parse(code.split('RUNTIME_SCRIPTS = ')[1].split(';')[0]);
                scripts = scripts.filter(path => !path.includes(['hydra', 'accelerometer', 'shaders', 'fullscreen']));
                if (Utils.query('bundle')) scripts = ['assets/runtime/bundle.js'];
            };

            if (html.includes('RUNTIME_SCRIPTS')) {
                parseScripts(html);
            } else if (html.includes('runtime/boot.js')) {
                let boot = await get(root + '/assets/runtime/boot.js');
                parseScripts(boot);
            } else {
                scripts = ['assets/js/app--debug.js'];
            }

            let promises = scripts.map(s => get(root + '/' + s));
            let files = await Promise.all(promises);

            if (Hydra.LOCAL) {
                Events.emitter._addEvent(WorldEnvironment.HOTLOAD_SCRIPT, async e => {
                    if (!scripts.includes(e.file)) return;
                    try {
                        let code = await get(root + '/' + e.file);
                        WorldEnvironment.addScript(code);
                        Events.emitter._fireEvent(SceneLayout.HOTLOAD_SCRIPT, e);
                    } catch (e) { }
                }, _this);
            }

            WorldEnvironment.clearScripts();
            for (let code of files) {
                try {
                    WorldEnvironment.addScript(code);
                } catch (e) {
                    console.log(code);
                    throw e;
                }
            }

            _remote = false;
        } catch (e) {
            console.log(e);
            throw e;
            _remote = true;
        }
    };

    let getBasePath = _ => {
        let base = Platform.PATH;

        if (_remote) {
            base += `worlds/${_perma}`;
        } else {
            base = base.split('platform')[0] + `worlds/${_perma}/html`;
        }

        return base;
    };

    let connectAssets = _ => {
        let base = getBasePath();
        Assets.CDN = base + '/';
    };

    let connectAssetsUILShaders = async dependency => {
        let base = getBasePath();

        let project = window.UIL_ID ? window.UIL_ID.split('-')[0] : '';
        let uilPath = base + '/assets/data/uil.json';
        let shaderPath = base + '/assets/shaders/compiled.vs';
        UILStorage.reload(`${project}-${_perma}`, uilPath, dependency);

        get(Assets.getPath(base + '/assets/css/style-scss.css')).then(text => {
            if (Config.MOUNTS?.includes(_perma)) {
                $(document.head).create('SCSS-'+_perma, 'style').text(text);
            } else {
                WorldEnvironment.getCSSElement(_perma).text(text);
            }
       }).catch(() => {});

        connectAssets();

        await Promise.all([
            AssetLoader.loadAssets([shaderPath]),
            UILStorage.ready()
        ]);

        if (window.StageLayoutUtil) await StageLayoutUtil.reload();
    };

    //*** Event handlers

    //*** Public methods
    this.load = async function () {
        Dev.pathName = location.pathname.toLowerCase().split('/platform')[0] + '/worlds/' + _perma + '/html/';

        if (!_this.loaded) {
            await _this.evaluate();
            await connectAssetsUILShaders();
            _this.loaded = true;
        }
        _main = new Main();
        _main._initRoute(Router.getState());
        _this.element = _main.$element = Stage.create(_perma);
        World.ELEMENT.add(_this.element);
        if ((Router.virtualQuery || location.search.indexOf('p=') > 0) && Utils.query('p') && Hydra.LOCAL) Playground.instance();
        else _this.texture = await _main.init(_this.element);
    };

    this.evaluate = async function () {
        let state = {};
        if (_dependency) {
            state.assets = window.ASSETS;
        }
        if (!_local) {
            try {
                await loadRemote();
            } catch (e) {
                throw e;
            }

        } else {
            try {
                await loadLocal();
            } catch (e) {
                try { await loadRemote(); } catch (e) { throw e; }
            }
        }
        let assets = window.ASSETS;
        if (state.assets) window.ASSETS = state.assets;
        return assets;
    }

    this.evaluateWithAssets = async function () {
        let assets = await _this.evaluate();
        Assets.registerPath(getBasePath() + '/', assets);
        await connectAssetsUILShaders(true);
    }

    this.onRouteChange = function (route) {
        return _main ? _main._onRouteChange(route) : null;
    }

    this.extraTransitionTime = function () {
        if (!_main || !_main.extraTransitionTime) return 0;
        return _main.extraTransitionTime();
    }

    this.shouldTransition = function (route) {
        route = [...route];
        route.shift();
        return _main && _main.shouldTransition ? _main.shouldTransition(route) : true;
    }

    this.unload = function () {
        if (_this.element) _this.element.remove();
        _this.killed = true;
        if (_main) _main.destroy();
        if (Hydra.LOCAL) Events.emitter._destroyEvents(_this);
    }

    this.displayScene = async function (scene) {
        await _this.parent.transitionScene(scene);
        _this.texture = scene;
    }
}, () => {
    WorldEnvironment.HOTLOAD_SCRIPT = 'worldenv_hotload_script';
    var _scripts = [];
    WorldEnvironment.addScript = function (code) {
        let script = document.createElement('script');
        script.innerHTML = code;
        document.getElementsByTagName('head')[0].appendChild(script);
        _scripts.push(script);
    };
    WorldEnvironment.addCode = function (code) {
        let script = document.createElement('script');
        script.innerHTML = code;
        document.getElementsByTagName('head')[0].appendChild(script);
        _scripts.push(script);
    };
    WorldEnvironment.clearScripts = function () {
        try {
            _scripts.forEach(script => script.parentNode.removeChild(script));
            _scripts.length = 0;
        } catch (e) {

        }
    };

    var _css = {};
    WorldEnvironment.getCSSElement = function (perma) {
        if (!_css[perma]) _css[perma] = $(document.head).create('SCSS-' + perma, 'style');
        return _css[perma];
    }
});

Class(function Worlds() {
    Inherit(this, Component);
    const _this = this;
    var _world, _shader, _isCoverTransition = false;

    //*** Constructor
    (async function () {
        GroupEnvironment.instance();
        GlobalEnvironment.instance();
        AntimatterUtil.cache = false;

        if (Platform.usingVR()) Transition.instance().cover(true);
        await Platform.mount();
        if (!Global.PLAYGROUND) await PlayerModel.ready();
        _this.events.fire(Worlds.LOADED);
        initMesh();
        initFirstWorld();
        addListeners();
    })();

    async function initFirstWorld() {
        if (_this.flag('blockingFirstLoad')) {
            await _this.wait('readyFirstLoad');
        }

        initWorld(Router.getState().join('/'));
    }

    function initMesh() {
        if (RenderManager.type != RenderManager.NORMAL) return;

        _shader = _this.initClass(Shader, 'ScreenQuad', {
            tMap: {value: null}
        });

        let mesh = new Mesh(World.QUAD, _shader);
        if (!Global.PLAYGROUND) World.SCENE.add(mesh);
        mesh.frustumCulled = false;
    }

    async function initWorld(perma) {
        _this.flag('hasWorld', false);

        if (_world) {
            Render.capFPS = null;
            Router.lock();
            await Transition.instance().cover('external');
            GLUI.clear();
            Utils3D.clearTextureCache();
            _shader.set('tMap', null);
            Multiplayer.reset();
            GroupEnvironment.instance().unmount();
            GlobalEnvironment.instance().unmount();
            OptimizedAvatar.LOD = '';
            SoundFX.clear();
            _world.unload();
        }

        let route = Platform.getRoute(perma);

        _world = Worlds.stash[perma] || _this.initClass(WorldEnvironment, route);
        delete Worlds.stash[perma];

        try {
            await _world.load();
            _this.flag('hasWorld', true);
            _this.flag('initialized', true);
            _shader?.set('tMap', _world.texture);
            await _this.wait(_world.extraTransitionTime());
            await Transition.instance().reveal();
            Router.unlock();
        } catch(e) {
            _world = null;
            console.error(e);
            console.log('404 not found, display error screen');
        }
    }

    async function internalTransition(perma) {
        if (_this.flag('internalTransitioning')) return;
        _this.flag('internalTransitioning', true);
        await defer();
        Router.lock();
        let showTransition = _world.shouldTransition(perma);
        if (showTransition || _isCoverTransition) await Transition.instance().cover('internal');
        let scene = await _world.onRouteChange(perma);
        _shader?.set('tMap', scene);
        await _this.wait(_world.extraTransitionTime());
        if (showTransition || _isCoverTransition) await Transition.instance().reveal();
        Router.unlock();
        _this.flag('internalTransitioning', false);
    }

    //*** Event handlers
    function addListeners() {
        if (!Config.TEST_UI_ROUTES) _this.events.sub(Router, Router.UPDATE, routeUpdate);
        _this.events.sub(XRDeviceManager.SESSION_END, _ => location.reload());
    }

    async function routeUpdate(e) {
        if (e.value.includes('?')) return location.reload();
        let perma = Router.getState().join('/');
        let route = Platform.getRoute(perma);
        if (route == _world.perma && !Config.TEST_PERMA_RELOAD) {
            internalTransition(e.split);
        } else {
            initWorld(e.value);
        }
    }

    //*** Public methods
    this.transitionScene = function(scene) {
        if (_shader) _shader.set('tMap', scene);
    }

    this.setState = function(route) {
        let perma = _world.perma + '/' + route;
        Router.setState(perma);
    }

    this.canDisplayFirstWorld = function() {
        if (Platform.usingVR() || Global.PLAYGROUND) return true;
        return _this.wait('initialized');
    }

    this.setCoverTransition = function(isCoverTransition) {
        _isCoverTransition = isCoverTransition;
    }

    this.blockFirstLoad = function() {
        _this.flag('blockingFirstLoad', true);
    }

    this.unblockFirstLoad = function() {
        _this.flag('readyFirstLoad', true);
    }

    DreamWorld.getActiveEnvironment = async function() {
        if (Global.PLAYGROUND) return null;
        await _this.wait('hasWorld');
        return DreamWorld.active.getEnvironment();
    }
}, 'singleton', _ => {
    Worlds.stash = {};
    Worlds.LOADED = 'worlds_loaded';
});

Class(function ControllerShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);

    var _this = this;

    //*** Constructor
    (function() {
        _shader.addUniforms({
            tMap: {value: null},
            uColor: {value: new Color()},
            uGradient: {value: new Vector2(0.0, 1.0)},
            uAlphaCutoff: {value: 0.0},
            transparent: true
        });

        PlayerModel.state.bind('SecretSkyAvatar_uColor', value => {
            if (Array.isArray(value)) _shader.get('uColor').fromArray(value);
        });

        _mesh.renderOrder = 99999999;
    })();

    //*** Event handlers

    //*** Public methods
});
Class(function SceneView() {
    Inherit(this, Object3D);
    const _this = this;

    //*** Constructor
    (function () {
        initMesh();
    })();

    function initMesh() {
        let mesh = new Mesh(new BoxGeometry(1, 1, 1), Utils3D.getTestShader());
        _this.add(mesh);

        mesh.position.z = -4;

        _this.startRender(t => {
            mesh.position.y = Math.sin(t * 0.002) * 0.3;
            mesh.rotation.y += 0.01;
            mesh.rotation.x += 0.004;
        });

        World.SCENE.add(_this.group);

        let camera = _this.initClass(GazeCamera);
        camera.moveXY.set(8, 4);
        camera.position.set(0, 0, 6);
        camera.lerpSpeed = 0.07;
        camera.lookAt = new Vector3();
        camera.lock();

    }

    //*** Event handlers

    //*** Public methods

});

Class(function AbstractAvatar() {
    Inherit(this, Object3D);
    const _this = this;

    //*** Event handlers

    //*** Public methods
    this.state = this.parent.state;
    this.bindLink = this.parent.bindLink;
    this.bindEvent = this.parent.bindEvent;
    this.bindGlobal = this.parent.bindGlobal;
    this.bindGlobalEvent = this.parent.bindGlobalEvent;
    this.fireEvent = this.parent.fireEvent;
    this.fireEvent = this.parent.fireEvent;

    this.setUserData = async function(data) {
        //receive updates on the user data and edit the avatar accordingly
        // console.warn('AbstractAvatar::setUserData not implemented');
    }

    this.getHitBox = async function() {
        //return a hitbox mesh
        // console.warn('AbstractAvatar::setUserData not implemented');
    }

    this.addToBatch = function(mesh, key) {

    }

    this.getPlayerController = function() {
        return _this.findParent('GroupEnvironment').player;
    }

    this.getPlayerControls = async function() {
        let player = _this.getPlayerController();
        await player.wait('controls');
        return player.controls;
    }
});
Class(function AbstractEnvironment(_layout) {
    Inherit(this, Object3D);
    const _this = this;
    var _multiplayerConfig, _batches, _config, _interaction, _savedCamera, _videoManager, _overrideConfig;
    var _reconnectMultiplayer;

    const NAME = Utils.getConstructorName(_this);

    //NOTE: Using _this.parent here is not going to give you Main.js.
    //Use DreamWorld.active to get access to Main
    if (!_layout) _layout = `${NAME}_env`;
    this.layout = _this.initClass(SceneLayout, _layout, { physics: !!window.Physics });

    //so visibility events happen correctly
    _this.startRender(_ => {});
    GLSEO.registerPage(_this.group, NAME);

    _this.events.sub(GameCenter.LOST_CONNECTION, async e => {
        if (_this.isActive) {
            if (_this.stageMultiplayer && !_this.canEnterMultiplayer) return;
            if (_this.flag('lost')) return;
            _this.flag('lost', true);
            if (_videoManager) {
                _videoManager.removePlayer(_this.player);
                _videoManager.reset();
            }
            Multiplayer.reset();
            await e.reconnected();
            if (_this.player) _this.player.onLocalActivate();
            if (_this.isActive) connectMultiplayer();
            _this.flag('lost', false);
            if (_videoManager) _videoManager.addPlayer(_this.player);
        }
    });

    function setCamera() {
        if (!_this._type || _this._type == 'global') return;
        if (Global.PLAYGROUND) return;
        let player = _this.getPlayerController();
        if (player) {
            player.wait('controls').then(_ => {
                if (!Platform.usingVR()) {
                    player.controls.ready().then(_ => {
                        Camera.instance().lock(_config.camera.camera || _config.camera);
                    });
                }
            });
        } else {
            Camera.instance().lock(_config.camera.camera || _config.camera);
        }
    }

    async function connectMultiplayer() {
        if (Global.PLAYGROUND) return;
        if (_this.stageMultiplayer && !_this.canEnterMultiplayer) return;
        if (_multiplayerConfig) {
            if (_config) {
                if (_config.audioStream != undefined) GameCenterMedia.audioStream = _config.audioStream;
                if (_config.videoStream != undefined) GameCenterMedia.videoStream = Platform.usingVR() ? false : _config.videoStream;
                if (_config.p2pStream != undefined) GameCenterMedia.p2p = _config.p2pStream;
            }

            for (let i = 0; i < 999; i++) {
                try {
                    let room = await Multiplayer.establish(_multiplayerConfig);
                    _this.events.sub(room, GameCenterRoom.ERROR, _ => _this._activate());
                    break;
                } catch (e) {
                    Multiplayer.failed();
                    if (_this.onMultiplayerError) return _this.onMultiplayerError();
                    await _this.wait(250);
                }
            }
        }
    }

    async function displayPrompt() {
        await _this.wait(500);
        let config = AbstractEnvironment.PENDING_PROMPT;
        AbstractEnvironment.PENDING_PROMPT = null;

        let _prompt = _this.initClass(UI3DPrompt, config);
        let _v3 = new Vector3();
        _prompt.scale = 1.25;
        _prompt.animateIn();
        _prompt.group.visible = true;
        _prompt.group.position.copy(_this.player.group.position);
        _prompt.group.position.y += 0.6;
        _this.group.add(_prompt.group);

        let _target = new Group();

        const VR = Platform.usingVR();

        const loop = _ => {
            if (PlayerControls.getViewState() == '1st') {
                _target.position.copy(World.CAMERA.position);
                _target.position.add(_v3.set(0, 0, -1.5).applyQuaternion(World.CAMERA.quaternion));
                _target.lookAt(World.CAMERA.position);
                _prompt.group.position.lerp(_target.position, 0.1);
                _prompt.group.quaternion.slerp(_target.quaternion, 0.1);
            } else {
                _target.quaternion.copy(World.CAMERA.quaternion);
                _prompt.group.quaternion.slerp(_target.getWorldQuaternion(), 0.1);
            }
        };

        if (!VR) _this.startRender(loop);
        if (VR || PlayerControls.getViewState() == '1st') {
            _prompt.scale = 0.4;
            _prompt.group.position.copy(World.CAMERA.position);
            _prompt.group.position.y -= 0.25;
            _prompt.group.position.add(new Vector3(0, 0, -1).applyQuaternion(World.CAMERA.quaternion));
            _prompt.group.lookAt(World.CAMERA.position);
        }

        _this.events.sub(_prompt, Events.COMPLETE, _ => {
            _prompt.animateOut();
        });
    }

    //*** Event handlers
    function onWorldResize() {

    }
    //*** Public methods
    this.getHitMesh = function() {
        if (!_this.layout.exists('hitmesh')) return;// console.warn('AbstractEnvironment :: Missing hitmesh layer or custom getHitMesh override');
        return _this.layout.getLayer('hitmesh');
    };

    this.getHitMeshVR = function() {
        if (!_this.layout.exists('hitmeshVR')) return;// console.warn('AbstractEnvironment :: Missing hitmesh layer or custom getHitMesh override');
        return _this.layout.getLayer('hitmeshVR');
    };

    this.getSpawn = function() {
        if (!_this.layout.exists('spawn')) return;// console.warn('AbstractEnvironment :: Missing spawn layer or custom getSpawn override');
        return _this.layout.getLayer('spawn');
    };

    this.loaded = function() {
        return _this.layout.loadedAllLayers();
    };

    this._onPlayerConnect = function(player) {
        _this.events.fire(AbstractEnvironment.PLAYER_CONNECT, { player });
        if (_interaction) _interaction.addPlayer(player);
        if (_videoManager) _videoManager.addPlayer(player);
    };

    this._onPlayerDisconnect = function(player) {
        _this.events.fire(AbstractEnvironment.PLAYER_DISCONNECT, { player });
        if (_interaction) _interaction.removePlayer(player);
        if (_videoManager) _videoManager.removePlayer(player);
    };

    this._connectLocalPlayer = function(player) {
        _this.events.fire(AbstractEnvironment.PLAYER_CONNECT, { player, local: true });
    };

    this.onConnectPlayer = function() {
        //when a player joins the room
        // console.warn('AbstractEnvironment::onConnectPlayer not implemented');
    };

    this.onDisconnectPlayer = function() {
        //when a player leaves the room
        // console.warn('AbstractEnvironment::onDisconnectPlayer not implemented');
    };

    this.createPhysics = async function(config) {
        config.random = false;

        let scene = this.getScene();

        _this.physics = Physics.instance().createScene(Utils.getConstructorName(_this), scene, config);
        if (_this.isPlayground() || true) Physics.instance().useScene(Utils.getConstructorName(_this)); //TODO: Sort out the order of initializing physics!

        return _this.physics;
    };

    this._activate = async function() {
        _this.domActive = true;
        _this.activateTime = Render.TIME;
        Multiplayer.reset();
        if (!Global.PLAYGROUND) Lighting.useScene(Utils.getConstructorName(_this));

        if (_this.element) _this.element.show();

        if (_this.needsReactivate) {
            _this.needsReactivate = false;
            if (_videoManager) _videoManager.reset();
        }

        if (Platform.visibility != 'visible') {
            await Platform.waitForFocus();
        }

        _this.player = _this.getPlayerController();
        if (_this.player) _this.player.onLocalActivate();

        if (!_config) _config = _overrideConfig;
        if (_config) {
            if (!Global.PLAYGROUND) {
                try {
                    _this.player.wait('controls').then(_ => {
                        if (_config.globalView || _config.preventMovement || _this.player.view instanceof AbstractAvatar) _this.player.controls.disable();
                        else _this.player.controls.enable();

                        if (_config.preventTeleport) _this.player.controls.disableTeleport();
                    });
                } catch (e) { }
            }

            if (_config.camera) {
                if (_config.camera.lock) _config.camera.lock();
                setCamera();
            }

            // if (_config.freeMove) PlayerControls.FREE_MOVE = true;
            // else PlayerControls.FREE_MOVE = false;
            PlayerControls.FREE_MOVE = false;

            if (_config.walkingAvatar) PlayerControls.WALKING_AVATAR = true;
            else PlayerControls.WALKING_AVATAR = false;

            if (_config.joystickSpeed) PlayerControlsVR.JOYSTICK_SPEED = _config.joystickSpeed;
            else PlayerControlsVR.JOYSTICK_SPEED = 1;

            if (_config.maxMouseTeleport) PlayerTeleportMouse.MAX_MOVE = _config.maxMouseTeleport;
            else PlayerTeleportMouse.MAX_MOVE = PlayerTeleportMouse.MAX_MOVE_DEFAULT;

            if (_config.vrTransitionWaitTime) Transition.EXTRA_WAIT_TIME = _config.vrTransitionWaitTime;
            else Transition.EXTRA_WAIT_TIME = 0;

            if (_config.mobileControlsOffset) PlayerControls.MOBILE_CONTROLS_OFFSET = _config.mobileControlsOffset;
            else PlayerControls.MOBILE_CONTROLS_OFFSET = false;

            if (_config.noJumping) PlayerControls.NO_JUMP = true;
            else PlayerControls.NO_JUMP = false;

            if (_config.vrTeleportScalar) PlayerControlsVR.TELEPORT_SCALAR = _config.vrTeleportScalar;
            else PlayerControlsVR.TELEPORT_SCALAR = 1;

            if (_config.blockTeleport) PlayerControls.BLOCK_TELEPORT = true;
            else PlayerControls.BLOCK_TELEPORT = false;

            if (_config.moveMultiplier) PlayerControls.MOVE_MULTIPLIER = _config.moveMultiplier;
            else PlayerControls.MOVE_MULTIPLIER = 1;

            if (_config.zoomMultiplier) PlayerControls.ZOOM_MULTIPLIER = _config.zoomMultiplier;
            else PlayerControls.ZOOM_MULTIPLIER = 1;

            if (_config.controlsFOV) PlayerControls.FOV = _config.controlsFOV;
            else PlayerControls.FOV = undefined;

            if (_config.controlsConfig) PlayerControls.CUSTOM_CONFIG = _config.controlsConfig;
            else PlayerControls.CUSTOM_CONFIG = undefined;

            if (_config.globalView && !_config.camera && !_this.globalCamera) {
                _this.globalCamera = _this.initClass(GlobalViewCamera, _this);
            }

            if (_config.cameraViewToggle && !_this.cameraViewToggleUI) {
                _this.cameraViewToggleUI = _this.initClass(DreamUI.CameraViewToggle, _config.cameraViewToggle, [_this.getDOMElement()]);
            }

            try {
                if (_config.hidePlayer && !Global.PLAYGROUND) {
                    _this.player.view.visible = false;
                } else {
                    _this.player.view.visible = true;
                }
            } catch (e) { }

            if (_config.videoChatZones?.avatarProfileGrid) _config.avatarProfileGrid = _config.videoChatZones.avatarProfileGrid;

            if (_config.avatarProfileGrid) {
                if (!_this.avatarProfileGrid) _this.avatarProfileGrid = _this.initClass(AvatarProfileGrid, _config.avatarProfileGrid);
                else _this.avatarProfileGrid.reset();
            }

            if (_config.videoChatZones) {
                _config.videoStream = _config.videoChatZones.audioOnly !== undefined ? !_config.videoChatZones.audioOnly : !Platform.usingVR();
                _config.audioStream = true;
                _config.videoPreview = false;
                _config.videoLayout = _this.avatarProfileGrid;
                _config.preventMovement = false;
                _config.avatarInteraction = true;
                if (_multiplayerConfig) _multiplayerConfig.chatZones = true;
                console.log(_config.videoChatZones)
            }

            if (_config.avatarNameLabels) {
                if (!_this.avatarNameLabels) _this.avatarNameLabels = _this.initClass(AvatarNameLabels, _config.avatarNameLabels);
                else _this.avatarNameLabels.reset();
            }

            if (_config.profilePrompt) {
                _config.avatarInteraction = true;
                if (!_this.profilePrompt) {
                    _this.profilePrompt = _this.initClass(ProfilePrompt, _config.profilePrompt);
                    _this.setFXAAMask(_this.profilePrompt);
                }
            }

            if (_config.audioStream != undefined) GameCenterMedia.audioStream = _config.audioStream;
            if (_config.videoStream != undefined) {
                if (_config.videoStream && _config.videoPreview === undefined) _config.videoPreview = true;
                if (_config.videoStream && !_config.videoLayout) _config.videoLayout = _this.initClass(VideoLayoutWrapper, _config.videoLayoutConfig);
                if (!_videoManager && _config.videoLayout) {
                    _videoManager = _this.videoManager = _this.initClass(VideoManager, _config.videoLayout, _config.videoPreview, _config.instructions);
                    _this.videoLayout = _config.videoLayout;
                    _this.flag(AbstractEnvironment.VIDEO_MANAGER_READY, true);
                }

                GameCenterMedia.videoStream = _config.videoStream;
                if (_config.videoStream) {
                    if (_config.preventMovement === false) _config.videoPreview = false;
                    else if (_config.preventMovement !== true) _config.preventMovement = true;
                    if (_config.videoPreview !== false) {
                        _this.stageMultiplayer = true;
                        _this.canEnterMultiplayer = false;
                        _config.videoPreview = true;
                    } else {
                        if (_videoManager) _videoManager.addPlayer(_this.player);
                    }
                }
            }

            if (!_config.videoStream && _config.videoChatZones) {
                if (_videoManager) _videoManager.addPlayer(_this.player);
            }

            if (_config.p2pStream != undefined) GameCenterMedia.p2p = _config.p2pStream;

            if (_config.avatarAudio) {
                AvatarAudio.NEAR = _config.avatarAudio.near ? _config.avatarAudio.near : 5;
                AvatarAudio.FAR = _config.avatarAudio.far ? _config.avatarAudio.far : 10;
            }

            if (_config.avatarInteraction) {
                if (!_interaction) _interaction = _this.initClass(AvatarInteraction, typeof _config.avatarInteraction === 'object' ? _config.avatarInteraction : undefined);
                _interaction.activate();
            } else {
                if (_interaction) _interaction = _interaction.destroy();
            }

            if (_config.videoChatZones) {
                if (_this.videoChatZones) _this.videoChatZones.destroy();
                _this.videoChatZones = _this.initClass(VideoChatZones, typeof _config.videoChatZones === 'object' ? _config.videoChatZones : {}, _interaction);
                _this.setFXAAMask(_this.videoChatZones);
            } else {
                if (_this.videoChatZones) _this.videoChatZones = _this.videoChatZones.destroy();
            }
        }

        if (_this.onActivate) _this.onActivate();
        if (_this.onResetGame) _this.onResetGame();

        if (_this.physics) Physics.instance().useScene(Utils.getConstructorName(_this));

        connectMultiplayer();
        if (_interaction) _interaction.addLocalPlayer(_this.player);

        if (!_this.isActive && AbstractEnvironment.PENDING_PROMPT) displayPrompt();
        _this.isActive = true;
    };

    this.addToBatch = function(mesh, key) {
        if (!_batches) _batches = {};
        if (!_batches[key]) {
            _batches[key] = _this.initClass(MeshBatch, { worldCoords: true, parent: 2, bypassVisibilityCheck: true });
            _batches[key].frustumCulled = false;
            if (key == 'avatar') _batches[key].maxIndices = 256;
        }
        mesh.batch = _batches[key];
        _batches[key].add(mesh);

        if (key == 'avatar' && _config && _config.maxVisibleAvatars) {
            mesh.batch.wait('mesh').then(_ => {
                mesh.batch.mesh.maxInstancedCount = _config.maxVisibleAvatars;
            });
        }
    };

    this.getBatch = function(key, config) {
        if (!_batches) _batches = {};
        if (!_batches[key]) {
            _batches[key] = _this.initClass(MeshBatch, config || { worldCoords: true, parent: 2, bypassVisibilityCheck: true });
            _batches[key].frustumCulled = false;
            if (key == 'avatar') _batches[key].maxIndices = 256;
        }
        return _batches[key];
    };

    // eslint-disable-next-line no-multi-assign
    this.setupMultiplayer = this.configureMultiplayer = async function(obj) {
        if (!_multiplayerConfig) {
            // eslint-disable-next-line no-multi-assign
            _this.multiplayerConfig = _multiplayerConfig = obj;
        } else {
            for (let key in obj) {
                _multiplayerConfig[key] = obj[key];
            }
        }

        if (_multiplayerConfig) {
            if (!_multiplayerConfig.roomKey) throw 'setupMultiplayer must define roomKey';

            //roomKey = unique room identifier. this should match with the server configuration for number of players in a room.
            //roomId = if dreamworld has unique sessions (think google hangout) OR trying to connect to a specific room
            //community = is a community view (many connections): true by default
            //p2p
            //maxInRoom = total allowable in said room
            //maxVisibleAvatars = reduce the avatars visible for lower powered devices

            if (_multiplayerConfig.p2p !== true) _multiplayerConfig.community = true;
        }
        if (_this.isActive && !Global.PLAYGROUND) {
            if (_this.stageMultiplayer && !_this.canEnterMultiplayer) return;
            GameCenter.TEMP_BLOCK_RESET = true;

            if (_reconnectMultiplayer) {
                if (Hydra.LOCAL) console.warn('Attempting to reconfigure multiplayer & reconnect before the previous connection has been established');
                await _reconnectMultiplayer;
            }
            _reconnectMultiplayer = Promise.create();
            if (_videoManager) _videoManager.removePlayer(_this.player);
            Multiplayer.reset();
            await _this.wait(100);
            if (_this.player) _this.player.onLocalActivate();
            if (_videoManager) _videoManager.addPlayer(_this.player);
            if (_interaction) _interaction.addLocalPlayer(_this.player);
            if (_this.onResetGame) _this.onResetGame();
            await connectMultiplayer();
            GameCenter.TEMP_BLOCK_RESET = false;
            await _this.wait(500);
            _reconnectMultiplayer.resolve();
            _reconnectMultiplayer = null;
        }
    };

    this.configureSpace = function(obj) {
        if (_overrideConfig) Utils.mergeObject(obj, _overrideConfig);
        _config = _this.config = obj;

        //preventMovement = disable controls so you can't move around
        //hidePlayer = hide the local player avatar
        //camera = custom camera
        //controls = 1st || 3rd (default controls)
        //audioStream
        //videoStream
        //p2pStream
        //avatarInteraction
        //globalView
        //freeMove
        //moveMultiplier
        //blockTeleport
        //controlsFOV
        //controlsConfig
        //cameraViewToggle = camera UI
        //preventTeleport
        //maxVisibleAvatars = reduce the avatars visible for lower powered devices
        //persistAvatarLocation
        //maxMouseTeleport

        if (obj.avatarPlaygroundClass) {
            GlobalEnvironment.instance().registerPlayerClass(obj.avatarPlaygroundClass);
        }

        if (_config.globalView && !_this.globalCamera) {
            _this.globalData = _this.initClass(GlobalViewData, _this);
        }

        if (Global.PLAYGROUND || _this.isActive) _this._activate();
    };

    this.setCamera = function (camera) {
        if (typeof _config !== 'object') _config = {};
        _config.camera = camera;
        setCamera();
    };

    this.deactivate = function() {
        if (_this.element) _this.element.hide();
        if (_videoManager) _videoManager.deactivate();
        for (let key in _batches) {
            _batches[key].destroy();
        }
        _batches = null;
        if (_this.physics) Physics.instance().deactivateScene();
        if (_this.onDeactivate) _this.onDeactivate();
        _this.isActive = false;
        _this.domActive = false;
        _this.needsReactivate = true;
    };

    this._bindOnDestroy(_ => {
        _this.group.deleted = true;
        if (_this.element && _this.element.remove) _this.element.remove();
        if (_this.physics) Physics.instance().destroyScene(Utils.getConstructorName(_this));
    });

    this.getPlayerController = function() {
        let env = _this.findParent('GroupEnvironment');
        return env ? env.player : undefined;
    };

    this.overrideCamera = async function(camera, time = 1, ease = 'easeOutCubic', delay) {
        camera = camera.camera || camera;
        if (!Global.PLAYGROUND && (!_config || !_config.globalView)) {
            let parent = _this.findParent('GroupEnvironment');
            await parent.wait('player');
            let player = parent.player;
            await player.wait('controls');
        } else {
            if (_this.wait) await _this.wait(500);
        }
        if (!_savedCamera) _savedCamera = Camera.instance().lockCamera;
        Camera.instance().transition(camera, time, ease, delay);
    };

    this.restoreCamera = async function(time = 500, ease = 'easeOutCubic', delay) {
        if (!_savedCamera) return;
        Camera.instance().transition(_savedCamera, time, ease, delay);
        _savedCamera = null;
    };

    this.customEnvironment = function() {
        _overrideConfig = {
            preventMovement: true,
            hidePlayer: true
        };
    };

    this.enterVideoChat = function() {
        if (!_this.canEnterMultiplayer) {
            _this.canEnterMultiplayer = true;
            if (_videoManager) _videoManager.addPlayer(_this.player);
            GameCenter.TEMP_BLOCK_RESET = true;
            _this.wait(Multiplayer, 'room').then(_ => GameCenter.TEMP_BLOCK_RESET = false);
            connectMultiplayer();
        }
    };

    this.getDOMElement = function() {
        if (!_this.element) {
            let resize = [];

            let left = 0;
            let top = 0;

            if (UIController.instance().layout) {
                let { sizes } = UIController.instance();

                left = sizes.left;
                top = sizes.top;
            }

            _this.element = $(Utils.getConstructorName(_this));
            _this.element.css({ left, top }).size(Stage.width, Stage.height);

            UIController.instance().element.add(_this.element);

            if (!_this.domActive) _this.element.hide();

            let fireResize = _ => {
                resize.forEach((fn, i) => {
                    try {
                        fn();
                    } catch (e) {
                        resize.splice(i, 1);
                    }
                });
            };

            _this.events.sub(World.RESIZE, () => {
                if (_this.element && _this.element.size) {
                    _this.element.size(Stage.width, Stage.height);
                }

                fireResize();
            });

            _this.element.onResize = async fn => {
                resize.push(fn);
                await _this.wait(1000);
                fn();
            };
        }

        return _this.element;
    };

    this.disconnectMultiplayer = function() {
        Multiplayer.reset();
        _this.stageMultiplayer = true;
        _this.canEnterMultiplayer = false;
    };

    this.getScene = function() {
        if (!_this.scene) {
            let p = _this.group._parent;
            while (p) {
                if (p instanceof Scene) _this.scene = p;
                p = p._parent;
            }
        }

        return _this.scene;
    };

    function initFXAAMask() {
        let scene = _this.getScene();
        let passes = scene?.nuke?.passes;

        if (!passes) return;

        let [fxaa] = passes;

        if (!_this.fxaaMask && fxaa) {
            _this.fxaaMask = _this.initClass(FXScene, World.NUKE);

            _this.fxaaMaskShader = _this.initClass(Shader, 'FXAAMaskShader');

            _this.fxaaMeshMerge = new MeshMerge();
            _this.fxaaMeshMerge.onMeshCreated = mesh => {
                _this.fxaaMeshMergeMesh = mesh;
                _this.fxaaMeshMergeMesh.frustumCulled = false;
                _this.fxaaMeshMergeMesh.shader = _this.fxaaMaskShader;

                _this.fxaaMask.add(mesh);
            };

            fxaa.setMask(_this.fxaaMask);
        }
    }

    function setFXAAElement(element) {
        let clone = _this.fxaaMask.add(element);

        clone.shader = _this.fxaaMaskShader;
        clone.visible = false;
    }

    function setFXAAMaskShader(object) {
        if (!_this.fxaaMask) return;

        let name = Utils.getConstructorName(object);

        if (name === 'ProfilePrompt') {
            setFXAAElement(object.group.children[0].children[0]);
        } else if (name === 'TriggerZone' || name === 'VideoChatZones') {
            setFXAAElement(object.dialog.group.children[0].children[0]);
        } else if (name === 'Mesh') {
            _this.fxaaMeshMerge.add(object.clone());
        }
    }

    this.setFXAAMask = function(objects) {
        if (Platform.usingVR() || Global.PLAYGROUND) return false;
        initFXAAMask();

        if (objects.length) {
            objects.forEach(object => setFXAAMaskShader(object));
        } else {
            setFXAAMaskShader(objects);
        }
    };
}, _ => {
    AbstractEnvironment.PLAYER_CONNECT = 'abs_player_connect';
    AbstractEnvironment.PLAYER_DISCONNECT = 'abs_player_disconnect';
    AbstractEnvironment.VIDEO_MANAGER_READY = ' AbstractEnvironment.VIDEO_MANAGER_READY';
});

Class(function CrowdAvatar() {
    Inherit(this, Object3D);
    const _this = this;
    var _options;

    var _map = {};

    if (!World.AVATAR_BOX) {
        World.AVATAR_BOX = new BoxGeometry(1, 1, 1).toNonIndexed();
        World.AVATAR_SPHERE = new SphereGeometry(1).toNonIndexed();
    }

    async function merge(layers) {
        let array = [];
        let index = 0;
        for (let key in layers) {
            layers[key].geomIndex = index;
            _map[key] = index++;
            array.push(layers[key]);
        }

        if (array.length == 1) return array[0];

        let meshes = [];
        let buffer = [];

        array.forEach((mesh, i) => {
            let position = mesh.geometry.attributes.position.array;
            let uv = mesh.geometry.attributes.uv.array;
            let normal = mesh.geometry.attributes.normal.array;

            let positionClone = new Float32Array(position);
            let uvClone = new Float32Array(uv);
            let normalClone = new Float32Array(normal);

            mesh.updateMatrix();

            meshes.push({p: positionClone, u: uvClone, n: normalClone, geomIndex: mesh.geomIndex, matrix: mesh.matrix.elements});
            buffer.push(positionClone.buffer, uvClone.buffer, normalClone.buffer);
        });

        let {arrays} = await Thread.shared().crowdAvatarMergeMeshes({meshes});
        let geom = new Geometry();
        for (let key in arrays) {
            geom.addAttribute(key, new GeometryAttribute(arrays[key].array, arrays[key].components));
        }
        return geom;
    }

    function editShader(shader) {
        let vs = shader.vertexShader;
        let fs = shader.fragmentShader;

        if (!fs) return;

        let modify = code => {
            let defines = '\n';
            for (let key in _map) {
                defines += `#define ${key} ${_map[key]}.0\n`;
            }

            let split = code.split('__ACTIVE_THEORY_LIGHTS__');
            code = split[0] + '__ACTIVE_THEORY_LIGHTS__' + defines + split[1];
            return code;
        };

        shader.vertexShader = modify(vs);
        shader.fragmentShader = modify(fs);
    }

    //*** Event handlers

    //*** Public methods
    this.create = async function(shader, options = {}) {
        let layout = _this.initClass(SceneLayout, `crowd_avatar_${Utils.getConstructorName(_this)}`, {noGraph: !_this.isPlayground()});
        await layout.loadedAllLayers();

        let geom = await merge(layout.layers);
        editShader(shader);

        _options = options;
        _this.mesh = new Mesh(geom, shader);
        _this.mesh.frustumCulled = false;
        if (options.castShadow) _this.mesh.castShadow = true;

        if (_this.isPlayground()) {
            let plane = new Mesh(World.PLANE, Utils3D.getTestShader());
            _this.add(plane);
            plane.rotation.x = Math.radians(-90);
            plane.scale.setScalar(4);

            _this.group.add(_this.mesh);
            _this.mesh.position.x = 0.5;
        } else {
            _this.remove(layout.group);
        }
    }

    this.loadAttribBuffers = async function() {
        let geom = _this.mesh.geometry;
        let count = geom.attributes.random.count;

        for (let key in _options.attribs) {
            let val = _options.attribs[key];
            let components = (function() {
                switch (val) {
                    case 'f': return 1; break;
                    case 'v3': return 3; break;
                    case 'c': return 3; break;
                }
            })();
            let buffer = new Float32Array(count * components);
            _this.fillAttributeBuffer && _this.fillAttributeBuffer(buffer, count, key, val);
            geom.addAttribute(key, new GeometryAttribute(buffer, components, 1));
        }
    }

    this.getMesh = async function() {
        await _this.wait('mesh');
        return _this.mesh;
    }
}, _ => {
    function crowdAvatarMergeMeshes({meshes}, id) {
        let fill = (array, value) => {
            for (let i = 0; i < array.length; i++) array[i] = value;
            return array;
        };

        let geometry;
        meshes.forEach(m => {
            let geom = new Geometry();
            geom.addAttribute('position', new GeometryAttribute(m.p, 3));
            geom.addAttribute('uv', new GeometryAttribute(m.u, 2));
            geom.addAttribute('normal', new GeometryAttribute(m.n, 3));
            geom.addAttribute('geomIndex', new GeometryAttribute(fill(new Float32Array(m.u.length / 2), m.geomIndex), 1));
            geom.applyMatrix(new Matrix4().fromArray(m.matrix));

            if (geometry) geometry.merge(geom);
            else geometry = geom;
        });

        let buffers = [];
        let obj = {};

        for (let key in geometry.attributes) {
            obj[key] = {array: geometry.attributes[key].array, components: geometry.attributes[key].itemSize};
            buffers.push(obj[key].array.buffer);
        }

        resolve({arrays: obj}, id, buffers);
    }

    Thread.upload(crowdAvatarMergeMeshes);
});
Class(function DefaultCrowdAvatar() {
    Inherit(this, CrowdAvatar);
    const _this = this;

    //*** Constructor
    (async function () {
        if (!World.CROWD_AVATAR_BOX) {
            World.CROWD_AVATAR_BOX = new BoxGeometry(0.1, 0.1, 0.1).toNonIndexed();
        }

        let shader = _this.initClass(Shader, 'DefaultCrowdAvatar', {

        });

        await _this.create(shader, {
            attribs: {color0: 'c', color1: 'c', color2: 'c'},
            castShadow: true
        });
    })();

    //*** Event handlers

    //*** Public methods
    this.fillAttributeBuffer = function(buffer, count, key, type) {
        for (let i = 0; i < count; i++) {
            buffer[i * 3 + 0] = Math.random(0, 1, 4);
            buffer[i * 3 + 1] = Math.random(0, 1, 4);
            buffer[i * 3 + 2] = Math.random(0, 1, 4);
        }
    }
});
Class(function AvatarNameLabels(_config) {
    Inherit(this, Object3D);
    const _this = this;
    var _worker, _mesh, _data, _shader;

    var _players = [];

    const VR = Platform.usingVR();

    //*** Constructor
    (function () {
        initConfig();
        initBatches();
        addListeners();
        _this.startRender(loop);
    })();

    function initBatches() {
        let batch = _this.parent?.getBatch?.('avatar');
        if (!batch) throw `AvatarNameLabels couldn't find batch??`;
        if (!batch.maxIndices) batch.maxIndices = 256;
        let pot = Math.pow(2, Math.ceil(Math.log(batch.maxIndices)/Math.log(2)));
        let size = Math.sqrt(pot);
        _data = new DataTexture(new Float32Array(pot * 4), size, size, Texture.RGBFormat);
    }

    function initMesh(geom) {
        _shader = _this.initClass(Shader, 'AvatarNameLabels', {
            tData: {value: _data},
            uSize: {value: _data.width},
            uQuaternion: {value: World.CAMERA.quaternion},
            tMap: {value: _players[0].avatarTextLabel.mesh.shader.get('tMap')},
            uColor: {value: new Color(_config.color)},
            uAlpha: {value: _config.alpha},
            uDistanceFade: {value: new Vector2(_config.distanceFade[0], _config.distanceFade[1])},
            transparent: true,
            depthWrite: false
        });
        _mesh = new Mesh(geom, _shader);
        _mesh.frustumCulled = false;
        _mesh.renderOrder = 9999;
        _this.add(_mesh);
    }

    function initConfig() {
        _config.font = _config.font || 'myriad';
        _config.size = _config.size || 0.3;
        _config.yPos = _config.yPos || 1.8;
        _config.alpha = _config.alpha || 1;
        _config.color = _config.color || '#ffffff';
        _config.distanceFade = _config.distanceFade || [10, 15];
    }

    function loop() {
        for (let i = _players.length-1; i > -1; i--) {
            let player = _players[i];
            if (!player.view) continue;
            let $obj = player.avatarTextLabel;

            let offsetY = 0;
            if (player.gcPlayer && player.gcPlayer.me) offsetY += 9999;
            if (player.hidden) offsetY += 9999;

            let index = player.view.mesh.batchIndex;
            _data.data[index * 3 + 0] = player.group.position.x;
            _data.data[index * 3 + 1] = player.group.position.y + _config.yPos + offsetY;
            _data.data[index * 3 + 2] = player.group.position.z;
        }

        _data.needsUpdate = true;
    }

    function applyIndex(geom, index) {
        let count = geom.attributes.position.count;
        let buffer = new Float32Array(count);
        for (let i = 0; i < count; i++) buffer[i] = index;
        geom.addAttribute('tIndex', new GeometryAttribute(buffer, 1));
    }

    function createMergedGeometry() {
        if (_worker) _worker.stop();
        if (!_players.length) return;
        if (!_players[0].avatarGeom) return;
        let geom = _players[0].avatarGeom.toNonIndexed();
        if (!geom.attributes.tIndex) applyIndex(geom, _players[0].view.mesh.batchIndex);
        let index = 0;

        let complete = _ => {
            if (!_mesh) initMesh(geom);
            else {
                _this.group.remove(_mesh);
                _mesh.geometry.destroy(_mesh);
                _mesh = new Mesh(geom, _shader);
                _mesh.frustumCulled = false;
                _mesh.renderOrder = 9999;
                _this.add(_mesh);
            }
        };

        _worker = new Render.Worker(_ => {
            index++;
            let player = _players[index];
            if (!player) {
                complete();
                return _worker.stop();
            }

            if (player.avatarGeom) {
                let pgeom = player.avatarGeom.toNonIndexed();
                if (!pgeom.attributes.tIndex) applyIndex(pgeom, player.view.mesh.batchIndex);
                geom.merge(pgeom);
            }
        }, 1);
    }

    //*** Event handlers
    function addListeners() {
        _this.events.sub(Player.JOIN, playerJoin);
        _this.events.sub(Player.LEAVE, playerLeave);
    }

    function playerJoin({player}) {
        if (_this._invisible) return;

        player.__avatarNameBind = player.state.bind(_config.stateKey || 'name', async nameString => {
            playerLeave({player});
            let $text = $glText(player.state.get(_config.stateKey || 'name'), _config.font, _config.size, {align: 'center'});
            await Promise.all([player.view.ready(), $text.loaded()]);
            await _this.wait(1200);
            if (!player.view) return;
            player.avatarTextLabel = $text;
            let geometryText = $text.mesh.geometry;
            let geometry = new Geometry();
            geometry.index = geometryText.index;
            geometry.addAttribute('position', geometryText.attributes.position.clone());
            geometry.addAttribute('uv', geometryText.attributes.uv.clone());
            player.avatarGeom = geometry;
            _players.push(player);
            Utils.debounce(createMergedGeometry, 100);
        });
    }

    function playerLeave({player}) {
        if (_this._invisible) return;
        _players.remove(player);
        player.__avatarNameBind?.destroy?.();
        Utils.debounce(createMergedGeometry, 100);
    }

    //*** Public methods
    this.reset = function() {
        _players.length = 0;
    }

    this.set('alpha', v => {
        _config.alpha = v;
        _mesh?.shader.set('uAlpha', v);
    });

    this.get('alpha', v => {
        return _config.alpha;
    });

}, _ => {

});
Class(function DefaultOptimizedAvatar() {
    Inherit(this, OptimizedAvatar);
    const _this = this;

    //*** Constructor
    (async function () {
        let shader = _this.initClass(Shader, 'DefaultOptimizedAvatar', {
            uColor: {value: new Color(Utils.randomColor()), batchUnique: true}
        });

        await _this.create(['accessory'], shader);
        // _this.setVisibility('accessory', Utils.headsTails() ? 'sphere' : 'box');
    })();

    //*** Event handlers

    //*** Public methods
});
Class(function OptimizedAvatar() {
    Inherit(this, AbstractAvatar);
    const _this = this;
    var _shader, _name;

    var _visibility = [];

    this.rotation = 0;

    //*** Constructor
    (function () {
        if (!World.AVATAR_BOX) {
            World.AVATAR_BOX = new BoxGeometry(1, 1, 1).toNonIndexed();
            World.AVATAR_SPHERE = new SphereGeometry(1).toNonIndexed();
        }

        if (!_this.parent.group) return;
        _this.parent.group.matrixAutoUpdate = false;
        _this.parent.group.visible = false;
    })();

    //*** Event handlers

    //*** Public methods
    this.create = async function(groups, shader = Utils3D.getTestShader()) {
        if (_this.isPlayground()) {
            let plane = new Mesh(World.PLANE, Utils3D.getTestShader());
            plane.scale.setScalar(3);
            _this.add(plane);
            plane.rotation.x = Math.radians(-90);
            plane.scale.setScalar(4);
        }

        let className = Utils.getConstructorName(_this);
        await _this.instance().create(className, groups, _this.rotation);
        if (!_this.create) return;
        await _this.instance().ready();
        if (!_this.create) return;

        shader.addUniforms({
            uAVVis: {value: new Vector4(-1, -1, -1, -1), batchUnique: true}
        });

        _this.instance().modifyShader(shader);

        _this.mesh = new Mesh(_this.instance().geometry, shader);
        _this.add(_this.mesh);

        if (_this.trackVelocity) {
            let velocity;
            let angle = 0;
            let zero = new Vector3();
            let v3 = new Vector3();
            let v32 = new Vector3();
            let vec = new Vector4();
            if (_this.parent && _this.parent.group && _this.parent.group.position) {
                velocity = _this.initClass(VelocityTracker, _this.parent.group.position);
            }
            shader.addUniforms({
                uVelocity: {value: vec, batchUnique: true}
            });
            if (velocity) {
                let velocityLoop = _ => {
                    if (!_this.mesh) return Render.stop(velocityLoop);

                    const VR = _this.parent && _this.parent.isVR;
                    const THRESHOLD = VR ? 0.0002 : 0.000036;

                    velocity.update();
                    v32.copy(velocity.value);
                    if (VR && velocity.value.lengthSq() < THRESHOLD) v32.set(0, 0, 0);
                    v3.lerp(v32, 0.1);
                    let newAngle = v3.lengthSq() < THRESHOLD ? angle : Math.atan2(v3.x, v3.z);
                    angle = newAngle;
                    vec.set(v3.x, v3.y, v3.z, angle);
                };
                Render.start(velocityLoop);
            }
        }

        let parent = _this.findParent('GroupEnvironment');
        if (shader.waitForPromise) await shader.waitForPromise;
        if (parent && parent.view && parent.view.addToBatch) parent.view.addToBatch(_this.mesh, 'avatar');

        _shader = shader;

        if (_this.isPlayground()) _this.mesh.position.x = 0.8;
    }

    this.setVisibility = function(group, label, inline) {
        if (!_visibility.includes(group)) {
            if (_visibility.length == 4) throw `Can only have 4 groups with visibility customization`;
            _visibility.push(group);
        }

        let value = _this.instance().map[group][label];

        let index = _visibility.indexOf(group);
        switch (index) {
            case 0: _shader.get('uAVVis').x = value; break;
            case 1: _shader.get('uAVVis').y = value; break;
            case 2: _shader.get('uAVVis').z = value; break;
            case 3: _shader.get('uAVVis').w = value; break;
        }

        if (!inline) PlayerModel.set(Utils.getConstructorName(_this)+'Vis_' + group, label);
    }

    this.getCustomizableLabels = function() {
        let obj = {};
        let map = _this.instance().map;
        for (let key in map) {
            obj[key] = [];
            for (let key2 in map[key]) {
                if (!key2.includes('perm')) obj[key].push(key2);
            }
        }
        return obj;
    }

    this.instance = function() {
        return OptimizedAvatar.getInstance(_this.isPlayground() ? _this : null);
    }

    this.setUniform = async function(key, value) {
        await _this.ready();
        if (!_this.create) return;
        _shader.set(key, value);
        if (!!value.toArray) value = value.toArray();
        PlayerModel.set(Utils.getConstructorName(_this)+'_'+key, value);
    }

    this.setUserData = async function(data) {
        if (_this.overrideUserData) _this.overrideUserData(data);
        await _this.ready();
        if (!_this.create) return;
        _this.parent.group.visible = true;
        try {
            if (!_name) _name = Utils.getConstructorName(_this);
            let name = _name;
            for (let key in data) {
                let value = data[key];

                if (key.includes(name + '_')) {
                    let uniform = key.split(name + '_')[1];
                    if (Array.isArray(value)) {
                        let shaderUniform = _shader.get(uniform);
                        if (shaderUniform) shaderUniform.fromArray(value);
                    } else {
                        if (_shader.uniforms[uniform]) _shader.set(uniform, value);
                    }
                }

                if (key.includes(name + 'Vis_')) {
                    let group = key.split('Vis_')[1];
                    _this.setVisibility(group, value, true);
                }
            }
        } catch(e) {
            // console.log(e);
        }
    }

    // this._bindOnDestroy(function() {
    //     OptimizedAvatar.destroyInstance();
    // });

    this.ready = function() {
        return this.wait('mesh');
    }
}, _ => {
    var _map = {};
    OptimizedAvatar.LOD = '';
    OptimizedAvatar.getInstance = function(inst) {
        if (!_map[OptimizedAvatar.LOD]) _map[OptimizedAvatar.LOD] = new OptimizedAvatarInstance(inst, OptimizedAvatar.LOD);
        return _map[OptimizedAvatar.LOD];
    }

    OptimizedAvatar.destroyInstance = function() {
        try {
            if (_map[OptimizedAvatar.LOD]) _map[OptimizedAvatar.LOD].destroy();
            delete _map[OptimizedAvatar.LOD];
        } catch(e) { }
    }
});
Class(function OptimizedAvatarInstance(_local, _lod) {
    Inherit(this, Object3D);
    const _this = this;
    var _layouts, _name;

    var _group = _local ? _local.group : null;

    this.map = {};
    this.groups = {};

    async function initMerge(groups) {
        await Promise.all(Object.values(_layouts).map(l => l.loadedAllLayers()));
        let meshes = [];

        let geomIndex = 0;
        let uv2 = false;
        let vdata = false;

        if (!OptimizedAvatarInstance.cached) OptimizedAvatarInstance.cached = {};

        for (let key in _layouts) {
            let layout = _layouts[key];
            let groupIndex = groups.indexOf(key);

            _this.map[key] = {};
            _this.groups[key] = layout.group;

            layout.group.groupIndex = groupIndex;

            let input;
            if (_group && key != 'main') {
                input = InputUIL.create('Customize_' + key);
            }

            for (let key2 in layout.layers) {
                let cached = OptimizedAvatarInstance.cached[_name + '/' + key + '/' + key2];
                let mesh = layout.layers[key2];
                mesh.groupIndex = groupIndex;
                mesh.geomIndex = typeof cached !== 'undefined' ? cached : key2.includes('perm') || key == 'main' ? geomIndex + 100 : geomIndex;
                _this.map[key][key2] = mesh.geomIndex;
                OptimizedAvatarInstance.cached[_name + '/' + key + '/' + key2] = mesh.geomIndex;

                if (mesh.geometry.attributes.uv2) uv2 = true;
                if (mesh.geometry.attributes.vdata) vdata = true;

                if (input && !key2.includes('perm')) {
                    let callback = _ => _local.setVisibility(key, key2);
                    input.addButton('on', {label: key2, actions: [{title: key2, callback}]});
                }

                geomIndex++;
                meshes.push(mesh);
            }
        }

        if (!meshes.length) return;
        await mergeMeshes(meshes, uv2, vdata);
    }

    async function mergeMeshes(array, uv2, vdata) {
        let buffer = [];
        let meshes = [];

        array.forEach(mesh => {
            let position = mesh.geometry.attributes.position.array;
            let uv = mesh.geometry.attributes.uv.array;
            let normal = mesh.geometry.attributes.normal.array;

            let positionClone = new Float32Array(position);
            let uvClone = new Float32Array(uv);
            let normalClone = new Float32Array(normal);

            mesh.updateMatrixWorld(true);

            let obj = {p: positionClone, u: uvClone, n: normalClone, geomIndex: mesh.geomIndex, groupIndex: mesh.groupIndex, matrix: mesh.matrixWorld.elements};
            meshes.push(obj);
            buffer.push(positionClone.buffer, uvClone.buffer, normalClone.buffer);
            if (uv2) {
                obj.u2 = new Float32Array(mesh.geometry.attributes.uv2 ? mesh.geometry.attributes.uv2.array : mesh.geometry.attributes.uv.array.length);
                buffer.push(obj.u2.buffer);
            }
            if (vdata) {
                obj.vdata = new Float32Array(mesh.geometry.attributes.vdata ? mesh.geometry.attributes.vdata.array : mesh.geometry.attributes.position.array.length);
                buffer.push(obj.vdata.buffer);
            }
        });

        let {arrays, boundingBox, boundingSphere} = await Thread.shared().avatarMergeMeshes({meshes});
        let geom = new Geometry();
        for (let key in arrays) {
            geom.addAttribute(key, new GeometryAttribute(arrays[key].array, arrays[key].components));
        }
        geom.boundingBox = boundingBox;
        geom.boundingSphere = boundingSphere;
        _this.geometry = geom;
    }

    function overrideGeometry(geom, wildcard) {
        if (wildcard == 'lod' && _lod && _lod.length) return geom + _lod;
        return geom;
    }

    //*** Event handlers

    //*** Public methods
    this.create = async function(className, groups, rotation = 0) {
        if (_this.geometry) return;
        groups = ['main', ...groups];

        _name = className;

        let layouts = _layouts = {};

        groups.forEach(name => {
            layouts[name] = _this.initClass(SceneLayout, `${className}_${name}`, {noGraph: !_group});
            layouts[name].onCreateGeometry = overrideGeometry;
            layouts[name].group.rotation.y = rotation;
            layouts[name].group.updateMatrixWorld(true);
            if (_group) _group.add(layouts[name].group);

            layouts[name].group.prefix = `${className}_${name}`;
        });

        await initMerge(groups);

        return this;
    }

    this.ready = function() {
        return _this.wait('geometry');
    }

    this.modifyShader = function(shader) {
        if (_this.flag('shadermod') || !shader.vertexShader) return;
        _this.flag('shadermod', true);

        let modify = code => {
            let defines = '\n';
            for (let key in _this.groups) {
                defines += `#define _${key} ${_this.groups[key].groupIndex}.0\n`;
            }

            let split = code.split('__ACTIVE_THEORY_LIGHTS__');
            code = split[0] + '__ACTIVE_THEORY_LIGHTS__' + defines + split[1];

            code = code.split('\n');

            code.forEach((line, i) => {
                if (line.includes('#define') && line.includes('/')) {
                    let split = line.split(' ');
                    split = split[split.length-1];
                    let [group, label] = split.trim().split('/');
                    let map = _this.map[group];
                    if (!map) throw `modifyShader :: Group ${group} not found`;
                    map = map[label];
                    if (map === undefined) throw `modifyShader :: Label ${label} not found`;
                    code[i] = line.replace(`${group}/${label}`, map + '.0');
                }
            });
            return code.join('\n');
        };

        let vs = modify(shader.vertexShader);
        let fs = modify(shader.fragmentShader);
        shader.vertexShader = vs;
        shader.fragmentShader = fs;
        shader.restoreVS = vs;
        shader.restoreFS = fs;
    }

    this.getLayers = function(key) {
        let array = Object.keys(_this.map[key]);
        array.sort();
        return array;
    }

    this.onDestroy = function() {
        _this.geometry.destroy();
    }
}, _ => {
    function avatarMergeMeshes({meshes}, id) {
        let fill = (array, value) => {
            for (let i = 0; i < array.length; i++) array[i] = value;
            return array;
        };

        let geometry;
        meshes.forEach(m => {
            let geom = new Geometry();
            geom.addAttribute('position', new GeometryAttribute(m.p, 3));
            geom.addAttribute('uv', new GeometryAttribute(m.u, 2));
            if (m.u2) geom.addAttribute('uv2', new GeometryAttribute(m.u2, 2));
            if (m.vdata) geom.addAttribute('vdata', new GeometryAttribute(m.vdata, 3));
            geom.addAttribute('normal', new GeometryAttribute(m.n, 3));
            geom.addAttribute('geomIndex', new GeometryAttribute(fill(new Float32Array(m.u.length / 2), m.geomIndex), 1));
            geom.addAttribute('groupIndex', new GeometryAttribute(fill(new Float32Array(m.u.length / 2), m.groupIndex), 1));
            geom.applyMatrix(new Matrix4().fromArray(m.matrix));

            if (geometry) geometry.merge(geom);
            else geometry = geom;
        });

        geometry.computeBoundingSphere();
        geometry.computeBoundingBox();

        let buffers = [];
        let obj = {};

        for (let key in geometry.attributes) {
            obj[key] = {array: geometry.attributes[key].array, components: geometry.attributes[key].itemSize};
            buffers.push(obj[key].array.buffer);
        }

        resolve({arrays: obj, boundingBox: geometry.boundingBox, boundingSphere: geometry.boundingSphere}, id, buffers);
    }

    Thread.upload(avatarMergeMeshes);
});
Class(function VideoChatZone(_position, _id, _config, _users) {
    Inherit(this, Object3D);
    const _this = this;
    var _binding, _shader, _mesh;

    this.position = _this.group.position;
    this.id = _id;
    this.users = Array.isArray(_users) ? _users : [];
    this.createdTime = Render.TIME;

    //*** Constructor
    (function () {
        _this.group.position.fromArray(_position);
        initMesh();
        let targetY = _this.group.position.y;
        _shader.set('uAlpha', 0);
        _shader.tween('uAlpha', 1, 500, 'easeOutCubic');
        _this.group.position.y -= 1;
        tween(_this.group.position, {y: targetY}, 500, 'easeOutCubic');
        _this.events.sub(Events.VISIBILITY, handleVisibility);
    })();

    function initMesh() {
        let geom = World.TELEPORT_CYLINDER;
        let shader = _config.shader || _this.initClass(Shader, 'BaseVideoChatZone', {
            uColor: {value: new Color(_config.color || '#ffffff')},
            uAlpha: {value: 1, batchUnique: true},
            blending: Shader.ADDITIVE_BLENDING,
            transparent: true
        });
        shader.transparent = true;
        shader.depthWrite = false;
        shader.side = Shader.DOUBLE_SIDE;
        let mesh = new Mesh(geom, shader);
        mesh.scale.set(_config.radius, 1, _config.radius);
        _shader = shader;
        _this.add(mesh);
        _mesh = mesh;
        _this.parent.parent.getBatch('chatZones', {}).debug = true;
    }

    async function close(force) {
        if (_this.flag('closing') && !force) return;
        _this.flag('closing', true);
        setTimeout(_ => {
            _this.parent.parent.getBatch('chatZones', {}).remove(_mesh);
            _this.events.fire(Events.END);
        }, 300);
        try {
            _shader.tween('uAlpha', 0, 300, 'easeOutCubic');
            await tween(_this.group.position, {y: _this.group.position.y - 1}, 300, 'easeOutCubic').promise();
        } catch(e) { }
    }

    //*** Event handlers
    function handleVisibility(e) {
        if (e.type == 'focus') {
            if (!_this.users.length) close(true);
        }
    }

    function cleanupPop(e) {
        if (e.key == 'P') _this.forceEnd();
    }

    //*** Public methods
    this.update = function(data) {
        if (Array.isArray(data.users)) {
            if (!data.users.length && Render.TIME - _this.createdTime < 250) return;
            _this.users = data.users;
        }
        if (!_this.users.length) close();
        // console.log(`Update VideoChatZone `, _id, Utils.cloneObject(data).users);
    }

    this.canJoin = function() {
        return _this.users.length < _config.maxUsers;
    }

    this.join = function() {
        if (_this.flag('joined')) return;
        _this.flag('joined', true);
        _this.events.fire(VideoChatZone.JOIN);
        let pushArray = {key: 'users', value: PlayerModel.get('uid') || Multiplayer.room.me.id};
        Multiplayer.room?.pin({chatZone: true, unique: _id, pushArray}, 99999);
        _binding = GameCenterMedia.state.bind('hasMediaAccess', state => {
            if (state == 'failed') {
                _this.leave();
            }
        });

        if (Hydra.LOCAL) {
            _this.events.sub(Keyboard.PRESS, cleanupPop);
        }
    }

    this.leave = function() {
        if (!_this.flag('joined')) return;
        _this.flag('joined', false);
        _this.events.unsub(Keyboard.PRESS, cleanupPop);
        _this.events.fire(VideoChatZone.LEAVE);
        let popArray = {key: 'users', value: PlayerModel.get('uid') || Multiplayer.room.me.id};
        Multiplayer.room?.pin({chatZone: true, unique: _id, popArray}, 99999);
        _binding?.destroy?.();
    }

    this.forceLeave = function() {
        let popArray = {key: 'users', value: PlayerModel.get('uid') || Multiplayer.room.me.id};
        Multiplayer.room?.pin({chatZone: true, unique: _id, popArray}, 99999);
        _binding?.destroy?.();
    }

    this.forceEnd = function() {
        if (_this.users.length) console.log('FORCE END', _id, _this.users.length);
        _this.users.forEach(id => {
            let popArray = {key: 'users', value: id};
            Multiplayer.room?.pin({chatZone: true, unique: _id, popArray}, 99999);
        });
        _this.users.length = 0;
    }

    this.onDisconnect = function(player) {
        let id = player.state.get('uid') || player.gcPlayer.id;
        if (_this.users.includes(id)) {
            // console.log('Report disconnect for ', _id, id);
            let popArray = {key: 'users', value: id};
            Multiplayer.room?.pin({chatZone: true, unique: _id, popArray}, 99999);
        }
    }
}, _ => {
    VideoChatZone.JOIN = 'video_chat_zone_join';
    VideoChatZone.LEAVE = 'video_chat_zone_leave';
});
Class(function VideoChatZoneUI(_config, $element) {
    Inherit(this, Element);
    const _this = this;
    var $this;
    var _avSettings, _videoUI, _video, $wrapper;
    var _startTime;
    //*** Constructor
    (function () {
        initHTML();
        initStyles();
        addHandlers();
    })();

    function initHTML() {
        $this = _this.element;
        $this.size('100%').css({
            opacity: 0,
            display: 'none'
        });
        $wrapper = $this.create('VideoChatZoneUI__wrapper');
        if (!_config.audioOnly) {
            _videoUI = _this.initClass(VideoChatZoneVideoPreview, [$wrapper]);
        }
        _avSettings = _this.initClass(VideoChatZoneAVSettings, _config, [$wrapper]);
    }

    function initStyles() {
        $wrapper.css({
            bottom: '3rem',
            width: '100%',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            flexDirection: 'column',
            pointerEvents: 'auto'
        });
    }

    //*** Event handlers

    function addHandlers() {
        _this.onResize(resize);
    }

    function resize() {
        $this.css({ width: Stage.width, height: Stage.height });
    }

    function determineTimeElapsed(startTime) {
        let timeDiff = Date.now() - startTime;
        timeDiff /= 1000;
        const seconds = Math.round(timeDiff);
        return parseFloat(seconds / 60).toFixed(2);
    }

    //*** Public methods
    this.connect = async function() {
        Track.event('chatzone', 'start');
        _startTime = Date.now();
        _video = await GameCenterMedia.getUserVideo(true);
        _videoUI?.updateVideo(_video);
        if ($this && $this.css) $this.css({ opacity: 1, display: 'block' });
    };

    this.disconnect = function() {
        let timeElapsed = determineTimeElapsed(_startTime);
        Track.event('chatzone', 'end', null, timeElapsed);
        if ($this && $this.css) $this.css({ opacity: 0, display: 'none' });
    };
});

/* eslint-disable quote-props */
Class(function VideoChatZoneVideoPreview() {
    Inherit(this, AbstractUIComponent);
    const _this = this;
    const $this = _this.element;
    var $avatar, $video;
    //*** Constructor
    (function () {
        initHTML();
        initStyles();
        addHandlers();
    })();

    function initHTML() {
    //temp
        $avatar = $this.create(_this.getPrefix('avatar'), 'img');
        const path = PlayerModel.get('profileImage') || '~assets/images/icon/user.svg';
        $avatar.attr('src', Assets.getPath(path));
    }

    function initStyles() {
        $this.css({
            height: '10rem',
            width: '10rem',
            border: '2px solid white',
            borderRadius: '50%',
            background: 'lightblue',
            position: 'relative',
            marginBottom: '2rem',
            overflow: 'hidden',
            "-webkit-mask-image": '-webkit-radial-gradient(white, black)'
        });

        $avatar.css({
            objectFit: 'cover',
            left: '50%',
            top: '50%',
            width: '100%',
            height: '100%'
        }).transform({ x: '-50%', y: '-50%' });
    }

    //*** Event handlers
    function addHandlers() {
        _this.events.sub(AVSettingsController.VIDEO_STATE_CHANGE, handleStateChange);
    }

    function handleStateChange({ isEnabled }) {
        if (!$video) return;
        if (isEnabled) {
            $video.tween({ opacity: 1, scaleX: -1, x: '-50%', y: '-50%' }, 10, 'easeInOut');
        } else {
            $video.tween({ opacity: 0, scaleX: -1, x: '-50%', y: '-50%' }, 10, 'easeInOut');
        }
    }

    //*** Public methods

    _this.updateVideo = function(video) {
        if (!video) return;
        $video = $(video);
        $video.attr('width', '100%').attr('height', '100%').css({
            borderRadius: '50%',
            left: '50%',
            top: '50%',
            width: '20rem',
            height: '10rem',
            transform: 'translate(-50%, -50%) scaleX(-1)'
        });
        $this.add(video);
    };
});

Class(function VideoChatZoneAVSettings(_config) {
    Inherit(this, Element);
    const _prefix = 'VideoChatZoneAVSettings';

    const _this = this;
    const $this = _this.element;
    var $content, $audioVideoWrapper, $divider;

    //*** Constructor
    (function () {
        initHTML();
        initStyles();
    })();

    function initHTML() {
        $content = $this.create(`${_prefix}__content`).hide();
        //Settings Button

        //Audio + Video Toggle
        $audioVideoWrapper = $content.create(`${_prefix}__audio-video-wrapper`);
        _this.audioToggle = _this.initClass(UIAVAudioToggle, { preset: 'video-chat-zone' }, [$audioVideoWrapper]);
        if (_config && !_config.audioOnly) {
            _this.videoToggle = _this.initClass(UIAVVideoToggle, { preset: 'video-chat-zone' }, [$audioVideoWrapper]);
        }
        _this.initClass(UIAVSettingsButton, { type: 'video-chat-zone' }, [$content]);
    }

    function initStyles() {
        CoreUIState.instance().uiBuilder.buildVideoChatZoneAVSettings({
            $container: $this,
            $content,
            $audioVideoWrapper
        }, {
            audioOnly: _config && _config.audioOnly
        });
    }

    //*** Event handler


    //*** Public methods
});

Class(function VideoChatZoneAVSettingsStyles() {
    Inherit(this, Component);

    this.buildVideoChatZoneAVSettings = function(els, props) {
        const {$container, $content, $audioVideoWrapper} = els
        const {audioOnly} = props
        $container.css({
            position: 'relative',
            background: 'black',
            alignItems: 'center',
            padding: '1.3rem 1.8rem',
            borderRadius: '0.5rem'
        }).transform({scale: 0.95})

        $content.css({
            display: 'flex',
            justifyContent: 'space-between',
            position: 'relative'
        })

        $audioVideoWrapper.css({
            position: 'relative',
            display: 'grid',
            gridTemplateColumns: audioOnly ? '1fr' : '1fr 1fr',
            gridColumnGap: '1.6rem',
            alignItems: 'center',
            justifyContent: 'center',
        });
    };
}, 'static');

Class(function MediaAccessToast(_config) {
  Inherit(this, AbstractUIComponent);
  const _this = this;
  const $this = _this.element;
  let $content, $title, $desc;
  //*** Constructor
  (function () {
    _this.parseConfig(_config);
    initHTML();
    initStyles();
  })();
  
  function initHTML() {
    $content = $this.create(_this.getPrefix('content'))
    $title = $content.create(_this.getPrefix('title'))
    $title.text(_this.titleText)

    $desc = $content.create(_this.getPrefix('desc'))
    $desc.text(_this.descText)
  }
  
  function initStyles() {
    CoreUIState.instance().uiBuilder.buildMediaAccessToastStyles({
      $container: $this,
      $content, 
      $title, 
      $desc,
    })

  }
  
  //*** Event handlers
  
  //*** Public methods

  _this.show = function() {
    console.log('showing')
    $this.show()
    $this.css({
      display: 'flex'
    })
    $this.tween({opacity: 1}, 500, 'easeOutCubic')
  }

  _this.hide = async function() {
    await $this.tween({opacity: 0}, 500, 'easeOutCubic').promise()
    $this.hide()
  }
 
});
Class(function MediaAccessToastStyles() {
  Inherit(this, Component);

  this.buildMediaAccessToastStyles = function(els, props) {
      const {$container, $content, $title, $desc} = els
      $container.css({
          background: 'black',
          padding: '1.3rem 1.8rem',
          borderRadius: '0.5rem',
          height: '13rem',
          width: '41.6rem',
          boxShadow: '0 0.4rem 0.4rem rgba(0,0,0,0.25)',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          top: '3rem',
          left: '3rem',
          zIndex: '100000',
          opacity: 0, 
      }).hide()

      $content.css({
          display: 'flex',
          justifyContent: 'space-between',
          position: 'relative',
          flexDirection: 'column'
      })

      $title.css({
        ...this.styleguide.button3,
        color: this.colors.white[0],
        marginBottom: '0.7rem'
      })

      $desc.css({
        ...this.styleguide.button2,
        color: this.colors.monochrome[0],
        maxWidth: '25rem',
        lineHeight: '120%'
      })
  };
}, 'static');

/*
    EmoteEnvironment is used to enable emotes in your current environment.
    The _texture argument can only accept a Texture class using an image with vertical size.
    All the emojis needs to be centralized in a square and distributed vertically, for example 72x72.
*/
Class(function EmoteEnvironment() {
    const _this = this;

    var _origin;
    var _texture, _textureLength;
    var _proton;
    var _ui;
    var _y = 0;

    //*** Constructor
    function initUI(isHorizontal) {
        _ui = _this.initClass(EmoteUI, _texture, _textureLength, isHorizontal);
        _ui.animateIn();

        _this.events.sub(EmoteUI.OPTION_CLICK, handleOptionClick);

        _this.flag('uiReady', true);

        _this.getDOMElement().add(_ui);
    }

    function initProton() {
        _proton = _this.initClass(EmoteProton, _origin);
    }

    async function initTextures(src) {
        _texture = Utils3D.getTexture(src || '~assets/images/emotes/emotes.png');
        await _texture.promise;
        _textureLength = _texture.dimensions.height / _texture.dimensions.width;
    }

    function fireEmote(position, index) {
        _proton.fire(position, index, _y);
    }

    //*** Event handlers
    function handleOptionClick({ index }) {
        let player = _this.getPlayerController();
        player.fireEvent('emote', { index });
    }

    //*** Loop
    function loop() {

    }

    //*** Public methods
    this.onVisible = this.enableEmote = function() {
        if (!_this.multiplayerConfig) return;

        _this.showEmoteUI();
    }

    this.onInvisible = this.disableEmote = function() {
        _this.hideEmoteUI();

        _this.flag('init' , false);
    }

    this.getUI = async function () {
        await _this.wait('uiReady');
        return _ui;
    }

    this.get('ui', _ => _ui);

    this.onConnectPlayer = this.onConnectLocalPlayer = function(player) {
        player.bindEvent('emote', async ({ index }) => {
            fireEmote(player.group.position, index);
        });
    }

    this.onDisconnectPlayer = function(player) {

    }

    this.emote = function(index) {
        fireEmote(player.group.position, index);
    }

    this.showEmoteUI = function() {
        if (_ui) _ui.animateIn();
    }

    this.hideEmoteUI = function() {
        if (_ui) _ui.animateOut();
    }

    this.initEmotes = async function(src, isHorizontal = false, origin, y) {
        if (origin) _origin = origin;
        if (y) _y = y;

        initProton();
        await initTextures(src);
        initUI(isHorizontal);

        _this.startRender(loop);
    }

    this.setOrigin = function(value) {
        _origin.copy(value);
    }
});

Class(function EmoteParticle(_proton, _group) {
    Inherit(this, Object3D);

    const _this = this;
    
    //*** Constructor
    (function () {
        initMesh();
    })();

    async function initMesh() {
        await _proton.spawn.ready();

        let geometry = new Geometry().instanceFrom(new PlaneGeometry(1, 1));

        _proton.applyToInstancedGeometry(geometry);

        let shader = _this.initClass(Shader, 'EmoteParticleShader', {
            uIndex: { value: 0 },
            uLength: { value: 0 },
            uScale: { value: 1 },
            tMap: { value: null },
            uQuaternion: { value: World.CAMERA.quaternion },
            depthTest: false,
            depthWrite: false,
            transparent: true,
        });

        _proton.applyToShader(shader);
        _proton.spawn.applyToShader(shader);

        ShaderUIL.add(shader, _group).setLabel('Shader');

        let mesh = new Mesh(geometry, shader);

        mesh.renderOrder = 999999;

        _this.add(mesh);
    }
});
Class(function EmoteProton(_origin) {
    Inherit(this, Object3D);

    const _this = this;

    var _layout;

    //*** Constructor
    (async function () {
        _layout = _this.initClass(SceneLayout, 'emote');

        await _layout.loadedAllLayers();

        _this.layers = await _layout.getAllLayers();

        if (Utils.query('fire')) {
            setInterval(_ => {
                _this.fire(new Vector3(), Math.random(0, 7), 0);
            }, Utils.query('fire'));
        }

        Dev.expose('emoteFire', _this.fire);

        _this.flag('isReady', true);
    })();

    //*** Public methods
    _this.fire = function(position, index, y) {
        if (_this.layers.proton && _this.layers.proton.spawn) {
            let vector = _origin || position;

            vector = vector.clone();
            vector.y += y;

            _this.layers.proton.spawn.emit(vector.toArray(), [index, 0, 0]);
        }
    };

    _this.ready = function() {
        return _this.wait('isReady');
    };
});
Class(function EmoteUI(_texture, _length, _horizontal = false) {
    Inherit(this, Element);
    const _this = this;
    var _isHorizontal = _horizontal;

    var $this, $bg, $iconWrap, $icon, $toggle, $toggleChevron, $options, $optionsItems = [];
    var _index = _length - 1;

    //*** Constructor
    (function () {
        initHTML();
        addListeners();
    })();

    function initHTML() {
        $this = _this.element;

        $iconWrap = $this.create('EmoteUI__icon-wrap');

        $icon = $iconWrap.create('EmoteUI__icon');
        $icon.interact(handleHover, handleIconClick);

        $toggle = $this.create('EmoteUI__toggle');
        $toggle.interact(handleHover, handleToggleClick);

        $toggleChevron = $toggle.create('EmoteUI__toggle__chevron');

        $options = $this.create('EmoteUI__options');

        $bg = $options.create('EmoteUI__options__background');

        for (let i = 0; i < _length; i++) {
            let $option = $options.create('EmoteUI__options__option');

            $option.interact(handleHover, _ => {
                handleOptionClick(i);
            });

            $option.multiTween = true;

            $optionsItems.push($option);

            CoreUIState.instance().uiBuilder.buildUIEmotesItem({
                $option,
            }, {
                index: i,
                isHorizontal: _isHorizontal,
                src: _texture.src
            });
        }

        CoreUIState.instance().uiBuilder.buildUIEmotes({
            $container: $this,
            $iconWrap,
            $icon,
            $bg,
            $toggle,
            $toggleChevron,
            $options
        }, {
            isHorizontal: _isHorizontal,
            src: _texture.src
        });
    }

    //*** Event handlers
    function addListeners() {
        _this.onResize(resize);
        _this.events.sub(UIPanelLayout.RESIZE,resize);
    }

    function handleHover(e) {
        if (Device.mobile) return;
        
        switch (e.action) {
            case 'over': e.object.tween({ scale: 1.15, y: 0 }, 200, 'easeOutCubic'); break;
            case 'out': e.object.tween({ scale: 1 }, 400, 'easeOutCubic'); break;
        }
    }

    async function handleIconClick() {
        _this.events.fire(EmoteUI.OPTION_CLICK, { index: _index });
    }

    async function handleOptionClick(index) {
        _index = index;

        $icon.tween({ opacity: 0, scale: 0.5 }, 200, 'easeOutCubic', _ => {
            $icon.css({ backgroundPosition: `0 ${100 * (index + 1)}%` });
            $icon.tween({ opacity: 1, scale: 1 }, 200, 'easeOutCubic');
        });

        _this.events.fire(EmoteUI.OPTION_CLICK, { index: _index });
        _this.close();
    }

    function handleToggleClick() {
        if (_this.flag('isOpen')) {
            _this.close();
        } else {
            _this.open();
        }
    }

    function resize() {
        $this.css({
            right: '3rem'
        });
    }

    //*** Public methods
    this.animateIn = function() {
        $this.transform({ scale: 1.2 });
        $this.tween({ opacity: 1, scale: Device.mobile.phone && Stage.width < Stage.height ? .8 : 1}, 400, 'easeOutCubic');
    }

    this.animateOut = function() {
        $this.tween({ opacity: 0, scale: 1.2 }, 400, 'easeOutCubic');
    }

    this.open = function() {
        _this.flag('isOpen', true);
        $options.css({
            pointerEvents:'auto'
        })
        if(_isHorizontal) {
            $bg.tween({ scaleX: 1, opacity: 0.6 }, 500, 'easeOutCubic');
        }else{
            $bg.tween({ scaleY: 1, opacity: 0.6 }, 500, 'easeOutCubic');
        }
        $toggleChevron.tween({ rotation: 180, x: '-50%', y: '-50%' }, 500, 'easeOutCubic');

        $optionsItems.forEach(($option, index) => {
            $option.css({ scale: 0.5, transform: 'translateY(25px)', visibility: 'visible' });
            $option.tween({ opacity: 1, scale: 1, y: 0 }, 500, 'easeOutCubic', 25 * index);
        });
    }

    this.close = function() {
        _this.flag('isOpen', false);
        $options.css({
            pointerEvents:'none'
        })

        $bg.tween({ scaleY: 1, opacity: 0 }, 500, 'easeOutCubic');
        $toggleChevron.tween({ rotation: 0, x: '-50%', y: '-50%' }, 500, 'easeOutCubic');

        $optionsItems.forEach(($option, index) => {
            $option.tween({ opacity: 0, scale: 0.5, y: 25 }, 500, 'easeOutCubic', 5 * index, _ => {
                $option.css({ visibility: 'hidden' });
            });
        });
    }
}, 'singleton', _ => {
    EmoteUI.OPTION_CLICK = 'EmoteUI_option_click';
});
Class(function EmoteUIStyles() {
    Inherit(this, Component);

    this.buildUIEmotes = function({ $container, $iconWrap, $icon, $bg, $toggle, $toggleChevron, $options }, { isHorizontal, src }) {
        $container.css({
            background: 'white',
            bottom: '3rem',
            borderRadius: '0.5rem',
            height: '4.8rem',
            opacity: 0,
            boxShadow: '0px 4px 14px rgba(0, 0, 0, 0.15)',
            right: '3rem',
            zIndex: 10,
        });

        $iconWrap.css({
            padding: '1rem',
            position:'relative',
            display:'inline-block',
            verticalAlign: 'middle',
        });

        $bg.size('100%').bg('#fff');

        if (isHorizontal) {
            $bg.transformPoint('100%', '50%');
        }else{
            $bg.transformPoint('50%', '100%');
        }

        $bg.css({
            left: isHorizontal ? 'unset' : '0rem',
            right: isHorizontal ? '2rem' : 'unset ',
            top: isHorizontal ? '0' :'-2rem',
            opacity: 0,
            width: '100%'
        });

        $icon.css({
            backgroundImage: `url(${Assets.getPath(src)})`,
            backgroundPosition: '0 0',
            backgroundSize: '100%',
            height: '3.2rem',
            position: 'relative',
            width: '3.2rem',
        });

        $toggle.css({
            position: 'relative',
            height: '5rem',
            width: '3rem',
            float:'right',
            display:'inline-block',
            verticalAlign: 'middle',
        });

        $toggleChevron.css({
            borderColor: '#5961ff transparent transparent transparent',
            borderStyle: 'solid',
            borderWidth: '0.5rem 0.5rem 0 0.5rem',
            height: 0,
            width: 0
        });

        $toggleChevron.center();
        $toggleChevron.transform({ x: '-50%', y: '-50%' });

        $options.css({
            bottom: isHorizontal ? 'unset' : '100%',
            top: isHorizontal ? '50%' : 'unset',
            right: isHorizontal ? 'calc(100% + 1rem)' : 'unset',
            display: 'flex',
            flexDirection:isHorizontal ? 'row-reverse' : 'column-reverse',
            left: isHorizontal ? 'unset' : '1.5rem',
            pointerEvents:'none'
        });

        if (isHorizontal) {
            $options.transform({
                y:'-50%'
            })
        }
    };

    this.buildUIEmotesItem = function({ $option }, { index, isHorizontal, src }) {
        $option.css({
            backgroundImage: `url(${Assets.getPath(src)})`,
            backgroundPosition: `0 ${100 * (index + 1)}%`,
            backgroundSize: '100%',
            height: '3.2rem',
            marginBottom: isHorizontal ? '0' :'1rem',
            marginRight: isHorizontal ? '1rem' :'0rem',
            opacity: 0,
            position: 'relative',
            transform: 'translateX(25px) scale(0.5)',
            visibility: 'hidden',
            width: '3.2rem'
        });
    };
}, 'static');

Class(function EnvironmentShadowAttachment(_mesh, _shader) {
    Inherit(this, Component);
    const _this = this;

    //*** Constructor
    (async function () {
        await _this.parent.loadedAllLayers();
        for (let key in _this.parent.layers) {
            if (_this.parent.layers[key] instanceof EnvironmentShadows) {
                _this.parent.layers[key].applyTo(_shader);
            }
        }
    })();

    //*** Event handlers

    //*** Public methods

});
Class(function EnvironmentShadows(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    var _mesh, _plane, _batch;

    var _scene = _this.initClass(FXScene, World.NUKE, {rtFormat: Texture.RGBAFormat, rtType: Texture.FLOAT});
    var _env = _this.parent.parent;
    var _players = [];
    var _shaders = [];
    var _remove = [];
    var _box = new Vector4();

    //*** Constructor
    (async function () {
        _mesh = new Mesh(World.PLANE, Utils3D.getTestShader());
        _mesh.rotation.x = Math.radians(-90);
        if (!Utils.query('editShadows')) _mesh.shader.neverRender = true;
        _this.add(_mesh);

        await defer();

        let box = new Box3();
        box.setFromObject(_this.group);
        _box.set(box.min.x, box.max.x, box.min.z, box.max.z);

        if (!Global.PLAYGROUND) {
            initCamera();
            addListeners();
            _this.startRender(loop);
        }
    })();

    function initCamera() {
        let aspect = _this.group.scale.x / _this.group.scale.z;

        _scene.setSize(1024, 1024 / aspect, true);
        _scene.clearColor = '#000000';

        let shader = _this.initClass(Shader, 'TextureMaterial', {
            tMap: {value: Utils3D.getTexture('assets/images/_scenelayout/uv.jpg')}
        })
        let mesh = new Mesh(World.PLANE, shader);
        mesh.scale.copy(_this.group.scale);
        mesh.rotation.x = Math.radians(-90);
        // console.log(mesh.scale);
        // _scene.scene.add(mesh);

        let camera = new PerspectiveCamera(45, aspect, 0.1, 1000);
        camera.rotation.x = Math.radians(-90);
        camera.position.y = Utils3D.getPositionFromCameraSize(camera, mesh.scale.z) / 2.17;
        _scene.useCamera(camera);

        // let $debug = $gl(512, 512 / aspect, _scene);
        // GLUI.Stage.add($debug);
    }

    function initBatch() {
        _batch = _this.initClass(MeshBatch);
        _scene.scene.add(_batch.group);
    }

    function initMesh() {
        if (!_batch) initBatch();
        let shader = _this.initClass(Shader, 'EnvironmentShadow', {
            uYPos: {value: 0, batchUnique: false},
            tMap: {value: Utils3D.getTexture('~assets/images/avatar/shadow.jpg')},
            transparent: true,
            depthWrite: false,
            depthTest: false
        });
        let mesh = new Mesh(World.PLANE, shader);
        mesh.scale.setScalar(2.5);
        mesh.rotation.x = Math.radians(-90);
        _batch.add(mesh);
        return mesh;
    }

    function loop() {
        for (let i = _players.length-1; i > -1; i--) {
            let player = _players[i];
            if (player.shadowMesh) {
                player.shadowMesh.position.copy(player.group.position);
                player.shadowMesh.position.y = 0;
                player.shadowMesh.scale.x = player.shadowMesh.scale.z = 2.5 * player.group.scale.x;
                player.shadowMesh.shader.set('uYPos', player.group.position.y);
            } else {
                _remove.push(player);
            }
        }

        if (_remove.length) {
            _remove.forEach(r => _players.remove(r));
            _remove.length = 0;
        }
    }

    function reset() {
        _scene.scene.remove(_batch.group);
        _batch.destroy();
        initBatch();
        _players.length = 0;
        _scene.render();
    }

    //*** Event handlers
    function addListeners() {
        _this.events.sub(_env, AbstractEnvironment.PLAYER_CONNECT, playerConnect);
        _this.events.sub(_env, AbstractEnvironment.PLAYER_DISCONNECT, playerDisconnect);
    }

    function playerConnect({player}) {
        player.shadowMesh = initMesh();
        _players.push(player);
    }

    function playerDisconnect({player}) {
        _players.remove(player);
        _batch.remove(player.shadowMesh);
    }

    //*** Public methods
    this.applyTo = function(shader) {
        shader = shader.shader || shader;
        shader.addUniforms({
            uBox: {value: _box},
            tShadowMap: {value: _scene.rt}
        });
        _shaders.push(shader);
    }

    this.onInvisible = function() {
        reset();
    }

    this.onDestroy = function() {
        _shaders.forEach(shader => {
            shader.set('tShadowMap', null);
        });
    }
});
Class(function GlobalCrowd(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    var _config, _particles, _first;

    var _visibility = 1;

    //*** Constructor
    (async function () {
        initConfig();
        let data = {particleCount: _config.getNumber('particleCount')};
        let layout = _this.initClass(SceneLayout, 'globalcrowd', {noGraph: true, data});
        _particles = await layout.getLayer('particles');
        await _particles.ready();
        _config.onUpdate();
        initMesh();
        _this.startRender(loop);
    })();

    function initConfig() {
        _config = InputUIL.create(_input.prefix+'crowd', _group);
        _config.setLabel('Config');
        _config.add('particleCount', 1000);
        _config.addNumber('radius', 10);
        _config.addNumber('seed', 1);
        _config.addNumber('moveSpeed', 0.4);
        _config.addNumber('moveRadius', 0.4);
        _config.addNumber('randomRotation', 0);
        _config.addImage('mask');
        _config.addVector('maskBoundingMin', [-1, -1]);
        _config.addVector('maskBoundingMax', [1, 1]);
        _config.addToggle('debugMask');
        _config.addToggle('castShadow');

        _config.onUpdate = _ => {
            _particles.behavior.setUniform('uRadius', _config.getNumber('radius'));
            _particles.behavior.setUniform('uSeed', _config.getNumber('seed'));
            _particles.behavior.setUniform('uTimeScale', _config.getNumber('moveSpeed'));
            _particles.behavior.setUniform('uSinRadius', _config.getNumber('moveRadius'));
            if (_this.mesh) {
                _this.mesh.shader.get('uMaskMin').fromArray(_config.get('maskBoundingMin'));
                _this.mesh.shader.get('uMaskMax').fromArray(_config.get('maskBoundingMax'));
                _this.mesh.shader.set('tMask', getMask());
                _this.mesh.shader.set('uMaskDebug', _config.get('debugMask') ? 1 : 0);
                _this.mesh.shader.set('uRotation', _config.getNumber('randomRotation'));
                _this.mesh.castShadow = _config.get('castShadow');
            }
        };
    }

    function getMask() {
        let data = JSON.parse(_config.get('mask'));
        if (!data || !data.src) return Utils3D.getTexture('assets/images/_scenelayout/mask.jpg');
        let src = data.src;
        if (data.compressed) src += '-compressKtx';
        return Utils3D.getTexture(src);
    }

    function loop() {
        let lerp = !_first ? 1 : 0.1;
        _particles.behavior.uniforms.uVisibility.value = Math.lerp(_visibility, _particles.behavior.uniforms.uVisibility.value, lerp);
        _first = true;
    }

    async function initMesh() {
        let avatar = _this.initClass(GlobalEnvironment.instance().getPlayerClass());
        let mesh = await avatar.getMesh();

        mesh.castShadow = _config.get('castShadow');

        mesh.shader.addUniforms({
            tMask: {value: getMask()},
            uMaskMin: {value: new Vector2().fromArray(_config.get('maskBoundingMin'))},
            uMaskMax: {value: new Vector2().fromArray(_config.get('maskBoundingMax'))},
            uMaskOffset: {value: _config.getNumber('maskOffset')},
            uRotation: {value: _config.getNumber('randomRotation')},
            uMaskDebug: {value: _config.get('debugMask') && Hydra.LOCAL ? true : false},
        })

        _particles.applyToInstancedGeometry(mesh.geometry);
        _particles.applyToShader(mesh.shader);
        await avatar.loadAttribBuffers();
        _this.add(mesh);
        _this.mesh = mesh;
    }

    //*** Event handlers

    //*** Public methods
    this.set('visibility', v => {
        _visibility = v;
    });

    this.ready = function() {
        return _this.wait('mesh');
    }
});
Class(function GlobalViewData(_env) {
    Inherit(this, Component);
    const _this = this;

    var _min = 0;
    var _bindings = [];
    var _crowds = {};
    var _range;

    //*** Constructor
    (async function () {
        await _env.layout.loadedAllLayers();
        for (let key in _env.layout.layers) {
            let layer = _env.layout.layers[key];
            if (layer instanceof GlobalCrowd) _crowds[key] = layer;
        }

        _this.startRender(_ => { });
    })();

    async function loadData() {
        if (!window.Config || !Config.COMMUNITY) return console.warn('Missing Config.COMMUNITY');
        let data = await get(`${Config.COMMUNITY}?${Date.now()}`);
        if (!Array.isArray(data)) data = [data];

        let connections = 0;

        data.forEach(d => connections += d.connections);
        let scalar = _range ? Math.range(connections, _range.min, _range.max, _range.minScalar, _range.maxScalar, true) : 1;

        _bindings.forEach(({ labels, crowd }) => {
            let total = 0;
            data.forEach(server => {
                for (let key in server) {
                    labels.forEach(label => {
                        if (key.includes(label)) {
                            total += server[key];
                        }
                    });
                }
            });
            _crowds[crowd].visibility = Math.max(_min, (total / connections) * scalar);
        });

        _this.delayedCall(loadData, 30000);
    }

    //*** Event handlers

    //*** Public methods
    this.setRange = function (min, max, minScalar, maxScalar) {
        _range = { min, max, minScalar, maxScalar };
    };

    this.setMin = function (min) {
        _min = min;
    };

    this.bind = function (labels, crowd) {
        if (!Array.isArray(labels)) labels = [labels];
        _bindings.push({ labels, crowd });
    };

    this.onVisible = function () {
        loadData();
    };

    this.onInvisible = function () {
        _this.clearTimers();
    };
});

Class(function LoaderView(_config) {
    Inherit(this, Element);
    const _this = this;
    const $this = this.element;
    var $text, $wrapper, $spinner, $message;
    var _percent = 0;

    //*** Constructor
    (function () {
        initHTML();
        initSpinner();
        
        if (!_config || !_config.hidePercent) {
            initText();
        }

        if (_config && _config.message) {
            initMessage()
        }

        _this.startRender(loop);
    })();

    function initHTML() {
        $this.size('100%').setZ(1000);

        $wrapper = $this.create('.wrapper');
        $wrapper.size(200,200).center().css({ opacity: 0 }).tween({ opacity: 1 }, 250, 'easeOutCubic', 150 );

        _this.delayedCall(  _ => {
            Stage.css({ opacity: 1 });
        }, 150 );
    }

    function initSpinner() {
        let size = Device.mobile.phone ? 100 : 110;
        $spinner = $wrapper.create('.spinner-anim');
        $spinner.size(size,size).center();
    }

    function initText() {
        let size = 16;
        $text = $wrapper.create('LoaderViewText');
        $text.size(200, size).center()
            .css({ textAlign: 'center', lineHeight: size, letterSpacing: 2, opacity: 0.8 });
        $text.percent = 0;
    }

    function initMessage() {
        $message = $wrapper.create('LoaderViewText', 'h5')
        $message.size(200, 16).css({ textAlign: 'center', lineHeight: 16, letterSpacing: 2, opacity: 0.8 });
        $message.text(_config.message)
    }

    //*** Event handlers
    function loop() {
        if ($text) {
            let rate = Math.range( $text.percent - _percent, 0.1, 0.5, 0.0175, 0.035, true );
            if ( $text.percent >= 1 ) rate = 0.35;
            _percent = Math.lerp( Math.lerp( $text.percent, _percent, rate ), _percent, 0.275 );
            if ($text) $text.html(`${Math.round( _percent * 100 )}`);
        }

    }

    //*** Public methods
    this.progress = function(e) {
        if ($text) $text.percent = e.percent;
    };

    this.animateOut = async function(callback, time) {
        let tweenTime = time || 500;
        await tween($text, { percent: 1 }, tweenTime, 'easeOutSine').promise();
        $this.tween({ opacity: 0 }, tweenTime, 'easeInOutSine', tweenTime).onComplete(() => callback && callback());
        $wrapper.tween({ opacity: 0 }, tweenTime, 'easeInOutSine');
    };

});
Class(function ProfilePrompt(_config = {}) {
    Inherit(this, Object3D);
    const _this = this;
    var $root, $capture, _capture, _viewing, _posDistance, _view, _hoverUniform;

    if (typeof _config !== 'object') _config = {};
    if (!_config.scale) _config.scale = 1;
    if (!_config.width) _config.width = 1024;
    if (!_config.height) _config.height = 512;
    if (!_config.y) _config.y = 1;
    if (!_config.view) throw `profilePrompt must have a view property!`;

    var _toDestroy = [];

    const VR = Platform.usingVR();

    //*** Constructor
    (function () {
        _this.group.scale.setScalar(0);
        addListeners();
        initStageLayoutCapture();
        _this.startRender(loop);
        _this.startRender(clearDestroy, 10);
    })();

    function clearDestroy() {
        for (let i = 0; i < _toDestroy.length; i++) {
            let obj = _toDestroy[i];
            if (obj) {
                if (Render.TIME - obj.time > 5000) {
                    if (obj.view && obj.view.destroy) obj.view.destroy();
                    _toDestroy.splice(i, 1);
                }
            }
        }
    }

    function initStageLayoutCapture() {
        _capture = _this.initClass(StageLayoutCapture, _config.width, _config.height, true);
        _capture.visible = false;

        $root = _capture.root;
        $capture = $gl(2, 1, _capture);
        $capture.enable3D();
        _this.add($capture.group);
        if (!Platform.usingVR()) {
            $capture.mesh.shader.depthTest = false;
            $capture.mesh.shader.depthWrite = false;
        }
        $capture.mesh.shader.transparent = true;
        $capture.mesh.renderOrder = 9999;
        _capture.object3d = $capture;
        $capture.hide();
    }

    async function hideUI() {
        if (!_viewing) return;
        _posDistance = null;
        _viewing = null;
        await tween(_this.group.scale, { x: 0, y: 0, z: 0 }, 300, 'easeOutCubic');
        _capture.visible = false;
        $capture.hide();
        if (_view) {
            _toDestroy.push({ time: Render.TIME, view: _view });
            try { $root.removeChild(_view.element); } catch (e) { }
        }
    }

    function loop() {
        if (!_posDistance) return;

        let player = _posDistance.player;
        let me = _posDistance.me;

        let originalDistance = player.distanceTo(me);

        if (!VR) _this.group.lookAt(World.CAMERA.position);

        if (player.distanceTo(_this.parent.player.group.position) > originalDistance + 1) {
            hideUI();
        }
    }

    //*** Event handlers
    function addListeners() {
        _this.events.sub(Player.JOIN, playerJoin);
        _this.events.sub(Player.LEAVE, playerLeave);
        _this.events.sub(TriggerZone.INSIDE, hideUI);
        _this.events.sub(VideoChatZones.PROMPT, hideUI);
    }

    function playerJoin({ player }) {
        if (_this._invisible) return;
        _this.events.sub(player, AvatarInteraction.HOVER, avatarHover);
        _this.events.sub(player, AvatarInteraction.CLICK, avatarClick);
    }

    function playerLeave(e) {
        if (_this._invisible) return;
        if (e.player == _viewing) hideUI();
    }

    function avatarHover(e) {
        if (_this._invisible) return;
        let shader = e.object.view?.mesh?.shader;
        if (shader && _hoverUniform) {
            shader.tween(_hoverUniform, e.action == 'over' && !_this.parent.videoChatZones?.interacting ? 1 : 0, 300, 'easeOutCubic');
        }
    }

    function avatarClick(e) {
        if (_this.parent.videoChatZones?.interacting) return;
        if (_this._invisible || e.isLeaveEvent) return;
        let player = e.object;
        if (_viewing == player) return;

        if (_view) {
            _toDestroy.push({ time: Render.TIME, view: _view });
            try { $root.removeChild(_view.element); } catch (e) { }
        }

        _this.group.position.copy(player.group.position);
        _this.group.position.y += _config.y;
        if (VR) _this.group.position.add(new Vector3(0, 0, 0.4).applyQuaternion(World.CAMERA.quaternion));
        _this.group.lookAt(World.CAMERA.position);
        _viewing = player;

        _capture.visible = true;
        $capture.show();
        _this.group.scale.setScalar(0);

        let scale = VR ? 0.4 : _config.scale;
        tween(_this.group.scale, { x: scale, y: scale, z: scale }, 300, 'easeOutCubic');

        _view = _this.initClass(_config.view, player);
        _this.events.sub(_view, Events.END, hideUI);
        $root.add(_view.element);

        _posDistance = { me: _this.parent.player.group.position.clone(), player: player.group.position.clone() };
    }

    //*** Public methods
    this.setHoverUniform = function(key) {
        _hoverUniform = key;
    };

    this.onDestroy = function() {
        _toDestroy.forEach(obj => {
            obj.view?.destroy?.();
        });
    };
});

Class(function ObjectSnapshot() {
    Inherit(this, Object3D);
    const _this = this;

    //*** Constructor
    (function () {
        
    })();

    //*** Public methods
    this.capture = async function(_mesh, _type = 'image/png', _overlay) {
        let bb = new Box3();

        bb.setFromObject(_mesh);

        let points = [
            new Vector3(bb.min.x, bb.max.y, bb.min.z),
            new Vector3(bb.min.x, bb.max.y, bb.max.z),
            new Vector3(bb.min.x, bb.min.y, bb.min.z),
            new Vector3(bb.min.x, bb.min.y, bb.max.z),
            new Vector3(bb.max.x, bb.max.y, bb.min.z),
            new Vector3(bb.max.x, bb.max.y, bb.max.z),
            new Vector3(bb.max.x, bb.min.y, bb.min.z),
            new Vector3(bb.max.x, bb.min.y, bb.max.z)
        ];

        points = points.map(p => new Vector2().copy(ScreenProjection.find(World.CAMERA).project(p)));

        let minX = 9999;
        let minY = 9999;
        let maxX = 0;
        let maxY = 0;

        points.forEach(p => {
            minX = Math.min(minX, p.x);
            minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x);
            maxY = Math.max(maxY, p.y);
        });

        let x = Math.max(Math.round(minX), 0);
        let y = Math.min(Math.round(minY), Stage.width);
        let width = Math.min(Math.round(maxX - minX), Stage.width);
        let height = Math.min(Math.round(maxY - minY), Stage.height);

        let canvas = DreamWorld.active.capturePixels(x, y, width, height);

        if (_overlay) {
            canvas.context.drawImage(_overlay.image, _overlay.x, _overlay.y, _overlay.width, _overlay.height);
        }
        
        if (Utils.query('snapshotDebug')) Stage.add(canvas);

        return canvas.toDataURL(_type);
    };
}, 'singleton');

Class(function BoxTest() {
    Inherit(this, Object3D);
    const _this = this;

    //*** Constructor
    (async function () {
        var layout = _this.initClass(SceneLayout, 'boxtest');
        let [b0, b1] = await layout.getLayers('b0', 'b1');
        _this.startRender(_ => {
            console.log(b0.isInsideOf(b1));
        }, 10);
    })();

    //*** Event handlers

    //*** Public methods

});
Class(function PhysicsTest() {
    Inherit(this, Object3D);
    const _this = this;
    var _balls = [];
    var _states = [];

    //*** Constructor
    (async function () {
        initLayout();
        await getLayers();
        snap();
    })();

    function initLayout() {
        _this.layout = _this.initClass(SceneLayout, 'phystest', { physics: true });
    }

    async function getLayers() {
        let layers = await _this.layout.getAllLayers();
        for ( let id in layers ) if ( id.includes('ball')) _balls.push( layers[id]);
    }

    function snap() {
        for ( let ball of _balls ) _states.push( ball.scriptClass.getState());
        _this.startRender( loop, 0.5 );
    }

    function loop() {
        for ( let [ i, ball ] of _balls.entries()) ball.scriptClass.applyState( _states[i]);
    }

    //*** Event handlers

    //*** Public methods

});
Class(function TestEnvironment() {
    Inherit(this, AbstractEnvironment);
    const _this = this;

    //*** Constructor
    (function () {
        let shader = _this.initClass(Shader, 'TextureMaterial', {
            tMap: {value: Utils3D.getTexture('assets/images/_scenelayout/uv.jpg')}
        });
        let plane = new Mesh(World.PLANE, shader);
        _this.add(plane);
        plane.scale.setScalar(30);
        plane.rotation.x = Math.radians(-90);
    })();

    //*** Event handlers

    //*** Public methods

});
Class(function Transition() {
    Inherit(this, Element);

    const _this = this;
    const $this = _this.element;

    const VR = Platform.usingVR();

    var _view, _vrCover;
    var _ui = UIController.instance().layout ? UIController.instance().layout.element : Stage;
    var _transitions = {};

    //*** Constructor
    (function () {
        initHTML();
        initViews();
        if (VR) initVRCover();
    })();

    function initVRCover() {
        let shader = _this.initClass(Shader, 'VRCover', {
           uAlpha: {value: 1}
        });
        _vrCover = new Mesh(World.SPHERE, shader);
        _vrCover.shader.transparent = true;
        _vrCover.shader.side = Shader.BACK_SIDE;
        _vrCover.shader.depthTest = false;
        _vrCover.renderOrder = 99999;
        _vrCover.scale.setScalar(0.5);
        _vrCover.visible = false;

        let spinner = new Mesh(World.PLANE, _this.initClass(Shader, 'VRCoverSpinner', {
            tMap: {value: Utils3D.getTexture('~assets/images/icon/spinner.png')},
            uAlpha: shader.uniforms.uAlpha,
            uColor: {value: new Color()},
            transparent: true,
            depthWrite: false,
            depthTest: false
        }));
        spinner.scale.setScalar(0.4);
        spinner.position.set(-0.07, 0, -1);
        spinner.renderOrder = 999999;
        _vrCover.add(spinner);

        let div = document.createElement('div');
        div.className = 'spinner-anim';
        document.body.appendChild(div);
        let color = getComputedStyle(div).borderTopColor;
        if (color.includes('rgb')) {
            color = color.split('rgb(')[1].split(')')[0];
            color = color.trim().split(',').map(v => Number(v));
            spinner.shader.uniforms.uColor.value.setRGB(1, 1, 1);
        }
        document.body.removeChild(div);

        World.SCENE.add(_vrCover);

        _this.startRender(_ => {
            spinner.rotation.z += 0.06 * Render.HZ_MULTIPLIER;
            _vrCover.position.copy(World.CAMERA.position);
            _vrCover.quaternion.copy(World.CAMERA.quaternion);
        }, World.NUKE);
    }

    function initHTML() {
        $this.size('100%');
        if (_ui) _ui.add($this);
        $this.setZ(100).hide();
    }

    function initViews() {
        _transitions.external = _this.initClass(TransitionBasicView);
        _transitions.internal = _this.initClass(TransitionBasicView);

        _transitions.external.element.hide();
        _transitions.internal.element.hide();
    }

    //*** Public methods
    this.cover = async function (type) {
        if (_this.flag('cover')) return;
        _this.flag('cover', true);
        _this.vrTransition = Promise.create();

        if (VR) {
            DreamWorld.getActiveEnvironment?.().then(env => env.player.controls.disable());
            _vrCover.type = type;
            _vrCover.visible = true;
            await _vrCover.shader.tween('uAlpha', 1, 300, 'easeOutSine').promise();
        } else {
            $this.setZ(9999999);
            $this.show();
            _view = _transitions[type];
            _view.element.show();
            await _view.cover();
        }
    };

    this.reveal = async function () {
        if (!_this.flag('cover')) return;
        _this.flag('cover', false);

        if (VR) {
            VRInput.controllers.forEach(c => c.hideBeam());
            await _this.wait(750 + Transition.EXTRA_WAIT_TIME);
            DreamWorld.active.ensureSceneVisibility();
            _this.vrTransition.resolve();
            await _vrCover.shader.tween('uAlpha', 0, 500, 'easeOutSine').promise();
            _vrCover.visible = false;
            DreamWorld.getActiveEnvironment?.().then(env => env.player.controls.enable());
        } else {
            await _view.reveal();
            $this.setZ(9999999);
            _view.element.hide();
            $this.hide();
        }
    };

    this.registerView = function (Class, type) {
        if (_transitions[type]) _transitions[type].destroy();
        _transitions[type] = _this.initClass(Class);
        _transitions[type].element.hide();
    };

    this.updateVRPosition = function(obj) {
        _vrCover.position.copy(obj.position);
        _vrCover.quaternion.copy(obj.quaternion);
    }
}, 'singleton', _ => {
    Transition.STARTED = 'Transition_started';
    Transition.COMPLETE = 'Transition_complete';
    Transition.EXTRA_WAIT_TIME = 0;
});

Class(function TransitionBasicView() {
    Inherit(this, Element);
    const _this = this;
    var $this;

    //*** Constructor
    (function () {
        initHTML();
    })();

    function initHTML() {
        $this = _this.element;
        $this.size('100%').bg('#eeeeee');
    }

    //*** Event handlers

    //*** Public methods
    this.cover = function() {
        return $this.transformPoint('100%', '50%').transform({ scaleX: 0 }).tween({ scaleX: 1 }, 600, 'easeOutCubic').promise();
    }

    this.reveal = function() {
        return $this.transformPoint('0%', '50%').tween({ scaleX: 0 }, 1000, 'easeOutCubic').promise();
    }
});
Class(function Main() {
    //*** Constructor
    (async function () {
        await Config.ready();
        await Device.system.detectXR();
        if (Utils.query('performance')) return Performance.displayResults();
        init();
    })();

    function init() {
        GLUI.init();
        if (window.location.search.includes('p=') && !Router.virtualQuery && Hydra.LOCAL) return AssetLoader.loadAssets(Assets.list().filter(['data', 'shaders'])).then(Playground.instance);
        Container.instance();
        if (Hydra.LOCAL && Utils.query('streamKey')) DesktopStream.instance(Platform.usingVR() || Utils.query('client'));
    }

    //*** Event Handlers

    //*** Public methods
});


window._BUILT_=true;